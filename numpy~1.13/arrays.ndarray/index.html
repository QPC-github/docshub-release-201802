
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>The N-dimensional Array (Ndarray) - NumPy 1.13 - W3cubDocs</title>
  
  <meta name="description" content="An ndarray is a (usually fixed-size) multidimensional container of items of the same type and size. The number of dimensions and items in an array &hellip;">
  <meta name="keywords" content="n-dimensional, array, ndarray, -, numpy, numpy~1.13">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/numpy~1.13/arrays.ndarray/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-e0f881b0fce8cbe96f33dadc355b7159d5d2912911231446d60eb8f9caffa802.css">
  <script type="text/javascript" src="/assets/application-8fc46316434047265cd383f02b8e7f434ed7dec4a59f920dd633deef8d488d1b.js"></script>
  <script src="/json/numpy~1.13.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/numpy~1.13/" class="_nav-link" title="" style="margin-left:0;">NumPy 1.13</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _sphinx">
				
<h1 id="arrays-ndarray">The N-dimensional array (ndarray)</h1> <p id="the-n-dimensional-array-ndarray">An <a class="reference internal" href="../generated/numpy.ndarray/#numpy.ndarray" title="numpy.ndarray"><code>ndarray</code></a> is a (usually fixed-size) multidimensional container of items of the same type and size. The number of dimensions and items in an array is defined by its <a class="reference internal" href="../generated/numpy.ndarray.shape/#numpy.ndarray.shape" title="numpy.ndarray.shape"><code>shape</code></a>, which is a <a class="reference external" href="https://docs.python.org/dev/library/stdtypes.html#tuple" title="(in Python v3.7)" target="_blank"><code>tuple</code></a> of <em>N</em> positive integers that specify the sizes of each dimension. The type of items in the array is specified by a separate <a class="reference internal" href="../arrays.dtypes/#arrays-dtypes"><span class="std std-ref">data-type object (dtype)</span></a>, one of which is associated with each ndarray.</p> <p>As with other container objects in Python, the contents of an <a class="reference internal" href="../generated/numpy.ndarray/#numpy.ndarray" title="numpy.ndarray"><code>ndarray</code></a> can be accessed and modified by <a class="reference internal" href="../arrays.indexing/#arrays-indexing"><span class="std std-ref">indexing or slicing</span></a> the array (using, for example, <em>N</em> integers), and via the methods and attributes of the <a class="reference internal" href="../generated/numpy.ndarray/#numpy.ndarray" title="numpy.ndarray"><code>ndarray</code></a>.</p> <p id="index-0">Different <a class="reference internal" href="../generated/numpy.ndarray/#numpy.ndarray" title="numpy.ndarray"><code>ndarrays</code></a> can share the same data, so that changes made in one <a class="reference internal" href="../generated/numpy.ndarray/#numpy.ndarray" title="numpy.ndarray"><code>ndarray</code></a> may be visible in another. That is, an ndarray can be a <em>“view”</em> to another ndarray, and the data it is referring to is taken care of by the <em>“base”</em> ndarray. ndarrays can also be views to memory owned by Python <a class="reference external" href="https://docs.python.org/dev/library/stdtypes.html#str" title="(in Python v3.7)" target="_blank"><code>strings</code></a> or objects implementing the <code>buffer</code> or <a class="reference internal" href="../arrays.interface/#arrays-interface"><span class="std std-ref">array</span></a> interfaces.</p>  <h4>Example</h4> <p>A 2-dimensional array of size 2 x 3, composed of 4-byte integer elements:</p> <pre data-language="python">&gt;&gt;&gt; x = np.array([[1, 2, 3], [4, 5, 6]], np.int32)
&gt;&gt;&gt; type(x)
&lt;type 'numpy.ndarray'&gt;
&gt;&gt;&gt; x.shape
(2, 3)
&gt;&gt;&gt; x.dtype
dtype('int32')
</pre> <p>The array can be indexed using Python container-like syntax:</p> <pre data-language="python">&gt;&gt;&gt; # The element of x in the *second* row, *third* column, namely, 6.
&gt;&gt;&gt; x[1, 2]
</pre> <p>For example <a class="reference internal" href="../arrays.indexing/#arrays-indexing"><span class="std std-ref">slicing</span></a> can produce views of the array:</p> <pre data-language="python">&gt;&gt;&gt; y = x[:,1]
&gt;&gt;&gt; y
array([2, 5])
&gt;&gt;&gt; y[0] = 9 # this also changes the corresponding element in x
&gt;&gt;&gt; y
array([9, 5])
&gt;&gt;&gt; x
array([[1, 9, 3],
       [4, 5, 6]])
</pre>   <h2 id="constructing-arrays">Constructing arrays</h2> <p>New arrays can be constructed using the routines detailed in <a class="reference internal" href="../routines.array-creation/#routines-array-creation"><span class="std std-ref">Array creation routines</span></a>, and also by using the low-level <a class="reference internal" href="../generated/numpy.ndarray/#numpy.ndarray" title="numpy.ndarray"><code>ndarray</code></a> constructor:</p> <table class="longtable docutils">   <tr class="row-odd">
<td><a class="reference internal" href="../generated/numpy.ndarray/#numpy.ndarray" title="numpy.ndarray"><code>ndarray</code></a></td> <td>An array object represents a multidimensional, homogeneous array of fixed-size items.</td> </tr>  </table>   <h2 id="arrays-ndarray-indexing">Indexing arrays</h2> <p id="indexing-arrays">Arrays can be indexed using an extended Python slicing syntax, <code>array[selection]</code>. Similar syntax is also used for accessing fields in a <span class="xref std std-ref">structured array</span>.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <p class="last"><a class="reference internal" href="../arrays.indexing/#arrays-indexing"><span class="std std-ref">Array Indexing</span></a>.</p> </div>   <h2 id="internal-memory-layout-of-an-ndarray">Internal memory layout of an ndarray</h2> <p>An instance of class <a class="reference internal" href="../generated/numpy.ndarray/#numpy.ndarray" title="numpy.ndarray"><code>ndarray</code></a> consists of a contiguous one-dimensional segment of computer memory (owned by the array, or by some other object), combined with an indexing scheme that maps <em>N</em> integers into the location of an item in the block. The ranges in which the indices can vary is specified by the <a class="reference internal" href="../generated/numpy.ndarray.shape/#numpy.ndarray.shape" title="numpy.ndarray.shape"><code>shape</code></a> of the array. How many bytes each item takes and how the bytes are interpreted is defined by the <a class="reference internal" href="../arrays.dtypes/#arrays-dtypes"><span class="std std-ref">data-type object</span></a> associated with the array.</p> <p id="index-1">A segment of memory is inherently 1-dimensional, and there are many different schemes for arranging the items of an <em>N</em>-dimensional array in a 1-dimensional block. NumPy is flexible, and <a class="reference internal" href="../generated/numpy.ndarray/#numpy.ndarray" title="numpy.ndarray"><code>ndarray</code></a> objects can accommodate any <em>strided indexing scheme</em>. In a strided scheme, the N-dimensional index <img class="math" src="https://docs.scipy.org/doc/numpy-1.13.0/_images/math/55e2912fdc1638596e19ae6361f2d2db30450efc.png" alt="(n_0, n_1, ..., n_{N-1})" style="vertical-align: -4px"> corresponds to the offset (in bytes):</p> <div class="math"> <p><img src="https://docs.scipy.org/doc/numpy-1.13.0/_images/math/17fdc8233ee40cccdfeba940091cd2630850581a.png" alt="n_{\mathrm{offset}} = \sum_{k=0}^{N-1} s_k n_k"></p> </div>
<p>from the beginning of the memory block associated with the array. Here, <img class="math" src="https://docs.scipy.org/doc/numpy-1.13.0/_images/math/d5ab8e6081db79a4afcf29b7616b48025de0e80c.png" alt="s_k" style="vertical-align: -2px"> are integers which specify the <a class="reference internal" href="../generated/numpy.ndarray.strides/#numpy.ndarray.strides" title="numpy.ndarray.strides"><code>strides</code></a> of the array. The <a class="reference internal" href="https://docs.scipy.org/doc/numpy-1.13.0/glossary.html#term-column-major" target="_blank"><span class="xref std std-term">column-major</span></a> order (used, for example, in the Fortran language and in <em>Matlab</em>) and <a class="reference internal" href="https://docs.scipy.org/doc/numpy-1.13.0/glossary.html#term-row-major" target="_blank"><span class="xref std std-term">row-major</span></a> order (used in C) schemes are just specific kinds of strided scheme, and correspond to memory that can be <em>addressed</em> by the strides:</p> <div class="math"> <p><img src="https://docs.scipy.org/doc/numpy-1.13.0/_images/math/c28fa0657966b37e188e72dbfdb5dbb3a0707d63.png" alt="s_k^{\mathrm{column}} = \mathrm{itemsize} \prod_{j=0}^{k-1} d_j ,
\quad  s_k^{\mathrm{row}} = \mathrm{itemsize} \prod_{j=k+1}^{N-1} d_j ."></p> </div>
<p id="index-2">where <img class="math" src="https://docs.scipy.org/doc/numpy-1.13.0/_images/math/c375e8b96fc69dad77ee104906be2a9df776ad66.png" alt="d_j" style="vertical-align: -4px"> <code>= self.shape[j]</code>.</p> <p>Both the C and Fortran orders are <a class="reference external" href="https://docs.python.org/dev/glossary.html#term-contiguous" title="(in Python v3.7)" target="_blank"><span class="xref std std-term">contiguous</span></a>, <em>i.e.,</em> <span class="xref std std-term">single-segment</span>, memory layouts, in which every part of the memory block can be accessed by some combination of the indices.</p> <p>While a C-style and Fortran-style contiguous array, which has the corresponding flags set, can be addressed with the above strides, the actual strides may be different. This can happen in two cases:</p>  <ol class="arabic simple"> <li>If <code>self.shape[k] == 1</code> then for any legal index <code>index[k] == 0</code>. This means that in the formula for the offset <img class="math" src="https://docs.scipy.org/doc/numpy-1.13.0/_images/math/9fed4bdf69e096e1239bd758fe79e8076f28d793.png" alt="n_k = 0" style="vertical-align: -2px"> and thus <img class="math" src="https://docs.scipy.org/doc/numpy-1.13.0/_images/math/36e9c492db6f4ad8e065f978a3d4a33a3c6df086.png" alt="s_k n_k = 0" style="vertical-align: -2px"> and the value of <img class="math" src="https://docs.scipy.org/doc/numpy-1.13.0/_images/math/d5ab8e6081db79a4afcf29b7616b48025de0e80c.png" alt="s_k" style="vertical-align: -2px"> <code>= self.strides[k]</code> is arbitrary.</li> <li>If an array has no elements (<code>self.size == 0</code>) there is no legal index and the strides are never used. Any array with no elements may be considered C-style and Fortran-style contiguous.</li> </ol>  <p>Point 1. means that <code>self</code> and <code>self.squeeze()</code> always have the same contiguity and <span class="xref std std-term">aligned</span> flags value. This also means that even a high dimensional array could be C-style and Fortran-style contiguous at the same time.</p> <p id="index-3">An array is considered aligned if the memory offsets for all elements and the base offset itself is a multiple of <code>self.itemsize</code>.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p>Points (1) and (2) are not yet applied by default. Beginning with NumPy 1.8.0, they are applied consistently only if the environment variable <code>NPY_RELAXED_STRIDES_CHECKING=1</code> was defined when NumPy was built. Eventually this will become the default.</p> <p class="last">You can check whether this option was enabled when your NumPy was built by looking at the value of <code>np.ones((10,1),
order='C').flags.f_contiguous</code>. If this is <code>True</code>, then your NumPy has relaxed strides checking enabled.</p> </div> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p class="last">It does <em>not</em> generally hold that <code>self.strides[-1] == self.itemsize</code> for C-style contiguous arrays or <code>self.strides[0] == self.itemsize</code> for Fortran-style contiguous arrays is true.</p> </div> <p>Data in new <a class="reference internal" href="../generated/numpy.ndarray/#numpy.ndarray" title="numpy.ndarray"><code>ndarrays</code></a> is in the <a class="reference internal" href="https://docs.scipy.org/doc/numpy-1.13.0/glossary.html#term-row-major" target="_blank"><span class="xref std std-term">row-major</span></a> (C) order, unless otherwise specified, but, for example, <a class="reference internal" href="../arrays.indexing/#arrays-indexing"><span class="std std-ref">basic array slicing</span></a> often produces <a class="reference internal" href="https://docs.scipy.org/doc/numpy-1.13.0/glossary.html#term-view" target="_blank"><span class="xref std std-term">views</span></a> in a different scheme.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">Several algorithms in NumPy work on arbitrarily strided arrays. However, some algorithms require single-segment arrays. When an irregularly strided array is passed in to such algorithms, a copy is automatically made.</p> </div>   <h2 id="arrays-ndarray-attributes">Array attributes</h2> <p id="array-attributes">Array attributes reflect information that is intrinsic to the array itself. Generally, accessing an array through its attributes allows you to get and sometimes set intrinsic properties of the array without creating a new array. The exposed attributes are the core parts of an array and only some of them can be reset meaningfully without creating a new array. Information on each attribute is given below.</p>  <h3 id="memory-layout">Memory layout</h3> <p>The following attributes contain information about the memory layout of the array:</p> <table class="longtable docutils">   <tr class="row-odd">
<td><a class="reference internal" href="../generated/numpy.ndarray.flags/#numpy.ndarray.flags" title="numpy.ndarray.flags"><code>ndarray.flags</code></a></td> <td>Information about the memory layout of the array.</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../generated/numpy.ndarray.shape/#numpy.ndarray.shape" title="numpy.ndarray.shape"><code>ndarray.shape</code></a></td> <td>Tuple of array dimensions.</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../generated/numpy.ndarray.strides/#numpy.ndarray.strides" title="numpy.ndarray.strides"><code>ndarray.strides</code></a></td> <td>Tuple of bytes to step in each dimension when traversing an array.</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../generated/numpy.ndarray.ndim/#numpy.ndarray.ndim" title="numpy.ndarray.ndim"><code>ndarray.ndim</code></a></td> <td>Number of array dimensions.</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../generated/numpy.ndarray.data/#numpy.ndarray.data" title="numpy.ndarray.data"><code>ndarray.data</code></a></td> <td>Python buffer object pointing to the start of the array’s data.</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../generated/numpy.ndarray.size/#numpy.ndarray.size" title="numpy.ndarray.size"><code>ndarray.size</code></a></td> <td>Number of elements in the array.</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../generated/numpy.ndarray.itemsize/#numpy.ndarray.itemsize" title="numpy.ndarray.itemsize"><code>ndarray.itemsize</code></a></td> <td>Length of one array element in bytes.</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../generated/numpy.ndarray.nbytes/#numpy.ndarray.nbytes" title="numpy.ndarray.nbytes"><code>ndarray.nbytes</code></a></td> <td>Total bytes consumed by the elements of the array.</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../generated/numpy.ndarray.base/#numpy.ndarray.base" title="numpy.ndarray.base"><code>ndarray.base</code></a></td> <td>Base object if memory is from some other object.</td> </tr>  </table>   <h3 id="data-type">Data type</h3> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <p class="last"><a class="reference internal" href="../arrays.dtypes/#arrays-dtypes"><span class="std std-ref">Data type objects</span></a></p> </div> <p>The data type object associated with the array can be found in the <a class="reference internal" href="../generated/numpy.ndarray.dtype/#numpy.ndarray.dtype" title="numpy.ndarray.dtype"><code>dtype</code></a> attribute:</p> <table class="longtable docutils">   <tr class="row-odd">
<td><a class="reference internal" href="../generated/numpy.ndarray.dtype/#numpy.ndarray.dtype" title="numpy.ndarray.dtype"><code>ndarray.dtype</code></a></td> <td>Data-type of the array’s elements.</td> </tr>  </table>   <h3 id="other-attributes">Other attributes</h3> <table class="longtable docutils">   <tr class="row-odd">
<td><a class="reference internal" href="../generated/numpy.ndarray.t/#numpy.ndarray.T" title="numpy.ndarray.T"><code>ndarray.T</code></a></td> <td>Same as self.transpose(), except that self is returned if self.ndim &lt; 2.</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../generated/numpy.ndarray.real/#numpy.ndarray.real" title="numpy.ndarray.real"><code>ndarray.real</code></a></td> <td>The real part of the array.</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../generated/numpy.ndarray.imag/#numpy.ndarray.imag" title="numpy.ndarray.imag"><code>ndarray.imag</code></a></td> <td>The imaginary part of the array.</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../generated/numpy.ndarray.flat/#numpy.ndarray.flat" title="numpy.ndarray.flat"><code>ndarray.flat</code></a></td> <td>A 1-D iterator over the array.</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../generated/numpy.ndarray.ctypes/#numpy.ndarray.ctypes" title="numpy.ndarray.ctypes"><code>ndarray.ctypes</code></a></td> <td>An object to simplify the interaction of the array with the ctypes module.</td> </tr>  </table>   <h3 id="arrays-ndarray-array-interface">Array interface</h3> <div class="admonition seealso" id="array-interface"> <p class="first admonition-title">See also</p> <p class="last"><a class="reference internal" href="../arrays.interface/#arrays-interface"><span class="std std-ref">The Array Interface</span></a>.</p> </div> <table class="docutils">   <tr class="row-odd">
<td><a class="reference internal" href="../arrays.interface/#__array_interface__" title="__array_interface__"><code>__array_interface__</code></a></td> <td>Python-side of the array interface</td> </tr> <tr class="row-even">
<td><code>__array_struct__</code></td> <td>C-side of the array interface</td> </tr>  </table>   <h3 id="ctypes-foreign-function-interface">
<a class="reference external" href="https://docs.python.org/dev/library/ctypes.html#module-ctypes" title="(in Python v3.7)" target="_blank"><code>ctypes</code></a> foreign function interface</h3> <table class="longtable docutils">   <tr class="row-odd">
<td><a class="reference internal" href="../generated/numpy.ndarray.ctypes/#numpy.ndarray.ctypes" title="numpy.ndarray.ctypes"><code>ndarray.ctypes</code></a></td> <td>An object to simplify the interaction of the array with the ctypes module.</td> </tr>  </table>    <h2 id="array-ndarray-methods">Array methods</h2> <p id="array-methods">An <a class="reference internal" href="../generated/numpy.ndarray/#numpy.ndarray" title="numpy.ndarray"><code>ndarray</code></a> object has many methods which operate on or with the array in some fashion, typically returning an array result. These methods are briefly explained below. (Each method’s docstring has a more complete description.)</p> <p>For the following methods there are also corresponding functions in <a class="reference internal" href="../#module-numpy" title="numpy"><code>numpy</code></a>: <a class="reference internal" href="../generated/numpy.all/#numpy.all" title="numpy.all"><code>all</code></a>, <a class="reference internal" href="../generated/numpy.any/#numpy.any" title="numpy.any"><code>any</code></a>, <a class="reference internal" href="../generated/numpy.argmax/#numpy.argmax" title="numpy.argmax"><code>argmax</code></a>, <a class="reference internal" href="../generated/numpy.argmin/#numpy.argmin" title="numpy.argmin"><code>argmin</code></a>, <a class="reference internal" href="../generated/numpy.argpartition/#numpy.argpartition" title="numpy.argpartition"><code>argpartition</code></a>, <a class="reference internal" href="../generated/numpy.argsort/#numpy.argsort" title="numpy.argsort"><code>argsort</code></a>, <a class="reference internal" href="../generated/numpy.choose/#numpy.choose" title="numpy.choose"><code>choose</code></a>, <a class="reference internal" href="../generated/numpy.clip/#numpy.clip" title="numpy.clip"><code>clip</code></a>, <a class="reference internal" href="../generated/numpy.compress/#numpy.compress" title="numpy.compress"><code>compress</code></a>, <a class="reference internal" href="../generated/numpy.copy/#numpy.copy" title="numpy.copy"><code>copy</code></a>, <a class="reference internal" href="../generated/numpy.cumprod/#numpy.cumprod" title="numpy.cumprod"><code>cumprod</code></a>, <a class="reference internal" href="../generated/numpy.cumsum/#numpy.cumsum" title="numpy.cumsum"><code>cumsum</code></a>, <a class="reference internal" href="../generated/numpy.diagonal/#numpy.diagonal" title="numpy.diagonal"><code>diagonal</code></a>, <a class="reference internal" href="../generated/numpy.imag/#numpy.imag" title="numpy.imag"><code>imag</code></a>, <a class="reference internal" href="../generated/numpy.amax/#numpy.amax" title="numpy.amax"><code>max</code></a>, <a class="reference internal" href="../generated/numpy.mean/#numpy.mean" title="numpy.mean"><code>mean</code></a>, <a class="reference internal" href="../generated/numpy.amin/#numpy.amin" title="numpy.amin"><code>min</code></a>, <a class="reference internal" href="../generated/numpy.nonzero/#numpy.nonzero" title="numpy.nonzero"><code>nonzero</code></a>, <a class="reference internal" href="../generated/numpy.partition/#numpy.partition" title="numpy.partition"><code>partition</code></a>, <a class="reference internal" href="../generated/numpy.prod/#numpy.prod" title="numpy.prod"><code>prod</code></a>, <a class="reference internal" href="../generated/numpy.ptp/#numpy.ptp" title="numpy.ptp"><code>ptp</code></a>, <a class="reference internal" href="../generated/numpy.put/#numpy.put" title="numpy.put"><code>put</code></a>, <a class="reference internal" href="../generated/numpy.ravel/#numpy.ravel" title="numpy.ravel"><code>ravel</code></a>, <a class="reference internal" href="../generated/numpy.real/#numpy.real" title="numpy.real"><code>real</code></a>, <a class="reference internal" href="../generated/numpy.repeat/#numpy.repeat" title="numpy.repeat"><code>repeat</code></a>, <a class="reference internal" href="../generated/numpy.reshape/#numpy.reshape" title="numpy.reshape"><code>reshape</code></a>, <a class="reference internal" href="../generated/numpy.around/#numpy.around" title="numpy.around"><code>round</code></a>, <a class="reference internal" href="../generated/numpy.searchsorted/#numpy.searchsorted" title="numpy.searchsorted"><code>searchsorted</code></a>, <a class="reference internal" href="../generated/numpy.sort/#numpy.sort" title="numpy.sort"><code>sort</code></a>, <a class="reference internal" href="../generated/numpy.squeeze/#numpy.squeeze" title="numpy.squeeze"><code>squeeze</code></a>, <a class="reference internal" href="../generated/numpy.std/#numpy.std" title="numpy.std"><code>std</code></a>, <a class="reference internal" href="../generated/numpy.sum/#numpy.sum" title="numpy.sum"><code>sum</code></a>, <a class="reference internal" href="../generated/numpy.swapaxes/#numpy.swapaxes" title="numpy.swapaxes"><code>swapaxes</code></a>, <a class="reference internal" href="../generated/numpy.take/#numpy.take" title="numpy.take"><code>take</code></a>, <a class="reference internal" href="../generated/numpy.trace/#numpy.trace" title="numpy.trace"><code>trace</code></a>, <a class="reference internal" href="../generated/numpy.transpose/#numpy.transpose" title="numpy.transpose"><code>transpose</code></a>, <a class="reference internal" href="../generated/numpy.var/#numpy.var" title="numpy.var"><code>var</code></a>.</p>  <h3 id="array-conversion">Array conversion</h3> <table class="longtable docutils">   <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.ndarray.item/#numpy.ndarray.item" title="numpy.ndarray.item"><code>ndarray.item</code></a>(*args)</td> <td>Copy an element of an array to a standard Python scalar and return it.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/numpy.ndarray.tolist/#numpy.ndarray.tolist" title="numpy.ndarray.tolist"><code>ndarray.tolist</code></a>()</td> <td>Return the array as a (possibly nested) list.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.ndarray.itemset/#numpy.ndarray.itemset" title="numpy.ndarray.itemset"><code>ndarray.itemset</code></a>(*args)</td> <td>Insert scalar into an array (scalar is cast to array’s dtype, if possible)</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/numpy.ndarray.tostring/#numpy.ndarray.tostring" title="numpy.ndarray.tostring"><code>ndarray.tostring</code></a>([order])</td> <td>Construct Python bytes containing the raw data bytes in the array.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.ndarray.tobytes/#numpy.ndarray.tobytes" title="numpy.ndarray.tobytes"><code>ndarray.tobytes</code></a>([order])</td> <td>Construct Python bytes containing the raw data bytes in the array.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/numpy.ndarray.tofile/#numpy.ndarray.tofile" title="numpy.ndarray.tofile"><code>ndarray.tofile</code></a>(fid[, sep, format])</td> <td>Write array to a file as text or binary (default).</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.ndarray.dump/#numpy.ndarray.dump" title="numpy.ndarray.dump"><code>ndarray.dump</code></a>(file)</td> <td>Dump a pickle of the array to the specified file.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/numpy.ndarray.dumps/#numpy.ndarray.dumps" title="numpy.ndarray.dumps"><code>ndarray.dumps</code></a>()</td> <td>Returns the pickle of the array as a string.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.ndarray.astype/#numpy.ndarray.astype" title="numpy.ndarray.astype"><code>ndarray.astype</code></a>(dtype[, order, casting, ...])</td> <td>Copy of the array, cast to a specified type.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/numpy.ndarray.byteswap/#numpy.ndarray.byteswap" title="numpy.ndarray.byteswap"><code>ndarray.byteswap</code></a>(inplace)</td> <td>Swap the bytes of the array elements</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.ndarray.copy/#numpy.ndarray.copy" title="numpy.ndarray.copy"><code>ndarray.copy</code></a>([order])</td> <td>Return a copy of the array.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/numpy.ndarray.view/#numpy.ndarray.view" title="numpy.ndarray.view"><code>ndarray.view</code></a>([dtype, type])</td> <td>New view of array with the same data.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.ndarray.getfield/#numpy.ndarray.getfield" title="numpy.ndarray.getfield"><code>ndarray.getfield</code></a>(dtype[, offset])</td> <td>Returns a field of the given array as a certain type.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/numpy.ndarray.setflags/#numpy.ndarray.setflags" title="numpy.ndarray.setflags"><code>ndarray.setflags</code></a>([write, align, uic])</td> <td>Set array flags WRITEABLE, ALIGNED, and UPDATEIFCOPY, respectively.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.ndarray.fill/#numpy.ndarray.fill" title="numpy.ndarray.fill"><code>ndarray.fill</code></a>(value)</td> <td>Fill the array with a scalar value.</td> </tr>  </table>   <h3 id="shape-manipulation">Shape manipulation</h3> <p>For reshape, resize, and transpose, the single tuple argument may be replaced with <code>n</code> integers which will be interpreted as an n-tuple.</p> <table class="longtable docutils">   <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.ndarray.reshape/#numpy.ndarray.reshape" title="numpy.ndarray.reshape"><code>ndarray.reshape</code></a>(shape[, order])</td> <td>Returns an array containing the same data with a new shape.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/numpy.ndarray.resize/#numpy.ndarray.resize" title="numpy.ndarray.resize"><code>ndarray.resize</code></a>(new_shape[, refcheck])</td> <td>Change shape and size of array in-place.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.ndarray.transpose/#numpy.ndarray.transpose" title="numpy.ndarray.transpose"><code>ndarray.transpose</code></a>(*axes)</td> <td>Returns a view of the array with axes transposed.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/numpy.ndarray.swapaxes/#numpy.ndarray.swapaxes" title="numpy.ndarray.swapaxes"><code>ndarray.swapaxes</code></a>(axis1, axis2)</td> <td>Return a view of the array with <code>axis1</code> and <code>axis2</code> interchanged.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.ndarray.flatten/#numpy.ndarray.flatten" title="numpy.ndarray.flatten"><code>ndarray.flatten</code></a>([order])</td> <td>Return a copy of the array collapsed into one dimension.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/numpy.ndarray.ravel/#numpy.ndarray.ravel" title="numpy.ndarray.ravel"><code>ndarray.ravel</code></a>([order])</td> <td>Return a flattened array.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.ndarray.squeeze/#numpy.ndarray.squeeze" title="numpy.ndarray.squeeze"><code>ndarray.squeeze</code></a>([axis])</td> <td>Remove single-dimensional entries from the shape of <code>a</code>.</td> </tr>  </table>   <h3 id="item-selection-and-manipulation">Item selection and manipulation</h3> <p>For array methods that take an <em>axis</em> keyword, it defaults to <code>None</code>. If axis is <em>None</em>, then the array is treated as a 1-D array. Any other value for <em>axis</em> represents the dimension along which the operation should proceed.</p> <table class="longtable docutils">   <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.ndarray.take/#numpy.ndarray.take" title="numpy.ndarray.take"><code>ndarray.take</code></a>(indices[, axis, out, mode])</td> <td>Return an array formed from the elements of <code>a</code> at the given indices.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/numpy.ndarray.put/#numpy.ndarray.put" title="numpy.ndarray.put"><code>ndarray.put</code></a>(indices, values[, mode])</td> <td>Set <code>a.flat[n] = values[n]</code> for all <code>n</code> in indices.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.ndarray.repeat/#numpy.ndarray.repeat" title="numpy.ndarray.repeat"><code>ndarray.repeat</code></a>(repeats[, axis])</td> <td>Repeat elements of an array.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/numpy.ndarray.choose/#numpy.ndarray.choose" title="numpy.ndarray.choose"><code>ndarray.choose</code></a>(choices[, out, mode])</td> <td>Use an index array to construct a new array from a set of choices.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.ndarray.sort/#numpy.ndarray.sort" title="numpy.ndarray.sort"><code>ndarray.sort</code></a>([axis, kind, order])</td> <td>Sort an array, in-place.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/numpy.ndarray.argsort/#numpy.ndarray.argsort" title="numpy.ndarray.argsort"><code>ndarray.argsort</code></a>([axis, kind, order])</td> <td>Returns the indices that would sort this array.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.ndarray.partition/#numpy.ndarray.partition" title="numpy.ndarray.partition"><code>ndarray.partition</code></a>(kth[, axis, kind, order])</td> <td>Rearranges the elements in the array in such a way that value of the element in kth position is in the position it would be in a sorted array.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/numpy.ndarray.argpartition/#numpy.ndarray.argpartition" title="numpy.ndarray.argpartition"><code>ndarray.argpartition</code></a>(kth[, axis, kind, order])</td> <td>Returns the indices that would partition this array.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.ndarray.searchsorted/#numpy.ndarray.searchsorted" title="numpy.ndarray.searchsorted"><code>ndarray.searchsorted</code></a>(v[, side, sorter])</td> <td>Find indices where elements of v should be inserted in a to maintain order.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/numpy.ndarray.nonzero/#numpy.ndarray.nonzero" title="numpy.ndarray.nonzero"><code>ndarray.nonzero</code></a>()</td> <td>Return the indices of the elements that are non-zero.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.ndarray.compress/#numpy.ndarray.compress" title="numpy.ndarray.compress"><code>ndarray.compress</code></a>(condition[, axis, out])</td> <td>Return selected slices of this array along given axis.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/numpy.ndarray.diagonal/#numpy.ndarray.diagonal" title="numpy.ndarray.diagonal"><code>ndarray.diagonal</code></a>([offset, axis1, axis2])</td> <td>Return specified diagonals.</td> </tr>  </table>   <h3 id="calculation">Calculation</h3> <p id="index-4">Many of these methods take an argument named <em>axis</em>. In such cases,</p> <ul class="simple"> <li>If <em>axis</em> is <em>None</em> (the default), the array is treated as a 1-D array and the operation is performed over the entire array. This behavior is also the default if self is a 0-dimensional array or array scalar. (An array scalar is an instance of the types/classes float32, float64, etc., whereas a 0-dimensional array is an ndarray instance containing precisely one array scalar.)</li> <li>If <em>axis</em> is an integer, then the operation is done over the given axis (for each 1-D subarray that can be created along the given axis).</li> </ul> <div class="admonition-example-of-the-axis-argument admonition"> <p class="first admonition-title">Example of the <em>axis</em> argument</p> <p>A 3-dimensional array of size 3 x 3 x 3, summed over each of its three axes</p> <pre data-language="python">&gt;&gt;&gt; x
array([[[ 0,  1,  2],
        [ 3,  4,  5],
        [ 6,  7,  8]],
       [[ 9, 10, 11],
        [12, 13, 14],
        [15, 16, 17]],
       [[18, 19, 20],
        [21, 22, 23],
        [24, 25, 26]]])
&gt;&gt;&gt; x.sum(axis=0)
array([[27, 30, 33],
       [36, 39, 42],
       [45, 48, 51]])
&gt;&gt;&gt; # for sum, axis is the first keyword, so we may omit it,
&gt;&gt;&gt; # specifying only its value
&gt;&gt;&gt; x.sum(0), x.sum(1), x.sum(2)
(array([[27, 30, 33],
        [36, 39, 42],
        [45, 48, 51]]),
 array([[ 9, 12, 15],
        [36, 39, 42],
        [63, 66, 69]]),
 array([[ 3, 12, 21],
        [30, 39, 48],
        [57, 66, 75]]))
</pre> </div> <p>The parameter <em>dtype</em> specifies the data type over which a reduction operation (like summing) should take place. The default reduce data type is the same as the data type of <em>self</em>. To avoid overflow, it can be useful to perform the reduction using a larger data type.</p> <p>For several methods, an optional <em>out</em> argument can also be provided and the result will be placed into the output array given. The <em>out</em> argument must be an <a class="reference internal" href="../generated/numpy.ndarray/#numpy.ndarray" title="numpy.ndarray"><code>ndarray</code></a> and have the same number of elements. It can have a different data type in which case casting will be performed.</p> <table class="longtable docutils">   <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.ndarray.argmax/#numpy.ndarray.argmax" title="numpy.ndarray.argmax"><code>ndarray.argmax</code></a>([axis, out])</td> <td>Return indices of the maximum values along the given axis.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/numpy.ndarray.min/#numpy.ndarray.min" title="numpy.ndarray.min"><code>ndarray.min</code></a>([axis, out, keepdims])</td> <td>Return the minimum along a given axis.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.ndarray.argmin/#numpy.ndarray.argmin" title="numpy.ndarray.argmin"><code>ndarray.argmin</code></a>([axis, out])</td> <td>Return indices of the minimum values along the given axis of <code>a</code>.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/numpy.ndarray.ptp/#numpy.ndarray.ptp" title="numpy.ndarray.ptp"><code>ndarray.ptp</code></a>([axis, out])</td> <td>Peak to peak (maximum - minimum) value along a given axis.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.ndarray.clip/#numpy.ndarray.clip" title="numpy.ndarray.clip"><code>ndarray.clip</code></a>([min, max, out])</td> <td>Return an array whose values are limited to <code>[min, max]</code>.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/numpy.ndarray.conj/#numpy.ndarray.conj" title="numpy.ndarray.conj"><code>ndarray.conj</code></a>()</td> <td>Complex-conjugate all elements.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.ndarray.round/#numpy.ndarray.round" title="numpy.ndarray.round"><code>ndarray.round</code></a>([decimals, out])</td> <td>Return <code>a</code> with each element rounded to the given number of decimals.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/numpy.ndarray.trace/#numpy.ndarray.trace" title="numpy.ndarray.trace"><code>ndarray.trace</code></a>([offset, axis1, axis2, dtype, out])</td> <td>Return the sum along diagonals of the array.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.ndarray.sum/#numpy.ndarray.sum" title="numpy.ndarray.sum"><code>ndarray.sum</code></a>([axis, dtype, out, keepdims])</td> <td>Return the sum of the array elements over the given axis.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/numpy.ndarray.cumsum/#numpy.ndarray.cumsum" title="numpy.ndarray.cumsum"><code>ndarray.cumsum</code></a>([axis, dtype, out])</td> <td>Return the cumulative sum of the elements along the given axis.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.ndarray.mean/#numpy.ndarray.mean" title="numpy.ndarray.mean"><code>ndarray.mean</code></a>([axis, dtype, out, keepdims])</td> <td>Returns the average of the array elements along given axis.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/numpy.ndarray.var/#numpy.ndarray.var" title="numpy.ndarray.var"><code>ndarray.var</code></a>([axis, dtype, out, ddof, keepdims])</td> <td>Returns the variance of the array elements, along given axis.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.ndarray.std/#numpy.ndarray.std" title="numpy.ndarray.std"><code>ndarray.std</code></a>([axis, dtype, out, ddof, keepdims])</td> <td>Returns the standard deviation of the array elements along given axis.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/numpy.ndarray.prod/#numpy.ndarray.prod" title="numpy.ndarray.prod"><code>ndarray.prod</code></a>([axis, dtype, out, keepdims])</td> <td>Return the product of the array elements over the given axis</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.ndarray.cumprod/#numpy.ndarray.cumprod" title="numpy.ndarray.cumprod"><code>ndarray.cumprod</code></a>([axis, dtype, out])</td> <td>Return the cumulative product of the elements along the given axis.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/numpy.ndarray.all/#numpy.ndarray.all" title="numpy.ndarray.all"><code>ndarray.all</code></a>([axis, out, keepdims])</td> <td>Returns True if all elements evaluate to True.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.ndarray.any/#numpy.ndarray.any" title="numpy.ndarray.any"><code>ndarray.any</code></a>([axis, out, keepdims])</td> <td>Returns True if any of the elements of <code>a</code> evaluate to True.</td> </tr>  </table>    <h2 id="arithmetic-matrix-multiplication-and-comparison-operations">Arithmetic, matrix multiplication, and comparison operations</h2> <p id="index-5">Arithmetic and comparison operations on <a class="reference internal" href="../generated/numpy.ndarray/#numpy.ndarray" title="numpy.ndarray"><code>ndarrays</code></a> are defined as element-wise operations, and generally yield <a class="reference internal" href="../generated/numpy.ndarray/#numpy.ndarray" title="numpy.ndarray"><code>ndarray</code></a> objects as results.</p> <p>Each of the arithmetic operations (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>//</code>, <code>%</code>, <code>divmod()</code>, <code>**</code> or <code>pow()</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&amp;</code>, <code>^</code>, <code>|</code>, <code>~</code>) and the comparisons (<code>==</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>!=</code>) is equivalent to the corresponding <span class="xref std std-term">universal function</span> (or <a class="reference internal" href="https://docs.scipy.org/doc/numpy-1.13.0/glossary.html#term-ufunc" target="_blank"><span class="xref std std-term">ufunc</span></a> for short) in NumPy. For more information, see the section on <a class="reference internal" href="../ufuncs/#ufuncs"><span class="std std-ref">Universal Functions</span></a>.</p> <p>Comparison operators:</p> <table class="longtable docutils">   <tr class="row-odd">
<td><a class="reference internal" href="../generated/numpy.ndarray.__lt__/#numpy.ndarray.__lt__" title="numpy.ndarray.__lt__"><code>ndarray.__lt__</code></a></td> <td>x.__lt__(y) &lt;==&gt; x&lt;y</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../generated/numpy.ndarray.__le__/#numpy.ndarray.__le__" title="numpy.ndarray.__le__"><code>ndarray.__le__</code></a></td> <td>x.__le__(y) &lt;==&gt; x&lt;=y</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../generated/numpy.ndarray.__gt__/#numpy.ndarray.__gt__" title="numpy.ndarray.__gt__"><code>ndarray.__gt__</code></a></td> <td>x.__gt__(y) &lt;==&gt; x&gt;y</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../generated/numpy.ndarray.__ge__/#numpy.ndarray.__ge__" title="numpy.ndarray.__ge__"><code>ndarray.__ge__</code></a></td> <td>x.__ge__(y) &lt;==&gt; x&gt;=y</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../generated/numpy.ndarray.__eq__/#numpy.ndarray.__eq__" title="numpy.ndarray.__eq__"><code>ndarray.__eq__</code></a></td> <td>x.__eq__(y) &lt;==&gt; x==y</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../generated/numpy.ndarray.__ne__/#numpy.ndarray.__ne__" title="numpy.ndarray.__ne__"><code>ndarray.__ne__</code></a></td> <td>x.__ne__(y) &lt;==&gt; x!=y</td> </tr>  </table> <p>Truth value of an array (<code>bool</code>):</p> <table class="longtable docutils">   <tr class="row-odd">
<td><a class="reference internal" href="../generated/numpy.ndarray.__nonzero__/#numpy.ndarray.__nonzero__" title="numpy.ndarray.__nonzero__"><code>ndarray.__nonzero__</code></a></td> <td>x.__nonzero__() &lt;==&gt; x != 0</td> </tr>  </table> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">Truth-value testing of an array invokes <a class="reference internal" href="../generated/numpy.ndarray.__nonzero__/#numpy.ndarray.__nonzero__" title="numpy.ndarray.__nonzero__"><code>ndarray.__nonzero__</code></a>, which raises an error if the number of elements in the array is larger than 1, because the truth value of such arrays is ambiguous. Use <a class="reference internal" href="../generated/numpy.ndarray.any/#numpy.ndarray.any" title="numpy.ndarray.any"><code>.any()</code></a> and <a class="reference internal" href="../generated/numpy.ndarray.all/#numpy.ndarray.all" title="numpy.ndarray.all"><code>.all()</code></a> instead to be clear about what is meant in such cases. (If the number of elements is 0, the array evaluates to <code>False</code>.)</p> </div> <p>Unary operations:</p> <table class="longtable docutils">   <tr class="row-odd">
<td><a class="reference internal" href="../generated/numpy.ndarray.__neg__/#numpy.ndarray.__neg__" title="numpy.ndarray.__neg__"><code>ndarray.__neg__</code></a></td> <td>x.__neg__() &lt;==&gt; -x</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../generated/numpy.ndarray.__pos__/#numpy.ndarray.__pos__" title="numpy.ndarray.__pos__"><code>ndarray.__pos__</code></a></td> <td>x.__pos__() &lt;==&gt; +x</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.ndarray.__abs__/#numpy.ndarray.__abs__" title="numpy.ndarray.__abs__"><code>ndarray.__abs__</code></a>() &lt;==&gt; abs(x)</td> <td></td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../generated/numpy.ndarray.__invert__/#numpy.ndarray.__invert__" title="numpy.ndarray.__invert__"><code>ndarray.__invert__</code></a></td> <td>x.__invert__() &lt;==&gt; ~x</td> </tr>  </table> <p>Arithmetic:</p> <table class="longtable docutils">   <tr class="row-odd">
<td><a class="reference internal" href="../generated/numpy.ndarray.__add__/#numpy.ndarray.__add__" title="numpy.ndarray.__add__"><code>ndarray.__add__</code></a></td> <td>x.__add__(y) &lt;==&gt; x+y</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../generated/numpy.ndarray.__sub__/#numpy.ndarray.__sub__" title="numpy.ndarray.__sub__"><code>ndarray.__sub__</code></a></td> <td>x.__sub__(y) &lt;==&gt; x-y</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../generated/numpy.ndarray.__mul__/#numpy.ndarray.__mul__" title="numpy.ndarray.__mul__"><code>ndarray.__mul__</code></a></td> <td>x.__mul__(y) &lt;==&gt; x*y</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../generated/numpy.ndarray.__div__/#numpy.ndarray.__div__" title="numpy.ndarray.__div__"><code>ndarray.__div__</code></a></td> <td>x.__div__(y) &lt;==&gt; x/y</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../generated/numpy.ndarray.__truediv__/#numpy.ndarray.__truediv__" title="numpy.ndarray.__truediv__"><code>ndarray.__truediv__</code></a></td> <td>x.__truediv__(y) &lt;==&gt; x/y</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../generated/numpy.ndarray.__floordiv__/#numpy.ndarray.__floordiv__" title="numpy.ndarray.__floordiv__"><code>ndarray.__floordiv__</code></a></td> <td>x.__floordiv__(y) &lt;==&gt; x//y</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../generated/numpy.ndarray.__mod__/#numpy.ndarray.__mod__" title="numpy.ndarray.__mod__"><code>ndarray.__mod__</code></a></td> <td>x.__mod__(y) &lt;==&gt; x%y</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/numpy.ndarray.__divmod__/#numpy.ndarray.__divmod__" title="numpy.ndarray.__divmod__"><code>ndarray.__divmod__</code></a>(y) &lt;==&gt; divmod(x, y)</td> <td></td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.ndarray.__pow__/#numpy.ndarray.__pow__" title="numpy.ndarray.__pow__"><code>ndarray.__pow__</code></a>(y[, z]) &lt;==&gt; pow(x, y[, z])</td> <td></td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../generated/numpy.ndarray.__lshift__/#numpy.ndarray.__lshift__" title="numpy.ndarray.__lshift__"><code>ndarray.__lshift__</code></a></td> <td>x.__lshift__(y) &lt;==&gt; x&lt;&lt;y</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../generated/numpy.ndarray.__rshift__/#numpy.ndarray.__rshift__" title="numpy.ndarray.__rshift__"><code>ndarray.__rshift__</code></a></td> <td>x.__rshift__(y) &lt;==&gt; x&gt;&gt;y</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../generated/numpy.ndarray.__and__/#numpy.ndarray.__and__" title="numpy.ndarray.__and__"><code>ndarray.__and__</code></a></td> <td>x.__and__(y) &lt;==&gt; x&amp;y</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../generated/numpy.ndarray.__or__/#numpy.ndarray.__or__" title="numpy.ndarray.__or__"><code>ndarray.__or__</code></a></td> <td>x.__or__(y) &lt;==&gt; x|y</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../generated/numpy.ndarray.__xor__/#numpy.ndarray.__xor__" title="numpy.ndarray.__xor__"><code>ndarray.__xor__</code></a></td> <td>x.__xor__(y) &lt;==&gt; x^y</td> </tr>  </table> <div class="admonition note"> <p class="first admonition-title">Note</p> <ul class="last simple"> <li>Any third argument to <a class="reference external" href="https://docs.python.org/dev/library/functions.html#pow" title="(in Python v3.7)" target="_blank"><code>pow</code></a> is silently ignored, as the underlying <a class="reference internal" href="../generated/numpy.power/#numpy.power" title="numpy.power"><code>ufunc</code></a> takes only two arguments.</li> <li>The three division operators are all defined; <code>div</code> is active by default, <code>truediv</code> is active when <a class="reference external" href="https://docs.python.org/dev/library/__future__.html#module-__future__" title="(in Python v3.7)" target="_blank"><code>__future__</code></a> division is in effect.</li> <li>Because <a class="reference internal" href="../generated/numpy.ndarray/#numpy.ndarray" title="numpy.ndarray"><code>ndarray</code></a> is a built-in type (written in C), the <code>__r{op}__</code> special methods are not directly defined.</li> <li>The functions called to implement many arithmetic special methods for arrays can be modified using <code>set_numeric_ops</code>.</li> </ul> </div> <p>Arithmetic, in-place:</p> <table class="longtable docutils">   <tr class="row-odd">
<td><a class="reference internal" href="../generated/numpy.ndarray.__iadd__/#numpy.ndarray.__iadd__" title="numpy.ndarray.__iadd__"><code>ndarray.__iadd__</code></a></td> <td>x.__iadd__(y) &lt;==&gt; x+=y</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../generated/numpy.ndarray.__isub__/#numpy.ndarray.__isub__" title="numpy.ndarray.__isub__"><code>ndarray.__isub__</code></a></td> <td>x.__isub__(y) &lt;==&gt; x-=y</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../generated/numpy.ndarray.__imul__/#numpy.ndarray.__imul__" title="numpy.ndarray.__imul__"><code>ndarray.__imul__</code></a></td> <td>x.__imul__(y) &lt;==&gt; x*=y</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../generated/numpy.ndarray.__idiv__/#numpy.ndarray.__idiv__" title="numpy.ndarray.__idiv__"><code>ndarray.__idiv__</code></a></td> <td>x.__idiv__(y) &lt;==&gt; x/=y</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../generated/numpy.ndarray.__itruediv__/#numpy.ndarray.__itruediv__" title="numpy.ndarray.__itruediv__"><code>ndarray.__itruediv__</code></a></td> <td>x.__itruediv__(y) &lt;==&gt; x/y</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../generated/numpy.ndarray.__ifloordiv__/#numpy.ndarray.__ifloordiv__" title="numpy.ndarray.__ifloordiv__"><code>ndarray.__ifloordiv__</code></a></td> <td>x.__ifloordiv__(y) &lt;==&gt; x//y</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../generated/numpy.ndarray.__imod__/#numpy.ndarray.__imod__" title="numpy.ndarray.__imod__"><code>ndarray.__imod__</code></a></td> <td>x.__imod__(y) &lt;==&gt; x%=y</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../generated/numpy.ndarray.__ipow__/#numpy.ndarray.__ipow__" title="numpy.ndarray.__ipow__"><code>ndarray.__ipow__</code></a></td> <td>x.__ipow__(y) &lt;==&gt; x**=y</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../generated/numpy.ndarray.__ilshift__/#numpy.ndarray.__ilshift__" title="numpy.ndarray.__ilshift__"><code>ndarray.__ilshift__</code></a></td> <td>x.__ilshift__(y) &lt;==&gt; x&lt;&lt;=y</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../generated/numpy.ndarray.__irshift__/#numpy.ndarray.__irshift__" title="numpy.ndarray.__irshift__"><code>ndarray.__irshift__</code></a></td> <td>x.__irshift__(y) &lt;==&gt; x&gt;&gt;=y</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../generated/numpy.ndarray.__iand__/#numpy.ndarray.__iand__" title="numpy.ndarray.__iand__"><code>ndarray.__iand__</code></a></td> <td>x.__iand__(y) &lt;==&gt; x&amp;=y</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../generated/numpy.ndarray.__ior__/#numpy.ndarray.__ior__" title="numpy.ndarray.__ior__"><code>ndarray.__ior__</code></a></td> <td>x.__ior__(y) &lt;==&gt; x|=y</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../generated/numpy.ndarray.__ixor__/#numpy.ndarray.__ixor__" title="numpy.ndarray.__ixor__"><code>ndarray.__ixor__</code></a></td> <td>x.__ixor__(y) &lt;==&gt; x^=y</td> </tr>  </table> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p class="last">In place operations will perform the calculation using the precision decided by the data type of the two operands, but will silently downcast the result (if necessary) so it can fit back into the array. Therefore, for mixed precision calculations, <code>A {op}=
B</code> can be different than <code>A = A {op} B</code>. For example, suppose <code>a = ones((3,3))</code>. Then, <code>a += 3j</code> is different than <code>a = a +
3j</code>: while they both perform the same computation, <code>a += 3</code> casts the result to fit back in <code>a</code>, whereas <code>a = a + 3j</code> re-binds the name <code>a</code> to the result.</p> </div> <p>Matrix Multiplication:</p> <table class="longtable docutils">   <tr class="row-odd">
<td><code>ndarray.__matmul__</code></td> <td></td> </tr>  </table> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">Matrix operators <code>@</code> and <code>@=</code> were introduced in Python 3.5 following PEP465. NumPy 1.10.0 has a preliminary implementation of <code>@</code> for testing purposes. Further documentation can be found in the <a class="reference internal" href="../generated/numpy.matmul/#numpy.matmul" title="numpy.matmul"><code>matmul</code></a> documentation.</p> </div>   <h2 id="special-methods">Special methods</h2> <p>For standard library functions:</p> <table class="longtable docutils">   <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.ndarray.__copy__/#numpy.ndarray.__copy__" title="numpy.ndarray.__copy__"><code>ndarray.__copy__</code></a>([order])</td> <td>Return a copy of the array.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/numpy.ndarray.__deepcopy__/#numpy.ndarray.__deepcopy__" title="numpy.ndarray.__deepcopy__"><code>ndarray.__deepcopy__</code></a>(() -&gt; Deep copy of array.)</td> <td>Used if copy.deepcopy is called on an array.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.ndarray.__reduce__/#numpy.ndarray.__reduce__" title="numpy.ndarray.__reduce__"><code>ndarray.__reduce__</code></a>()</td> <td>For pickling.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/numpy.ndarray.__setstate__/#numpy.ndarray.__setstate__" title="numpy.ndarray.__setstate__"><code>ndarray.__setstate__</code></a>(version, shape, dtype, ...)</td> <td>For unpickling.</td> </tr>  </table> <p>Basic customization:</p> <table class="longtable docutils">   <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.ndarray.__new__/#numpy.ndarray.__new__" title="numpy.ndarray.__new__"><code>ndarray.__new__</code></a>((S, ...)</td> <td></td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/numpy.ndarray.__array__/#numpy.ndarray.__array__" title="numpy.ndarray.__array__"><code>ndarray.__array__</code></a>(...)</td> <td>Returns either a new reference to self if dtype is not given or a new array of provided data type if dtype is different from the current dtype of the array.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.ndarray.__array_wrap__/#numpy.ndarray.__array_wrap__" title="numpy.ndarray.__array_wrap__"><code>ndarray.__array_wrap__</code></a>(...)</td> <td></td> </tr>  </table> <p>Container customization: (see <a class="reference internal" href="../arrays.indexing/#arrays-indexing"><span class="std std-ref">Indexing</span></a>)</p> <table class="longtable docutils">   <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.ndarray.__len__/#numpy.ndarray.__len__" title="numpy.ndarray.__len__"><code>ndarray.__len__</code></a>() &lt;==&gt; len(x)</td> <td></td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../generated/numpy.ndarray.__getitem__/#numpy.ndarray.__getitem__" title="numpy.ndarray.__getitem__"><code>ndarray.__getitem__</code></a></td> <td>x.__getitem__(y) &lt;==&gt; x[y]</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../generated/numpy.ndarray.__setitem__/#numpy.ndarray.__setitem__" title="numpy.ndarray.__setitem__"><code>ndarray.__setitem__</code></a></td> <td>x.__setitem__(i, y) &lt;==&gt; x[i]=y</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../generated/numpy.ndarray.__contains__/#numpy.ndarray.__contains__" title="numpy.ndarray.__contains__"><code>ndarray.__contains__</code></a></td> <td>x.__contains__(y) &lt;==&gt; y in x</td> </tr>  </table> <p>Conversion; the operations <code>complex</code>, <code>int</code>, <code>long</code>, <code>float</code>, <a class="reference external" href="https://docs.python.org/dev/library/functions.html#oct" title="(in Python v3.7)" target="_blank"><code>oct</code></a>, and <a class="reference external" href="https://docs.python.org/dev/library/functions.html#hex" title="(in Python v3.7)" target="_blank"><code>hex</code></a>. They work only on arrays that have one element in them and return the appropriate scalar.</p> <table class="longtable docutils">   <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.ndarray.__int__/#numpy.ndarray.__int__" title="numpy.ndarray.__int__"><code>ndarray.__int__</code></a>() &lt;==&gt; int(x)</td> <td></td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/numpy.ndarray.__long__/#numpy.ndarray.__long__" title="numpy.ndarray.__long__"><code>ndarray.__long__</code></a>() &lt;==&gt; long(x)</td> <td></td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.ndarray.__float__/#numpy.ndarray.__float__" title="numpy.ndarray.__float__"><code>ndarray.__float__</code></a>() &lt;==&gt; float(x)</td> <td></td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/numpy.ndarray.__oct__/#numpy.ndarray.__oct__" title="numpy.ndarray.__oct__"><code>ndarray.__oct__</code></a>() &lt;==&gt; oct(x)</td> <td></td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.ndarray.__hex__/#numpy.ndarray.__hex__" title="numpy.ndarray.__hex__"><code>ndarray.__hex__</code></a>() &lt;==&gt; hex(x)</td> <td></td> </tr>  </table> <p>String representations:</p> <table class="longtable docutils">   <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.ndarray.__str__/#numpy.ndarray.__str__" title="numpy.ndarray.__str__"><code>ndarray.__str__</code></a>() &lt;==&gt; str(x)</td> <td></td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/numpy.ndarray.__repr__/#numpy.ndarray.__repr__" title="numpy.ndarray.__repr__"><code>ndarray.__repr__</code></a>() &lt;==&gt; repr(x)</td> <td></td> </tr>  </table>
<div class="_attribution">
  <p class="_attribution-p">
    © 2008–2017 NumPy Developers<br>Licensed under the NumPy License.<br>
    <a href="https://docs.scipy.org/doc/numpy-1.13.0/reference/arrays.ndarray.html" class="_attribution-link" target="_blank">https://docs.scipy.org/doc/numpy-1.13.0/reference/arrays.ndarray.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
