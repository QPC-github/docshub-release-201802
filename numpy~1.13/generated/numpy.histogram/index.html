
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>numpy.histogram() - NumPy 1.13 - W3cubDocs</title>
  
  <meta name="description" content=" Compute the histogram of a set of data. ">
  <meta name="keywords" content="numpy, histogram, -, numpy~1.13">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/numpy~1.13/generated/numpy.histogram/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-e0f881b0fce8cbe96f33dadc355b7159d5d2912911231446d60eb8f9caffa802.css">
  <script type="text/javascript" src="/assets/application-8fc46316434047265cd383f02b8e7f434ed7dec4a59f920dd633deef8d488d1b.js"></script>
  <script src="/json/numpy~1.13.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/numpy~1.13/" class="_nav-link" title="" style="margin-left:0;">NumPy 1.13</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _sphinx">
				
<h1 id="numpy-histogram">numpy.histogram</h1> <dl class="function"> <dt id="numpy.histogram">
<code>numpy.histogram(a, bins=10, range=None, normed=False, weights=None, density=None)</code> <a class="reference external" href="http://github.com/numpy/numpy/blob/v1.13.0/numpy/lib/function_base.py#L432-L826" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Compute the histogram of a set of data.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr class="field-odd field">
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>a</strong> : array_like</p>  <p>Input data. The histogram is computed over the flattened array.</p>  <p><strong>bins</strong> : int or sequence of scalars or str, optional</p>  <p>If <code>bins</code> is an int, it defines the number of equal-width bins in the given range (10, by default). If <code>bins</code> is a sequence, it defines the bin edges, including the rightmost edge, allowing for non-uniform bin widths.</p> <div class="versionadded"> <p><span class="versionmodified">New in version 1.11.0.</span></p> </div> <p>If <code>bins</code> is a string from the list below, <a class="reference internal" href="#numpy.histogram" title="numpy.histogram"><code>histogram</code></a> will use the method chosen to calculate the optimal bin width and consequently the number of bins (see <code>Notes</code> for more detail on the estimators) from the data that falls within the requested range. While the bin width will be optimal for the actual data in the range, the number of bins will be computed to fill the entire range, including the empty portions. For visualisation, using the ‘auto’ option is suggested. Weighted data is not supported for automated bin size selection.</p> <dl class="docutils"> <dt>‘auto’</dt> <dd>
<p class="first last">Maximum of the ‘sturges’ and ‘fd’ estimators. Provides good all around performance.</p> </dd> <dt>‘fd’ (Freedman Diaconis Estimator)</dt> <dd>
<p class="first last">Robust (resilient to outliers) estimator that takes into account data variability and data size.</p> </dd> <dt>‘doane’</dt> <dd>
<p class="first last">An improved version of Sturges’ estimator that works better with non-normal datasets.</p> </dd> <dt>‘scott’</dt> <dd>
<p class="first last">Less robust estimator that that takes into account data variability and data size.</p> </dd> <dt>‘rice’</dt> <dd>
<p class="first last">Estimator does not take variability into account, only data size. Commonly overestimates number of bins required.</p> </dd> <dt>‘sturges’</dt> <dd>
<p class="first last">R’s default method, only accounts for data size. Only optimal for gaussian data and underestimates number of bins for large non-gaussian datasets.</p> </dd> <dt>‘sqrt’</dt> <dd>
<p class="first last">Square root (of data size) estimator, used by Excel and other programs for its speed and simplicity.</p> </dd> </dl>  <p><strong>range</strong> : (float, float), optional</p>  <p>The lower and upper range of the bins. If not provided, range is simply <code>(a.min(), a.max())</code>. Values outside the range are ignored. The first element of the range must be less than or equal to the second. <code>range</code> affects the automatic bin computation as well. While bin width is computed to be optimal based on the actual data within <code>range</code>, the bin count will fill the entire range including portions containing no data.</p>  <p><strong>normed</strong> : bool, optional</p>  <p>This keyword is deprecated in NumPy 1.6.0 due to confusing/buggy behavior. It will be removed in NumPy 2.0.0. Use the <code>density</code> keyword instead. If <code>False</code>, the result will contain the number of samples in each bin. If <code>True</code>, the result is the value of the probability <em>density</em> function at the bin, normalized such that the <em>integral</em> over the range is 1. Note that this latter behavior is known to be buggy with unequal bin widths; use <code>density</code> instead.</p>  <p><strong>weights</strong> : array_like, optional</p>  <p>An array of weights, of the same shape as <code>a</code>. Each value in <code>a</code> only contributes its associated weight towards the bin count (instead of 1). If <code>density</code> is True, the weights are normalized, so that the integral of the density over the range remains 1.</p>  <p><strong>density</strong> : bool, optional</p>  <p>If <code>False</code>, the result will contain the number of samples in each bin. If <code>True</code>, the result is the value of the probability <em>density</em> function at the bin, normalized such that the <em>integral</em> over the range is 1. Note that the sum of the histogram values will not be equal to 1 unless bins of unity width are chosen; it is not a probability <em>mass</em> function.</p> <p>Overrides the <code>normed</code> keyword if given.</p>  </td> </tr> <tr class="field-even field">
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>hist</strong> : array</p>  <p>The values of the histogram. See <code>density</code> and <code>weights</code> for a description of the possible semantics.</p>  <p><strong>bin_edges</strong> : array of dtype float</p>  <p>Return the bin edges <code>(length(hist)+1)</code>.</p>  </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <p class="last"><a class="reference internal" href="../numpy.histogramdd/#numpy.histogramdd" title="numpy.histogramdd"><code>histogramdd</code></a>, <a class="reference internal" href="../numpy.bincount/#numpy.bincount" title="numpy.bincount"><code>bincount</code></a>, <a class="reference internal" href="../numpy.searchsorted/#numpy.searchsorted" title="numpy.searchsorted"><code>searchsorted</code></a>, <a class="reference internal" href="../numpy.digitize/#numpy.digitize" title="numpy.digitize"><code>digitize</code></a></p> </div> <h4 class="rubric">Notes</h4> <p>All but the last (righthand-most) bin is half-open. In other words, if <code>bins</code> is:</p> <pre data-language="python">[1, 2, 3, 4]
</pre> <p>then the first bin is <code>[1, 2)</code> (including 1, but excluding 2) and the second <code>[2, 3)</code>. The last bin, however, is <code>[3, 4]</code>, which <em>includes</em> 4.</p> <div class="versionadded"> <p><span class="versionmodified">New in version 1.11.0.</span></p> </div> <p>The methods to estimate the optimal number of bins are well founded in literature, and are inspired by the choices R provides for histogram visualisation. Note that having the number of bins proportional to <img class="math" src="https://docs.scipy.org/doc/numpy-1.13.0/_images/math/c7d0f69434fe8fb83b3d847860ce222ee5323ef5.png" alt="n^{1/3}" style="vertical-align: 0px"> is asymptotically optimal, which is why it appears in most estimators. These are simply plug-in methods that give good starting points for number of bins. In the equations below, <img class="math" src="https://docs.scipy.org/doc/numpy-1.13.0/_images/math/8df9e36fd35706e719b27fb3992ef573de0c1d93.png" alt="h" style="vertical-align: 0px"> is the binwidth and <img class="math" src="https://docs.scipy.org/doc/numpy-1.13.0/_images/math/d23a211a3a5b47439bdbdc706965925cb0f95544.png" alt="n_h" style="vertical-align: -2px"> is the number of bins. All estimators that compute bin counts are recast to bin width using the <a class="reference internal" href="../numpy.ptp/#numpy.ptp" title="numpy.ptp"><code>ptp</code></a> of the data. The final bin count is obtained from <a href="#id1"><span class="problematic" id="id2">``</span></a>np.round(np.ceil(range / h))`.</p> <dl class="docutils"> <dt>‘Auto’ (maximum of the ‘Sturges’ and ‘FD’ estimators)</dt> <dd>A compromise to get a good value. For small datasets the Sturges value will usually be chosen, while larger datasets will usually default to FD. Avoids the overly conservative behaviour of FD and Sturges for small and large datasets respectively. Switchover point is usually <img class="math" src="https://docs.scipy.org/doc/numpy-1.13.0/_images/math/aaf420152d0d851794fa73716ff3e543e36e1386.png" alt="a.size \approx 1000" style="vertical-align: -1px">.</dd> <dt>‘FD’ (Freedman Diaconis Estimator)</dt> <dd>
<div class="first math"> <p><img src="https://docs.scipy.org/doc/numpy-1.13.0/_images/math/10b6aa25e9ef1f25434cdfddf5cbb67f398f29a7.png" alt="h = 2 \frac{IQR}{n^{1/3}}"></p> </div>
<p class="last">The binwidth is proportional to the interquartile range (IQR) and inversely proportional to cube root of a.size. Can be too conservative for small datasets, but is quite good for large datasets. The IQR is very robust to outliers.</p> </dd> <dt>‘Scott’</dt> <dd>
<div class="first math"> <p><img src="https://docs.scipy.org/doc/numpy-1.13.0/_images/math/f7dc925b2da3af8c6d7b9730ecbd5e387753a866.png" alt="h = \sigma \sqrt[3]{\frac{24 * \sqrt{\pi}}{n}}"></p> </div>
<p class="last">The binwidth is proportional to the standard deviation of the data and inversely proportional to cube root of <code>x.size</code>. Can be too conservative for small datasets, but is quite good for large datasets. The standard deviation is not very robust to outliers. Values are very similar to the Freedman-Diaconis estimator in the absence of outliers.</p> </dd> <dt>‘Rice’</dt> <dd>
<div class="first math"> <p><img src="https://docs.scipy.org/doc/numpy-1.13.0/_images/math/2d64f76d4f643178b719e4ea627bdf4c3471524a.png" alt="n_h = 2n^{1/3}"></p> </div>
<p class="last">The number of bins is only proportional to cube root of <code>a.size</code>. It tends to overestimate the number of bins and it does not take into account data variability.</p> </dd> <dt>‘Sturges’</dt> <dd>
<div class="first math"> <p><img src="https://docs.scipy.org/doc/numpy-1.13.0/_images/math/1bae769e32d4741e00463cfdeb070904086bd7d0.png" alt="n_h = \log _{2}n+1"></p> </div>
<p class="last">The number of bins is the base 2 log of <code>a.size</code>. This estimator assumes normality of data and is too conservative for larger, non-normal datasets. This is the default method in R’s <code>hist</code> method.</p> </dd> <dt>‘Doane’</dt> <dd>
<div class="first math"> <p><img src="https://docs.scipy.org/doc/numpy-1.13.0/_images/math/b7318cd405779a78210d7be4ec1cc6d8c3c8ad32.png" alt="n_h = 1 + \log_{2}(n) +
            \log_{2}(1 + \frac{|g_1|}{\sigma_{g_1}})

g_1 = mean[(\frac{x - \mu}{\sigma})^3]

\sigma_{g_1} = \sqrt{\frac{6(n - 2)}{(n + 1)(n + 3)}}"></p> </div>
<p class="last">An improved version of Sturges’ formula that produces better estimates for non-normal datasets. This estimator attempts to account for the skew of the data.</p> </dd> <dt>‘Sqrt’</dt> <dd>
<div class="first math"> <p><img src="https://docs.scipy.org/doc/numpy-1.13.0/_images/math/e63575dd3cf9c7134989d8106537e13a602a25f6.png" alt="n_h = \sqrt n"></p> </div>
<p class="last">The simplest and fastest estimator. Only takes into account the data size.</p> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; np.histogram([1, 2, 1], bins=[0, 1, 2, 3])
(array([0, 2, 1]), array([0, 1, 2, 3]))
&gt;&gt;&gt; np.histogram(np.arange(4), bins=np.arange(5), density=True)
(array([ 0.25,  0.25,  0.25,  0.25]), array([0, 1, 2, 3, 4]))
&gt;&gt;&gt; np.histogram([[1, 2, 1], [1, 0, 1]], bins=[0,1,2,3])
(array([1, 4, 1]), array([0, 1, 2, 3]))
</pre> <pre data-language="python">&gt;&gt;&gt; a = np.arange(5)
&gt;&gt;&gt; hist, bin_edges = np.histogram(a, density=True)
&gt;&gt;&gt; hist
array([ 0.5,  0. ,  0.5,  0. ,  0. ,  0.5,  0. ,  0.5,  0. ,  0.5])
&gt;&gt;&gt; hist.sum()
2.4999999999999996
&gt;&gt;&gt; np.sum(hist * np.diff(bin_edges))
1.0
</pre> <div class="versionadded"> <p><span class="versionmodified">New in version 1.11.0.</span></p> </div> <p>Automated Bin Selection Methods example, using 2 peak random data with 2000 points:</p> <pre data-language="python">&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; rng = np.random.RandomState(10)  # deterministic random data
&gt;&gt;&gt; a = np.hstack((rng.normal(size=1000),
...                rng.normal(loc=5, scale=2, size=1000)))
&gt;&gt;&gt; plt.hist(a, bins='auto')  # arguments are passed to np.histogram
&gt;&gt;&gt; plt.title("Histogram with 'auto' bins")
&gt;&gt;&gt; plt.show()
</pre> <p>(<a class="reference external" href="https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy-histogram-1.py" target="_blank">Source code</a>, <a class="reference external" href="https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy-histogram-1.png" target="_blank">png</a>, <a class="reference external" href="https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy-histogram-1.pdf" target="_blank">pdf</a>)</p> <div class="figure"> <img alt="../../_images/numpy-histogram-1.png" src="https://docs.scipy.org/doc/numpy-1.13.0/_images/numpy-histogram-1.png"> </div> </dd>
</dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 2008–2017 NumPy Developers<br>Licensed under the NumPy License.<br>
    <a href="https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.histogram.html" class="_attribution-link" target="_blank">https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.histogram.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
