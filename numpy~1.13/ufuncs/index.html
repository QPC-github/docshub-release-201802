
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Universal Functions (Ufunc) - NumPy 1.13 - W3cubDocs</title>
  
  <meta name="description" content="A universal function (or ufunc for short) is a function that operates on ndarrays in an element-by-element fashion, supporting array broadcasting, &hellip;">
  <meta name="keywords" content="universal, functions, ufunc, -, numpy, numpy~1.13">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/numpy~1.13/ufuncs/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-e0f881b0fce8cbe96f33dadc355b7159d5d2912911231446d60eb8f9caffa802.css">
  <script type="text/javascript" src="/assets/application-8fc46316434047265cd383f02b8e7f434ed7dec4a59f920dd633deef8d488d1b.js"></script>
  <script src="/json/numpy~1.13.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/numpy~1.13/" class="_nav-link" title="" style="margin-left:0;">NumPy 1.13</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _sphinx">
				
<h1 id="ufuncs">Universal functions (ufunc)</h1> <p id="universal-functions-ufunc">A universal function (or <a class="reference internal" href="https://docs.scipy.org/doc/numpy-1.13.0/glossary.html#term-ufunc" target="_blank"><span class="xref std std-term">ufunc</span></a> for short) is a function that operates on <a class="reference internal" href="../generated/numpy.ndarray/#numpy.ndarray" title="numpy.ndarray"><code>ndarrays</code></a> in an element-by-element fashion, supporting <a class="reference internal" href="#ufuncs-broadcasting"><span class="std std-ref">array broadcasting</span></a>, <a class="reference internal" href="#ufuncs-casting"><span class="std std-ref">type casting</span></a>, and several other standard features. That is, a ufunc is a “<span class="xref std std-term">vectorized</span>” wrapper for a function that takes a fixed number of scalar inputs and produces a fixed number of scalar outputs.</p> <p>In NumPy, universal functions are instances of the <code>numpy.ufunc</code> class. Many of the built-in functions are implemented in compiled C code, but <code>ufunc</code> instances can also be produced using the <a class="reference internal" href="../generated/numpy.frompyfunc/#numpy.frompyfunc" title="numpy.frompyfunc"><code>frompyfunc</code></a> factory function.</p>  <h2 id="ufuncs-broadcasting">Broadcasting</h2> <p id="broadcasting">Each universal function takes array inputs and produces array outputs by performing the core function element-wise on the inputs. Standard broadcasting rules are applied so that inputs not sharing exactly the same shapes can still be usefully operated on. Broadcasting can be understood by four rules:</p> <ol class="arabic simple"> <li>All input arrays with <a class="reference internal" href="../generated/numpy.ndarray.ndim/#numpy.ndarray.ndim" title="numpy.ndarray.ndim"><code>ndim</code></a> smaller than the input array of largest <a class="reference internal" href="../generated/numpy.ndarray.ndim/#numpy.ndarray.ndim" title="numpy.ndarray.ndim"><code>ndim</code></a>, have 1’s prepended to their shapes.</li> <li>The size in each dimension of the output shape is the maximum of all the input sizes in that dimension.</li> <li>An input can be used in the calculation if its size in a particular dimension either matches the output size in that dimension, or has value exactly 1.</li> <li>If an input has a dimension size of 1 in its shape, the first data entry in that dimension will be used for all calculations along that dimension. In other words, the stepping machinery of the <a class="reference internal" href="https://docs.scipy.org/doc/numpy-1.13.0/glossary.html#term-ufunc" target="_blank"><span class="xref std std-term">ufunc</span></a> will simply not step along that dimension (the <span class="xref std std-term">stride</span> will be 0 for that dimension).</li> </ol> <p>Broadcasting is used throughout NumPy to decide how to handle disparately shaped arrays; for example, all arithmetic operations (<code>+</code>, <code>-</code>, <code>*</code>, ...) between <a class="reference internal" href="../generated/numpy.ndarray/#numpy.ndarray" title="numpy.ndarray"><code>ndarrays</code></a> broadcast the arrays before operation.</p> <p id="index-1">A set of arrays is called “<span class="xref std std-term">broadcastable</span>” to the same shape if the above rules produce a valid result, <em>i.e.</em>, one of the following is true:</p> <ol class="arabic simple"> <li>The arrays all have exactly the same shape.</li> <li>The arrays all have the same number of dimensions and the length of each dimensions is either a common length or 1.</li> <li>The arrays that have too few dimensions can have their shapes prepended with a dimension of length 1 to satisfy property 2.</li> </ol>  <h4>Example</h4> <p>If <code>a.shape</code> is (5,1), <code>b.shape</code> is (1,6), <code>c.shape</code> is (6,) and <code>d.shape</code> is () so that <em>d</em> is a scalar, then <em>a</em>, <em>b</em>, <em>c</em>, and <em>d</em> are all broadcastable to dimension (5,6); and</p> <ul class="last simple"> <li>
<em>a</em> acts like a (5,6) array where <code>a[:,0]</code> is broadcast to the other columns,</li> <li>
<em>b</em> acts like a (5,6) array where <code>b[0,:]</code> is broadcast to the other rows,</li> <li>
<em>c</em> acts like a (1,6) array and therefore like a (5,6) array where <code>c[:]</code> is broadcast to every row, and finally,</li> <li>
<em>d</em> acts like a (5,6) array where the single value is repeated.</li> </ul>    <h2 id="ufuncs-output-type">Output type determination</h2> <p id="output-type-determination">The output of the ufunc (and its methods) is not necessarily an <a class="reference internal" href="../generated/numpy.ndarray/#numpy.ndarray" title="numpy.ndarray"><code>ndarray</code></a>, if all input arguments are not <a class="reference internal" href="../generated/numpy.ndarray/#numpy.ndarray" title="numpy.ndarray"><code>ndarrays</code></a>.</p> <p>All output arrays will be passed to the <a class="reference internal" href="../arrays.classes/#numpy.class.__array_prepare__" title="numpy.class.__array_prepare__"><code>__array_prepare__</code></a> and <a class="reference internal" href="../arrays.classes/#numpy.class.__array_wrap__" title="numpy.class.__array_wrap__"><code>__array_wrap__</code></a> methods of the input (besides <a class="reference internal" href="../generated/numpy.ndarray/#numpy.ndarray" title="numpy.ndarray"><code>ndarrays</code></a>, and scalars) that defines it <strong>and</strong> has the highest <a class="reference internal" href="../arrays.classes/#numpy.class.__array_priority__" title="numpy.class.__array_priority__"><code>__array_priority__</code></a> of any other input to the universal function. The default <a class="reference internal" href="../arrays.classes/#numpy.class.__array_priority__" title="numpy.class.__array_priority__"><code>__array_priority__</code></a> of the ndarray is 0.0, and the default <a class="reference internal" href="../arrays.classes/#numpy.class.__array_priority__" title="numpy.class.__array_priority__"><code>__array_priority__</code></a> of a subtype is 1.0. Matrices have <a class="reference internal" href="../arrays.classes/#numpy.class.__array_priority__" title="numpy.class.__array_priority__"><code>__array_priority__</code></a> equal to 10.0.</p> <p>All ufuncs can also take output arguments. If necessary, output will be cast to the data-type(s) of the provided output array(s). If a class with an <a class="reference internal" href="../arrays.classes/#numpy.class.__array__" title="numpy.class.__array__"><code>__array__</code></a> method is used for the output, results will be written to the object returned by <a class="reference internal" href="../arrays.classes/#numpy.class.__array__" title="numpy.class.__array__"><code>__array__</code></a>. Then, if the class also has an <a class="reference internal" href="../arrays.classes/#numpy.class.__array_prepare__" title="numpy.class.__array_prepare__"><code>__array_prepare__</code></a> method, it is called so metadata may be determined based on the context of the ufunc (the context consisting of the ufunc itself, the arguments passed to the ufunc, and the ufunc domain.) The array object returned by <a class="reference internal" href="../arrays.classes/#numpy.class.__array_prepare__" title="numpy.class.__array_prepare__"><code>__array_prepare__</code></a> is passed to the ufunc for computation. Finally, if the class also has an <a class="reference internal" href="../arrays.classes/#numpy.class.__array_wrap__" title="numpy.class.__array_wrap__"><code>__array_wrap__</code></a> method, the returned <a class="reference internal" href="../generated/numpy.ndarray/#numpy.ndarray" title="numpy.ndarray"><code>ndarray</code></a> result will be passed to that method just before passing control back to the caller.</p>   <h2 id="use-of-internal-buffers">Use of internal buffers</h2> <p id="index-2">Internally, buffers are used for misaligned data, swapped data, and data that has to be converted from one data type to another. The size of internal buffers is settable on a per-thread basis. There can be up to <img class="math" src="https://docs.scipy.org/doc/numpy-1.13.0/_images/math/a5fb52153321429a5267e5ca4acbed9a4501a412.png" alt="2 (n_{\mathrm{inputs}} + n_{\mathrm{outputs}})" style="vertical-align: -4px"> buffers of the specified size created to handle the data from all the inputs and outputs of a ufunc. The default size of a buffer is 10,000 elements. Whenever buffer-based calculation would be needed, but all input arrays are smaller than the buffer size, those misbehaved or incorrectly-typed arrays will be copied before the calculation proceeds. Adjusting the size of the buffer may therefore alter the speed at which ufunc calculations of various sorts are completed. A simple interface for setting this variable is accessible using the function</p> <table class="longtable docutils">   <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.setbufsize/#numpy.setbufsize" title="numpy.setbufsize"><code>setbufsize</code></a>(size)</td> <td>Set the size of the buffer used in ufuncs.</td> </tr>  </table>   <h2 id="error-handling">Error handling</h2> <p id="index-3">Universal functions can trip special floating-point status registers in your hardware (such as divide-by-zero). If available on your platform, these registers will be regularly checked during calculation. Error handling is controlled on a per-thread basis, and can be configured using the functions</p> <table class="longtable docutils">   <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.seterr/#numpy.seterr" title="numpy.seterr"><code>seterr</code></a>([all, divide, over, under, invalid])</td> <td>Set how floating-point errors are handled.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/numpy.seterrcall/#numpy.seterrcall" title="numpy.seterrcall"><code>seterrcall</code></a>(func)</td> <td>Set the floating-point error callback function or log object.</td> </tr>  </table>   <h2 id="ufuncs-casting">Casting Rules</h2> <div class="admonition note" id="casting-rules"> <p class="first admonition-title">Note</p> <p class="last">In NumPy 1.6.0, a type promotion API was created to encapsulate the mechanism for determining output types. See the functions <a class="reference internal" href="../generated/numpy.result_type/#numpy.result_type" title="numpy.result_type"><code>result_type</code></a>, <a class="reference internal" href="../generated/numpy.promote_types/#numpy.promote_types" title="numpy.promote_types"><code>promote_types</code></a>, and <a class="reference internal" href="../generated/numpy.min_scalar_type/#numpy.min_scalar_type" title="numpy.min_scalar_type"><code>min_scalar_type</code></a> for more details.</p> </div> <p>At the core of every ufunc is a one-dimensional strided loop that implements the actual function for a specific type combination. When a ufunc is created, it is given a static list of inner loops and a corresponding list of type signatures over which the ufunc operates. The ufunc machinery uses this list to determine which inner loop to use for a particular case. You can inspect the <a class="reference internal" href="../generated/numpy.ufunc.types/#numpy.ufunc.types" title="numpy.ufunc.types"><code>.types</code></a> attribute for a particular ufunc to see which type combinations have a defined inner loop and which output type they produce (<a class="reference internal" href="../arrays.scalars/#arrays-scalars-character-codes"><span class="std std-ref">character codes</span></a> are used in said output for brevity).</p> <p>Casting must be done on one or more of the inputs whenever the ufunc does not have a core loop implementation for the input types provided. If an implementation for the input types cannot be found, then the algorithm searches for an implementation with a type signature to which all of the inputs can be cast “safely.” The first one it finds in its internal list of loops is selected and performed, after all necessary type casting. Recall that internal copies during ufuncs (even for casting) are limited to the size of an internal buffer (which is user settable).</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">Universal functions in NumPy are flexible enough to have mixed type signatures. Thus, for example, a universal function could be defined that works with floating-point and integer values. See <a class="reference internal" href="../generated/numpy.ldexp/#numpy.ldexp" title="numpy.ldexp"><code>ldexp</code></a> for an example.</p> </div> <p>By the above description, the casting rules are essentially implemented by the question of when a data type can be cast “safely” to another data type. The answer to this question can be determined in Python with a function call: <a class="reference internal" href="../generated/numpy.can_cast/#numpy.can_cast" title="numpy.can_cast"><code>can_cast(fromtype, totype)</code></a>. The Figure below shows the results of this call for the 24 internally supported types on the author’s 64-bit system. You can generate this table for your system with the code given in the Figure.</p> <div class="admonition-figure admonition"> <p class="first admonition-title">Figure</p> <p>Code segment showing the “can cast safely” table for a 32-bit system.</p> <pre data-language="python">&gt;&gt;&gt; def print_table(ntypes):
...     print 'X',
...     for char in ntypes: print char,
...     print
...     for row in ntypes:
...         print row,
...         for col in ntypes:
...             print int(np.can_cast(row, col)),
...         print
&gt;&gt;&gt; print_table(np.typecodes['All'])
X ? b h i l q p B H I L Q P e f d g F D G S U V O M m
? 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
b 0 1 1 1 1 1 1 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 0 0
h 0 0 1 1 1 1 1 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 0 0
i 0 0 0 1 1 1 1 0 0 0 0 0 0 0 0 1 1 0 1 1 1 1 1 1 0 0
l 0 0 0 0 1 1 1 0 0 0 0 0 0 0 0 1 1 0 1 1 1 1 1 1 0 0
q 0 0 0 0 1 1 1 0 0 0 0 0 0 0 0 1 1 0 1 1 1 1 1 1 0 0
p 0 0 0 0 1 1 1 0 0 0 0 0 0 0 0 1 1 0 1 1 1 1 1 1 0 0
B 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0
H 0 0 0 1 1 1 1 0 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1 0 0
I 0 0 0 0 1 1 1 0 0 1 1 1 1 0 0 1 1 0 1 1 1 1 1 1 0 0
L 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 1 1 0 1 1 1 1 1 1 0 0
Q 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 1 1 0 1 1 1 1 1 1 0 0
P 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 1 1 0 1 1 1 1 1 1 0 0
e 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 0 0
f 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 0 0
d 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 1 1 1 1 1 1 0 0
g 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 1 1 1 1 0 0
F 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 0 0
D 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 0 0
G 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 0 0
S 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 0 0
U 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0
V 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0
O 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0
M 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0
m 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1
</pre> </div> <p>You should note that, while included in the table for completeness, the ‘S’, ‘U’, and ‘V’ types cannot be operated on by ufuncs. Also, note that on a 32-bit system the integer types may have different sizes, resulting in a slightly altered table.</p> <p>Mixed scalar-array operations use a different set of casting rules that ensure that a scalar cannot “upcast” an array unless the scalar is of a fundamentally different kind of data (<em>i.e.</em>, under a different hierarchy in the data-type hierarchy) than the array. This rule enables you to use scalar constants in your code (which, as Python types, are interpreted accordingly in ufuncs) without worrying about whether the precision of the scalar constant will cause upcasting on your large (small precision) array.</p>   <h2 id="overriding-ufunc-behavior">Overriding Ufunc behavior</h2> <p>Classes (including ndarray subclasses) can override how ufuncs act on them by defining certain special methods. For details, see <a class="reference internal" href="../arrays.classes/#arrays-classes"><span class="std std-ref">Standard array subclasses</span></a>.</p>   <h2 id="ufunc"><code>ufunc</code></h2>  <h3 id="ufuncs-kwargs">Optional keyword arguments</h3> <p id="optional-keyword-arguments">All ufuncs take optional keyword arguments. Most of these represent advanced usage and will not typically be used.</p> <p id="index-5"><em>out</em></p>  <div class="versionadded"> <p><span class="versionmodified">New in version 1.6.</span></p> </div> <p>The first output can be provided as either a positional or a keyword parameter. Keyword ‘out’ arguments are incompatible with positional ones.</p> <div class="versionadded"> <p><span class="versionmodified">New in version 1.10.</span></p> </div> <p>The ‘out’ keyword argument is expected to be a tuple with one entry per output (which can be <code>None</code> for arrays to be allocated by the ufunc). For ufuncs with a single output, passing a single array (instead of a tuple holding a single array) is also valid.</p> <p>Passing a single array in the ‘out’ keyword argument to a ufunc with multiple outputs is deprecated, and will raise a warning in numpy 1.10, and an error in a future release.</p>  <p><em>where</em></p>  <div class="versionadded"> <p><span class="versionmodified">New in version 1.7.</span></p> </div> <p>Accepts a boolean array which is broadcast together with the operands. Values of True indicate to calculate the ufunc at that position, values of False indicate to leave the value in the output alone.</p>  <p><em>casting</em></p>  <div class="versionadded"> <p><span class="versionmodified">New in version 1.6.</span></p> </div> <p>May be ‘no’, ‘equiv’, ‘safe’, ‘same_kind’, or ‘unsafe’. See <a class="reference internal" href="../generated/numpy.can_cast/#numpy.can_cast" title="numpy.can_cast"><code>can_cast</code></a> for explanations of the parameter values.</p> <p>Provides a policy for what kind of casting is permitted. For compatibility with previous versions of NumPy, this defaults to ‘unsafe’ for numpy &lt; 1.7. In numpy 1.7 a transition to ‘same_kind’ was begun where ufuncs produce a DeprecationWarning for calls which are allowed under the ‘unsafe’ rules, but not under the ‘same_kind’ rules. From numpy 1.10 and onwards, the default is ‘same_kind’.</p>  <p><em>order</em></p>  <div class="versionadded"> <p><span class="versionmodified">New in version 1.6.</span></p> </div> <p>Specifies the calculation iteration order/memory layout of the output array. Defaults to ‘K’. ‘C’ means the output should be C-contiguous, ‘F’ means F-contiguous, ‘A’ means F-contiguous if the inputs are F-contiguous and not also not C-contiguous, C-contiguous otherwise, and ‘K’ means to match the element ordering of the inputs as closely as possible.</p>  <p><em>dtype</em></p>  <div class="versionadded"> <p><span class="versionmodified">New in version 1.6.</span></p> </div> <p>Overrides the dtype of the calculation and output arrays. Similar to <em>signature</em>.</p>  <p><em>subok</em></p>  <div class="versionadded"> <p><span class="versionmodified">New in version 1.6.</span></p> </div> <p>Defaults to true. If set to false, the output will always be a strict array, not a subtype.</p>  <p><em>signature</em></p>  Either a data-type, a tuple of data-types, or a special signature string indicating the input and output types of a ufunc. This argument allows you to provide a specific signature for the 1-d loop to use in the underlying calculation. If the loop specified does not exist for the ufunc, then a TypeError is raised. Normally, a suitable loop is found automatically by comparing the input types with what is available and searching for a loop with data-types to which all inputs can be cast safely. This keyword argument lets you bypass that search and choose a particular loop. A list of available signatures is provided by the <strong>types</strong> attribute of the ufunc object. For backwards compatibility this argument can also be provided as <em>sig</em>, although the long form is preferred. <p><em>extobj</em></p>  a list of length 1, 2, or 3 specifying the ufunc buffer-size, the error mode integer, and the error call-back function. Normally, these values are looked up in a thread-specific dictionary. Passing them here circumvents that look up and uses the low-level specification provided for the error mode. This may be useful, for example, as an optimization for calculations requiring many ufunc calls on small arrays in a loop.   <h3 id="attributes">Attributes</h3> <p>There are some informational attributes that universal functions possess. None of the attributes can be set.</p> <table class="docutils" id="index-6">   <tr class="row-odd">
<td><strong>__doc__</strong></td> <td>A docstring for each ufunc. The first part of the docstring is dynamically generated from the number of outputs, the name, and the number of inputs. The second part of the docstring is provided at creation time and stored with the ufunc.</td> </tr> <tr class="row-even">
<td><strong>__name__</strong></td> <td>The name of the ufunc.</td> </tr>  </table> <table class="longtable docutils">   <tr class="row-odd">
<td><a class="reference internal" href="../generated/numpy.ufunc.nin/#numpy.ufunc.nin" title="numpy.ufunc.nin"><code>ufunc.nin</code></a></td> <td>The number of inputs.</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../generated/numpy.ufunc.nout/#numpy.ufunc.nout" title="numpy.ufunc.nout"><code>ufunc.nout</code></a></td> <td>The number of outputs.</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../generated/numpy.ufunc.nargs/#numpy.ufunc.nargs" title="numpy.ufunc.nargs"><code>ufunc.nargs</code></a></td> <td>The number of arguments.</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../generated/numpy.ufunc.ntypes/#numpy.ufunc.ntypes" title="numpy.ufunc.ntypes"><code>ufunc.ntypes</code></a></td> <td>The number of types.</td> </tr> <tr class="row-odd">
<td><a class="reference internal" href="../generated/numpy.ufunc.types/#numpy.ufunc.types" title="numpy.ufunc.types"><code>ufunc.types</code></a></td> <td>Returns a list with types grouped input-&gt;output.</td> </tr> <tr class="row-even">
<td><a class="reference internal" href="../generated/numpy.ufunc.identity/#numpy.ufunc.identity" title="numpy.ufunc.identity"><code>ufunc.identity</code></a></td> <td>The identity value.</td> </tr>  </table>   <h3 id="ufuncs-methods">Methods</h3> <p id="methods">All ufuncs have four methods. However, these methods only make sense on ufuncs that take two input arguments and return one output argument. Attempting to call these methods on other ufuncs will cause a <a class="reference external" href="https://docs.python.org/dev/library/exceptions.html#ValueError" title="(in Python v3.7)" target="_blank"><code>ValueError</code></a>. The reduce-like methods all take an <em>axis</em> keyword, a <em>dtype</em> keyword, and an <em>out</em> keyword, and the arrays must all have dimension &gt;= 1. The <em>axis</em> keyword specifies the axis of the array over which the reduction will take place and may be negative, but must be an integer. The <em>dtype</em> keyword allows you to manage a very common problem that arises when naively using <span class="xref std std-ref">{op}.reduce</span>. Sometimes you may have an array of a certain data type and wish to add up all of its elements, but the result does not fit into the data type of the array. This commonly happens if you have an array of single-byte integers. The <em>dtype</em> keyword allows you to alter the data type over which the reduction takes place (and therefore the type of the output). Thus, you can ensure that the output is a data type with precision large enough to handle your output. The responsibility of altering the reduce type is mostly up to you. There is one exception: if no <em>dtype</em> is given for a reduction on the “add” or “multiply” operations, then if the input type is an integer (or Boolean) data-type and smaller than the size of the <code>int_</code> data type, it will be internally upcast to the <code>int_</code> (or <code>uint</code>) data-type. Finally, the <em>out</em> keyword allows you to provide an output array (for single-output ufuncs, which are currently the only ones supported; for future extension, however, a tuple with a single argument can be passed in). If <em>out</em> is given, the <em>dtype</em> argument is ignored.</p> <p>Ufuncs also have a fifth method that allows in place operations to be performed using fancy indexing. No buffering is used on the dimensions where fancy indexing is used, so the fancy index can list an item more than once and the operation will be performed on the result of the previous operation for that item.</p> <table class="longtable docutils">   <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.ufunc.reduce/#numpy.ufunc.reduce" title="numpy.ufunc.reduce"><code>ufunc.reduce</code></a>(a[, axis, dtype, out, keepdims])</td> <td>Reduces <code>a</code>‘s dimension by one, by applying ufunc along one axis.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/numpy.ufunc.accumulate/#numpy.ufunc.accumulate" title="numpy.ufunc.accumulate"><code>ufunc.accumulate</code></a>(array[, axis, dtype, out, ...])</td> <td>Accumulate the result of applying the operator to all elements.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.ufunc.reduceat/#numpy.ufunc.reduceat" title="numpy.ufunc.reduceat"><code>ufunc.reduceat</code></a>(a, indices[, axis, dtype, out])</td> <td>Performs a (local) reduce with specified slices over a single axis.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/numpy.ufunc.outer/#numpy.ufunc.outer" title="numpy.ufunc.outer"><code>ufunc.outer</code></a>(A, B, **kwargs)</td> <td>Apply the ufunc <code>op</code> to all pairs (a, b) with a in <code>A</code> and b in <code>B</code>.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.ufunc.at/#numpy.ufunc.at" title="numpy.ufunc.at"><code>ufunc.at</code></a>(a, indices[, b])</td> <td>Performs unbuffered in place operation on operand ‘a’ for elements specified by ‘indices’.</td> </tr>  </table> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p class="last">A reduce-like operation on an array with a data-type that has a range “too small” to handle the result will silently wrap. One should use <a class="reference internal" href="../generated/numpy.dtype/#numpy.dtype" title="numpy.dtype"><code>dtype</code></a> to increase the size of the data-type over which reduction takes place.</p> </div>    <h2 id="available-ufuncs">Available ufuncs</h2> <p>There are currently more than 60 universal functions defined in <a class="reference internal" href="../#module-numpy" title="numpy"><code>numpy</code></a> on one or more types, covering a wide variety of operations. Some of these ufuncs are called automatically on arrays when the relevant infix notation is used (<em>e.g.</em>, <a class="reference internal" href="../generated/numpy.add/#numpy.add" title="numpy.add"><code>add(a, b)</code></a> is called internally when <code>a + b</code> is written and <em>a</em> or <em>b</em> is an <a class="reference internal" href="../generated/numpy.ndarray/#numpy.ndarray" title="numpy.ndarray"><code>ndarray</code></a>). Nevertheless, you may still want to use the ufunc call in order to use the optional output argument(s) to place the output(s) in an object (or objects) of your choice.</p> <p>Recall that each ufunc operates element-by-element. Therefore, each ufunc will be described as if acting on a set of scalar inputs to return a set of scalar outputs.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">The ufunc still returns its output(s) even if you use the optional output argument(s).</p> </div>  <h3 id="math-operations">Math operations</h3> <table class="longtable docutils">   <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.add/#numpy.add" title="numpy.add"><code>add</code></a>(x1, x2, /[, out, where, casting, order, ...])</td> <td>Add arguments element-wise.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/numpy.subtract/#numpy.subtract" title="numpy.subtract"><code>subtract</code></a>(x1, x2, /[, out, where, casting, ...])</td> <td>Subtract arguments, element-wise.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.multiply/#numpy.multiply" title="numpy.multiply"><code>multiply</code></a>(x1, x2, /[, out, where, casting, ...])</td> <td>Multiply arguments element-wise.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/numpy.divide/#numpy.divide" title="numpy.divide"><code>divide</code></a>(x1, x2, /[, out, where, casting, ...])</td> <td>Divide arguments element-wise.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.logaddexp/#numpy.logaddexp" title="numpy.logaddexp"><code>logaddexp</code></a>(x1, x2, /[, out, where, casting, ...])</td> <td>Logarithm of the sum of exponentiations of the inputs.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/numpy.logaddexp2/#numpy.logaddexp2" title="numpy.logaddexp2"><code>logaddexp2</code></a>(x1, x2, /[, out, where, casting, ...])</td> <td>Logarithm of the sum of exponentiations of the inputs in base-2.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.true_divide/#numpy.true_divide" title="numpy.true_divide"><code>true_divide</code></a>(x1, x2, /[, out, where, ...])</td> <td>Returns a true division of the inputs, element-wise.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/numpy.floor_divide/#numpy.floor_divide" title="numpy.floor_divide"><code>floor_divide</code></a>(x1, x2, /[, out, where, ...])</td> <td>Return the largest integer smaller or equal to the division of the inputs.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.negative/#numpy.negative" title="numpy.negative"><code>negative</code></a>(x, /[, out, where, casting, order, ...])</td> <td>Numerical negative, element-wise.</td> </tr> <tr class="row-even">
<td>
<code>positive</code>(x, /[, out, where, casting, order, ...])</td> <td>Numerical positive, element-wise.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.power/#numpy.power" title="numpy.power"><code>power</code></a>(x1, x2, /[, out, where, casting, ...])</td> <td>First array elements raised to powers from second array, element-wise.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/numpy.remainder/#numpy.remainder" title="numpy.remainder"><code>remainder</code></a>(x1, x2, /[, out, where, casting, ...])</td> <td>Return element-wise remainder of division.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.mod/#numpy.mod" title="numpy.mod"><code>mod</code></a>(x1, x2, /[, out, where, casting, order, ...])</td> <td>Return element-wise remainder of division.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/numpy.fmod/#numpy.fmod" title="numpy.fmod"><code>fmod</code></a>(x1, x2, /[, out, where, casting, ...])</td> <td>Return the element-wise remainder of division.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.divmod/#numpy.divmod" title="numpy.divmod"><code>divmod</code></a>(x1, x2[, out1, out2], / [[, out, ...])</td> <td>Return element-wise quotient and remainder simultaneously.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/numpy.absolute/#numpy.absolute" title="numpy.absolute"><code>absolute</code></a>(x, /[, out, where, casting, order, ...])</td> <td>Calculate the absolute value element-wise.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.fabs/#numpy.fabs" title="numpy.fabs"><code>fabs</code></a>(x, /[, out, where, casting, order, ...])</td> <td>Compute the absolute values element-wise.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/numpy.rint/#numpy.rint" title="numpy.rint"><code>rint</code></a>(x, /[, out, where, casting, order, ...])</td> <td>Round elements of the array to the nearest integer.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.sign/#numpy.sign" title="numpy.sign"><code>sign</code></a>(x, /[, out, where, casting, order, ...])</td> <td>Returns an element-wise indication of the sign of a number.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/numpy.heaviside/#numpy.heaviside" title="numpy.heaviside"><code>heaviside</code></a>(x1, x2, /[, out, where, casting, ...])</td> <td>Compute the Heaviside step function.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.conj/#numpy.conj" title="numpy.conj"><code>conj</code></a>(x, /[, out, where, casting, order, ...])</td> <td>Return the complex conjugate, element-wise.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/numpy.exp/#numpy.exp" title="numpy.exp"><code>exp</code></a>(x, /[, out, where, casting, order, ...])</td> <td>Calculate the exponential of all elements in the input array.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.exp2/#numpy.exp2" title="numpy.exp2"><code>exp2</code></a>(x, /[, out, where, casting, order, ...])</td> <td>Calculate <code>2**p</code> for all <code>p</code> in the input array.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/numpy.log/#numpy.log" title="numpy.log"><code>log</code></a>(x, /[, out, where, casting, order, ...])</td> <td>Natural logarithm, element-wise.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.log2/#numpy.log2" title="numpy.log2"><code>log2</code></a>(x, /[, out, where, casting, order, ...])</td> <td>Base-2 logarithm of <code>x</code>.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/numpy.log10/#numpy.log10" title="numpy.log10"><code>log10</code></a>(x, /[, out, where, casting, order, ...])</td> <td>Return the base 10 logarithm of the input array, element-wise.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.expm1/#numpy.expm1" title="numpy.expm1"><code>expm1</code></a>(x, /[, out, where, casting, order, ...])</td> <td>Calculate <code>exp(x) - 1</code> for all elements in the array.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/numpy.log1p/#numpy.log1p" title="numpy.log1p"><code>log1p</code></a>(x, /[, out, where, casting, order, ...])</td> <td>Return the natural logarithm of one plus the input array, element-wise.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.sqrt/#numpy.sqrt" title="numpy.sqrt"><code>sqrt</code></a>(x, /[, out, where, casting, order, ...])</td> <td>Return the positive square-root of an array, element-wise.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/numpy.square/#numpy.square" title="numpy.square"><code>square</code></a>(x, /[, out, where, casting, order, ...])</td> <td>Return the element-wise square of the input.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.cbrt/#numpy.cbrt" title="numpy.cbrt"><code>cbrt</code></a>(x, /[, out, where, casting, order, ...])</td> <td>Return the cube-root of an array, element-wise.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/numpy.reciprocal/#numpy.reciprocal" title="numpy.reciprocal"><code>reciprocal</code></a>(x, /[, out, where, casting, ...])</td> <td>Return the reciprocal of the argument, element-wise.</td> </tr>  </table> <div class="admonition tip"> <p class="first admonition-title">Tip</p> <p class="last">The optional output arguments can be used to help you save memory for large calculations. If your arrays are large, complicated expressions can take longer than absolutely necessary due to the creation and (later) destruction of temporary calculation spaces. For example, the expression <code>G = a * b + c</code> is equivalent to <code>t1 = A * B; G = T1 + C; del t1</code>. It will be more quickly executed as <code>G = A * B; add(G, C, G)</code> which is the same as <code>G = A * B; G += C</code>.</p> </div>   <h3 id="trigonometric-functions">Trigonometric functions</h3> <p>All trigonometric functions use radians when an angle is called for. The ratio of degrees to radians is <img class="math" src="https://docs.scipy.org/doc/numpy-1.13.0/_images/math/12c98ea646cced587241525c07f00ba03f16f840.png" alt="180^{\circ}/\pi." style="vertical-align: -4px"></p> <table class="longtable docutils">   <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.sin/#numpy.sin" title="numpy.sin"><code>sin</code></a>(x, /[, out, where, casting, order, ...])</td> <td>Trigonometric sine, element-wise.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/numpy.cos/#numpy.cos" title="numpy.cos"><code>cos</code></a>(x, /[, out, where, casting, order, ...])</td> <td>Cosine element-wise.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.tan/#numpy.tan" title="numpy.tan"><code>tan</code></a>(x, /[, out, where, casting, order, ...])</td> <td>Compute tangent element-wise.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/numpy.arcsin/#numpy.arcsin" title="numpy.arcsin"><code>arcsin</code></a>(x, /[, out, where, casting, order, ...])</td> <td>Inverse sine, element-wise.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.arccos/#numpy.arccos" title="numpy.arccos"><code>arccos</code></a>(x, /[, out, where, casting, order, ...])</td> <td>Trigonometric inverse cosine, element-wise.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/numpy.arctan/#numpy.arctan" title="numpy.arctan"><code>arctan</code></a>(x, /[, out, where, casting, order, ...])</td> <td>Trigonometric inverse tangent, element-wise.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.arctan2/#numpy.arctan2" title="numpy.arctan2"><code>arctan2</code></a>(x1, x2, /[, out, where, casting, ...])</td> <td>Element-wise arc tangent of <code>x1/x2</code> choosing the quadrant correctly.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/numpy.hypot/#numpy.hypot" title="numpy.hypot"><code>hypot</code></a>(x1, x2, /[, out, where, casting, ...])</td> <td>Given the “legs” of a right triangle, return its hypotenuse.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.sinh/#numpy.sinh" title="numpy.sinh"><code>sinh</code></a>(x, /[, out, where, casting, order, ...])</td> <td>Hyperbolic sine, element-wise.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/numpy.cosh/#numpy.cosh" title="numpy.cosh"><code>cosh</code></a>(x, /[, out, where, casting, order, ...])</td> <td>Hyperbolic cosine, element-wise.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.tanh/#numpy.tanh" title="numpy.tanh"><code>tanh</code></a>(x, /[, out, where, casting, order, ...])</td> <td>Compute hyperbolic tangent element-wise.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/numpy.arcsinh/#numpy.arcsinh" title="numpy.arcsinh"><code>arcsinh</code></a>(x, /[, out, where, casting, order, ...])</td> <td>Inverse hyperbolic sine element-wise.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.arccosh/#numpy.arccosh" title="numpy.arccosh"><code>arccosh</code></a>(x, /[, out, where, casting, order, ...])</td> <td>Inverse hyperbolic cosine, element-wise.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/numpy.arctanh/#numpy.arctanh" title="numpy.arctanh"><code>arctanh</code></a>(x, /[, out, where, casting, order, ...])</td> <td>Inverse hyperbolic tangent element-wise.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.deg2rad/#numpy.deg2rad" title="numpy.deg2rad"><code>deg2rad</code></a>(x, /[, out, where, casting, order, ...])</td> <td>Convert angles from degrees to radians.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/numpy.rad2deg/#numpy.rad2deg" title="numpy.rad2deg"><code>rad2deg</code></a>(x, /[, out, where, casting, order, ...])</td> <td>Convert angles from radians to degrees.</td> </tr>  </table>   <h3 id="bit-twiddling-functions">Bit-twiddling functions</h3> <p>These function all require integer arguments and they manipulate the bit-pattern of those arguments.</p> <table class="longtable docutils">   <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.bitwise_and/#numpy.bitwise_and" title="numpy.bitwise_and"><code>bitwise_and</code></a>(x1, x2, /[, out, where, ...])</td> <td>Compute the bit-wise AND of two arrays element-wise.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/numpy.bitwise_or/#numpy.bitwise_or" title="numpy.bitwise_or"><code>bitwise_or</code></a>(x1, x2, /[, out, where, casting, ...])</td> <td>Compute the bit-wise OR of two arrays element-wise.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.bitwise_xor/#numpy.bitwise_xor" title="numpy.bitwise_xor"><code>bitwise_xor</code></a>(x1, x2, /[, out, where, ...])</td> <td>Compute the bit-wise XOR of two arrays element-wise.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/numpy.invert/#numpy.invert" title="numpy.invert"><code>invert</code></a>(x, /[, out, where, casting, order, ...])</td> <td>Compute bit-wise inversion, or bit-wise NOT, element-wise.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.left_shift/#numpy.left_shift" title="numpy.left_shift"><code>left_shift</code></a>(x1, x2, /[, out, where, casting, ...])</td> <td>Shift the bits of an integer to the left.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/numpy.right_shift/#numpy.right_shift" title="numpy.right_shift"><code>right_shift</code></a>(x1, x2, /[, out, where, ...])</td> <td>Shift the bits of an integer to the right.</td> </tr>  </table>   <h3 id="comparison-functions">Comparison functions</h3> <table class="longtable docutils">   <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.greater/#numpy.greater" title="numpy.greater"><code>greater</code></a>(x1, x2, /[, out, where, casting, ...])</td> <td>Return the truth value of (x1 &gt; x2) element-wise.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/numpy.greater_equal/#numpy.greater_equal" title="numpy.greater_equal"><code>greater_equal</code></a>(x1, x2, /[, out, where, ...])</td> <td>Return the truth value of (x1 &gt;= x2) element-wise.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.less/#numpy.less" title="numpy.less"><code>less</code></a>(x1, x2, /[, out, where, casting, ...])</td> <td>Return the truth value of (x1 &lt; x2) element-wise.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/numpy.less_equal/#numpy.less_equal" title="numpy.less_equal"><code>less_equal</code></a>(x1, x2, /[, out, where, casting, ...])</td> <td>Return the truth value of (x1 =&lt; x2) element-wise.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.not_equal/#numpy.not_equal" title="numpy.not_equal"><code>not_equal</code></a>(x1, x2, /[, out, where, casting, ...])</td> <td>Return (x1 != x2) element-wise.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/numpy.equal/#numpy.equal" title="numpy.equal"><code>equal</code></a>(x1, x2, /[, out, where, casting, ...])</td> <td>Return (x1 == x2) element-wise.</td> </tr>  </table> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p class="last">Do not use the Python keywords <code>and</code> and <code>or</code> to combine logical array expressions. These keywords will test the truth value of the entire array (not element-by-element as you might expect). Use the bitwise operators &amp; and | instead.</p> </div> <table class="longtable docutils">   <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.logical_and/#numpy.logical_and" title="numpy.logical_and"><code>logical_and</code></a>(x1, x2, /[, out, where, ...])</td> <td>Compute the truth value of x1 AND x2 element-wise.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/numpy.logical_or/#numpy.logical_or" title="numpy.logical_or"><code>logical_or</code></a>(x1, x2, /[, out, where, casting, ...])</td> <td>Compute the truth value of x1 OR x2 element-wise.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.logical_xor/#numpy.logical_xor" title="numpy.logical_xor"><code>logical_xor</code></a>(x1, x2, /[, out, where, ...])</td> <td>Compute the truth value of x1 XOR x2, element-wise.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/numpy.logical_not/#numpy.logical_not" title="numpy.logical_not"><code>logical_not</code></a>(x, /[, out, where, casting, ...])</td> <td>Compute the truth value of NOT x element-wise.</td> </tr>  </table> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p class="last">The bit-wise operators &amp; and | are the proper way to perform element-by-element array comparisons. Be sure you understand the operator precedence: <code>(a &gt; 2) &amp; (a &lt; 5)</code> is the proper syntax because <code>a &gt; 2 &amp; a &lt; 5</code> will result in an error due to the fact that <code>2 &amp; a</code> is evaluated first.</p> </div> <table class="longtable docutils">   <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.maximum/#numpy.maximum" title="numpy.maximum"><code>maximum</code></a>(x1, x2, /[, out, where, casting, ...])</td> <td>Element-wise maximum of array elements.</td> </tr>  </table> <div class="admonition tip"> <p class="first admonition-title">Tip</p> <p class="last">The Python function <code>max()</code> will find the maximum over a one-dimensional array, but it will do so using a slower sequence interface. The reduce method of the maximum ufunc is much faster. Also, the <code>max()</code> method will not give answers you might expect for arrays with greater than one dimension. The reduce method of minimum also allows you to compute a total minimum over an array.</p> </div> <table class="longtable docutils">   <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.minimum/#numpy.minimum" title="numpy.minimum"><code>minimum</code></a>(x1, x2, /[, out, where, casting, ...])</td> <td>Element-wise minimum of array elements.</td> </tr>  </table> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p class="last">the behavior of <code>maximum(a, b)</code> is different than that of <code>max(a, b)</code>. As a ufunc, <code>maximum(a, b)</code> performs an element-by-element comparison of <code>a</code> and <code>b</code> and chooses each element of the result according to which element in the two arrays is larger. In contrast, <code>max(a, b)</code> treats the objects <code>a</code> and <code>b</code> as a whole, looks at the (total) truth value of <code>a &gt; b</code> and uses it to return either <code>a</code> or <code>b</code> (as a whole). A similar difference exists between <code>minimum(a, b)</code> and <code>min(a, b)</code>.</p> </div> <table class="longtable docutils">   <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.fmax/#numpy.fmax" title="numpy.fmax"><code>fmax</code></a>(x1, x2, /[, out, where, casting, ...])</td> <td>Element-wise maximum of array elements.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/numpy.fmin/#numpy.fmin" title="numpy.fmin"><code>fmin</code></a>(x1, x2, /[, out, where, casting, ...])</td> <td>Element-wise minimum of array elements.</td> </tr>  </table>   <h3 id="floating-functions">Floating functions</h3> <p>Recall that all of these functions work element-by-element over an array, returning an array output. The description details only a single operation.</p> <table class="longtable docutils">   <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.isfinite/#numpy.isfinite" title="numpy.isfinite"><code>isfinite</code></a>(x, /[, out, where, casting, order, ...])</td> <td>Test element-wise for finiteness (not infinity or not Not a Number).</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/numpy.isinf/#numpy.isinf" title="numpy.isinf"><code>isinf</code></a>(x, /[, out, where, casting, order, ...])</td> <td>Test element-wise for positive or negative infinity.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.isnan/#numpy.isnan" title="numpy.isnan"><code>isnan</code></a>(x, /[, out, where, casting, order, ...])</td> <td>Test element-wise for NaN and return result as a boolean array.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/numpy.fabs/#numpy.fabs" title="numpy.fabs"><code>fabs</code></a>(x, /[, out, where, casting, order, ...])</td> <td>Compute the absolute values element-wise.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.signbit/#numpy.signbit" title="numpy.signbit"><code>signbit</code></a>(x, /[, out, where, casting, order, ...])</td> <td>Returns element-wise True where signbit is set (less than zero).</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/numpy.copysign/#numpy.copysign" title="numpy.copysign"><code>copysign</code></a>(x1, x2, /[, out, where, casting, ...])</td> <td>Change the sign of x1 to that of x2, element-wise.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.nextafter/#numpy.nextafter" title="numpy.nextafter"><code>nextafter</code></a>(x1, x2, /[, out, where, casting, ...])</td> <td>Return the next floating-point value after x1 towards x2, element-wise.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/numpy.spacing/#numpy.spacing" title="numpy.spacing"><code>spacing</code></a>(x, /[, out, where, casting, order, ...])</td> <td>Return the distance between x and the nearest adjacent number.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.modf/#numpy.modf" title="numpy.modf"><code>modf</code></a>(x[, out1, out2], / [[, out, where, ...])</td> <td>Return the fractional and integral parts of an array, element-wise.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/numpy.ldexp/#numpy.ldexp" title="numpy.ldexp"><code>ldexp</code></a>(x1, x2, /[, out, where, casting, ...])</td> <td>Returns x1 * 2**x2, element-wise.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.frexp/#numpy.frexp" title="numpy.frexp"><code>frexp</code></a>(x[, out1, out2], / [[, out, where, ...])</td> <td>Decompose the elements of x into mantissa and twos exponent.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/numpy.fmod/#numpy.fmod" title="numpy.fmod"><code>fmod</code></a>(x1, x2, /[, out, where, casting, ...])</td> <td>Return the element-wise remainder of division.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.floor/#numpy.floor" title="numpy.floor"><code>floor</code></a>(x, /[, out, where, casting, order, ...])</td> <td>Return the floor of the input, element-wise.</td> </tr> <tr class="row-even">
<td>
<a class="reference internal" href="../generated/numpy.ceil/#numpy.ceil" title="numpy.ceil"><code>ceil</code></a>(x, /[, out, where, casting, order, ...])</td> <td>Return the ceiling of the input, element-wise.</td> </tr> <tr class="row-odd">
<td>
<a class="reference internal" href="../generated/numpy.trunc/#numpy.trunc" title="numpy.trunc"><code>trunc</code></a>(x, /[, out, where, casting, order, ...])</td> <td>Return the truncated value of the input, element-wise.</td> </tr>  </table>
<div class="_attribution">
  <p class="_attribution-p">
    © 2008–2017 NumPy Developers<br>Licensed under the NumPy License.<br>
    <a href="https://docs.scipy.org/doc/numpy-1.13.0/reference/ufuncs.html" class="_attribution-link" target="_blank">https://docs.scipy.org/doc/numpy-1.13.0/reference/ufuncs.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
