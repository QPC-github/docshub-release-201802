
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Ssh - Erlang 20 - W3cubDocs</title>
  
  <meta name="description" content=" ssh ">
  <meta name="keywords" content="ssh, -, erlang, erlang~20">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/erlang~20/lib/ssh-4.6/doc/html/ssh/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-e0f881b0fce8cbe96f33dadc355b7159d5d2912911231446d60eb8f9caffa802.css">
  <script type="text/javascript" src="/assets/application-8fc46316434047265cd383f02b8e7f434ed7dec4a59f920dd633deef8d488d1b.js"></script>
  <script src="/json/erlang~20.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/erlang~20/" class="_nav-link" title="" style="margin-left:0;">Erlang 20</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _erlang">
				
<h1>ssh</h1> <h2 id="module">Module</h2> <p class="REFBODY module-body">ssh</p> <h2 id="module-summary">Module Summary</h2> <p class="REFBODY module-summary-body">Main API of the ssh application</p> <h2 id="description">Description</h2> 
<p>Interface module for the <code class="code">ssh</code> application.</p> <p>See <code>ssh(6)</code> for details of supported version, algorithms and unicode support.</p>  <h2 id="id70334">Options</h2>  <p>The exact behaviour of some functions can be adjusted with the use of options which are documented together with the functions. Generally could each option be used at most one time in each function call. If given two or more times, the effect is not predictable unless explicitly documented.</p> <p>The options are of different kinds:</p> <dl> <dt><strong>Limits</strong></dt> <dd><p>which alters limits in the system, for example number of simultaneous login attempts.</p></dd> <dt><strong>Timeouts</strong></dt> <dd><p>which give some defined behaviour if too long time elapses before a given event or action, for example time to wait for an answer.</p></dd> <dt><strong>Callbacks</strong></dt> <dd><p>which gives the caller of the function the possibility to execute own code on some events, for example calling an own logging function or to perform an own login function</p></dd> <dt><strong>Behaviour</strong></dt> <dd><p>which changes the systems behaviour.</p></dd> </dl>  <h2 id="id70935">Data types</h2>  <p>Type definitions that are used more than once in this module, or abstractions to indicate the intended use of the data type, or both:</p> <dl> <dt><strong><code class="code">boolean() =</code></strong></dt> <dd><p><code class="code">true | false</code></p></dd> <dt><strong><code class="code">string() =</code></strong></dt> <dd><p><code class="code">[byte()]</code></p></dd> <dt><strong><code class="code">ssh_daemon_ref() =</code></strong></dt> <dd><p>opaque() - as returned by <code class="code">ssh:daemon/[1,2,3]</code></p></dd> <dt><strong><code class="code">ssh_connection_ref() =</code></strong></dt> <dd><p>opaque() - as returned by <code class="code">ssh:connect/3</code></p></dd> <dt><strong><code class="code">ip_address() =</code></strong></dt> <dd><p><code class="code">inet::ip_address</code></p></dd> <dt><strong><code class="code">subsystem_spec() =</code></strong></dt> <dd><p><code class="code">{subsystem_name(), {channel_callback(), channel_init_args()}}</code></p></dd> <dt><strong><code class="code">subsystem_name() =</code></strong></dt> <dd><p><code class="code">string()</code></p></dd> <dt><strong><code class="code">channel_callback() =</code></strong></dt> <dd><p><code class="code">atom()</code> - Name of the Erlang module implementing the subsystem using the <code class="code">ssh_channel</code> behavior, see <code><a href="../ssh_channel/">ssh_channel(3)</a></code></p></dd> <dt><strong><code class="code">key_cb() =</code></strong></dt> <dd> <p><code class="code">atom() | {atom(), list()}</code></p> <p><code class="code">atom()</code> - Name of the erlang module implementing the behaviours <code><a href="../ssh_client_key_api/">ssh_client_key_api</a></code> or <code><a href="../ssh_client_key_api/">ssh_client_key_api</a></code> as the case maybe.</p> <p><code class="code">list()</code> - List of options that can be passed to the callback module.</p> </dd> <dt><strong><code class="code">channel_init_args() =</code></strong></dt> <dd><p><code class="code">list()</code></p></dd> <dt><strong><code class="code">algs_list() =</code></strong></dt> <dd><p><code class="code">list( alg_entry() )</code></p></dd> <dt><strong><code class="code">alg_entry() =</code></strong></dt> <dd><p><code class="code">{kex, simple_algs()} | {public_key, simple_algs()} | {cipher, double_algs()} | {mac, double_algs()} | {compression, double_algs()}</code></p></dd> <dt><strong><code class="code">simple_algs() =</code></strong></dt> <dd><p><code class="code">list( atom() )</code></p></dd> <dt><strong><code class="code">double_algs() =</code></strong></dt> <dd><p><code class="code">[{client2serverlist,simple_algs()},{server2client,simple_algs()}] | simple_algs()</code></p></dd> <dt><strong><code class="code">modify_algs_list() =</code></strong></dt> <dd><p><code class="code">list( {append,algs_list()} | {prepend,algs_list()} | {rm,algs_list()} )</code></p></dd> </dl>  <h2 id="exports">Exports</h2> <div class="exports-body"> <h3><code id="close-1">close(ConnectionRef) -&gt; ok</code></h3>  <h2 class="func-types-title">Types</h2>   
<p>Closes an SSH connection.</p>  <h3>
<code id="connect-3">connect(Host, Port, Options) -&gt;</code><code id="connect-4">connect(Host, Port, Options, Timeout) -&gt;</code><code id="connect-2">connect(TcpSocket, Options) -&gt;</code><code id="connect-3">connect(TcpSocket, Options, Timeout) -&gt; {ok, ssh_connection_ref()} | {error, Reason}</code>
</h3>  <h2 class="func-types-title">Types</h2>    <code class="code">22</code> is default, the assigned well-known port number for SSH.   Negotiation time-out in milli-seconds. The default value is <code class="code">infinity</code>. For connection time-out, use option <code class="code">{connect_timeout, timeout()}</code>.  The socket is supposed to be from <code>gen_tcp:connect</code> or <code>gen_tcp:accept</code> with option <code class="code">{active,false}</code>   
<p>Connects to an SSH server. No channel is started. This is done by calling <code><a href="../ssh_connection/#session_channel-2">ssh_connection:session_channel/[2, 4]</a></code>.</p> <p>Options:</p> <dl> <dt><strong><code class="code">{inet, inet | inet6}</code></strong></dt> <dd> <p>IP version to use.</p> </dd> <dt><strong><code class="code" id="opt_user_dir">{user_dir, string()}</code></strong></dt> <dd> <p>Sets the user directory, that is, the directory containing <code class="code">ssh</code> configuration files for the user, such as <code class="code">known_hosts</code>, <code class="code">id_rsa, id_dsa</code>, and <code class="code">authorized_key</code>. Defaults to the directory normally referred to as <code class="code">~/.ssh</code>.</p> </dd> <dt><strong><code class="code">{dsa_pass_phrase, string()}</code></strong></dt> <dd> <p>If the user DSA key is protected by a passphrase, it can be supplied with this option. </p> </dd> <dt><strong><code class="code">{rsa_pass_phrase, string()}</code></strong></dt> <dd> <p>If the user RSA key is protected by a passphrase, it can be supplied with this option. </p> </dd> <dt><strong> <code class="code">{silently_accept_hosts, boolean()}</code> <br> <code class="code">{silently_accept_hosts, CallbackFun}</code> <br> <code class="code">{silently_accept_hosts, {HashAlgoSpec, CallbackFun} }</code> <br> <br> <code class="code">HashAlgoSpec = crypto:digest_type() | [ crypto:digest_type() ]</code><br> <code class="code">CallbackFun = fun(PeerName, FingerPrint) -&gt; boolean()</code><br> <code class="code">PeerName = string()</code><br> <code class="code">FingerPrint = string() | [ string() ]</code> </strong></dt> <dd> <p>This option guides the <code class="code">connect</code> function how to act when the connected server presents a Host Key that the client has not seen before. The default is to ask the user with a question on stdio of whether to accept or reject the new Host Key. See also the option <code><a href="#opt_user_dir"><span class="code">user_dir</span></a></code> for the path to the file <code class="code">known_hosts</code> where previously accepted Host Keys are recorded. </p> <p>The option can be given in three different forms as seen above:</p> <ul> <li>The value is a <code class="code">boolean()</code>. The value <code class="code">true</code> will make the client accept any unknown Host Key without any user interaction. The value <code class="code">false</code> keeps the default behaviour of asking the the user on stdio. </li> <li>A <code class="code">CallbackFun</code> will be called and the boolean return value <code class="code">true</code> will make the client accept the Host Key. A return value of <code class="code">false</code> will make the client to reject the Host Key and therefore also the connection will be closed. The arguments to the fun are: <ul> <li> <code class="code">PeerName</code> - a string with the name or address of the remote host.</li> <li> <code class="code">FingerPrint</code> - the fingerprint of the Host Key as <code>public_key:ssh_hostkey_fingerprint/1</code> calculates it. </li> </ul> </li> <li>A tuple <code class="code">{HashAlgoSpec, CallbackFun}</code>. The <code class="code">HashAlgoSpec</code> specifies which hash algorithm shall be used to calculate the fingerprint used in the call of the <code class="code">CallbackFun</code>. The <code class="code">HashALgoSpec</code> is either an atom or a list of atoms as the first argument in <code>public_key:ssh_hostkey_fingerprint/2</code>. If it is a list of hash algorithm names, the <code class="code">FingerPrint</code> argument in the <code class="code">CallbackFun</code> will be a list of fingerprints in the same order as the corresponding name in the <code class="code">HashAlgoSpec</code> list. </li> </ul> </dd> <dt><strong><code class="code">{user_interaction, boolean()}</code></strong></dt> <dd> <p>If <code class="code">false</code>, disables the client to connect to the server if any user interaction is needed, such as accepting the server to be added to the <code class="code">known_hosts</code> file, or supplying a password. Defaults to <code class="code">true</code>. Even if user interaction is allowed it can be suppressed by other options, such as <code class="code">silently_accept_hosts</code> and <code class="code">password</code>. However, those options are not always desirable to use from a security point of view.</p> </dd> <dt><strong><code class="code">{disconnectfun, fun(Reason:term()) -&gt; _}</code></strong></dt> <dd> <p>Provides a fun to implement your own logging when a server disconnects the client.</p> </dd> <dt><strong><code class="code">{unexpectedfun, fun(Message:term(), Peer) -&gt; report | skip }</code></strong></dt> <dd> <p>Provides a fun to implement your own logging or other action when an unexpected message arrives. If the fun returns <code class="code">report</code> the usual info report is issued but if <code class="code">skip</code> is returned no report is generated.</p> <p><code class="code">Peer</code> is in the format of <code class="code">{Host,Port}</code>.</p> </dd> <dt><strong><code class="code">{pref_public_key_algs, list()}</code></strong></dt> <dd> <p>List of user (client) public key algorithms to try to use.</p> <p>The default value is the <code class="code">public_key</code> entry in <code><a href="#default_algorithms-0">ssh:default_algorithms/0</a></code>. </p> <p>If there is no public key of a specified type available, the corresponding entry is ignored. Note that the available set is dependent on the underlying cryptolib and current user's public keys. </p> </dd> <dt><strong> <code class="code" id="option_preferred_algorithms">{preferred_algorithms, algs_list()}</code></strong></dt> <dd> <p>List of algorithms to use in the algorithm negotiation. The default <code class="code">algs_list()</code> can be obtained from <code><a href="#default_algorithms-0">default_algorithms/0</a></code>. </p> <p>If an alg_entry() is missing in the algs_list(), the default value is used for that entry.</p> <p>Here is an example of this option:</p> <pre data-language="erlang">
{preferred_algorithms, 
 [{public_key,['ssh-rsa','ssh-dss']},
  {cipher,[{client2server,['aes128-ctr']},
           {server2client,['aes128-cbc','3des-cbc']}]},
  {mac,['hmac-sha2-256','hmac-sha1']},
  {compression,[none,zlib]}
  ]
}
</pre> <p>The example specifies different algorithms in the two directions (client2server and server2client), for cipher but specifies the same algorithms for mac and compression in both directions. The kex (key exchange) is implicit but public_key is set explicitly.</p> <p>For background and more examples see the <code><a href="../configure_algos/#introduction">User's Guide</a></code>.</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>Changing the values can make a connection less secure. Do not change unless you know exactly what you are doing. If you do not understand the values then you are not supposed to change them.</p> </div> </div> </dd> <dt><strong> <code class="code" id="option_modify_algorithms">{modify_algorithms, modify_algs_list()}</code></strong></dt> <dd> <p>Modifies the list of algorithms to use in the algorithm negotiation. The modifications are applied after the option <code class="code">preferred_algorithms</code> (if existing) is applied.</p> <p>The algoritm for modifications works like this:</p> <ul> <li> <p>Input is the <code class="code">modify_algs_list()</code> and a set of algorithms <code class="code">A</code> obtained from the <code class="code">preferred_algorithms</code> option if existing, or else from the <code><a href="../ssh/#default_algorithms-0">ssh:default_algorithms/0</a></code>. </p> </li> <li> <p>The head of the <code class="code">modify_algs_list()</code> modifies <code class="code">A</code> giving the result <code class="code">A'</code>.</p> <p>The possible modifications are:</p> <ul> <li> <p>Append or prepend supported but not enabled algorithm(s) to the list of algorithms. If the wanted algorithms already are in <code class="code">A</code> they will first be removed and then appended or prepended, </p> </li> <li> <p>Remove (rm) one or more algorithms from <code class="code">A</code>. </p> </li> </ul> </li> <li> <p>Repeat the modification step with the tail of <code class="code">modify_algs_list()</code> and the resulting <code class="code">A'</code>. </p> </li> </ul> <p>If an unsupported algorithm is in the <code class="code">modify_algs_list()</code>, it will be silently ignored</p> <p>If there are more than one modify_algorithms options, the result is undefined.</p> <p>Here is an example of this option:</p> <pre data-language="erlang">
{modify_algorithms, 
 [{prepend, [{kex, ['diffie-hellman-group1-sha1']}],
  {rm,      [{compression, [none]}]}
 ]
}
</pre> <p>The example specifies that:</p> <ul> <li> <p>the old key exchange algorithm 'diffie-hellman-group1-sha1' should be the main alternative. It will be the main alternative since it is prepened to the list</p> </li> <li> <p>The compression algorithm none (= no compression) is removed so compression is enforced</p> </li> </ul> <p>For background and more examples see the <code><a href="../configure_algos/#introduction">User's Guide</a></code>.</p> </dd> <dt><strong><code class="code">{dh_gex_limits,{Min=integer(),I=integer(),Max=integer()}}</code></strong></dt> <dd> <p>Sets the three diffie-hellman-group-exchange parameters that guides the connected server in choosing a group. See RFC 4419 for the function of thoose. The default value is <code class="code">{1024, 6144, 8192}</code>. </p> </dd> <dt><strong><code class="code">{connect_timeout, timeout()}</code></strong></dt> <dd> <p>Sets a time-out on the transport layer connection. For <code class="code">gen_tcp</code> the time is in milli-seconds and the default value is <code class="code">infinity</code>.</p> </dd> <dt><strong><code class="code">{auth_methods, string()}</code></strong></dt> <dd> <p>Comma-separated string that determines which authentication methods that the client shall support and in which order they are tried. Defaults to <code class="code">"publickey,keyboard-interactive,password"</code></p> </dd> <dt><strong><code class="code">{user, string()}</code></strong></dt> <dd> <p>Provides a username. If this option is not given, <code class="code">ssh</code> reads from the environment (<code class="code">LOGNAME</code> or <code class="code">USER</code> on UNIX, <code class="code">USERNAME</code> on Windows).</p> </dd> <dt><strong><code class="code">{password, string()}</code></strong></dt> <dd> <p>Provides a password for password authentication. If this option is not given, the user is asked for a password, if the password authentication method is attempted.</p> </dd> <dt><strong><code class="code">{recv_ext_info, boolean()}</code></strong></dt> <dd> <p>Tell the server that the client accepts extension negotiation. See <code><a href="https://tools.ietf.org/html/draft-ietf-curdle-ssh-ext-info" target="_blank">Draft-ietf-curdle-ssh-ext-info (work in progress)</a></code> for details. </p> <p>Currently implemented extension is <code class="code">server-sig-algs</code> which is the list of the server's preferred user's public key algorithms. </p> <p>Default value is <code class="code">true</code>. </p> </dd> <dt><strong><code class="code">{key_cb, key_cb()}</code></strong></dt> <dd> <p>Module implementing the behaviour <code><a href="../ssh_client_key_api/">ssh_client_key_api</a></code>. Can be used to customize the handling of public keys. If callback options are provided along with the module name, they are made available to the callback module via the options passed to it under the key 'key_cb_private'. </p> </dd> <dt><strong><code class="code">{quiet_mode, atom() = boolean()}</code></strong></dt> <dd> <p>If <code class="code">true</code>, the client does not print anything on authorization.</p> </dd> <dt><strong><code class="code">{id_string, random | string()}</code></strong></dt> <dd> <p>The string that the client presents to a connected server initially. The default value is "Erlang/VSN" where VSN is the ssh application version number. </p> <p>The value <code class="code">random</code> will cause a random string to be created at each connection attempt. This is to make it a bit more difficult for a malicious peer to find the ssh software brand and version. </p> </dd> <dt><strong><code class="code">{fd, file_descriptor()}</code></strong></dt> <dd> <p>Allows an existing file descriptor to be used (by passing it on to the transport protocol).</p> </dd> <dt><strong><code class="code">{rekey_limit, integer()}</code></strong></dt> <dd> <p>Provides, in bytes, when rekeying is to be initiated. Defaults to once per each GB and once per hour.</p> </dd> <dt><strong><code class="code">{idle_time, integer()}</code></strong></dt> <dd> <p>Sets a time-out on a connection when no channels are active. Defaults to <code class="code">infinity</code>.</p> </dd> <dt><strong><code class="code">{ssh_msg_debug_fun, fun(ConnectionRef::ssh_connection_ref(), AlwaysDisplay::boolean(), Msg::binary(), LanguageTag::binary()) -&gt; _}</code></strong></dt> <dd> <p>Provide a fun to implement your own logging of the SSH message SSH_MSG_DEBUG. The last three parameters are from the message, see RFC4253, section 11.3. The <code class="code">ConnectionRef</code> is the reference to the connection on which the message arrived. The return value from the fun is not checked.</p> <p>The default behaviour is ignore the message. To get a printout for each message with <code class="code">AlwaysDisplay = true</code>, use for example <code class="code">{ssh_msg_debug_fun, fun(_,true,M,_)-&gt; io:format("DEBUG: ~p~n", [M]) end}</code></p> </dd> </dl>  <h3><code id="connection_info-2">connection_info(ConnectionRef, [Option]) -&gt;[{Option, Value}]</code></h3>  <h2 class="func-types-title">Types</h2>     
<p>Retrieves information about a connection.</p>  <h3>
<code id="daemon-1">daemon(Port) -&gt;</code><code id="daemon-2">daemon(Port, Options) -&gt;</code><code id="daemon-3">daemon(HostAddress, Port, Options) -&gt;</code><code id="daemon-1">daemon(TcpSocket) -&gt;</code><code id="daemon-2">daemon(TcpSocket, Options) -&gt; {ok, ssh_daemon_ref()} | {error, atom()}</code>
</h3>  <h2 class="func-types-title">Types</h2>       The socket is supposed to be from <code>gen_tcp:connect</code> or <code>gen_tcp:accept</code> with option <code class="code">{active,false}</code>   
<p>Starts a server listening for SSH connections on the given port. If the <code class="code">Port</code> is 0, a random free port is selected. See <code><a href="#daemon_info-1">daemon_info/1</a></code> about how to find the selected port number.</p> <p>Please note that by historical reasons both the <code class="code">HostAddress</code> argument and the inet socket option <code class="code">ip</code> set the listening address. This is a source of possible inconsistent settings.</p> <p>The rules for handling the two address passing options are:</p> <ul> <li>if <code class="code">HostAddress</code> is an IP-address, that IP-address is the listening address. An 'ip'-option will be discarded if present.</li> <li>if <code class="code">HostAddress</code> is <code class="code">loopback</code>, the listening address is <code class="code">loopback</code> and an loopback address will be choosen by the underlying layers. An 'ip'-option will be discarded if present.</li> <li>if <code class="code">HostAddress</code> is <code class="code">any</code> and no 'ip'-option is present, the listening address is <code class="code">any</code> and the socket will listen to all addresses</li> <li>if <code class="code">HostAddress</code> is <code class="code">any</code> and an 'ip'-option is present, the listening address is set to the value of the 'ip'-option</li> </ul> <p>Options:</p> <dl> <dt><strong><code class="code">{inet, inet | inet6}</code></strong></dt> <dd><p>IP version to use when the host address is specified as <code class="code">any</code>.</p></dd> <dt><strong><code class="code">{subsystems, [subsystem_spec()]}</code></strong></dt> <dd> <p>Provides specifications for handling of subsystems. The "sftp" subsystem specification is retrieved by calling <code class="code">ssh_sftpd:subsystem_spec/1</code>. If the subsystems option is not present, the value of <code class="code">[ssh_sftpd:subsystem_spec([])]</code> is used. The option can be set to the empty list if you do not want the daemon to run any subsystems.</p> </dd> <dt><strong><code class="code">{shell, {Module, Function, Args} | fun(string() = User) - &gt; pid() | fun(string() = User, ip_address() = PeerAddr) -&gt; pid()}</code></strong></dt> <dd> <p>Defines the read-eval-print loop used when a shell is requested by the client. The default is to use the Erlang shell: <code class="code">{shell, start, []}</code></p> </dd> <dt><strong><code class="code">{ssh_cli, {channel_callback(), channel_init_args()} | no_cli}</code></strong></dt> <dd> <p>Provides your own CLI implementation, that is, a channel callback module that implements a shell and command execution. The shell read-eval-print loop can be customized, using the option <code class="code">shell</code>. This means less work than implementing an own CLI channel. If set to <code class="code">no_cli</code>, the CLI channels are disabled and only subsystem channels are allowed.</p> </dd> <dt><strong><code class="code">{user_dir, string()}</code></strong></dt> <dd> <p>Sets the user directory. That is, the directory containing <code class="code">ssh</code> configuration files for the user, such as <code class="code">known_hosts</code>, <code class="code">id_rsa, id_dsa</code>, and <code class="code">authorized_key</code>. Defaults to the directory normally referred to as <code class="code">~/.ssh</code>.</p> </dd> <dt><strong><code class="code">{system_dir, string()}</code></strong></dt> <dd> <p>Sets the system directory, containing the host key files that identify the host keys for <code class="code">ssh</code>. Defaults to <code class="code">/etc/ssh</code>. For security reasons, this directory is normally accessible only to the root user.</p> </dd> <dt><strong><code class="code">{auth_methods, string()}</code></strong></dt> <dd> <p>Comma-separated string that determines which authentication methods that the server is to support and in what order they are tried. Defaults to <code class="code">"publickey,keyboard-interactive,password"</code></p> <p>Note that the client is free to use any order and to exclude methods.</p> </dd> <dt><strong><code class="code">{auth_method_kb_interactive_data, PromptTexts}</code> <br><code class="code">where:</code> <br><code class="code">PromptTexts = kb_int_tuple() | fun(Peer::{IP::tuple(),Port::integer()}, User::string(), Service::string()) -&gt; kb_int_tuple()</code> <br><code class="code">kb_int_tuple() = {Name::string(), Instruction::string(), Prompt::string(), Echo::boolean()}</code> </strong></dt> <dd> <p>Sets the text strings that the daemon sends to the client for presentation to the user when using <code class="code">keyboar-interactive</code> authentication. If the fun/3 is used, it is called when the actual authentication occurs and may therefore return dynamic data like time, remote ip etc.</p> <p>The parameter <code class="code">Echo</code> guides the client about need to hide the password.</p> <p>The default value is: <code class="code">{auth_method_kb_interactive_data, {"SSH server", "Enter password for \""++User++"\"", "password: ", false}&gt;</code></p> </dd> <dt><strong><code class="code">{user_passwords, [{string() = User, string() = Password}]}</code></strong></dt> <dd> <p>Provides passwords for password authentication. The passwords are used when someone tries to connect to the server and public key user-authentication fails. The option provides a list of valid usernames and the corresponding passwords. </p> </dd> <dt><strong><code class="code">{password, string()}</code></strong></dt> <dd> <p>Provides a global password that authenticates any user. From a security perspective this option makes the server very vulnerable.</p> </dd> <dt><strong><code class="code">{preferred_algorithms, algs_list()}</code></strong></dt> <dd> <p>List of algorithms to use in the algorithm negotiation. The default <code class="code">algs_list()</code> can be obtained from <code><a href="#default_algorithms-0">default_algorithms/0</a></code>. </p> <p>If an alg_entry() is missing in the algs_list(), the default value is used for that entry.</p> <p>Here is an example of this option:</p> <pre data-language="erlang">
{preferred_algorithms, 
 [{public_key,['ssh-rsa','ssh-dss']},
  {cipher,[{client2server,['aes128-ctr']},
           {server2client,['aes128-cbc','3des-cbc']}]},
  {mac,['hmac-sha2-256','hmac-sha1']},
  {compression,[none,zlib]}
  ]
}
</pre> <p>The example specifies different algorithms in the two directions (client2server and server2client), for cipher but specifies the same algorithms for mac and compression in both directions. The kex (key exchange) is implicit but public_key is set explicitly.</p> <p>For background and more examples see the <code><a href="../configure_algos/#introduction">User's Guide</a></code>.</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>Changing the values can make a connection less secure. Do not change unless you know exactly what you are doing. If you do not understand the values then you are not supposed to change them.</p> </div> </div> </dd> <dt><strong> <code class="code" id="option_modify_algorithms">{modify_algorithms, modify_algs_list()}</code></strong></dt> <dd> <p>Modifies the list of algorithms to use in the algorithm negotiation. The modifications are applied after the option <code class="code">preferred_algorithms</code> is applied (if existing)</p> <p>The possible modifications are to:</p> <ul> <li> <p>Append or prepend supported but not enabled algorithm(s) to the list of algorithms.</p> <p>If the wanted algorithms already are in the list of algorithms, they will first be removed and then appended or prepended. </p> </li> <li><p>Remove (rm) one or more algorithms from the list of algorithms.</p></li> </ul> <p>If an unsupported algorithm is in the list, it will be silently ignored</p> <p>Here is an example of this option:</p> <pre data-language="erlang">
{modify_algorithms, 
 [{prepend, [{kex, ['diffie-hellman-group1-sha1']}],
  {rm,      [{compression, [none]}]}
 ]
}
</pre> <p>The example specifies that:</p> <ul> <li> <p>the old key exchange algorithm 'diffie-hellman-group1-sha1' should be the main alternative. It will be the main alternative since it is prepened to the list</p> </li> <li> <p>The compression algorithm none (= no compression) is removed so compression is enforced</p> </li> </ul> <p>For background and more examples see the <code><a href="../configure_algos/#introduction">User's Guide</a></code>.</p> </dd> <dt><strong><code class="code">{dh_gex_groups, [{Size=integer(),G=integer(),P=integer()}] | {file,filename()} {ssh_moduli_file,filename()} }</code></strong></dt> <dd> <p>Defines the groups the server may choose among when diffie-hellman-group-exchange is negotiated. See RFC 4419 for details. The three variants of this option are: </p> <dl> <dt><strong><code class="code">{Size=integer(),G=integer(),P=integer()}</code></strong></dt> <dd>The groups are given explicitly in this list. There may be several elements with the same <code class="code">Size</code>. In such a case, the server will choose one randomly in the negotiated Size. </dd> <dt><strong><code class="code">{file,filename()}</code></strong></dt> <dd>The file must have one or more three-tuples <code class="code">{Size=integer(),G=integer(),P=integer()}</code> terminated by a dot. The file is read when the daemon starts. </dd> <dt><strong><code class="code">{ssh_moduli_file,filename()}</code></strong></dt> <dd>The file must be in <code>ssh-keygen moduli file format</code>. The file is read when the daemon starts. </dd> </dl> <p>The default list is fetched from the <code>public_key</code> application. </p> </dd> <dt><strong><code class="code">{dh_gex_limits,{Min=integer(),Max=integer()}}</code></strong></dt> <dd> <p>Limits what a client can ask for in diffie-hellman-group-exchange. The limits will be <code class="code">{MaxUsed = min(MaxClient,Max), MinUsed = max(MinClient,Min)}</code> where <code class="code">MaxClient</code> and <code class="code">MinClient</code> are the values proposed by a connecting client. </p> <p>The default value is <code class="code">{0,infinity}</code>. </p> <p>If <code class="code">MaxUsed &lt; MinUsed</code> in a key exchange, it will fail with a disconnect. </p> <p>See RFC 4419 for the function of the Max and Min values.</p> </dd> <dt><strong><code class="code">{pwdfun, fun(User::string(), Password::string(), PeerAddress::{ip_adress(),port_number()}, State::any()) -&gt; boolean() | disconnect | {boolean(),any()} }</code></strong></dt> <dd> <p>Provides a function for password validation. This could used for calling an external system or if passwords should be stored as a hash. The fun returns: </p> <ul> <li> <code class="code">true</code> if the user and password is valid and</li> <li> <code class="code">false</code> otherwise.</li> </ul> <p>This fun can also be used to make delays in authentication tries for example by calling <code>timer:sleep/1</code>. To facilitate counting of failed tries the <code class="code">State</code> variable could be used. This state is per connection only. The first time the pwdfun is called for a connection, the <code class="code">State</code> variable has the value <code class="code">undefined</code>. The pwdfun can return - in addition to the values above - a new state as: </p> <ul> <li> <code class="code">{true, NewState:any()}</code> if the user and password is valid or</li> <li> <code class="code">{false, NewState:any()}</code> if the user or password is invalid</li> </ul> <p>A third usage is to block login attempts from a missbehaving peer. The <code class="code">State</code> described above can be used for this. In addition to the responses above, the following return value is introduced: </p> <ul> <li> <code class="code">disconnect</code> if the connection should be closed immediately after sending a SSH_MSG_DISCONNECT message.</li> </ul> </dd> <dt><strong><code class="code">{pwdfun, fun(User::string(), Password::string()) -&gt; boolean()}</code></strong></dt> <dd> <p>Provides a function for password validation. This function is called with user and password as strings, and returns <code class="code">true</code> if the password is valid and <code class="code">false</code> otherwise.</p> <p>This option (<code class="code">{pwdfun,fun/2}</code>) is the same as a subset of the previous (<code class="code">{pwdfun,fun/4}</code>). It is kept for compatibility.</p> </dd> <dt><strong><code class="code">{negotiation_timeout, integer()}</code></strong></dt> <dd> <p>Maximum time in milliseconds for the authentication negotiation. Defaults to 120000 (2 minutes). If the client fails to log in within this time, the connection is closed. </p> </dd> <dt><strong><code class="code">{max_sessions, pos_integer()}</code></strong></dt> <dd> <p>The maximum number of simultaneous sessions that are accepted at any time for this daemon. This includes sessions that are being authorized. Thus, if set to <code class="code">N</code>, and <code class="code">N</code> clients have connected but not started the login process, connection attempt <code class="code">N+1</code> is aborted. If <code class="code">N</code> connections are authenticated and still logged in, no more logins are accepted until one of the existing ones log out. </p> <p>The counter is per listening port. Thus, if two daemons are started, one with <code class="code">{max_sessions,N}</code> and the other with <code class="code">{max_sessions,M}</code>, in total <code class="code">N+M</code> connections are accepted for the whole <code class="code">ssh</code> application. </p> <p>Notice that if <code class="code">parallel_login</code> is <code class="code">false</code>, only one client at a time can be in the authentication phase. </p> <p>By default, this option is not set. This means that the number is not limited. </p> </dd> <dt><strong><code class="code">{max_channels, pos_integer()}</code></strong></dt> <dd> <p>The maximum number of channels with active remote subsystem that are accepted for each connection to this daemon</p> <p>By default, this option is not set. This means that the number is not limited. </p> </dd> <dt><strong><code class="code">{parallel_login, boolean()}</code></strong></dt> <dd> <p>If set to false (the default value), only one login is handled at a time. If set to true, an unlimited number of login attempts are allowed simultaneously. </p> <p>If the <code class="code">max_sessions</code> option is set to <code class="code">N</code> and <code class="code">parallel_login</code> is set to <code class="code">true</code>, the maximum number of simultaneous login attempts at any time is limited to <code class="code">N-K</code>, where <code class="code">K</code> is the number of authenticated connections present at this daemon. </p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>Do not enable <code class="code">parallel_logins</code> without protecting the server by other means, for example, by the <code class="code">max_sessions</code> option or a firewall configuration. If set to <code class="code">true</code>, there is no protection against DOS attacks.</p> </div> </div> </dd> <dt><strong><code class="code">{minimal_remote_max_packet_size, non_negative_integer()}</code></strong></dt> <dd> <p>The least maximum packet size that the daemon will accept in channel open requests from the client. The default value is 0. </p> </dd> <dt><strong><code class="code">{id_string, random | string()}</code></strong></dt> <dd> <p>The string the daemon will present to a connecting peer initially. The default value is "Erlang/VSN" where VSN is the ssh application version number. </p> <p>The value <code class="code">random</code> will cause a random string to be created at each connection attempt. This is to make it a bit more difficult for a malicious peer to find the ssh software brand and version. </p> </dd> <dt><strong><code class="code">{send_ext_info, boolean()}</code></strong></dt> <dd> <p>Send a list of extensions to the client if the client has asked for it. See <code><a href="https://tools.ietf.org/html/draft-ietf-curdle-ssh-ext-info" target="_blank">Draft-ietf-curdle-ssh-ext-info (work in progress)</a></code> for details. </p> <p>Currently implemented extension is sending <code class="code">server-sig-algs</code> which is the list of the server's preferred user's public key algorithms. </p> <p>Default value is <code class="code">true</code>. </p> </dd> <dt><strong><code class="code">{key_cb, key_cb()}</code></strong></dt> <dd> <p>Module implementing the behaviour <code><a href="../ssh_server_key_api/">ssh_server_key_api</a></code>. Can be used to customize the handling of public keys. If callback options are provided along with the module name, they are made available to the callback module via the options passed to it under the key 'key_cb_private'. </p> </dd> <dt><strong><code class="code">{profile, atom()}</code></strong></dt> <dd> <p>Used together with <code class="code">ip-address</code> and <code class="code">port</code> to uniquely identify a ssh daemon. This can be useful in a virtualized environment, where there can be more that one server that has the same <code class="code">ip-address</code> and <code class="code">port</code>. If this property is not explicitly set, it is assumed that the the <code class="code">ip-address</code> and <code class="code">port</code> uniquely identifies the SSH daemon. </p> </dd> <dt><strong><code class="code">{fd, file_descriptor()}</code></strong></dt> <dd> <p>Allows an existing file-descriptor to be used (passed on to the transport protocol).</p> </dd> <dt><strong><code class="code">{failfun, fun(User::string(), PeerAddress::ip_address(), Reason::term()) -&gt; _}</code></strong></dt> <dd> <p>Provides a fun to implement your own logging when a user fails to authenticate.</p> </dd> <dt><strong><code class="code">{connectfun, fun(User::string(), PeerAddress::ip_address(), Method::string()) -&gt;_}</code></strong></dt> <dd> <p>Provides a fun to implement your own logging when a user authenticates to the server.</p> </dd> <dt><strong><code class="code">{disconnectfun, fun(Reason:term()) -&gt; _}</code></strong></dt> <dd> <p>Provides a fun to implement your own logging when a user disconnects from the server.</p> </dd> <dt><strong><code class="code">{unexpectedfun, fun(Message:term(), Peer) -&gt; report | skip }</code></strong></dt> <dd> <p>Provides a fun to implement your own logging or other action when an unexpected message arrives. If the fun returns <code class="code">report</code> the usual info report is issued but if <code class="code">skip</code> is returned no report is generated.</p> <p><code class="code">Peer</code> is in the format of <code class="code">{Host,Port}</code>.</p> </dd> <dt><strong><code class="code">{idle_time, integer()}</code></strong></dt> <dd> <p>Sets a time-out on a connection when no channels are active. Defaults to <code class="code">infinity</code>.</p> </dd> <dt><strong><code class="code">{ssh_msg_debug_fun, fun(ConnectionRef::ssh_connection_ref(), AlwaysDisplay::boolean(), Msg::binary(), LanguageTag::binary()) -&gt; _}</code></strong></dt> <dd> <p>Provide a fun to implement your own logging of the SSH message SSH_MSG_DEBUG. The last three parameters are from the message, see RFC4253, section 11.3. The <code class="code">ConnectionRef</code> is the reference to the connection on which the message arrived. The return value from the fun is not checked.</p> <p>The default behaviour is ignore the message. To get a printout for each message with <code class="code">AlwaysDisplay = true</code>, use for example <code class="code">{ssh_msg_debug_fun, fun(_,true,M,_)-&gt; io:format("DEBUG: ~p~n", [M]) end}</code></p> </dd> </dl>  <h3><code id="daemon_info-1">daemon_info(Daemon) -&gt; {ok, [DaemonInfo]} | {error,Error}</code></h3>  <h2 class="func-types-title">Types</h2>     
<p>Returns a key-value list with information about the daemon. For now, only the listening port is returned. This is intended for the case the daemon is started with the port set to 0.</p>  <h3><code id="default_algorithms-0">default_algorithms() -&gt; algs_list()</code></h3> 
<p>Returns a key-value list, where the keys are the different types of algorithms and the values are the algorithms themselves. An example:</p> <pre data-language="erlang">
20&gt; ssh:default_algorithms().
[{kex,['diffie-hellman-group1-sha1']},
 {public_key,['ssh-rsa','ssh-dss']},
 {cipher,[{client2server,['aes128-ctr','aes128-cbc','3des-cbc']},
          {server2client,['aes128-ctr','aes128-cbc','3des-cbc']}]},
 {mac,[{client2server,['hmac-sha2-256','hmac-sha1']},
       {server2client,['hmac-sha2-256','hmac-sha1']}]},
 {compression,[{client2server,[none,zlib]},
               {server2client,[none,zlib]}]}]
21&gt; 
</pre>  <h3>
<code id="shell-1">shell(Host) -&gt;</code><code id="shell-2">shell(Host, Option) -&gt;</code><code id="shell-3">shell(Host, Port, Option) -&gt;</code><code id="shell-1">shell(TcpSocket) -&gt; _</code>
</h3>  <h2 class="func-types-title">Types</h2>     The socket is supposed to be from <code>gen_tcp:connect</code> or <code>gen_tcp:accept</code> with option <code class="code">{active,false}</code>   
<p>Starts an interactive shell over an SSH server on the given <code class="code">Host</code>. The function waits for user input, and does not return until the remote shell is ended (that is, exit from the shell). </p>  <h3>
<code id="start-0">start() -&gt;</code><code id="start-1">start(Type) -&gt; ok | {error, Reason}</code>
</h3>  <h2 class="func-types-title">Types</h2>    
<p>Utility function that starts the applications <code class="code">crypto</code>, <code class="code">public_key</code>, and <code class="code">ssh</code>. Default type is <code class="code">temporary</code>. For more information, see the <code>application(3)</code> manual page in Kernel.</p>  <h3><code id="stop-0">stop() -&gt; ok | {error, Reason}</code></h3>  <h2 class="func-types-title">Types</h2>   
<p>Stops the <code class="code">ssh</code> application. For more information, see the <code>application(3)</code> manual page in Kernel.</p>  <h3>
<code id="stop_daemon-1">stop_daemon(DaemonRef) -&gt;</code><code id="stop_daemon-2">stop_daemon(Address, Port) -&gt; ok</code>
</h3>  <h2 class="func-types-title">Types</h2>     
<p>Stops the listener and all connections started by the listener.</p>  <h3>
<code id="stop_listener-1">stop_listener(DaemonRef) -&gt;</code><code id="stop_listener-2">stop_listener(Address, Port) -&gt; ok</code>
</h3>  <h2 class="func-types-title">Types</h2>     
<p>Stops the listener, but leaves existing connections started by the listener operational.</p>  </div>
<div class="_attribution">
  <p class="_attribution-p">
    © 2010–2017 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
