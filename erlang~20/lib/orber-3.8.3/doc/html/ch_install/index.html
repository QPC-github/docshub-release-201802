
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>5. Installing Orber - Erlang 20 - W3cubDocs</title>
  
  <meta name="description" content=" This chapter describes how to install Orber in an Erlang Environment. ">
  <meta name="keywords" content="installing, orber, -, erlang, erlang~20">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/erlang~20/lib/orber-3.8.3/doc/html/ch_install/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-e0f881b0fce8cbe96f33dadc355b7159d5d2912911231446d60eb8f9caffa802.css">
  <script type="text/javascript" src="/assets/application-8fc46316434047265cd383f02b8e7f434ed7dec4a59f920dd633deef8d488d1b.js"></script>
  <script src="/json/erlang~20.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/erlang~20/" class="_nav-link" title="" style="margin-left:0;">Erlang 20</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _erlang">
				
<h1>5 Installing Orber</h1> <h2 id="id70060">5.1 Installation Process </h2> <p>This chapter describes how to install Orber in an Erlang Environment.</p> <h4>Preparation</h4> <p>To begin with, you must decide if you want to run Orber as a:</p> <ul> <li> <strong>Single node (non-distributed)</strong> - all communication with other Orber instances and ORB's supplied by other vendors use the OMG GIOP protocol.</li> <li> <strong>Multi node (distributed)</strong> - all Orber nodes, within the same <code class="code">domain</code>, communicate via the Erlang distribution protocol. For all other Orber instances, i.e. not part of the same <code class="code">domain</code>, and ORB's supplied by other vendors, the OMG GIOP protocol is used.</li> </ul> <p>Which approach to use is highly implementation specific, but a few things you should consider:</p> <ul> <li>All nodes within an Orber domain should have the same security level.</li> <li>If the capacity is greater than load (volume of traffic) a single-node Orber might be a good solution.</li> <li>In some cases the distributed system architecture requires a single-node Orber installation.</li> <li>A multi-node Orber makes it possible to load balance and create a more fault tolerant system. The Objects can also have a uniform view if you use distributed Mnesia tables.</li> <li>Since the GIOP protocol creates a larger overhead than the Erlang distribution protocol, the performance will be better when communicating with Objects within the same Orber domain compared with inter ORB communication (GIOP).</li> </ul> <p>You also have to decide if you want Orber to store internal data using <code class="code">disc_copies</code> and/or <code class="code">ram_copies</code>. Which storage type you should depends if/how you intend to use Mnesia in your application. If you intend to use <code class="code">disc_copies</code> you must start with creating a Mnesia schema, which contain information about the location of the Erlang nodes where Orber is planned to be run. For more background information, see the Mnesia documentation.</p> <p>In some cases it is absolutely necessary to change the default configuration of Orber. For example, if two Orber-ORB's shall be able to communicate via GIOP, they must have a unique <code class="code">domain</code> domain. Consult the <code><a href="../ch_install/#config">configuration settings</a></code> section. If you encounter any problems; see the chapter about <strong>Debugging</strong> in this User's Guide.</p> <h4>Jump Start Orber</h4> <p>The easiest way to start Orber is to use <code class="code">orber:jump_start(Port)</code>, which start a single-node ORB with (most likely) a unique domain (i.e. "IP-number:Port"). This function may only be used during development and testing. For any other situation, install and start Orber as described in the following sections. The listen port, i.e. iiop_port configuration parameter, is set to the supplied Port.</p> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>How Orber is configured when using <code class="code">orber:jump_start(Port)</code> may change at any time without warning. Hence, this operation must not be used in systems delivered to a customer.</p> </div> </div> <h4>Install Single Node Orber</h4> <p>Since a single node Orber communicate via the OMG GIOP protocol it is not necessary to start the Erlang distribution (i.e. using <code class="code">-name/-sname</code>).</p> <p>If we use <code class="code">ram_copies</code> there is no need for creating a disk based schema. Simply use:</p> <pre data-language="erlang">
erl&gt; mnesia:start().
erl&gt; corba:orb_init([{domain, "MyRAMSingleNodeORB"}]).
erl&gt; orber:install([node()], [{ifr_storage_type, ram_copies}]).
erl&gt; orber:start().
      </pre> <p>If you installation requires <code class="code">disc_copies</code> you must begin with creating a Mnesia schema. Otherwise, the installation is similar to a RAM installation:</p> <pre data-language="erlang">
erl&gt; mnesia:create_schema([node()]).
erl&gt; mnesia:start().
erl&gt; corba:orb_init([{domain, "MyDiskSingleNodeORB"}]).
erl&gt; orber:install([node()], [{ifr_storage_type, disc_copies},
                              {nameservice_storage_type, disc_copies}]).
erl&gt; orber:start().
      </pre> <p>You can still choose to store the IFR data as ram_copies, but then the data must be re-installed (i.e. invoke <code class="code">orber:install/2</code>) if the node is restarted. Hence, since the IFR data is rather static you should use <code class="code">disc_copies</code>. For more information see the <code class="code">orber</code> section in the reference manual.</p> <p>If you do not need to change Orber's configuration you can skip <code><a href="../corba/">orb_init/1</a></code>. But, you <strong>should</strong> at least set the IIOP timeout parameters.</p> <h4>Install RAM Based Multi Node Orber</h4> <p>Within a domain Orber uses the Erlang distribution protocol. Hence, you <strong>must</strong> start it first by, for example, using:</p> <pre data-language="erlang">
hostA&gt; erl -sname nodeA
      </pre> <p>In this example, we assume that we want to use two nodes; <code class="code">nodeA</code> and <code class="code">nodeB</code>. Since Mnesia must know which other nodes should a part of the distribution we either need to add the Mnesia configuration parameter <code class="code">extra_db_nodes</code> or use <code class="code">mnesia:change_config/2</code>. To begin with, Mnesia must be started on all nodes before we can install Orber:</p> <pre data-language="erlang">
nodeA@hostA&gt; mnesia:start().
nodeA@hostA&gt; mnesia:change_config(extra_db_nodes, 
                                  [nodeA@hostA, nodeB@hostB]).
      </pre> <p>After that the above have been repeated on <code class="code">nodeB</code> we must first make sure that both nodes will use the same domain name, then we can install Orber:</p> <pre data-language="erlang">
nodeA@hostA&gt; corba:orb_init([{domain, "MyRAMMultiNodeORB"}]).
nodeA@hostA&gt; orber:install([nodeA@hostA, nodeB@hostB],
                           [{ifr_storage_type, ram_copies}]).
nodeA@hostA&gt; orber:start().
      </pre> <p>Note that you can only invoke <code class="code">orber:install/1/2</code> on one of the nodes. Now we can start Orber on the other node:</p> <pre data-language="erlang">
nodeB@hostB&gt; corba:orb_init([{domain, "MyRAMMultiNodeORB"}]).
nodeB@hostB&gt; orber:start().
      </pre> <h4>Install Disk Based Multi Node Orber</h4> <p>As for RAM based multi-node Orber installations, the Erlang distribution must be started (e.g. erl -sname nodeA). The major difference is that when it is disk based a Mnesia schema must be created:</p> <pre data-language="erlang">
nodeA@hostA&gt; mnesia:create_schema([nodeA@hostA, nodeB@hostB]).
nodeA@hostA&gt; mnesia:start().
      </pre> <p>In this example, we assume that we want to use two nodes; <code class="code">nodeA</code> and <code class="code">nodeB</code>. Since it is not possible to create a schema on more than one node. Hence, all we have to do is to start Mnesia (i.e. invoke <code class="code">mnesia:start()</code>) on <code class="code">nodeB</code>.</p> <p>After Mnesia have been started on all nodes, you must confirm that all nodes have the same domain name, then Orber is ready to be installed:</p> <pre data-language="erlang">
nodeA@hostA&gt; corba:orb_init([{domain, "MyDiskMultiNodeORB"}]).
nodeA@hostA&gt; orber:install([nodeA@hostA, nodeB@hostB],
                           [{ifr_storage_type, disc_copies}]).
nodeA@hostA&gt; orber:start().
      </pre> <p>Note that you can only invoke <code class="code">orber:install/1/2</code> on one of the nodes. Now we can start Orber on the other node:</p> <pre data-language="erlang">
nodeB@hostB&gt; corba:orb_init([{domain, "MyDiskMultiNodeORB"}]).
nodeB@hostB&gt; orber:start().
      </pre> <h2 id="id74643">5.2 Configuration</h2>  <p id="config">It is essential that one configure Orber properly, to avoid, for example, malicious attacks and automatically terminate IIOP connections no longer in use. An easy way to extract information about Orber's configuration parameters is to invoke the operation <code><a href="../orber/">orber:info/1/2</a></code>. Orber offer the following configuration parameters:</p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td><strong>Key</strong></td> <td><strong>Range</strong></td> <td><strong>Default</strong></td> </tr> <tr> <td>domain</td> <td>string()</td> <td>"ORBER"</td> </tr> <tr> <td>iiop_port</td> <td>integer() &gt;= 0</td> <td>4001</td> </tr> <tr> <td>nat_iiop_port</td> <td>integer() &gt; 0 | {local, integer(), [{integer(), integer()}]}</td> <td>The same as <code class="code">iiop_port</code> </td> </tr> <tr> <td>iiop_out_ports</td> <td>0 | {integer(),integer()}</td> <td>0</td> </tr> <tr> <td>iiop_out_ports_attempts</td> <td>integer() &gt; 0</td> <td>1</td> </tr> <tr> <td>iiop_out_ports_random</td> <td>true | false</td> <td>false</td> </tr> <tr> <td>iiop_max_fragments</td> <td>integer() &gt; 0 | infinity</td> <td>infinity</td> </tr> <tr> <td>iiop_max_in_requests</td> <td>integer() &gt; 0 | infinity</td> <td>infinity</td> </tr> <tr> <td>iiop_max_in_connections</td> <td>integer() &gt; 0</td> <td>infinity</td> </tr> <tr> <td>iiop_backlog</td> <td>integer() &gt; 0</td> <td>5</td> </tr> <tr> <td>iiop_packet_size</td> <td>integer() &gt; 0 | infinity</td> <td>infinity</td> </tr> <tr> <td>ip_address</td> <td>string() | {multiple, [string()]}</td> <td>All interfaces</td> </tr> <tr> <td>ip_address_local</td> <td>string()</td> <td>Defined by the underlying system</td> </tr> <tr> <td>nat_ip_address</td> <td>string() | {multiple, [string()]} | {local, string(), [{string(), string()}]}</td> <td>The same as <code class="code">ip_address</code> </td> </tr> <tr> <td>objectkeys_gc_time</td> <td>integer() &gt; 0 | infinity</td> <td>infinity</td> </tr> <tr> <td>giop_version</td> <td>{1,0} | {1,1} | {1,2}</td> <td>{1,1}</td> </tr> <tr> <td>iiop_setup_connection_timeout</td> <td>integer() &gt; 0 | infinity</td> <td>infinity</td> </tr> <tr> <td>iiop_connection_timeout</td> <td>integer() &gt; 0 | infinity</td> <td>infinity</td> </tr> <tr> <td>iiop_in_connection_timeout</td> <td>integer() &gt; 0 | infinity</td> <td>infinity</td> </tr> <tr> <td>iiop_out_keepalive</td> <td>true | false</td> <td>false</td> </tr> <tr> <td>iiop_in_keepalive</td> <td>true | false</td> <td>false</td> </tr> <tr> <td>iiop_timeout</td> <td>integer() &gt; 0 | infinity</td> <td>infinity</td> </tr> <tr> <td>interceptors</td> <td>{native, [atom()]}</td> <td>-</td> </tr> <tr> <td>local_interceptors</td> <td>{native, [atom()]}</td> <td>-</td> </tr> <tr> <td>orbInitRef</td> <td>[string()] | undefined</td> <td>undefined</td> </tr> <tr> <td>orbDefaultInitRef</td> <td>string() | undefined</td> <td>undefined</td> </tr> <tr> <td>orber_debug_level</td> <td>0 - 10</td> <td>0</td> </tr> <tr> <td>flags</td> <td>integer() &gt;= 0</td> <td>0</td> </tr> <tr> <td>iiop_acl</td> <td>[{atom(), string()}] | [{atom(), string(), [string()]}]</td> <td>[]</td> </tr> <tr> <td>secure</td> <td>no | ssl</td> <td>no</td> </tr> <tr> <td>ssl_generation</td> <td>2 | 3</td> <td>2</td> </tr> <tr> <td>iiop_ssl_port</td> <td>integer() &gt;= 0</td> <td>4002</td> </tr> <tr> <td>iiop_ssl_accept_timeout</td> <td>integer() &gt; 0 | infinity</td> <td>infinity</td> </tr> <tr> <td>iiop_ssl_backlog</td> <td>integer() &gt; 0</td> <td>5</td> </tr> <tr> <td>iiop_ssl_ip_address_local</td> <td>string()</td> <td>Defined by the underlying system</td> </tr> <tr> <td>nat_iiop_ssl_port</td> <td>integer() &gt; 0 | {local, integer(), [{integer(), integer()}]}</td> <td>The same as <code class="code">iiop_ssl_port</code> </td> </tr> <tr> <td>ssl_server_options</td> <td>list()</td> <td>See the <code>SSL application</code> for valid options.</td> </tr> <tr> <td>ssl_client_options</td> <td>list()</td> <td>See the <code>SSL application</code> for valid options.</td> </tr> <tr> <td>iiop_ssl_out_keepalive</td> <td>true | false</td> <td>false</td> </tr> <tr> <td>iiop_ssl_in_keepalive</td> <td>true | false</td> <td>false</td> </tr> </table> <p class="doc-table-caption">Table 5.1: Orber Configuration Parameters</p> </div>   <p><strong>Comments on the table 'Orber Configuration Parameters':</strong></p> <dl> <dt><strong><strong>domain</strong></strong></dt> <dd>Since Orber domains, they are supposed to communicate via IIOP, <strong>MUST</strong> have unique names, communication will fail if two domains have the same name. The domain name <strong>MAY NOT</strong> contain <code class="code">^G</code> (i.e. <code class="code">\007</code>).</dd> <dt><strong><strong>iiop_port</strong></strong></dt> <dd>If set to 0 the OS will pick any vacant port. <br> <strong>Note:</strong>On a UNIX system it is preferable to have a IIOP port higher than 1023, since it is not recommended to run Erlang as a root user.</dd> <dt><strong><strong>nat_iiop_port</strong></strong></dt> <dd>The value is either an integer or <code class="code">{local, DefaultNATPort, [{Port, NATPort}]}</code>. See also <code><a href="../ch_install/#firewall">Firewall Configuration</a></code>.</dd> <dt><strong><strong>iiop_out_ports</strong></strong></dt> <dd>When set to 0 any available port will be used. If a range is specified, Orber will only use the local ports within the interval when trying to connect to another ORB (Orber acts as a client ORB). If all ports are in use communication will fail. Hence, it is <strong>absolutely necessary</strong> to set <code class="code">iiop_connection_timeout</code> as well. Otherwise, connections no longer in use will block further communication. If one use, for example, <code class="code">erl -orber iiop_out_ports "{5000,5020}"</code>, Orber will only use port 5000 to 5020 when connecting. If communicating via SSL, make sure you use a version that supports the local <code class="code">{port, Port}</code> option. See also <code><a href="../ch_install/#firewall">Firewall Configuration</a></code>.</dd> <dt><strong><strong>iiop_out_ports_random</strong></strong></dt> <dd>Requires that <code class="code">iiop_out_ports</code> define a port range. If that is the case Orber will select a port randomly from that sequence.</dd> <dt><strong><strong>iiop_out_ports_attempts</strong></strong></dt> <dd>Requires that <code class="code">iiop_out_ports</code> define a port range. If so Orber will accept a number of timeouts, defined by this parameter, when trying to connect to another ORB.</dd> <dt><strong><strong>iiop_max_fragments</strong></strong></dt> <dd>Limits the number of IIOP fragments allowed per request.</dd> <dt><strong><strong>iiop_max_in_requests</strong></strong></dt> <dd>Limits the number of concurrent incoming requests per incoming connection.</dd> <dt><strong><strong>iiop_max_in_connections</strong></strong></dt> <dd>Limits the number of concurrent incoming connections.</dd> <dt><strong><strong>iiop_backlog</strong></strong></dt> <dd>Defines the maximum length the queue of pending incoming connections may grow to.</dd> <dt><strong><strong>iiop_packet_size</strong></strong></dt> <dd>Defines the maximum size of incoming requests. If this limit is exceeded, the connection is closed.</dd> <dt><strong><strong>ip_address</strong></strong></dt> <dd>This option is used if orber only should listen on a specific ip interface on a multi-interface host or if exported IOR:s should contain multiple components. The value is the IPv4 or IPv6 address as a string or <code class="code">{multiple, IPList}</code>. The latter requires that the object is available via the all IP addresses found in the list.</dd> <dt><strong><strong>ip_address_local</strong></strong></dt> <dd>This option defines the default local interface Orber will use when connecting to another ORB via IIOP, i.e., Orber act as the client side ORB. The value is a IPv4 or IPv6 address as a string. It is possible to override <code class="code">ip_address_local</code> by defining <code class="code">iiop_acl</code> or passing the Orber generic <code class="code">interface</code> Context. If this option is not used, the underlying OS will choose which interface to use. For more information, see the <code><a href="../ch_install/#interfaces">Interface Configuration</a></code> section.</dd> <dt><strong><strong>nat_ip_address</strong></strong></dt> <dd>The value is the ip address as a string (IPv4 or IPv6), <code class="code">{multiple, IPList}</code> or <code class="code">{local, DefaultNATIPAddress, [{IPAddress, NATIPAddress}]}</code>. See also <code><a href="../ch_install/#firewall">Firewall Configuration</a></code>.</dd> <dt><strong><strong>objectkeys_gc_time</strong></strong></dt> <dd>This option should be set if objects are started using the option <code class="code">{persistent, true}</code>. The value is <code class="code">integer()</code> seconds.</dd> <dt><strong><strong>giop_version</strong></strong></dt> <dd>Defines the default GIOP protocol version.</dd> <dt><strong><strong>iiop_setup_connection_timeout</strong></strong></dt> <dd>The value is an integer (seconds) or the atom infinity. This option is only valid for client-side connections. If this option is set, attempts to connect to other ORB's will timeout after the given time limit. Note, if the time limit is large the TCP protocol may timeout before the supplied value.</dd> <dt><strong><strong>iiop_connection_timeout</strong></strong></dt> <dd>The value is an integer (timeout in seconds between 0 and 1000000) or the atom infinity. This option is only valid for client object connections, i.e., will have no effect on server connections. Setting this option will cause client connections to be terminated, if and only if, there are no pending requests. If there are a client still waiting for a reply, Orber will try again after the given seconds have passed. The main purpose for this option is to reduce the number of open connections; it is, for example, not necessary to keep a connection, only used once a day, open at all time.</dd> <dt><strong><strong>iiop_in_connection_timeout</strong></strong></dt> <dd>The same as for <code class="code">iiop_connection_timeout</code>. The only difference is that this option only affects incoming connections (i.e. Orber act as server-side ORB).</dd> <dt><strong><strong>iiop_out_keepalive</strong></strong></dt> <dd>Enables periodic transmission on a connected socket, when no other data is being exchanged. If the other end does not respond, the connection is considered broken and will be terminated. When enabled the SO_KEEPALIVE socket level option is set.</dd> <dt><strong><strong>iiop_in_keepalive</strong></strong></dt> <dd>The same as for <code class="code">iiop_out_keepalive</code>. The only difference is that this option only affects incoming connections.</dd> <dt><strong><strong>iiop_timeout</strong></strong></dt> <dd>The value is an integer (timeout in seconds between 0 and 1000000) or the atom infinity. This option is only valid on the client side. Setting this option, cause all intra-ORB requests to timeout and raise a system exception, e.g. <code class="code">TIMEOUT</code>, if no replies are delivered within the given time limit.</dd> <dt><strong><strong>interceptors</strong></strong></dt> <dd>If one set this parameter, e.g., <code class="code">erl -orber interceptors "{native, ['myInterceptor']}"</code>, Orber will use the supplied interceptor(s) for all inter-ORB communication. <code class="code">'myInterceptor'</code> is the module name of the interceptor. For more information, see the interceptor chapter in the User's Guide and the Reference Manual.</dd> <dt><strong><strong>local_interceptors</strong></strong></dt> <dd>If defined, its value will be used when activating local interceptors via <code><a href="../ch_install/#flags">Orber Environment Flags</a></code>. If not defined, but the flag is set, Orber will use the value of the <code class="code">interceptors</code> parameter.</dd> <dt><strong><strong>orbInitRef</strong></strong></dt> <dd>Setting this option, e.g., <code class="code">erl -orber orbInitRef [\"NameService=corbaloc::host.com/NameService\"]</code>, will alter the location from where <code class="code">corba:resolve_initial_references(Key)</code> tries to find an object matching the given Key. The keys will also appear when invoking <code class="code">corba:list_initial_services()</code>. This variable overrides <code class="code">orbDefaultInitRef</code> </dd> <dt><strong><strong>orbDefaultInitRef</strong></strong></dt> <dd>If a matching Key for <code class="code">orbInitRef</code> is not found, and this variable is set, it determines the location from where <code class="code">orber:resolve_initial_references(Key)</code> tries to find an object matching the given Key. Usage: <code class="code">erl -orber orbDefaultInitRef \"corbaloc::host.com\"</code>.</dd> <dt><strong><strong>orber_debug_level</strong></strong></dt> <dd>The range is 0 to 10. Using level 10 is the most verbose configuration. This option will generate reports, using the <code class="code">error_logger</code>, for abnormal situations. It is not recommended to use this option for delivered systems since some of the reports is not to be considered as errors. The main purpose is to assist during development.</dd> <dt><strong><strong>flags</strong></strong></dt> <dd>No flags are activated in the default case. The available configuration settings are described in <code><a href="../ch_install/#flags">Orber Environment Flags</a></code>.</dd> <dt><strong><strong>iiop_acl</strong></strong></dt> <dd>This option must be activated by setting <code><a href="../ch_install/#flags">Orber Environment Flags</a></code> parameter. The value of this parameter shall be a list of <code class="code">[{Direction, Filter}]</code> and/or <code class="code">[{Direction, Filter, [Interfaces]}]</code>. The <code class="code">Direction</code>, <code class="code">tcp_in</code>, <code class="code">ssl_in</code>, <code class="code">tcp_out</code> or <code class="code">ssl_out</code>, determines if the Access Control List (ACL) applies to incoming or outgoing connections and IIOP or IIOP over SSL. The <code class="code">Filter</code> uses a extended format of Classless Inter Domain Routing (CIDR). For example, <code class="code">"123.123.123.10"</code> limits the connection to that particular host, while <code class="code">"123.123.123.10/17"</code> allows connections to or from any host equal to the 17 most significant bits. Orber also allow the user to specify a certain port or port range, for example, <code class="code">"123.123.123.10/17#4001"</code> and <code class="code">"123.123.123.10/17#4001/5001"</code> respectively. IPv4 or none compressed IPv6 strings are accepted. <br> The list of <code class="code">Interfaces</code>, IPv4 or IPv6 strings, may only contain <strong>one</strong> address for outgoing connections. For incoming connections, the <code class="code">Interfaces</code> list may contain several IP strings. If set for outgoing connections, and access is granted, Orber will use that local interface when connecting to the server-side ORB. For incoming connections, the client-side ORB is required to use one of the listed interfaces locally. If it fail to do so, access will be denied. The module <code><a href="../orber_acl/">orber_acl</a></code> provides operations for evaluating the access control for filters and addresses. See also the <code><a href="../ch_install/#interfaces">Interface Configuration</a></code> and <code><a href="../ch_install/#firewall">Firewall Configuration</a></code> chapters.</dd> <dt><strong><strong>secure</strong></strong></dt> <dd>Determines the security mode Orber will use, which is either <code class="code">no</code> if it is an insecure domain or the type of security mechanism used. Currently, per default, Orber is compliant with <code class="code">CSIv1</code> level 0, which means IIOP via SSL/TLS. The security chapter later in this manual describes how to get security in Orber and how the options are used.</dd> <dt><strong><strong>ssl_generation</strong></strong></dt> <dd>Defines which SSL version, i.e. available API, is installed. The default value, <code class="code">2</code>, refers to SSL-3.1 or later, but earlier than SSL-4.0. If set to <code class="code">3</code> SSL-4.0, or later, must be available. Currently it not possible to use <code class="code">1</code>, it is only reserved for future use.</dd> <dt><strong><strong>iiop_ssl_port</strong></strong></dt> <dd>If set, the value must be an integer greater than zero and not equal to <strong>iiop_port</strong>.</dd> <dt><strong><strong>iiop_ssl_accept_timeout</strong></strong></dt> <dd>The value is an integer (timeout in seconds) or the atom infinity and determine how long the SSL handshake may take. This option should be set to avoid if a client never initiate the handshake.</dd> <dt><strong><strong>iiop_ssl_backlog</strong></strong></dt> <dd>Defines the maximum length the queue of pending incoming connections may grow to.</dd> <dt><strong><strong>iiop_ssl_ip_address_local</strong></strong></dt> <dd>This option defines the default local interface Orber will use when connecting to another ORB via IIOP SSL, i.e., Orber act as the client side ORB. The value is a IPv4 or IPv6 address as a string. It is possible to override <code class="code">iiop_ssl_ip_address_local</code> by defining <code class="code">iiop_acl</code> or passing the Orber generic <code class="code">interface</code> Context. If this option is not used, the underlying OS will choose which interface to use. For more information, see the <code><a href="../ch_install/#interfaces">Interface Configuration</a></code> section.</dd> <dt><strong><strong>nat_iiop_ssl_port</strong></strong></dt> <dd>If set, the value must be an integer greater than zero or <code class="code">{local, DefaultNATPort, [{Port, NATPort}]}</code>. See also <code><a href="../ch_install/#firewall">Firewall Configuration</a></code>.</dd> <dt><strong><strong>ssl_server_options</strong></strong></dt> <dd>A list of the SSL options when Orber is the server. In general it's just to remove the 'ssl_server_' prefix from the old options, i.e. <code class="code">ssl_server_verify</code> will just be <code class="code">verify</code> in this option list. See the <code>SSL application</code> for the correct list of possible options and their values. </dd> <dt><strong><strong>ssl_client_options</strong></strong></dt> <dd>A list of the SSL options when Orber is the client. In general it's just to remove the <code class="code">ssl_client_</code> prefix from the old options, i.e. <code class="code">ssl_client_depth</code> will just be <code class="code">depth</code> in this option list. See the <code>SSL application</code> for the correct list of possible options and their values. </dd> <dt><strong><strong>iiop_ssl_out_keepalive</strong></strong></dt> <dd>Enables periodic transmission on a connected socket, when no other data is being exchanged. If the other end does not respond, the connection is considered broken and will be terminated. When enabled the SO_KEEPALIVE socket level option is set. Requires that the installed SSL version support the <strong>keepalive</strong> option and that the <strong>ssl_generation</strong> points to this version.</dd> <dt><strong><strong>iiop_ssl_in_keepalive</strong></strong></dt> <dd>The same as for <code class="code">iiop_ssl_out_keepalive</code>. The only difference is that this option only affects incoming connections.</dd> </dl> <p>It is possible to invoke operations using the extra timeout parameter:</p> <pre data-language="erlang">
erl&gt; module_interface:function(ObjRef, Timeout, ..Arguments..).
erl&gt; module_interface:function(ObjRef, [{timeout, Timeout}], ..Arguments..).
erl&gt; module_interface:function(ObjRef, ..Arguments..).    </pre> <p>The extra Timeout argument will override the configuration parameter <code class="code">iiop_timeout</code>. It is, however, not possible to use <code class="code">infinity</code> to override the Timeout parameter. The Timeout option is also valid for objects which resides within the same Orber domain.</p> <p>The <code class="code">iiop_setup_connection_timeout</code>, <code class="code">iiop_timeout</code>, <code class="code">iiop_connection_timeout</code> and <code class="code">iiop_in_connection_timeout</code> variables should be used. The specified values is implementation specific, i.e., WAN or LAN, but they should range from <code class="code">iiop_setup_connection_timeout</code> to <code class="code">iiop_connection_timeout</code>.</p> <p>To change these settings in the configuration file, the <code class="code">-config</code> flag must be added to the erl command. See the Reference Manual <strong>config(4)</strong> for further information. The values can also be sent separately as options to the Erlang node when it is started, see the Reference Manual <strong>erl(1)</strong> for further information. </p> <h4 id="flags"> Orber Environment Flags</h4> <p>The <code class="code">Environment Flags</code> allows the user to activate debugging facilities or change Orber's behavior. The latter may result in that Orber is no longer compliant with the OMG standard, which may be necessary when communicating with a non-compliant ORB.</p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td><strong>Hexadecimal Value</strong></td> <td><strong>OMG Compliant</strong></td> <td><strong>Description</strong></td> </tr> <tr> <td>0001</td> <td>no</td> <td>Exclude CodeSet Component</td> </tr> <tr> <td>0002</td> <td>yes</td> <td>Local Typechecking</td> </tr> <tr> <td>0004</td> <td>yes</td> <td>Use Host Name in IOR</td> </tr> <tr> <td>0008</td> <td>yes</td> <td>Enable NAT</td> </tr> <tr> <td>0020</td> <td>yes</td> <td>Local Interceptors</td> </tr> <tr> <td>0080</td> <td>yes</td> <td>Light IFR</td> </tr> <tr> <td>0100</td> <td>yes</td> <td>Use IPv6</td> </tr> <tr> <td>0200</td> <td>yes</td> <td>EXIT Tolerance</td> </tr> <tr> <td>0400</td> <td>yes</td> <td>Enable Incoming ACL</td> </tr> <tr> <td>0800</td> <td>yes</td> <td>Enable Outgoing ACL</td> </tr> <tr> <td>1000</td> <td>yes</td> <td>Use Current Interface in IOR</td> </tr> </table> <p class="doc-table-caption">Table 5.2: Orber Environment Flags</p> </div> <p>Any combination of the flags above may be used and changes the behavior as follows:</p> <ul> <li> <strong>Exclude CodeSet Component</strong> - instruct Orber to exclude the CodeSet component in exported IOR:s. When activated, no negotiating regarding character and wide character conversions between the client and the server will occur. This flag will, most likely, cause problems if your IDL specification contains the data types wchar and/or wstring.</li> <li> <strong>Local Typechecking</strong> - If activated, parameters, replies and raised exceptions will be checked to ensure that the data is correct. If an error occurs, the <code class="code">error_logger</code> is used to generate reports. One <strong>MAY NOT</strong> use this option for delivered systems due to the extra overhead. Since this option activates typechecking for all objects generated on the target node, it is also possible to use the option <code class="code">{local_typecheck, boolean()}</code>, when invoking <code class="code">oe_create/2</code>, <code class="code">oe_create_link/2</code>, <code class="code">corba:create/4</code> or <code class="code">corba:create_link/4</code>, to override the configuration parameter.</li> <li> <strong>Use Host Name in IOR</strong> - normally Orber inserts the IP-number in IOR:s when they are exported. In some cases, this will cause the clients to open two connections instead of one.</li> <li> <strong>Enable NAT</strong> - if this flag is set, it is possible to use the NAT (Network Address Translation) configuration parameters (<code class="code">nat_iiop_port</code>, <code class="code">nat_iiop_ssl_port</code> and <code class="code">nat_ip_address</code>).</li> <li> <strong>Local Interceptors</strong> - use interceptors for local invocations.</li> <li> <strong>Light IFR</strong> - if the IFR is not explicitly used and this flag is set, Orber will use a minimal IFR to reduce memory usage and installation time.</li> <li> <strong>Use IPv6</strong> - when this option is activated, Orber will use <code class="code">IPv6</code> for inter-ORB communication.</li> <li> <strong>EXIT Tolerance</strong> - servers will survive even though the call-back module caused an EXIT.</li> <li> <strong>Enable Incoming ACL</strong> - activates access control for incoming connections.</li> <li> <strong>Enable Outgoing ACL</strong> - activates access control for outgoing connections.</li> <li> <strong>Use Current Interface in IOR</strong> - when set, Orber will add the interface the request came via to exported local IOR:s.</li> </ul> <p>Invoking the operation <code><a href="../orber/">orber:info/1/2</a></code> will display the currently set flags in a readable way.</p> <h2 id="id77230">5.3 Firewall Configuration</h2>  <p id="firewall">Firewalls are used to protect objects from clients in other networks or sub-networks, but also to restrict which hosts internal objects may connect to (i.e. <code class="code">inbound protection</code> and <code class="code">outbound protection</code>). A firewall can limit access based on:</p> <ul> <li> <strong>Transport Level</strong> - performs access control decisions based on address information in TCP headers.</li> <li> <strong>Application Level</strong> - understands GIOP messages and the specific transport level inter-ORB Protocol supported e.g. IIOP.</li> </ul> <p>This section describes how to configure a <code class="code">Transport Level</code> firewall. It must have prior knowledge of the source to destination mappings, and conceptually has a configuration table containing tuples of the form: <code class="code">({inhost:inport}, {outhost:outport})</code>. If there are no port restrictions it is rather easy to configure the firewall. Otherwise, we must consider the following alternatives:</p> <ul> <li> <strong>Incoming Requests</strong> - Orber only uses the port-numbers specified by the configuration parameters <strong>iiop_port</strong> and <strong>iiop_ssl_port</strong>. Other ORB's may use several ports but it should be possible to change this behavior. Consult the other ORBs documentation.</li> <li> <strong>Outgoing Requests</strong> - Most ORB's, Orber included, ask the OS to supply a vacant local port when connecting to the server-side ORB. It is possible to change this behavior when using Orber (i.e. set the configuration parameter <strong>iiop_out_ports</strong>).</li> </ul> <div class="warning"> <div class="label">Warning</div> <div class="content">

<p>Using the option <code class="code">iiop_out_ports</code> may result in that Orber runs out of valid ports numbers. For example, other applications may steal some of the ports or the number of concurrent outgoing connections to other ORBs may be higher than expected. To reduce, but not eliminate, the risk you should use <code class="code">iiop_connection_timeout</code>.</p> </div> </div> <p>Firewall configuration example:</p> <pre data-language="erlang">
# "Plain" IIOP
To: Orber-IPNo:(iiop_port)     From: ORB-IPNo:X
To: ORB-IPNo:Z                 From: Orber-IPNo:(iiop_out_ports | Any Port)

# IIOP via SSL
To: Orber-IPNo:(iiop_port)     From: ORB-IPNo:X
To: Orber-IPNo:(iiop_ssl_port) From: ORB-IPNo:Y
To: ORB-IPNo:Z                 From: Orber-IPNo:(iiop_out_ports | Any Port)
    </pre> <p>If the communication take place via a <code><a href="../ch_install/#firewall_nat">TCP Firewall with NAT</a></code> (Network Address Translation), we must activate this behavior and define the external address and/or ports.</p>  <div class="doc-image-wrapper" id="firewall_nat">  <p class="doc-image-caption">Figure 5.1: TCP Firewall With NAT</p> </div> <p>Using NAT makes it possible to use different host data for different network domains. This way we can share Internet Protocol address resources or obscure resources. To enable this feature the <code><a href="../ch_install/#flags">Enable NAT</a></code> flag must be set and <code class="code">nat_iiop_port</code>, <code class="code">nat_iiop_ssl_port</code> and <code class="code">nat_ip_address</code> configured, which maps to <code class="code">iiop_port</code>, <code class="code">iiop_ssl_port</code> and <code class="code">ip_address</code> respectively. Hence, the firewall must be configured to translate the external to the internal representation correctly. If these NAT parameters are assigned a single port number or IP address, only those will be used when an IOR is exported to another ORB. When <code class="code">ip_address</code> is set to <code class="code">{multiple, [IPAddress]}</code>, <code class="code">nat_ip_address</code> should be configured in the same way, so that each NAT IP address can be translated to a valid address by the firewall. If objects are supposed to be accessible via different interfaces and port, see also <code><a href="../ch_install/#interfaces">Interface Configuration</a></code>, the options <code class="code">{local, DefaultNATIPAddress, [{IPAddress, NATIPAddress}]}</code> and/or <code class="code">{local, DefaultNATPort, [{Port, NATPort}]}</code> shall be used. The default NAT IP address and port, should be translated to the value of <code class="code">ip_address_local</code> and the default listen port by the firewall. If the IP address and/or port is not found in the list, the default values will be inserted in the IOR. The firewall must be able to translate these correctly.</p> <p>If it is necessary to limit the access to an ORB within a secure network, but other applications running on the same host may not be blocked out, one can use a <strong>Application Level</strong> firewall or Orber Access Control List (ACL). The latter makes it possible for the user to define which hosts may communicate, either as server or client, with Orber. This is achieved by defining the configuration parameter <code><a href="../ch_install/#config">iiop_acl</a></code>. The Classless Inter Domain Routing (CIDR) <code class="code">Filter</code> determines which peer interfaces and ports the other ORB may use.</p> <div class="doc-table-wrapper"> <table class="doc-table"> <tr> <td><strong>Filter</strong></td> <td><strong>Peer Interface(s)</strong></td> <td><strong>Peer Port(s)</strong></td> </tr> <tr> <td>"10.1.1.1"</td> <td>10.1.1.1</td> <td>any</td> </tr> <tr> <td>"10.1.1.1/8"</td> <td>10.0.0.0-10.255.255.255</td> <td>any</td> </tr> <tr> <td>"10.1.1.1/8#4001"</td> <td>10.0.0.0-10.255.255.255</td> <td>4001</td> </tr> <tr> <td>"10.1.1.1/8#4001/5001"</td> <td>10.0.0.0-10.255.255.255</td> <td>4001-5001</td> </tr> </table> <p class="doc-table-caption">Table 5.3: Orber ACL Filters</p> </div> <p>Orber ACL, also allows the user to define which local interface(s) may be used, but will not detect <code class="code">spoofing</code>. The operation <code><a href="../orber_acl/">orber_acl:match/2/3</a></code> makes it easy to verify whether access would be granted or not. For example, if Orber would be started with the ACL <code class="code">[{tcp_out, "10.1.1.1/8#4001/5001"}]</code>, then <code class="code">orber_acl:match/2</code> would behave as follows:</p> <pre data-language="erlang">
erl&gt; orber_acl:match({11,1,1,1}, tcp_out).
false

erl&gt; orber_acl:match({10,1,1,1}, tcp_out).
true

erl&gt; orber_acl:match({11,1,1,1}, tcp_out, true).
{false,[],0}

erl&gt; orber_acl:match({10,1,1,1}, tcp_out, true).
{true,[],{4001,5001}}
    </pre> <p>Only if the returned boolean is true the extra return values makes a difference. In the example above, <code class="code">{true,[],{4001,5001}}</code> means that Orber may connect to <code class="code">"10.1.1.1"</code>, using any local interface, if the server-side ORB listens for incoming connect requests on a port within the range 4001-5001. Note, invoking the <code class="code">orber_acl:match/2/3</code> operation, will not result in a connect attempt by Orber. The reason for this, is that this function may be used on a live node as well as in test environment. Hence, if a local interface is currently not available or no server-side ORB available via the given host/port(s), will not be detected by Orber.</p> <h2 id="id77671">5.4 Interface Configuration</h2>  <p id="interfaces">In many cases it is sufficient to simply configure the underlying OS which local interfaces shall be used for all applications. But, in some cases it is required, due to, for example, the firewall configuration, that different local interfaces are used for different applications. Some times, it is even necessary to use a specific interface for a single CORBA object. This section describe how one can alter this in different ways.</p> <p>The default behavior is that Orber lets the OS configuration decide which interface will be added in IOR:s exported to another ORB and the local interface used when connecting to another ORB (Orber act as client side ORB). The latter can be overridden by setting the configuration parameters <code class="code">iiop_ssl_ip_address_local</code> and/or <code class="code">ip_address_local</code>, which will affect IIOP via SSL and IIOP respectively. These parameters can be overridden by using the Orber generic <code class="code">interface</code> Context or defining an ACL (Access Control List). The latter always takes precedence if a local interface is included (e.g. <code class="code">[{tcp_out, "10.0.0.0/8", ["10.0.0.1"]}]</code>). If the interface is excluded (e.g. <code class="code">[{tcp_out, "10.0.0.0/8"}]</code>), the interface chosen will, in the following order, be determined by <code class="code">#'IOP_ServiceContext'{}</code>, <code class="code">ip_address_local/iiop_ssl_ip_address_local</code> or the configuration of the underlying system.</p> <p>Adding the interface context, for generated stubs/skeletons, is done in the following way:</p> <pre data-language="erlang">
Ctx = #'IOP_ServiceContext'{context_id = ?ORBER_GENERIC_CTX_ID, 
                            context_data = {interface, "10.0.0.1"}},
'CosNaming_NamingContext':resolve(NS, [{context, [Ctx]}], Name),
    </pre> <p>It is also possible to add the context to <code class="code">corba:string_to_object/2, corba:resolve_initial_references/2, corba:resolve_initial_references_remote/3, corba:list_initial_services_remote/2, corba_object:not_existent/2, corba_object:non_existent/2</code> and <code class="code">corba_object:is_a/3</code>. The operations exported by <code class="code">corba_object</code> are affected if the supplied IOR is external. The function <code class="code">corba:string_to_object/2</code> might require the interface context if a <code class="code">corbaloc</code> or a <code class="code">corbaloc</code> string is passed (See the <code><a href="../ch_naming_service/#interop_ns">INS</a></code> chapter), while <code class="code">corba:resolve_initial_references_remote/3</code> and <code class="code">corba:list_initial_services_remote/2</code> always connect to another ORB and it might be necessary to add the context. The remaining <code class="code">corba</code> operations are affected if calls are re-directed by setting the <code class="code">orbInitRef</code> and/or <code class="code">orbDefaultInitRef</code> configuration parameters. For more information, see the Reference Manual for each module.</p> <p>Configuring which interface(s) that shall be used when exporting an IOR to another ORB, is determined by <code class="code">nat_ip_address</code>, setting the flag <code><a href="../ch_install/#flags">16#1000</a></code> and <code class="code">ip_address</code>, in that order. Orber listens for incoming connections either via all interfaces or the interface defined by <code class="code">ip_address</code>. It is also possible to add and remove extra listen interfaces by using <code class="code">orber:add_listen_interface/2/3</code> and <code class="code">orber:remove_listen_interface/1</code>. In this case one should set the 16#1000 flag and, if necessary, set the configuration parameters <code class="code">{local, DefaultNATIPAddress, [{IPAddress, NATIPAddress}]}</code> and/or <code class="code">{local, DefaultNATPort, [{Port, NATPort}]}</code>.</p>
<div class="_attribution">
  <p class="_attribution-p">
    © 2010–2017 Ericsson AB<br>Licensed under the Apache License, Version 2.0.<br>
    
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
