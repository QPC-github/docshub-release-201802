
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Transports and Protocols (Callback Based API) - Python 3.6 - W3cubDocs</title>
  
  <meta name="description" content=" Source code&#58; Lib&#47;asyncio&#47;transports.py ">
  <meta name="keywords" content="transports, and, protocols, callback, based, api, -, python, python~3.6">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/python~3.6/library/asyncio-protocol/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-e0f881b0fce8cbe96f33dadc355b7159d5d2912911231446d60eb8f9caffa802.css">
  <script type="text/javascript" src="/assets/application-8fc46316434047265cd383f02b8e7f434ed7dec4a59f920dd633deef8d488d1b.js"></script>
  <script src="/json/python~3.6.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/python~3.6/" class="_nav-link" title="" style="margin-left:0;">Python 3.6</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _sphinx">
				
<h1 id="transports-and-protocols-callback-based-api"> Transports and protocols (callback based API)</h1> <p><strong>Source code:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.6/Lib/asyncio/transports.py" target="_blank">Lib/asyncio/transports.py</a></p> <p><strong>Source code:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.6/Lib/asyncio/protocols.py" target="_blank">Lib/asyncio/protocols.py</a></p>  <h2 id="asyncio-transport">1. Transports</h2> <p id="transports">Transports are classes provided by <a class="reference internal" href="../asyncio/#module-asyncio" title="asyncio: Asynchronous I/O, event loop, coroutines and tasks."><code>asyncio</code></a> in order to abstract various kinds of communication channels. You generally won’t instantiate a transport yourself; instead, you will call an <a class="reference internal" href="../asyncio-eventloop/#asyncio.AbstractEventLoop" title="asyncio.AbstractEventLoop"><code>AbstractEventLoop</code></a> method which will create the transport and try to initiate the underlying communication channel, calling you back when it succeeds.</p> <p>Once the communication channel is established, a transport is always paired with a <a class="reference internal" href="#asyncio-protocol"><span class="std std-ref">protocol</span></a> instance. The protocol can then call the transport’s methods for various purposes.</p> <p><a class="reference internal" href="../asyncio/#module-asyncio" title="asyncio: Asynchronous I/O, event loop, coroutines and tasks."><code>asyncio</code></a> currently implements transports for TCP, UDP, SSL, and subprocess pipes. The methods available on a transport depend on the transport’s kind.</p> <p>The transport classes are <a class="reference internal" href="../asyncio-dev/#asyncio-multithreading"><span class="std std-ref">not thread safe</span></a>.</p> <div class="versionchanged"> <p><span class="versionmodified">Changed in version 3.6: </span>The socket option <code>TCP_NODELAY</code> is now set by default.</p> </div>  <h3 id="basetransport">1.1. BaseTransport</h3> <dl class="class"> <dt id="asyncio.BaseTransport">
<code>class asyncio.BaseTransport</code> </dt> <dd>
<p>Base class for transports.</p> <dl class="method"> <dt id="asyncio.BaseTransport.close">
<code>close()</code> </dt> <dd>
<p>Close the transport. If the transport has a buffer for outgoing data, buffered data will be flushed asynchronously. No more data will be received. After all buffered data is flushed, the protocol’s <code>connection_lost()</code> method will be called with <a class="reference internal" href="../constants/#None" title="None"><code>None</code></a> as its argument.</p> </dd>
</dl> <dl class="method"> <dt id="asyncio.BaseTransport.is_closing">
<code>is_closing()</code> </dt> <dd>
<p>Return <code>True</code> if the transport is closing or is closed.</p> <div class="versionadded"> <p><span class="versionmodified">New in version 3.5.1.</span></p> </div> </dd>
</dl> <dl class="method"> <dt id="asyncio.BaseTransport.get_extra_info">
<code>get_extra_info(name, default=None)</code> </dt> <dd>
<p>Return optional transport information. <em>name</em> is a string representing the piece of transport-specific information to get, <em>default</em> is the value to return if the information doesn’t exist.</p> <p>This method allows transport implementations to easily expose channel-specific information.</p> <ul class="simple"> <li>socket:<ul> <li>
<code>'peername'</code>: the remote address to which the socket is connected, result of <a class="reference internal" href="../socket/#socket.socket.getpeername" title="socket.socket.getpeername"><code>socket.socket.getpeername()</code></a> (<code>None</code> on error)</li> <li>
<code>'socket'</code>: <a class="reference internal" href="../socket/#socket.socket" title="socket.socket"><code>socket.socket</code></a> instance</li> <li>
<code>'sockname'</code>: the socket’s own address, result of <a class="reference internal" href="../socket/#socket.socket.getsockname" title="socket.socket.getsockname"><code>socket.socket.getsockname()</code></a>
</li> </ul> </li> <li>SSL socket:<ul> <li>
<code>'compression'</code>: the compression algorithm being used as a string, or <code>None</code> if the connection isn’t compressed; result of <a class="reference internal" href="../ssl/#ssl.SSLSocket.compression" title="ssl.SSLSocket.compression"><code>ssl.SSLSocket.compression()</code></a>
</li> <li>
<code>'cipher'</code>: a three-value tuple containing the name of the cipher being used, the version of the SSL protocol that defines its use, and the number of secret bits being used; result of <a class="reference internal" href="../ssl/#ssl.SSLSocket.cipher" title="ssl.SSLSocket.cipher"><code>ssl.SSLSocket.cipher()</code></a>
</li> <li>
<code>'peercert'</code>: peer certificate; result of <a class="reference internal" href="../ssl/#ssl.SSLSocket.getpeercert" title="ssl.SSLSocket.getpeercert"><code>ssl.SSLSocket.getpeercert()</code></a>
</li> <li>
<code>'sslcontext'</code>: <a class="reference internal" href="../ssl/#ssl.SSLContext" title="ssl.SSLContext"><code>ssl.SSLContext</code></a> instance</li> <li>
<code>'ssl_object'</code>: <a class="reference internal" href="../ssl/#ssl.SSLObject" title="ssl.SSLObject"><code>ssl.SSLObject</code></a> or <a class="reference internal" href="../ssl/#ssl.SSLSocket" title="ssl.SSLSocket"><code>ssl.SSLSocket</code></a> instance</li> </ul> </li> <li>pipe:<ul> <li>
<code>'pipe'</code>: pipe object</li> </ul> </li> <li>subprocess:<ul> <li>
<code>'subprocess'</code>: <a class="reference internal" href="../subprocess/#subprocess.Popen" title="subprocess.Popen"><code>subprocess.Popen</code></a> instance</li> </ul> </li> </ul> </dd>
</dl> <dl class="method"> <dt id="asyncio.BaseTransport.set_protocol">
<code>set_protocol(protocol)</code> </dt> <dd>
<p>Set a new protocol. Switching protocol should only be done when both protocols are documented to support the switch.</p> <div class="versionadded"> <p><span class="versionmodified">New in version 3.5.3.</span></p> </div> </dd>
</dl> <dl class="method"> <dt id="asyncio.BaseTransport.get_protocol">
<code>get_protocol()</code> </dt> <dd>
<p>Return the current protocol.</p> <div class="versionadded"> <p><span class="versionmodified">New in version 3.5.3.</span></p> </div> </dd>
</dl> <div class="versionchanged"> <p><span class="versionmodified">Changed in version 3.5.1: </span><code>'ssl_object'</code> info was added to SSL sockets.</p> </div> </dd>
</dl>   <h3 id="readtransport">1.2. ReadTransport</h3> <dl class="class"> <dt id="asyncio.ReadTransport">
<code>class asyncio.ReadTransport</code> </dt> <dd>
<p>Interface for read-only transports.</p> <dl class="method"> <dt id="asyncio.ReadTransport.pause_reading">
<code>pause_reading()</code> </dt> <dd>
<p>Pause the receiving end of the transport. No data will be passed to the protocol’s <code>data_received()</code> method until <a class="reference internal" href="#asyncio.ReadTransport.resume_reading" title="asyncio.ReadTransport.resume_reading"><code>resume_reading()</code></a> is called.</p> </dd>
</dl> <dl class="method"> <dt id="asyncio.ReadTransport.resume_reading">
<code>resume_reading()</code> </dt> <dd>
<p>Resume the receiving end. The protocol’s <code>data_received()</code> method will be called once again if some data is available for reading.</p> </dd>
</dl> </dd>
</dl>   <h3 id="writetransport">1.3. WriteTransport</h3> <dl class="class"> <dt id="asyncio.WriteTransport">
<code>class asyncio.WriteTransport</code> </dt> <dd>
<p>Interface for write-only transports.</p> <dl class="method"> <dt id="asyncio.WriteTransport.abort">
<code>abort()</code> </dt> <dd>
<p>Close the transport immediately, without waiting for pending operations to complete. Buffered data will be lost. No more data will be received. The protocol’s <code>connection_lost()</code> method will eventually be called with <a class="reference internal" href="../constants/#None" title="None"><code>None</code></a> as its argument.</p> </dd>
</dl> <dl class="method"> <dt id="asyncio.WriteTransport.can_write_eof">
<code>can_write_eof()</code> </dt> <dd>
<p>Return <a class="reference internal" href="../constants/#True" title="True"><code>True</code></a> if the transport supports <a class="reference internal" href="#asyncio.WriteTransport.write_eof" title="asyncio.WriteTransport.write_eof"><code>write_eof()</code></a>, <a class="reference internal" href="../constants/#False" title="False"><code>False</code></a> if not.</p> </dd>
</dl> <dl class="method"> <dt id="asyncio.WriteTransport.get_write_buffer_size">
<code>get_write_buffer_size()</code> </dt> <dd>
<p>Return the current size of the output buffer used by the transport.</p> </dd>
</dl> <dl class="method"> <dt id="asyncio.WriteTransport.get_write_buffer_limits">
<code>get_write_buffer_limits()</code> </dt> <dd>
<p>Get the <em>high</em>- and <em>low</em>-water limits for write flow control. Return a tuple <code>(low, high)</code> where <em>low</em> and <em>high</em> are positive number of bytes.</p> <p>Use <a class="reference internal" href="#asyncio.WriteTransport.set_write_buffer_limits" title="asyncio.WriteTransport.set_write_buffer_limits"><code>set_write_buffer_limits()</code></a> to set the limits.</p> <div class="versionadded"> <p><span class="versionmodified">New in version 3.4.2.</span></p> </div> </dd>
</dl> <dl class="method"> <dt id="asyncio.WriteTransport.set_write_buffer_limits">
<code>set_write_buffer_limits(high=None, low=None)</code> </dt> <dd>
<p>Set the <em>high</em>- and <em>low</em>-water limits for write flow control.</p> <p>These two values (measured in number of bytes) control when the protocol’s <code>pause_writing()</code> and <code>resume_writing()</code> methods are called. If specified, the low-water limit must be less than or equal to the high-water limit. Neither <em>high</em> nor <em>low</em> can be negative.</p> <p><code>pause_writing()</code> is called when the buffer size becomes greater than or equal to the <em>high</em> value. If writing has been paused, <code>resume_writing()</code> is called when the buffer size becomes less than or equal to the <em>low</em> value.</p> <p>The defaults are implementation-specific. If only the high-water limit is given, the low-water limit defaults to an implementation-specific value less than or equal to the high-water limit. Setting <em>high</em> to zero forces <em>low</em> to zero as well, and causes <code>pause_writing()</code> to be called whenever the buffer becomes non-empty. Setting <em>low</em> to zero causes <code>resume_writing()</code> to be called only once the buffer is empty. Use of zero for either limit is generally sub-optimal as it reduces opportunities for doing I/O and computation concurrently.</p> <p>Use <a class="reference internal" href="#asyncio.WriteTransport.get_write_buffer_limits" title="asyncio.WriteTransport.get_write_buffer_limits"><code>get_write_buffer_limits()</code></a> to get the limits.</p> </dd>
</dl> <dl class="method"> <dt id="asyncio.WriteTransport.write">
<code>write(data)</code> </dt> <dd>
<p>Write some <em>data</em> bytes to the transport.</p> <p>This method does not block; it buffers the data and arranges for it to be sent out asynchronously.</p> </dd>
</dl> <dl class="method"> <dt id="asyncio.WriteTransport.writelines">
<code>writelines(list_of_data)</code> </dt> <dd>
<p>Write a list (or any iterable) of data bytes to the transport. This is functionally equivalent to calling <a class="reference internal" href="#asyncio.WriteTransport.write" title="asyncio.WriteTransport.write"><code>write()</code></a> on each element yielded by the iterable, but may be implemented more efficiently.</p> </dd>
</dl> <dl class="method"> <dt id="asyncio.WriteTransport.write_eof">
<code>write_eof()</code> </dt> <dd>
<p>Close the write end of the transport after flushing buffered data. Data may still be received.</p> <p>This method can raise <a class="reference internal" href="../exceptions/#NotImplementedError" title="NotImplementedError"><code>NotImplementedError</code></a> if the transport (e.g. SSL) doesn’t support half-closes.</p> </dd>
</dl> </dd>
</dl>   <h3 id="datagramtransport">1.4. DatagramTransport</h3> <dl class="method"> <dt id="asyncio.DatagramTransport.sendto">
<code>DatagramTransport.sendto(data, addr=None)</code> </dt> <dd>
<p>Send the <em>data</em> bytes to the remote peer given by <em>addr</em> (a transport-dependent target address). If <em>addr</em> is <a class="reference internal" href="../constants/#None" title="None"><code>None</code></a>, the data is sent to the target address given on transport creation.</p> <p>This method does not block; it buffers the data and arranges for it to be sent out asynchronously.</p> </dd>
</dl> <dl class="method"> <dt id="asyncio.DatagramTransport.abort">
<code>DatagramTransport.abort()</code> </dt> <dd>
<p>Close the transport immediately, without waiting for pending operations to complete. Buffered data will be lost. No more data will be received. The protocol’s <code>connection_lost()</code> method will eventually be called with <a class="reference internal" href="../constants/#None" title="None"><code>None</code></a> as its argument.</p> </dd>
</dl>   <h3 id="basesubprocesstransport">1.5. BaseSubprocessTransport</h3> <dl class="class"> <dt id="asyncio.BaseSubprocessTransport">
<code>class asyncio.BaseSubprocessTransport</code> </dt> <dd>
<dl class="method"> <dt id="asyncio.BaseSubprocessTransport.get_pid">
<code>get_pid()</code> </dt> <dd>
<p>Return the subprocess process id as an integer.</p> </dd>
</dl> <dl class="method"> <dt id="asyncio.BaseSubprocessTransport.get_pipe_transport">
<code>get_pipe_transport(fd)</code> </dt> <dd>
<p>Return the transport for the communication pipe corresponding to the integer file descriptor <em>fd</em>:</p> <ul class="simple"> <li>
<code>0</code>: readable streaming transport of the standard input (<em>stdin</em>), or <a class="reference internal" href="../constants/#None" title="None"><code>None</code></a> if the subprocess was not created with <code>stdin=PIPE</code>
</li> <li>
<code>1</code>: writable streaming transport of the standard output (<em>stdout</em>), or <a class="reference internal" href="../constants/#None" title="None"><code>None</code></a> if the subprocess was not created with <code>stdout=PIPE</code>
</li> <li>
<code>2</code>: writable streaming transport of the standard error (<em>stderr</em>), or <a class="reference internal" href="../constants/#None" title="None"><code>None</code></a> if the subprocess was not created with <code>stderr=PIPE</code>
</li> <li>other <em>fd</em>: <a class="reference internal" href="../constants/#None" title="None"><code>None</code></a>
</li> </ul> </dd>
</dl> <dl class="method"> <dt id="asyncio.BaseSubprocessTransport.get_returncode">
<code>get_returncode()</code> </dt> <dd>
<p>Return the subprocess returncode as an integer or <a class="reference internal" href="../constants/#None" title="None"><code>None</code></a> if it hasn’t returned, similarly to the <a class="reference internal" href="../subprocess/#subprocess.Popen.returncode" title="subprocess.Popen.returncode"><code>subprocess.Popen.returncode</code></a> attribute.</p> </dd>
</dl> <dl class="method"> <dt id="asyncio.BaseSubprocessTransport.kill">
<code>kill()</code> </dt> <dd>
<p>Kill the subprocess, as in <a class="reference internal" href="../subprocess/#subprocess.Popen.kill" title="subprocess.Popen.kill"><code>subprocess.Popen.kill()</code></a>.</p> <p>On POSIX systems, the function sends SIGKILL to the subprocess. On Windows, this method is an alias for <a class="reference internal" href="#asyncio.BaseSubprocessTransport.terminate" title="asyncio.BaseSubprocessTransport.terminate"><code>terminate()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="asyncio.BaseSubprocessTransport.send_signal">
<code>send_signal(signal)</code> </dt> <dd>
<p>Send the <em>signal</em> number to the subprocess, as in <a class="reference internal" href="../subprocess/#subprocess.Popen.send_signal" title="subprocess.Popen.send_signal"><code>subprocess.Popen.send_signal()</code></a>.</p> </dd>
</dl> <dl class="method"> <dt id="asyncio.BaseSubprocessTransport.terminate">
<code>terminate()</code> </dt> <dd>
<p>Ask the subprocess to stop, as in <a class="reference internal" href="../subprocess/#subprocess.Popen.terminate" title="subprocess.Popen.terminate"><code>subprocess.Popen.terminate()</code></a>. This method is an alias for the <a class="reference internal" href="#asyncio.BaseSubprocessTransport.close" title="asyncio.BaseSubprocessTransport.close"><code>close()</code></a> method.</p> <p>On POSIX systems, this method sends SIGTERM to the subprocess. On Windows, the Windows API function TerminateProcess() is called to stop the subprocess.</p> </dd>
</dl> <dl class="method"> <dt id="asyncio.BaseSubprocessTransport.close">
<code>close()</code> </dt> <dd>
<p>Ask the subprocess to stop by calling the <a class="reference internal" href="#asyncio.BaseSubprocessTransport.terminate" title="asyncio.BaseSubprocessTransport.terminate"><code>terminate()</code></a> method if the subprocess hasn’t returned yet, and close transports of all pipes (<em>stdin</em>, <em>stdout</em> and <em>stderr</em>).</p> </dd>
</dl> </dd>
</dl>    <h2 id="asyncio-protocol">2. Protocols</h2> <p id="protocols"><a class="reference internal" href="../asyncio/#module-asyncio" title="asyncio: Asynchronous I/O, event loop, coroutines and tasks."><code>asyncio</code></a> provides base classes that you can subclass to implement your network protocols. Those classes are used in conjunction with <a class="reference internal" href="#asyncio-transport"><span class="std std-ref">transports</span></a> (see below): the protocol parses incoming data and asks for the writing of outgoing data, while the transport is responsible for the actual I/O and buffering.</p> <p>When subclassing a protocol class, it is recommended you override certain methods. Those methods are callbacks: they will be called by the transport on certain events (for example when some data is received); you shouldn’t call them yourself, unless you are implementing a transport.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">All callbacks have default implementations, which are empty. Therefore, you only need to implement the callbacks for the events in which you are interested.</p> </div>  <h3 id="protocol-classes">2.1. Protocol classes</h3> <dl class="class"> <dt id="asyncio.Protocol">
<code>class asyncio.Protocol</code> </dt> <dd>
<p>The base class for implementing streaming protocols (for use with e.g. TCP and SSL transports).</p> </dd>
</dl> <dl class="class"> <dt id="asyncio.DatagramProtocol">
<code>class asyncio.DatagramProtocol</code> </dt> <dd>
<p>The base class for implementing datagram protocols (for use with e.g. UDP transports).</p> </dd>
</dl> <dl class="class"> <dt id="asyncio.SubprocessProtocol">
<code>class asyncio.SubprocessProtocol</code> </dt> <dd>
<p>The base class for implementing protocols communicating with child processes (through a set of unidirectional pipes).</p> </dd>
</dl>   <h3 id="connection-callbacks">2.2. Connection callbacks</h3> <p>These callbacks may be called on <a class="reference internal" href="#asyncio.Protocol" title="asyncio.Protocol"><code>Protocol</code></a>, <a class="reference internal" href="#asyncio.DatagramProtocol" title="asyncio.DatagramProtocol"><code>DatagramProtocol</code></a> and <a class="reference internal" href="#asyncio.SubprocessProtocol" title="asyncio.SubprocessProtocol"><code>SubprocessProtocol</code></a> instances:</p> <dl class="method"> <dt id="asyncio.BaseProtocol.connection_made">
<code>BaseProtocol.connection_made(transport)</code> </dt> <dd>
<p>Called when a connection is made.</p> <p>The <em>transport</em> argument is the transport representing the connection. You are responsible for storing it somewhere (e.g. as an attribute) if you need to.</p> </dd>
</dl> <dl class="method"> <dt id="asyncio.BaseProtocol.connection_lost">
<code>BaseProtocol.connection_lost(exc)</code> </dt> <dd>
<p>Called when the connection is lost or closed.</p> <p>The argument is either an exception object or <a class="reference internal" href="../constants/#None" title="None"><code>None</code></a>. The latter means a regular EOF is received, or the connection was aborted or closed by this side of the connection.</p> </dd>
</dl> <p><a class="reference internal" href="#asyncio.BaseProtocol.connection_made" title="asyncio.BaseProtocol.connection_made"><code>connection_made()</code></a> and <a class="reference internal" href="#asyncio.BaseProtocol.connection_lost" title="asyncio.BaseProtocol.connection_lost"><code>connection_lost()</code></a> are called exactly once per successful connection. All other callbacks will be called between those two methods, which allows for easier resource management in your protocol implementation.</p> <p>The following callbacks may be called only on <a class="reference internal" href="#asyncio.SubprocessProtocol" title="asyncio.SubprocessProtocol"><code>SubprocessProtocol</code></a> instances:</p> <dl class="method"> <dt id="asyncio.SubprocessProtocol.pipe_data_received">
<code>SubprocessProtocol.pipe_data_received(fd, data)</code> </dt> <dd>
<p>Called when the child process writes data into its stdout or stderr pipe. <em>fd</em> is the integer file descriptor of the pipe. <em>data</em> is a non-empty bytes object containing the data.</p> </dd>
</dl> <dl class="method"> <dt id="asyncio.SubprocessProtocol.pipe_connection_lost">
<code>SubprocessProtocol.pipe_connection_lost(fd, exc)</code> </dt> <dd>
<p>Called when one of the pipes communicating with the child process is closed. <em>fd</em> is the integer file descriptor that was closed.</p> </dd>
</dl> <dl class="method"> <dt id="asyncio.SubprocessProtocol.process_exited">
<code>SubprocessProtocol.process_exited()</code> </dt> <dd>
<p>Called when the child process has exited.</p> </dd>
</dl>   <h3 id="streaming-protocols">2.3. Streaming protocols</h3> <p>The following callbacks are called on <a class="reference internal" href="#asyncio.Protocol" title="asyncio.Protocol"><code>Protocol</code></a> instances:</p> <dl class="method"> <dt id="asyncio.Protocol.data_received">
<code>Protocol.data_received(data)</code> </dt> <dd>
<p>Called when some data is received. <em>data</em> is a non-empty bytes object containing the incoming data.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">Whether the data is buffered, chunked or reassembled depends on the transport. In general, you shouldn’t rely on specific semantics and instead make your parsing generic and flexible enough. However, data is always received in the correct order.</p> </div> </dd>
</dl> <dl class="method"> <dt id="asyncio.Protocol.eof_received">
<code>Protocol.eof_received()</code> </dt> <dd>
<p>Called when the other end signals it won’t send any more data (for example by calling <code>write_eof()</code>, if the other end also uses asyncio).</p> <p>This method may return a false value (including <code>None</code>), in which case the transport will close itself. Conversely, if this method returns a true value, closing the transport is up to the protocol. Since the default implementation returns <code>None</code>, it implicitly closes the connection.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">Some transports such as SSL don’t support half-closed connections, in which case returning true from this method will not prevent closing the connection.</p> </div> </dd>
</dl> <p><code>data_received()</code> can be called an arbitrary number of times during a connection. However, <code>eof_received()</code> is called at most once and, if called, <code>data_received()</code> won’t be called after it.</p> <p>State machine:</p>  start -&gt; <a class="reference internal" href="#asyncio.BaseProtocol.connection_made" title="asyncio.BaseProtocol.connection_made"><code>connection_made()</code></a> [-&gt; <a class="reference internal" href="#asyncio.Protocol.data_received" title="asyncio.Protocol.data_received"><code>data_received()</code></a> *] [-&gt; <a class="reference internal" href="#asyncio.Protocol.eof_received" title="asyncio.Protocol.eof_received"><code>eof_received()</code></a> ?] -&gt; <a class="reference internal" href="#asyncio.BaseProtocol.connection_lost" title="asyncio.BaseProtocol.connection_lost"><code>connection_lost()</code></a> -&gt; end   <h3 id="datagram-protocols">2.4. Datagram protocols</h3> <p>The following callbacks are called on <a class="reference internal" href="#asyncio.DatagramProtocol" title="asyncio.DatagramProtocol"><code>DatagramProtocol</code></a> instances.</p> <dl class="method"> <dt id="asyncio.DatagramProtocol.datagram_received">
<code>DatagramProtocol.datagram_received(data, addr)</code> </dt> <dd>
<p>Called when a datagram is received. <em>data</em> is a bytes object containing the incoming data. <em>addr</em> is the address of the peer sending the data; the exact format depends on the transport.</p> </dd>
</dl> <dl class="method"> <dt id="asyncio.DatagramProtocol.error_received">
<code>DatagramProtocol.error_received(exc)</code> </dt> <dd>
<p>Called when a previous send or receive operation raises an <a class="reference internal" href="../exceptions/#OSError" title="OSError"><code>OSError</code></a>. <em>exc</em> is the <a class="reference internal" href="../exceptions/#OSError" title="OSError"><code>OSError</code></a> instance.</p> <p>This method is called in rare conditions, when the transport (e.g. UDP) detects that a datagram couldn’t be delivered to its recipient. In many conditions though, undeliverable datagrams will be silently dropped.</p> </dd>
</dl>   <h3 id="flow-control-callbacks">2.5. Flow control callbacks</h3> <p>These callbacks may be called on <a class="reference internal" href="#asyncio.Protocol" title="asyncio.Protocol"><code>Protocol</code></a>, <a class="reference internal" href="#asyncio.DatagramProtocol" title="asyncio.DatagramProtocol"><code>DatagramProtocol</code></a> and <a class="reference internal" href="#asyncio.SubprocessProtocol" title="asyncio.SubprocessProtocol"><code>SubprocessProtocol</code></a> instances:</p> <dl class="method"> <dt id="asyncio.BaseProtocol.pause_writing">
<code>BaseProtocol.pause_writing()</code> </dt> <dd>
<p>Called when the transport’s buffer goes over the high-water mark.</p> </dd>
</dl> <dl class="method"> <dt id="asyncio.BaseProtocol.resume_writing">
<code>BaseProtocol.resume_writing()</code> </dt> <dd>
<p>Called when the transport’s buffer drains below the low-water mark.</p> </dd>
</dl> <p><code>pause_writing()</code> and <code>resume_writing()</code> calls are paired – <code>pause_writing()</code> is called once when the buffer goes strictly over the high-water mark (even if subsequent writes increases the buffer size even more), and eventually <code>resume_writing()</code> is called once when the buffer size reaches the low-water mark.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">If the buffer size equals the high-water mark, <code>pause_writing()</code> is not called – it must go strictly over. Conversely, <code>resume_writing()</code> is called when the buffer size is equal or lower than the low-water mark. These end conditions are important to ensure that things go as expected when either mark is zero.</p> </div> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">On BSD systems (OS X, FreeBSD, etc.) flow control is not supported for <a class="reference internal" href="#asyncio.DatagramProtocol" title="asyncio.DatagramProtocol"><code>DatagramProtocol</code></a>, because send failures caused by writing too many packets cannot be detected easily. The socket always appears ‘ready’ and excess packets are dropped; an <a class="reference internal" href="../exceptions/#OSError" title="OSError"><code>OSError</code></a> with errno set to <a class="reference internal" href="../errno/#errno.ENOBUFS" title="errno.ENOBUFS"><code>errno.ENOBUFS</code></a> may or may not be raised; if it is raised, it will be reported to <a class="reference internal" href="#asyncio.DatagramProtocol.error_received" title="asyncio.DatagramProtocol.error_received"><code>DatagramProtocol.error_received()</code></a> but otherwise ignored.</p> </div>   <h3 id="coroutines-and-protocols">2.6. Coroutines and protocols</h3> <p>Coroutines can be scheduled in a protocol method using <a class="reference internal" href="../asyncio-task/#asyncio.ensure_future" title="asyncio.ensure_future"><code>ensure_future()</code></a>, but there is no guarantee made about the execution order. Protocols are not aware of coroutines created in protocol methods and so will not wait for them.</p> <p>To have a reliable execution order, use <a class="reference internal" href="../asyncio-stream/#asyncio-streams"><span class="std std-ref">stream objects</span></a> in a coroutine with <code>yield from</code>. For example, the <a class="reference internal" href="../asyncio-stream/#asyncio.StreamWriter.drain" title="asyncio.StreamWriter.drain"><code>StreamWriter.drain()</code></a> coroutine can be used to wait until the write buffer is flushed.</p>    <h2 id="protocol-examples">3. Protocol examples</h2>  <h3 id="asyncio-tcp-echo-client-protocol">3.1. TCP echo client protocol</h3> <p id="tcp-echo-client-protocol">TCP echo client using the <a class="reference internal" href="../asyncio-eventloop/#asyncio.AbstractEventLoop.create_connection" title="asyncio.AbstractEventLoop.create_connection"><code>AbstractEventLoop.create_connection()</code></a> method, send data and wait until the connection is closed:</p> <pre data-language="python">import asyncio

class EchoClientProtocol(asyncio.Protocol):
    def __init__(self, message, loop):
        self.message = message
        self.loop = loop

    def connection_made(self, transport):
        transport.write(self.message.encode())
        print('Data sent: {!r}'.format(self.message))

    def data_received(self, data):
        print('Data received: {!r}'.format(data.decode()))

    def connection_lost(self, exc):
        print('The server closed the connection')
        print('Stop the event loop')
        self.loop.stop()

loop = asyncio.get_event_loop()
message = 'Hello World!'
coro = loop.create_connection(lambda: EchoClientProtocol(message, loop),
                              '127.0.0.1', 8888)
loop.run_until_complete(coro)
loop.run_forever()
loop.close()
</pre> <p>The event loop is running twice. The <a class="reference internal" href="../asyncio-eventloop/#asyncio.AbstractEventLoop.run_until_complete" title="asyncio.AbstractEventLoop.run_until_complete"><code>run_until_complete()</code></a> method is preferred in this short example to raise an exception if the server is not listening, instead of having to write a short coroutine to handle the exception and stop the running loop. At <a class="reference internal" href="../asyncio-eventloop/#asyncio.AbstractEventLoop.run_until_complete" title="asyncio.AbstractEventLoop.run_until_complete"><code>run_until_complete()</code></a> exit, the loop is no longer running, so there is no need to stop the loop in case of an error.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <p class="last">The <a class="reference internal" href="../asyncio-stream/#asyncio-tcp-echo-client-streams"><span class="std std-ref">TCP echo client using streams</span></a> example uses the <a class="reference internal" href="../asyncio-stream/#asyncio.open_connection" title="asyncio.open_connection"><code>asyncio.open_connection()</code></a> function.</p> </div>   <h3 id="asyncio-tcp-echo-server-protocol">3.2. TCP echo server protocol</h3> <p id="tcp-echo-server-protocol">TCP echo server using the <a class="reference internal" href="../asyncio-eventloop/#asyncio.AbstractEventLoop.create_server" title="asyncio.AbstractEventLoop.create_server"><code>AbstractEventLoop.create_server()</code></a> method, send back received data and close the connection:</p> <pre data-language="python">import asyncio

class EchoServerClientProtocol(asyncio.Protocol):
    def connection_made(self, transport):
        peername = transport.get_extra_info('peername')
        print('Connection from {}'.format(peername))
        self.transport = transport

    def data_received(self, data):
        message = data.decode()
        print('Data received: {!r}'.format(message))

        print('Send: {!r}'.format(message))
        self.transport.write(data)

        print('Close the client socket')
        self.transport.close()

loop = asyncio.get_event_loop()
# Each client connection will create a new protocol instance
coro = loop.create_server(EchoServerClientProtocol, '127.0.0.1', 8888)
server = loop.run_until_complete(coro)

# Serve requests until Ctrl+C is pressed
print('Serving on {}'.format(server.sockets[0].getsockname()))
try:
    loop.run_forever()
except KeyboardInterrupt:
    pass

# Close the server
server.close()
loop.run_until_complete(server.wait_closed())
loop.close()
</pre> <p><code>Transport.close()</code> can be called immediately after <a class="reference internal" href="#asyncio.WriteTransport.write" title="asyncio.WriteTransport.write"><code>WriteTransport.write()</code></a> even if data are not sent yet on the socket: both methods are asynchronous. <code>yield from</code> is not needed because these transport methods are not coroutines.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <p class="last">The <a class="reference internal" href="../asyncio-stream/#asyncio-tcp-echo-server-streams"><span class="std std-ref">TCP echo server using streams</span></a> example uses the <a class="reference internal" href="../asyncio-stream/#asyncio.start_server" title="asyncio.start_server"><code>asyncio.start_server()</code></a> function.</p> </div>   <h3 id="asyncio-udp-echo-client-protocol">3.3. UDP echo client protocol</h3> <p id="udp-echo-client-protocol">UDP echo client using the <a class="reference internal" href="../asyncio-eventloop/#asyncio.AbstractEventLoop.create_datagram_endpoint" title="asyncio.AbstractEventLoop.create_datagram_endpoint"><code>AbstractEventLoop.create_datagram_endpoint()</code></a> method, send data and close the transport when we received the answer:</p> <pre data-language="python">import asyncio

class EchoClientProtocol:
    def __init__(self, message, loop):
        self.message = message
        self.loop = loop
        self.transport = None

    def connection_made(self, transport):
        self.transport = transport
        print('Send:', self.message)
        self.transport.sendto(self.message.encode())

    def datagram_received(self, data, addr):
        print("Received:", data.decode())

        print("Close the socket")
        self.transport.close()

    def error_received(self, exc):
        print('Error received:', exc)

    def connection_lost(self, exc):
        print("Socket closed, stop the event loop")
        loop = asyncio.get_event_loop()
        loop.stop()

loop = asyncio.get_event_loop()
message = "Hello World!"
connect = loop.create_datagram_endpoint(
    lambda: EchoClientProtocol(message, loop),
    remote_addr=('127.0.0.1', 9999))
transport, protocol = loop.run_until_complete(connect)
loop.run_forever()
transport.close()
loop.close()
</pre>   <h3 id="asyncio-udp-echo-server-protocol">3.4. UDP echo server protocol</h3> <p id="udp-echo-server-protocol">UDP echo server using the <a class="reference internal" href="../asyncio-eventloop/#asyncio.AbstractEventLoop.create_datagram_endpoint" title="asyncio.AbstractEventLoop.create_datagram_endpoint"><code>AbstractEventLoop.create_datagram_endpoint()</code></a> method, send back received data:</p> <pre data-language="python">import asyncio

class EchoServerProtocol:
    def connection_made(self, transport):
        self.transport = transport

    def datagram_received(self, data, addr):
        message = data.decode()
        print('Received %r from %s' % (message, addr))
        print('Send %r to %s' % (message, addr))
        self.transport.sendto(data, addr)

loop = asyncio.get_event_loop()
print("Starting UDP server")
# One protocol instance will be created to serve all client requests
listen = loop.create_datagram_endpoint(
    EchoServerProtocol, local_addr=('127.0.0.1', 9999))
transport, protocol = loop.run_until_complete(listen)

try:
    loop.run_forever()
except KeyboardInterrupt:
    pass

transport.close()
loop.close()
</pre>   <h3 id="asyncio-register-socket">3.5. Register an open socket to wait for data using a protocol</h3> <p id="register-an-open-socket-to-wait-for-data-using-a-protocol">Wait until a socket receives data using the <a class="reference internal" href="../asyncio-eventloop/#asyncio.AbstractEventLoop.create_connection" title="asyncio.AbstractEventLoop.create_connection"><code>AbstractEventLoop.create_connection()</code></a> method with a protocol, and then close the event loop</p> <pre data-language="python">import asyncio
try:
    from socket import socketpair
except ImportError:
    from asyncio.windows_utils import socketpair

# Create a pair of connected sockets
rsock, wsock = socketpair()
loop = asyncio.get_event_loop()

class MyProtocol(asyncio.Protocol):
    transport = None

    def connection_made(self, transport):
        self.transport = transport

    def data_received(self, data):
        print("Received:", data.decode())

        # We are done: close the transport (it will call connection_lost())
        self.transport.close()

    def connection_lost(self, exc):
        # The socket has been closed, stop the event loop
        loop.stop()

# Register the socket to wait for data
connect_coro = loop.create_connection(MyProtocol, sock=rsock)
transport, protocol = loop.run_until_complete(connect_coro)

# Simulate the reception of data from the network
loop.call_soon(wsock.send, 'abc'.encode())

# Run the event loop
loop.run_forever()

# We are done, close sockets and the event loop
rsock.close()
wsock.close()
loop.close()
</pre> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <p>The <a class="reference internal" href="../asyncio-eventloop/#asyncio-watch-read-event"><span class="std std-ref">watch a file descriptor for read events</span></a> example uses the low-level <a class="reference internal" href="../asyncio-eventloop/#asyncio.AbstractEventLoop.add_reader" title="asyncio.AbstractEventLoop.add_reader"><code>AbstractEventLoop.add_reader()</code></a> method to register the file descriptor of a socket.</p> <p class="last">The <a class="reference internal" href="../asyncio-stream/#asyncio-register-socket-streams"><span class="std std-ref">register an open socket to wait for data using streams</span></a> example uses high-level streams created by the <a class="reference internal" href="../asyncio-stream/#asyncio.open_connection" title="asyncio.open_connection"><code>open_connection()</code></a> function in a coroutine.</p> </div>
<div class="_attribution">
  <p class="_attribution-p">
    © 2001–2018 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.6/library/asyncio-protocol.html" class="_attribution-link" target="_blank">https://docs.python.org/3.6/library/asyncio-protocol.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
