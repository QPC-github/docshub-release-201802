
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Measure - Scikit-image - W3cubDocs</title>
  
  <meta name="description" content=" Approximate a polygonal chain with the specified tolerance. ">
  <meta name="keywords" content="module, measure, -, scikit-image, scikit_image">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/scikit_image/api/skimage.measure/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-e0f881b0fce8cbe96f33dadc355b7159d5d2912911231446d60eb8f9caffa802.css">
  <script type="text/javascript" src="/assets/application-8fc46316434047265cd383f02b8e7f434ed7dec4a59f920dd633deef8d488d1b.js"></script>
  <script src="/json/scikit_image.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/scikit_image/" class="_nav-link" title="" style="margin-left:0;">scikit-image</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _sphinx">
				
<h1 id="module-measure">Module: measure</h1> <table class="longtable docutils" id="module-skimage.measure">   <tr>
<td>
<a class="reference internal" href="#skimage.measure.approximate_polygon" title="skimage.measure.approximate_polygon"><code>skimage.measure.approximate_polygon</code></a>(coords, …)</td> <td>Approximate a polygonal chain with the specified tolerance.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.measure.block_reduce" title="skimage.measure.block_reduce"><code>skimage.measure.block_reduce</code></a>(image, block_size)</td> <td>Down-sample image by applying function to local blocks.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.measure.compare_mse" title="skimage.measure.compare_mse"><code>skimage.measure.compare_mse</code></a>(im1, im2)</td> <td>Compute the mean-squared error between two images.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.measure.compare_nrmse" title="skimage.measure.compare_nrmse"><code>skimage.measure.compare_nrmse</code></a>(im_true, im_test)</td> <td>Compute the normalized root mean-squared error (NRMSE) between two images.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.measure.compare_psnr" title="skimage.measure.compare_psnr"><code>skimage.measure.compare_psnr</code></a>(im_true, im_test)</td> <td>Compute the peak signal to noise ratio (PSNR) for an image.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.measure.compare_ssim" title="skimage.measure.compare_ssim"><code>skimage.measure.compare_ssim</code></a>(X, Y[, …])</td> <td>Compute the mean structural similarity index between two images.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.measure.correct_mesh_orientation" title="skimage.measure.correct_mesh_orientation"><code>skimage.measure.correct_mesh_orientation</code></a>(…)</td> <td>Correct orientations of mesh faces.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.measure.find_contours" title="skimage.measure.find_contours"><code>skimage.measure.find_contours</code></a>(array, level)</td> <td>Find iso-valued contours in a 2D array for a given level value.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.measure.grid_points_in_poly" title="skimage.measure.grid_points_in_poly"><code>skimage.measure.grid_points_in_poly</code></a>(shape, verts)</td> <td>Test whether points on a specified grid are inside a polygon.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.measure.label" title="skimage.measure.label"><code>skimage.measure.label</code></a>(input[, neighbors, …])</td> <td>Label connected regions of an integer array.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.measure.marching_cubes" title="skimage.measure.marching_cubes"><code>skimage.measure.marching_cubes</code></a>(volume[, …])</td> <td>Lewiner marching cubes algorithm to find surfaces in 3d volumetric data.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.measure.marching_cubes_classic" title="skimage.measure.marching_cubes_classic"><code>skimage.measure.marching_cubes_classic</code></a>(volume)</td> <td>Classic marching cubes algorithm to find surfaces in 3d volumetric data.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.measure.marching_cubes_lewiner" title="skimage.measure.marching_cubes_lewiner"><code>skimage.measure.marching_cubes_lewiner</code></a>(volume)</td> <td>Alias for <code>marching_cubes()</code>.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.measure.mesh_surface_area" title="skimage.measure.mesh_surface_area"><code>skimage.measure.mesh_surface_area</code></a>(verts, faces)</td> <td>Compute surface area, given vertices &amp; triangular faces</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.measure.moments" title="skimage.measure.moments"><code>skimage.measure.moments</code></a>(image[, order])</td> <td>Calculate all raw image moments up to a certain order.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.measure.moments_central" title="skimage.measure.moments_central"><code>skimage.measure.moments_central</code></a>(image, cr, cc)</td> <td>Calculate all central image moments up to a certain order.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.measure.moments_hu" title="skimage.measure.moments_hu"><code>skimage.measure.moments_hu</code></a>(nu)</td> <td>Calculate Hu’s set of image moments.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.measure.moments_normalized" title="skimage.measure.moments_normalized"><code>skimage.measure.moments_normalized</code></a>(mu[, order])</td> <td>Calculate all normalized central image moments up to a certain order.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.measure.perimeter" title="skimage.measure.perimeter"><code>skimage.measure.perimeter</code></a>(image[, neighbourhood])</td> <td>Calculate total perimeter of all objects in binary image.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.measure.points_in_poly" title="skimage.measure.points_in_poly"><code>skimage.measure.points_in_poly</code></a>(points, verts)</td> <td>Test whether points lie inside a polygon.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.measure.profile_line" title="skimage.measure.profile_line"><code>skimage.measure.profile_line</code></a>(img, src, dst)</td> <td>Return the intensity profile of an image measured along a scan line.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.measure.ransac" title="skimage.measure.ransac"><code>skimage.measure.ransac</code></a>(data, model_class, …)</td> <td>Fit a model to data with the RANSAC (random sample consensus) algorithm.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.measure.regionprops" title="skimage.measure.regionprops"><code>skimage.measure.regionprops</code></a>(label_image[, …])</td> <td>Measure properties of labeled image regions.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.measure.shannon_entropy" title="skimage.measure.shannon_entropy"><code>skimage.measure.shannon_entropy</code></a>(image[, base])</td> <td>Calculate the Shannon entropy of an image.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.measure.structural_similarity" title="skimage.measure.structural_similarity"><code>skimage.measure.structural_similarity</code></a>(X, Y)</td> <td>
<strong>Deprecated function</strong>. Use <code>compare_ssim</code> instead.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.measure.subdivide_polygon" title="skimage.measure.subdivide_polygon"><code>skimage.measure.subdivide_polygon</code></a>(coords[, …])</td> <td>Subdivision of polygonal curves using B-Splines.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.measure.CircleModel" title="skimage.measure.CircleModel"><code>skimage.measure.CircleModel</code></a>()</td> <td>Total least squares estimator for 2D circles.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.measure.EllipseModel" title="skimage.measure.EllipseModel"><code>skimage.measure.EllipseModel</code></a>()</td> <td>Total least squares estimator for 2D ellipses.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.measure.LineModel" title="skimage.measure.LineModel"><code>skimage.measure.LineModel</code></a>()</td> <td>Total least squares estimator for 2D lines.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.measure.LineModelND" title="skimage.measure.LineModelND"><code>skimage.measure.LineModelND</code></a>()</td> <td>Total least squares estimator for N-dimensional lines.</td> </tr> <tr>
<td><code>skimage.measure.block</code></td> <td></td> </tr> <tr>
<td><code>skimage.measure.entropy</code></td> <td></td> </tr> <tr>
<td><code>skimage.measure.fit</code></td> <td></td> </tr> <tr>
<td><code>skimage.measure.pnpoly</code></td> <td></td> </tr> <tr>
<td><code>skimage.measure.profile</code></td> <td></td> </tr> <tr>
<td><code>skimage.measure.simple_metrics</code></td> <td></td> </tr>  </table>  <h2 id="approximate-polygon">approximate_polygon</h2> <dl class="function"> <dt id="skimage.measure.approximate_polygon">
<code>skimage.measure.approximate_polygon(coords, tolerance)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/measure/_polygon.py#L5" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Approximate a polygonal chain with the specified tolerance.</p> <p>It is based on the Douglas-Peucker algorithm.</p> <p>Note that the approximated polygon is always within the convex hull of the original polygon.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>coords</strong> : (N, 2) array</p>  <p>Coordinate array.</p>  <p><strong>tolerance</strong> : float</p>  <p>Maximum distance from original points of polygon to approximated polygonal chain. If tolerance is 0, the original coordinate array is returned.</p>  </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>coords</strong> : (M, 2) array</p>  <p>Approximated polygonal chain where M &lt;= N.</p>  </td> </tr>  </table> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="r329" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id1">[R329]</a></td>
<td><a class="reference external" href="http://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm" target="_blank">http://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm</a></td>
</tr>  </table> </dd>
</dl>   <h2 id="block-reduce">block_reduce</h2> <dl class="function"> <dt id="skimage.measure.block_reduce">
<code>skimage.measure.block_reduce(image, block_size, func=&lt;function sum&gt;, cval=0)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/measure/block.py#L5" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Down-sample image by applying function to local blocks.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>image</strong> : ndarray</p>  <p>N-dimensional input image.</p>  <p><strong>block_size</strong> : array_like</p>  <p>Array containing down-sampling integer factor along each axis.</p>  <p><strong>func</strong> : callable</p>  <p>Function object which is used to calculate the return value for each local block. This function must implement an <code>axis</code> parameter such as <code>numpy.sum</code> or <code>numpy.min</code>.</p>  <p><strong>cval</strong> : float</p>  <p>Constant padding value if image is not perfectly divisible by the block size.</p>  </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>image</strong> : ndarray</p>  <p>Down-sampled image with same number of dimensions as input image.</p>  </td> </tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage.measure import block_reduce
&gt;&gt;&gt; image = np.arange(3*3*4).reshape(3, 3, 4)
&gt;&gt;&gt; image 
array([[[ 0,  1,  2,  3],
        [ 4,  5,  6,  7],
        [ 8,  9, 10, 11]],
       [[12, 13, 14, 15],
        [16, 17, 18, 19],
        [20, 21, 22, 23]],
       [[24, 25, 26, 27],
        [28, 29, 30, 31],
        [32, 33, 34, 35]]])
&gt;&gt;&gt; block_reduce(image, block_size=(3, 3, 1), func=np.mean)
array([[[ 16.,  17.,  18.,  19.]]])
&gt;&gt;&gt; image_max1 = block_reduce(image, block_size=(1, 3, 4), func=np.max)
&gt;&gt;&gt; image_max1 
array([[[11]],
       [[23]],
       [[35]]])
&gt;&gt;&gt; image_max2 = block_reduce(image, block_size=(3, 1, 4), func=np.max)
&gt;&gt;&gt; image_max2 
array([[[27],
        [31],
        [35]]])
</pre> </dd>
</dl>   <h2 id="compare-mse">compare_mse</h2> <dl class="function"> <dt id="skimage.measure.compare_mse">
<code>skimage.measure.compare_mse(im1, im2)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/measure/simple_metrics.py#L32" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Compute the mean-squared error between two images.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>im1, im2</strong> : ndarray</p>  <p>Image. Any dimensionality.</p>  </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>mse</strong> : float</p>  <p>The mean-squared error (MSE) metric.</p>  </td> </tr>  </table> </dd>
</dl>   <h2 id="compare-nrmse">compare_nrmse</h2> <dl class="function"> <dt id="skimage.measure.compare_nrmse">
<code>skimage.measure.compare_nrmse(im_true, im_test, norm_type='Euclidean')</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/measure/simple_metrics.py#L51" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Compute the normalized root mean-squared error (NRMSE) between two images.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>im_true</strong> : ndarray</p>  <p>Ground-truth image.</p>  <p><strong>im_test</strong> : ndarray</p>  <p>Test image.</p>  <p><strong>norm_type</strong> : {‘Euclidean’, ‘min-max’, ‘mean’}</p>  <p>Controls the normalization method to use in the denominator of the NRMSE. There is no standard method of normalization across the literature <a class="reference internal" href="#r330" id="id2">[R330]</a>. The methods available here are as follows:</p> <ul class="simple"> <li>‘Euclidean’ : normalize by the Euclidean norm of <code>im_true</code>.</li> <li>‘min-max’ : normalize by the intensity range of <code>im_true</code>.</li> <li>‘mean’ : normalize by the mean of <code>im_true</code>.</li> </ul>  </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>nrmse</strong> : float</p>  <p>The NRMSE metric.</p>  </td> </tr>  </table> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="r330" rules="none">   <tr>
<td class="label">[R330]</td>
<td>
<em>(<a class="fn-backref" href="#id2">1</a>, <a class="fn-backref" href="#id3">2</a>)</em> <a class="reference external" href="https://en.wikipedia.org/wiki/Root-mean-square_deviation" target="_blank">https://en.wikipedia.org/wiki/Root-mean-square_deviation</a>
</td>
</tr>  </table> </dd>
</dl>   <h2 id="compare-psnr">compare_psnr</h2> <dl class="function"> <dt id="skimage.measure.compare_psnr">
<code>skimage.measure.compare_psnr(im_true, im_test, data_range=None, dynamic_range=None)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/measure/simple_metrics.py#L95" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Compute the peak signal to noise ratio (PSNR) for an image.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>im_true</strong> : ndarray</p>  <p>Ground-truth image.</p>  <p><strong>im_test</strong> : ndarray</p>  <p>Test image.</p>  <p><strong>data_range</strong> : int</p>  <p>The data range of the input image (distance between minimum and maximum possible values). By default, this is estimated from the image data-type.</p>  </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>psnr</strong> : float</p>  <p>The PSNR metric.</p>  </td> </tr>  </table> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="r331" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id4">[R331]</a></td>
<td><a class="reference external" href="https://en.wikipedia.org/wiki/Peak_signal-to-noise_ratio" target="_blank">https://en.wikipedia.org/wiki/Peak_signal-to-noise_ratio</a></td>
</tr>  </table> </dd>
</dl>   <h2 id="compare-ssim">compare_ssim</h2> <dl class="function"> <dt id="skimage.measure.compare_ssim">
<code>skimage.measure.compare_ssim(X, Y, win_size=None, gradient=False, data_range=None, multichannel=False, gaussian_weights=False, full=False, dynamic_range=None, **kwargs)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/measure/_structural_similarity.py#L14" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Compute the mean structural similarity index between two images.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>X, Y</strong> : ndarray</p>  <p>Image. Any dimensionality.</p>  <p><strong>win_size</strong> : int or None</p>  <p>The side-length of the sliding window used in comparison. Must be an odd value. If <code>gaussian_weights</code> is True, this is ignored and the window size will depend on <code>sigma</code>.</p>  <p><strong>gradient</strong> : bool, optional</p>  <p>If True, also return the gradient.</p>  <p><strong>data_range</strong> : int, optional</p>  <p>The data range of the input image (distance between minimum and maximum possible values). By default, this is estimated from the image data-type.</p>  <p><strong>multichannel</strong> : bool, optional</p>  <p>If True, treat the last dimension of the array as channels. Similarity calculations are done independently for each channel then averaged.</p>  <p><strong>gaussian_weights</strong> : bool, optional</p>  <p>If True, each patch has its mean and variance spatially weighted by a normalized Gaussian kernel of width sigma=1.5.</p>  <p><strong>full</strong> : bool, optional</p>  <p>If True, return the full structural similarity image instead of the mean value.</p>  </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>mssim</strong> : float</p>  <p>The mean structural similarity over the image.</p>  <p><strong>grad</strong> : ndarray</p>  <p>The gradient of the structural similarity index between X and Y <a class="reference internal" href="#r333" id="id5">[R333]</a>. This is only returned if <code>gradient</code> is set to True.</p>  <p><strong>S</strong> : ndarray</p>  <p>The full SSIM image. This is only returned if <code>full</code> is set to True.</p>  </td> </tr> <tr><th class="field-name" colspan="2">Other Parameters:</th></tr> <tr>
<td> </td>
<td class="field-body">
<p class="first"><strong>use_sample_covariance</strong> : bool</p>  <p>if True, normalize covariances by N-1 rather than, N where N is the number of pixels within the sliding window.</p>  <p><strong>K1</strong> : float</p>  <p>algorithm parameter, K1 (small constant, see <a class="reference internal" href="#r332" id="id6">[R332]</a>)</p>  <p><strong>K2</strong> : float</p>  <p>algorithm parameter, K2 (small constant, see <a class="reference internal" href="#r332" id="id7">[R332]</a>)</p>  <p><strong>sigma</strong> : float</p>  <p>sigma for the Gaussian when <code>gaussian_weights</code> is True.</p>  </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>To match the implementation of Wang et. al. <a class="reference internal" href="#r332" id="id8">[R332]</a>, set <code>gaussian_weights</code> to True, <code>sigma</code> to 1.5, and <code>use_sample_covariance</code> to False.</p> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="r332" rules="none">   <tr>
<td class="label">[R332]</td>
<td>
<em>(<a class="fn-backref" href="#id6">1</a>, <a class="fn-backref" href="#id7">2</a>, <a class="fn-backref" href="#id8">3</a>, <a class="fn-backref" href="#id9">4</a>)</em> Wang, Z., Bovik, A. C., Sheikh, H. R., &amp; Simoncelli, E. P. (2004). Image quality assessment: From error visibility to structural similarity. IEEE Transactions on Image Processing, 13, 600-612. <a class="reference external" href="https://ece.uwaterloo.ca/~z70wang/publications/ssim.pdf" target="_blank">https://ece.uwaterloo.ca/~z70wang/publications/ssim.pdf</a>, DOI:10.1.1.11.2477</td>
</tr>  </table> <table class="docutils citation" frame="void" id="r333" rules="none">   <tr>
<td class="label">[R333]</td>
<td>
<em>(<a class="fn-backref" href="#id5">1</a>, <a class="fn-backref" href="#id10">2</a>)</em> Avanaki, A. N. (2009). Exact global histogram specification optimized for structural similarity. Optical Review, 16, 613-621. <a class="reference external" href="http://arxiv.org/abs/0901.0065" target="_blank">http://arxiv.org/abs/0901.0065</a>, DOI:10.1007/s10043-009-0119-z</td>
</tr>  </table> </dd>
</dl>   <h2 id="correct-mesh-orientation">correct_mesh_orientation</h2> <dl class="function"> <dt id="skimage.measure.correct_mesh_orientation">
<code>skimage.measure.correct_mesh_orientation(volume, verts, faces, spacing=(1.0, 1.0, 1.0), gradient_direction='descent')</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/measure/_marching_cubes_classic.py#L182" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Correct orientations of mesh faces.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>volume</strong> : (M, N, P) array of doubles</p>  <p>Input data volume to find isosurfaces. Will be cast to <code>np.float64</code>.</p>  <p><strong>verts</strong> : (V, 3) array of floats</p>  <p>Array containing (x, y, z) coordinates for V unique mesh vertices.</p>  <p><strong>faces</strong> : (F, 3) array of ints</p>  <p>List of length-3 lists of integers, referencing vertex coordinates as provided in <code>verts</code>.</p>  <p><strong>spacing</strong> : length-3 tuple of floats</p>  <p>Voxel spacing in spatial dimensions corresponding to numpy array indexing dimensions (M, N, P) as in <code>volume</code>.</p>  <p><strong>gradient_direction</strong> : string</p>  <p>Controls if the mesh was generated from an isosurface with gradient descent toward objects of interest (the default), or the opposite. The two options are: * descent : Object was greater than exterior * ascent : Exterior was greater than object</p>  </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first">faces_corrected (F, 3) array of ints</p>  <p>Corrected list of faces referencing vertex coordinates in <code>verts</code>.</p>  </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <p class="last"><a class="reference internal" href="#skimage.measure.marching_cubes_classic" title="skimage.measure.marching_cubes_classic"><code>skimage.measure.marching_cubes_classic</code></a>, <a class="reference internal" href="#skimage.measure.mesh_surface_area" title="skimage.measure.mesh_surface_area"><code>skimage.measure.mesh_surface_area</code></a></p> </div> <h4 class="rubric">Notes</h4> <p>Certain applications and mesh processing algorithms require all faces to be oriented in a consistent way. Generally, this means a normal vector points “out” of the meshed shapes. This algorithm corrects the output from <code>skimage.measure.marching_cubes_classic</code> by flipping the orientation of mis-oriented faces.</p> <p>Because marching cubes could be used to find isosurfaces either on gradient descent (where the desired object has greater values than the exterior) or ascent (where the desired object has lower values than the exterior), the <code>gradient_direction</code> kwarg allows the user to inform this algorithm which is correct. If the resulting mesh appears to be oriented completely incorrectly, try changing this option.</p> <p>The arguments expected by this function are the exact outputs from <code>skimage.measure.marching_cubes_classic</code>. Only <code>faces</code> is corrected and returned, as the vertices do not change; only the order in which they are referenced.</p> <p>This algorithm assumes <code>faces</code> provided are all triangles.</p> </dd>
</dl>   <h2 id="find-contours">find_contours</h2> <dl class="function"> <dt id="skimage.measure.find_contours">
<code>skimage.measure.find_contours(array, level, fully_connected='low', positive_orientation='low')</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/measure/_find_contours.py#L9" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Find iso-valued contours in a 2D array for a given level value.</p> <p>Uses the “marching squares” method to compute a the iso-valued contours of the input 2D array for a particular level value. Array values are linearly interpolated to provide better precision for the output contours.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>array</strong> : 2D ndarray of double</p>  <p>Input data in which to find contours.</p>  <p><strong>level</strong> : float</p>  <p>Value along which to find contours in the array.</p>  <p><strong>fully_connected</strong> : str, {‘low’, ‘high’}</p>  <p>Indicates whether array elements below the given level value are to be considered fully-connected (and hence elements above the value will only be face connected), or vice-versa. (See notes below for details.)</p>  <p><strong>positive_orientation</strong> : either ‘low’ or ‘high’</p>  <p>Indicates whether the output contours will produce positively-oriented polygons around islands of low- or high-valued elements. If ‘low’ then contours will wind counter- clockwise around elements below the iso-value. Alternately, this means that low-valued elements are always on the left of the contour. (See below for details.)</p>  </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>contours</strong> : list of (n,2)-ndarrays</p>  <p>Each contour is an ndarray of shape <code>(n, 2)</code>, consisting of n <code>(row, column)</code> coordinates along the contour.</p>  </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>The marching squares algorithm is a special case of the marching cubes algorithm <a class="reference internal" href="#r334" id="id11">[R334]</a>. A simple explanation is available here:</p> <pre data-language="python">http://www.essi.fr/~lingrand/MarchingCubes/algo.html
</pre> <p>There is a single ambiguous case in the marching squares algorithm: when a given <code>2 x 2</code>-element square has two high-valued and two low-valued elements, each pair diagonally adjacent. (Where high- and low-valued is with respect to the contour value sought.) In this case, either the high-valued elements can be ‘connected together’ via a thin isthmus that separates the low-valued elements, or vice-versa. When elements are connected together across a diagonal, they are considered ‘fully connected’ (also known as ‘face+vertex-connected’ or ‘8-connected’). Only high-valued or low-valued elements can be fully-connected, the other set will be considered as ‘face-connected’ or ‘4-connected’. By default, low-valued elements are considered fully-connected; this can be altered with the ‘fully_connected’ parameter.</p> <p>Output contours are not guaranteed to be closed: contours which intersect the array edge will be left open. All other contours will be closed. (The closed-ness of a contours can be tested by checking whether the beginning point is the same as the end point.)</p> <p>Contours are oriented. By default, array values lower than the contour value are to the left of the contour and values greater than the contour value are to the right. This means that contours will wind counter-clockwise (i.e. in ‘positive orientation’) around islands of low-valued pixels. This behavior can be altered with the ‘positive_orientation’ parameter.</p> <p>The order of the contours in the output list is determined by the position of the smallest <code>x,y</code> (in lexicographical order) coordinate in the contour. This is a side-effect of how the input array is traversed, but can be relied upon.</p> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p class="last">Array coordinates/values are assumed to refer to the <em>center</em> of the array element. Take a simple example input: <code>[0, 1]</code>. The interpolated position of 0.5 in this array is midway between the 0-element (at <code>x=0</code>) and the 1-element (at <code>x=1</code>), and thus would fall at <code>x=0.5</code>.</p> </div> <p>This means that to find reasonable contours, it is best to find contours midway between the expected “light” and “dark” values. In particular, given a binarized array, <em>do not</em> choose to find contours at the low or high value of the array. This will often yield degenerate contours, especially around structures that are a single array element wide. Instead choose a middle value, as above.</p> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="r334" rules="none">   <tr>
<td class="label">[R334]</td>
<td>
<em>(<a class="fn-backref" href="#id11">1</a>, <a class="fn-backref" href="#id12">2</a>)</em> Lorensen, William and Harvey E. Cline. Marching Cubes: A High Resolution 3D Surface Construction Algorithm. Computer Graphics (SIGGRAPH 87 Proceedings) 21(4) July 1987, p. 163-170).</td>
</tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; a = np.zeros((3, 3))
&gt;&gt;&gt; a[0, 0] = 1
&gt;&gt;&gt; a
array([[ 1.,  0.,  0.],
       [ 0.,  0.,  0.],
       [ 0.,  0.,  0.]])
&gt;&gt;&gt; find_contours(a, 0.5)
[array([[ 0. ,  0.5],
       [ 0.5,  0. ]])]
</pre> </dd>
</dl>   <h2 id="grid-points-in-poly">grid_points_in_poly</h2> <dl class="function"> <dt id="skimage.measure.grid_points_in_poly">
<code>skimage.measure.grid_points_in_poly(shape, verts)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/measure/pnpoly.py#L4" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Test whether points on a specified grid are inside a polygon.</p> <p>For each <code>(r, c)</code> coordinate on a grid, i.e. <code>(0, 0)</code>, <code>(0, 1)</code> etc., test whether that point lies inside a polygon.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>shape</strong> : tuple (M, N)</p>  <p>Shape of the grid.</p>  <p><strong>verts</strong> : (V, 2) array</p>  <p>Specify the V vertices of the polygon, sorted either clockwise or anti-clockwise. The first point may (but does not need to be) duplicated.</p>  </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>mask</strong> : (M, N) ndarray of bool</p>  <p>True where the grid falls inside the polygon.</p>  </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <p class="last"><a class="reference internal" href="#skimage.measure.points_in_poly" title="skimage.measure.points_in_poly"><code>points_in_poly</code></a></p> </div> </dd>
</dl>   <h2 id="label">label</h2> <dl class="function"> <dt id="skimage.measure.label">
<code>skimage.measure.label(input, neighbors=None, background=None, return_num=False, connectivity=None)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/measure/_label.py#L4" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Label connected regions of an integer array.</p> <p>Two pixels are connected when they are neighbors and have the same value. In 2D, they can be neighbors either in a 1- or 2-connected sense. The value refers to the maximum number of orthogonal hops to consider a pixel/voxel a neighbor:</p> <pre data-language="python">1-connectivity      2-connectivity     diagonal connection close-up

     [ ]           [ ]  [ ]  [ ]         [ ]
      |               \  |  /             |  &lt;- hop 2
[ ]--[x]--[ ]      [ ]--[x]--[ ]    [x]--[ ]
      |               /  |  \         hop 1
     [ ]           [ ]  [ ]  [ ]
</pre> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>input</strong> : ndarray of dtype int</p>  <p>Image to label.</p>  <p><strong>neighbors</strong> : {4, 8}, int, optional</p>  <p>Whether to use 4- or 8-“connectivity”. In 3D, 4-“connectivity” means connected pixels have to share face, whereas with 8-“connectivity”, they have to share only edge or vertex. <strong>Deprecated, use ``connectivity`` instead.</strong></p>  <p><strong>background</strong> : int, optional</p>  <p>Consider all pixels with this value as background pixels, and label them as 0. By default, 0-valued pixels are considered as background pixels.</p>  <p><strong>return_num</strong> : bool, optional</p>  <p>Whether to return the number of assigned labels.</p>  <p><strong>connectivity</strong> : int, optional</p>  <p>Maximum number of orthogonal hops to consider a pixel/voxel as a neighbor. Accepted values are ranging from 1 to input.ndim. If <code>None</code>, a full connectivity of <code>input.ndim</code> is used.</p>  </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>labels</strong> : ndarray of dtype int</p>  <p>Labeled array, where all connected regions are assigned the same integer value.</p>  <p><strong>num</strong> : int, optional</p>  <p>Number of labels, which equals the maximum label index and is only returned if return_num is <code>True</code>.</p>  </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <p class="last"><a class="reference internal" href="#skimage.measure.regionprops" title="skimage.measure.regionprops"><code>regionprops</code></a></p> </div> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="r335" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id13">[R335]</a></td>
<td>Christophe Fiorio and Jens Gustedt, “Two linear time Union-Find strategies for image processing”, Theoretical Computer Science 154 (1996), pp. 165-181.</td>
</tr>  </table> <table class="docutils citation" frame="void" id="r336" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id14">[R336]</a></td>
<td>Kensheng Wu, Ekow Otoo and Arie Shoshani, “Optimizing connected component labeling algorithms”, Paper LBNL-56864, 2005, Lawrence Berkeley National Laboratory (University of California), <a class="reference external" href="http://repositories.cdlib.org/lbnl/LBNL-56864" target="_blank">http://repositories.cdlib.org/lbnl/LBNL-56864</a>
</td>
</tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; x = np.eye(3).astype(int)
&gt;&gt;&gt; print(x)
[[1 0 0]
 [0 1 0]
 [0 0 1]]
&gt;&gt;&gt; print(label(x, connectivity=1))
[[1 0 0]
 [0 2 0]
 [0 0 3]]
&gt;&gt;&gt; print(label(x, connectivity=2))
[[1 0 0]
 [0 1 0]
 [0 0 1]]
&gt;&gt;&gt; print(label(x, background=-1))
[[1 2 2]
 [2 1 2]
 [2 2 1]]
&gt;&gt;&gt; x = np.array([[1, 0, 0],
...               [1, 1, 5],
...               [0, 0, 0]])
&gt;&gt;&gt; print(label(x))
[[1 0 0]
 [1 1 2]
 [0 0 0]]
</pre> </dd>
</dl>   <h2 id="marching-cubes">marching_cubes</h2> <dl class="function"> <dt id="skimage.measure.marching_cubes">
<code>skimage.measure.marching_cubes(volume, level=None, spacing=(1.0, 1.0, 1.0), gradient_direction='descent', step_size=1, allow_degenerate=True, use_classic=False)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/measure/_marching_cubes_lewiner.py#L56" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Lewiner marching cubes algorithm to find surfaces in 3d volumetric data.</p> <p>In contrast to <code>marching_cubes_classic()</code>, this algorithm is faster, resolves ambiguities, and guarantees topologically correct results. Therefore, this algorithm generally a better choice, unless there is a specific need for the classic algorithm.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>volume</strong> : (M, N, P) array</p>  <p>Input data volume to find isosurfaces. Will internally be converted to float32 if necessary.</p>  <p><strong>level</strong> : float</p>  <p>Contour value to search for isosurfaces in <code>volume</code>. If not given or None, the average of the min and max of vol is used.</p>  <p><strong>spacing</strong> : length-3 tuple of floats</p>  <p>Voxel spacing in spatial dimensions corresponding to numpy array indexing dimensions (M, N, P) as in <code>volume</code>.</p>  <p><strong>gradient_direction</strong> : string</p>  <p>Controls if the mesh was generated from an isosurface with gradient descent toward objects of interest (the default), or the opposite, considering the <em>left-hand</em> rule. The two options are: * descent : Object was greater than exterior * ascent : Exterior was greater than object</p>  <p><strong>step_size</strong> : int</p>  <p>Step size in voxels. Default 1. Larger steps yield faster but coarser results. The result will always be topologically correct though.</p>  <p><strong>allow_degenerate</strong> : bool</p>  <p>Whether to allow degenerate (i.e. zero-area) triangles in the end-result. Default True. If False, degenerate triangles are removed, at the cost of making the algorithm slower.</p>  <p><strong>use_classic</strong> : bool</p>  <p>If given and True, the classic marching cubes by Lorensen (1987) is used. This option is included for reference purposes. Note that this algorithm has ambiguities and is not guaranteed to produce a topologically correct result. The results with using this option are <em>not</em> generally the same as the <code>marching_cubes_classic()</code> function.</p>  </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>verts</strong> : (V, 3) array</p>  <p>Spatial coordinates for V unique mesh vertices. Coordinate order matches input <code>volume</code> (M, N, P).</p>  <p><strong>faces</strong> : (F, 3) array</p>  <p>Define triangular faces via referencing vertex indices from <code>verts</code>. This algorithm specifically outputs triangles, so each face has exactly three indices.</p>  <p><strong>normals</strong> : (V, 3) array</p>  <p>The normal direction at each vertex, as calculated from the data.</p>  <p><strong>values</strong> : (V, ) array</p>  <p>Gives a measure for the maximum value of the data in the local region near each vertex. This can be used by visualization tools to apply a colormap to the mesh.</p>  </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <p class="last"><a class="reference internal" href="#skimage.measure.marching_cubes_classic" title="skimage.measure.marching_cubes_classic"><code>skimage.measure.marching_cubes_classic</code></a>, <a class="reference internal" href="#skimage.measure.mesh_surface_area" title="skimage.measure.mesh_surface_area"><code>skimage.measure.mesh_surface_area</code></a></p> </div> <h4 class="rubric">Notes</h4> <p>The algorithm [1] is an improved version of Chernyaev’s Marching Cubes 33 algorithm. It is an efficient algorithm that relies on heavy use of lookup tables to handle the many different cases, keeping the algorithm relatively easy. This implementation is written in Cython, ported from Lewiner’s C++ implementation.</p> <p>To quantify the area of an isosurface generated by this algorithm, pass verts and faces to <code>skimage.measure.mesh_surface_area</code>.</p> <p>Regarding visualization of algorithm output, to contour a volume named <code>myvolume</code> about the level 0.0, using the <code>mayavi</code> package:</p> <pre data-language="python">&gt;&gt;&gt; from mayavi import mlab 
&gt;&gt;&gt; verts, faces, normals, values = marching_cubes(myvolume, 0.0) 
&gt;&gt;&gt; mlab.triangular_mesh([vert[0] for vert in verts],
...                      [vert[1] for vert in verts],
...                      [vert[2] for vert in verts],
...                      faces) 
&gt;&gt;&gt; mlab.show() 
</pre> <p>Similarly using the <code>visvis</code> package:</p> <pre data-language="python">&gt;&gt;&gt; import visvis as vv 
&gt;&gt;&gt; verts, faces, normals, values = marching_cubes_classic(myvolume, 0.0) 
&gt;&gt;&gt; vv.mesh(np.fliplr(verts), faces, normals, values) 
&gt;&gt;&gt; vv.use().Run() 
</pre> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="r337" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id15">[R337]</a></td>
<td>Thomas Lewiner, Helio Lopes, Antonio Wilson Vieira and Geovan Tavares. Efficient implementation of Marching Cubes’ cases with topological guarantees. Journal of Graphics Tools 8(2) pp. 1-15 (december 2003). DOI: 10.1080/10867651.2003.10487582</td>
</tr>  </table> </dd>
</dl>   <h2 id="marching-cubes-classic">marching_cubes_classic</h2> <dl class="function"> <dt id="skimage.measure.marching_cubes_classic">
<code>skimage.measure.marching_cubes_classic(volume, level=None, spacing=(1.0, 1.0, 1.0), gradient_direction='descent')</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/measure/_marching_cubes_classic.py#L7" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Classic marching cubes algorithm to find surfaces in 3d volumetric data.</p> <p>Note that the <code>marching_cubes()</code> algorithm is recommended over this algorithm, because it’s faster and produces better results.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>volume</strong> : (M, N, P) array of doubles</p>  <p>Input data volume to find isosurfaces. Will be cast to <code>np.float64</code>.</p>  <p><strong>level</strong> : float</p>  <p>Contour value to search for isosurfaces in <code>volume</code>. If not given or None, the average of the min and max of vol is used.</p>  <p><strong>spacing</strong> : length-3 tuple of floats</p>  <p>Voxel spacing in spatial dimensions corresponding to numpy array indexing dimensions (M, N, P) as in <code>volume</code>.</p>  <p><strong>gradient_direction</strong> : string</p>  <p>Controls if the mesh was generated from an isosurface with gradient descent toward objects of interest (the default), or the opposite. The two options are: * descent : Object was greater than exterior * ascent : Exterior was greater than object</p>  </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>verts</strong> : (V, 3) array</p>  <p>Spatial coordinates for V unique mesh vertices. Coordinate order matches input <code>volume</code> (M, N, P).</p>  <p><strong>faces</strong> : (F, 3) array</p>  <p>Define triangular faces via referencing vertex indices from <code>verts</code>. This algorithm specifically outputs triangles, so each face has exactly three indices.</p>  </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <p class="last"><a class="reference internal" href="#skimage.measure.marching_cubes" title="skimage.measure.marching_cubes"><code>skimage.measure.marching_cubes</code></a>, <a class="reference internal" href="#skimage.measure.mesh_surface_area" title="skimage.measure.mesh_surface_area"><code>skimage.measure.mesh_surface_area</code></a></p> </div> <h4 class="rubric">Notes</h4> <p>The marching cubes algorithm is implemented as described in <a class="reference internal" href="#r338" id="id16">[R338]</a>. A simple explanation is available here:</p> <pre data-language="python">http://www.essi.fr/~lingrand/MarchingCubes/algo.html
</pre> <p>There are several known ambiguous cases in the marching cubes algorithm. Using point labeling as in <a class="reference internal" href="#r338" id="id17">[R338]</a>, Figure 4, as shown:</p> <pre data-language="python">    v8 ------ v7
   / |       / |        y
  /  |      /  |        ^  z
v4 ------ v3   |        | /
 |  v5 ----|- v6        |/          (note: NOT right handed!)
 |  /      |  /          ----&gt; x
 | /       | /
v1 ------ v2
</pre> <p>Most notably, if v4, v8, v2, and v6 are all &gt;= <code>level</code> (or any generalization of this case) two parallel planes are generated by this algorithm, separating v4 and v8 from v2 and v6. An equally valid interpretation would be a single connected thin surface enclosing all four points. This is the best known ambiguity, though there are others.</p> <p>This algorithm does not attempt to resolve such ambiguities; it is a naive implementation of marching cubes as in <a class="reference internal" href="#r338" id="id18">[R338]</a>, but may be a good beginning for work with more recent techniques (Dual Marching Cubes, Extended Marching Cubes, Cubic Marching Squares, etc.).</p> <p>Because of interactions between neighboring cubes, the isosurface(s) generated by this algorithm are NOT guaranteed to be closed, particularly for complicated contours. Furthermore, this algorithm does not guarantee a single contour will be returned. Indeed, ALL isosurfaces which cross <code>level</code> will be found, regardless of connectivity.</p> <p>The output is a triangular mesh consisting of a set of unique vertices and connecting triangles. The order of these vertices and triangles in the output list is determined by the position of the smallest <code>x,y,z</code> (in lexicographical order) coordinate in the contour. This is a side-effect of how the input array is traversed, but can be relied upon.</p> <p>The generated mesh guarantees coherent orientation as of version 0.12.</p> <p>To quantify the area of an isosurface generated by this algorithm, pass outputs directly into <code>skimage.measure.mesh_surface_area</code>.</p> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="r338" rules="none">   <tr>
<td class="label">[R338]</td>
<td>
<em>(<a class="fn-backref" href="#id16">1</a>, <a class="fn-backref" href="#id17">2</a>, <a class="fn-backref" href="#id18">3</a>, <a class="fn-backref" href="#id19">4</a>)</em> Lorensen, William and Harvey E. Cline. Marching Cubes: A High Resolution 3D Surface Construction Algorithm. Computer Graphics (SIGGRAPH 87 Proceedings) 21(4) July 1987, p. 163-170). DOI: 10.1145/37401.37422</td>
</tr>  </table> </dd>
</dl>   <h2 id="marching-cubes-lewiner">marching_cubes_lewiner</h2> <dl class="function"> <dt id="skimage.measure.marching_cubes_lewiner">
<code>skimage.measure.marching_cubes_lewiner(volume, level=None, spacing=(1.0, 1.0, 1.0), gradient_direction='descent', step_size=1, allow_degenerate=True, use_classic=False)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/measure/_marching_cubes_lewiner.py#L179" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Alias for <code>marching_cubes()</code>.</p> </dd>
</dl>   <h2 id="mesh-surface-area">mesh_surface_area</h2> <dl class="function"> <dt id="skimage.measure.mesh_surface_area">
<code>skimage.measure.mesh_surface_area(verts, faces)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/measure/_marching_cubes_classic.py#L139" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Compute surface area, given vertices &amp; triangular faces</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>verts</strong> : (V, 3) array of floats</p>  <p>Array containing (x, y, z) coordinates for V unique mesh vertices.</p>  <p><strong>faces</strong> : (F, 3) array of ints</p>  <p>List of length-3 lists of integers, referencing vertex coordinates as provided in <code>verts</code></p>  </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>area</strong> : float</p>  <p>Surface area of mesh. Units now [coordinate units] ** 2.</p>  </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <p class="last"><a class="reference internal" href="#skimage.measure.marching_cubes" title="skimage.measure.marching_cubes"><code>skimage.measure.marching_cubes</code></a>, <a class="reference internal" href="#skimage.measure.marching_cubes_classic" title="skimage.measure.marching_cubes_classic"><code>skimage.measure.marching_cubes_classic</code></a>, <a class="reference internal" href="#skimage.measure.correct_mesh_orientation" title="skimage.measure.correct_mesh_orientation"><code>skimage.measure.correct_mesh_orientation</code></a></p> </div> <h4 class="rubric">Notes</h4> <p>The arguments expected by this function are the first two outputs from <code>skimage.measure.marching_cubes</code>. For unit correct output, ensure correct <code>spacing</code> was passed to <code>skimage.measure.marching_cubes</code>.</p> <p>This algorithm works properly only if the <code>faces</code> provided are all triangles.</p> </dd>
</dl>   <h2 id="moments">moments</h2> <dl class="function"> <dt id="skimage.measure.moments">
<code>skimage.measure.moments(image, order=3)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/measure/_moments.py#L6" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Calculate all raw image moments up to a certain order.</p> <dl class="docutils"> <dt>The following properties can be calculated from raw image moments:</dt> <dd>
<ul class="first last simple"> <li>Area as: <code>m[0, 0]</code>.</li> <li>Centroid as: {<code>m[0, 1] / m[0, 0]</code>, <code>m[1, 0] / m[0, 0]</code>}.</li> </ul> </dd> </dl> <p>Note that raw moments are neither translation, scale nor rotation invariant.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>image</strong> : 2D double or uint8 array</p>  <p>Rasterized shape as image.</p>  <p><strong>order</strong> : int, optional</p>  <p>Maximum order of moments. Default is 3.</p>  </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>m</strong> : (<code>order + 1</code>, <code>order + 1</code>) array</p>  <p>Raw image moments.</p>  </td> </tr>  </table> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="r339" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id20">[R339]</a></td>
<td>Wilhelm Burger, Mark Burge. Principles of Digital Image Processing: Core Algorithms. Springer-Verlag, London, 2009.</td>
</tr>  </table> <table class="docutils citation" frame="void" id="r340" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id21">[R340]</a></td>
<td>B. Jähne. Digital Image Processing. Springer-Verlag, Berlin-Heidelberg, 6. edition, 2005.</td>
</tr>  </table> <table class="docutils citation" frame="void" id="r341" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id22">[R341]</a></td>
<td>T. H. Reiss. Recognizing Planar Objects Using Invariant Image Features, from Lecture notes in computer science, p. 676. Springer, Berlin, 1993.</td>
</tr>  </table> <table class="docutils citation" frame="void" id="r342" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id23">[R342]</a></td>
<td><a class="reference external" href="http://en.wikipedia.org/wiki/Image_moment" target="_blank">http://en.wikipedia.org/wiki/Image_moment</a></td>
</tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; image = np.zeros((20, 20), dtype=np.double)
&gt;&gt;&gt; image[13:17, 13:17] = 1
&gt;&gt;&gt; m = moments(image)
&gt;&gt;&gt; cr = m[0, 1] / m[0, 0]
&gt;&gt;&gt; cc = m[1, 0] / m[0, 0]
&gt;&gt;&gt; cr, cc
(14.5, 14.5)
</pre> </dd>
</dl>   <h2 id="moments-central">moments_central</h2> <dl class="function"> <dt id="skimage.measure.moments_central">
<code>skimage.measure.moments_central(image, cr, cc, order=3)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/measure/_moments.py#L53" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Calculate all central image moments up to a certain order.</p> <p>The center coordinates (cr, cc) can be calculated from the raw moments as: {<code>m[0, 1] / m[0, 0]</code>, <code>m[1, 0] / m[0, 0]</code>}.</p> <p>Note that central moments are translation invariant but not scale and rotation invariant.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>image</strong> : 2D double or uint8 array</p>  <p>Rasterized shape as image.</p>  <p><strong>cr</strong> : double</p>  <p>Center row coordinate.</p>  <p><strong>cc</strong> : double</p>  <p>Center column coordinate.</p>  <p><strong>order</strong> : int, optional</p>  <p>Maximum order of moments. Default is 3.</p>  </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>mu</strong> : (<code>order + 1</code>, <code>order + 1</code>) array</p>  <p>Central image moments.</p>  </td> </tr>  </table> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="r343" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id24">[R343]</a></td>
<td>Wilhelm Burger, Mark Burge. Principles of Digital Image Processing: Core Algorithms. Springer-Verlag, London, 2009.</td>
</tr>  </table> <table class="docutils citation" frame="void" id="r344" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id25">[R344]</a></td>
<td>B. Jähne. Digital Image Processing. Springer-Verlag, Berlin-Heidelberg, 6. edition, 2005.</td>
</tr>  </table> <table class="docutils citation" frame="void" id="r345" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id26">[R345]</a></td>
<td>T. H. Reiss. Recognizing Planar Objects Using Invariant Image Features, from Lecture notes in computer science, p. 676. Springer, Berlin, 1993.</td>
</tr>  </table> <table class="docutils citation" frame="void" id="r346" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id27">[R346]</a></td>
<td><a class="reference external" href="http://en.wikipedia.org/wiki/Image_moment" target="_blank">http://en.wikipedia.org/wiki/Image_moment</a></td>
</tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; image = np.zeros((20, 20), dtype=np.double)
&gt;&gt;&gt; image[13:17, 13:17] = 1
&gt;&gt;&gt; m = moments(image)
&gt;&gt;&gt; cr = m[0, 1] / m[0, 0]
&gt;&gt;&gt; cc = m[1, 0] / m[0, 0]
&gt;&gt;&gt; moments_central(image, cr, cc)
array([[ 16.,   0.,  20.,   0.],
       [  0.,   0.,   0.,   0.],
       [ 20.,   0.,  25.,   0.],
       [  0.,   0.,   0.,   0.]])
</pre> </dd>
</dl>   <h2 id="moments-hu">moments_hu</h2> <dl class="function"> <dt id="skimage.measure.moments_hu">
<code>skimage.measure.moments_hu(nu)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/measure/_moments.py#L157" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Calculate Hu’s set of image moments.</p> <p>Note that this set of moments is proofed to be translation, scale and rotation invariant.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>nu</strong> : (M, M) array</p>  <p>Normalized central image moments, where M must be &gt; 4.</p>  </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>nu</strong> : (7, 1) array</p>  <p>Hu’s set of image moments.</p>  </td> </tr>  </table> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="r347" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id28">[R347]</a></td>
<td>M. K. Hu, “Visual Pattern Recognition by Moment Invariants”, IRE Trans. Info. Theory, vol. IT-8, pp. 179-187, 1962</td>
</tr>  </table> <table class="docutils citation" frame="void" id="r348" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id29">[R348]</a></td>
<td>Wilhelm Burger, Mark Burge. Principles of Digital Image Processing: Core Algorithms. Springer-Verlag, London, 2009.</td>
</tr>  </table> <table class="docutils citation" frame="void" id="r349" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id30">[R349]</a></td>
<td>B. Jähne. Digital Image Processing. Springer-Verlag, Berlin-Heidelberg, 6. edition, 2005.</td>
</tr>  </table> <table class="docutils citation" frame="void" id="r350" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id31">[R350]</a></td>
<td>T. H. Reiss. Recognizing Planar Objects Using Invariant Image Features, from Lecture notes in computer science, p. 676. Springer, Berlin, 1993.</td>
</tr>  </table> <table class="docutils citation" frame="void" id="r351" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id32">[R351]</a></td>
<td><a class="reference external" href="http://en.wikipedia.org/wiki/Image_moment" target="_blank">http://en.wikipedia.org/wiki/Image_moment</a></td>
</tr>  </table> </dd>
</dl>   <h2 id="moments-normalized">moments_normalized</h2> <dl class="function"> <dt id="skimage.measure.moments_normalized">
<code>skimage.measure.moments_normalized(mu, order=3)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/measure/_moments.py#L106" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Calculate all normalized central image moments up to a certain order.</p> <p>Note that normalized central moments are translation and scale invariant but not rotation invariant.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>mu</strong> : (M, M) array</p>  <p>Central image moments, where M must be &gt; <code>order</code>.</p>  <p><strong>order</strong> : int, optional</p>  <p>Maximum order of moments. Default is 3.</p>  </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>nu</strong> : (<code>order + 1</code>, <code>order + 1</code>) array</p>  <p>Normalized central image moments.</p>  </td> </tr>  </table> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="r352" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id33">[R352]</a></td>
<td>Wilhelm Burger, Mark Burge. Principles of Digital Image Processing: Core Algorithms. Springer-Verlag, London, 2009.</td>
</tr>  </table> <table class="docutils citation" frame="void" id="r353" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id34">[R353]</a></td>
<td>B. Jähne. Digital Image Processing. Springer-Verlag, Berlin-Heidelberg, 6. edition, 2005.</td>
</tr>  </table> <table class="docutils citation" frame="void" id="r354" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id35">[R354]</a></td>
<td>T. H. Reiss. Recognizing Planar Objects Using Invariant Image Features, from Lecture notes in computer science, p. 676. Springer, Berlin, 1993.</td>
</tr>  </table> <table class="docutils citation" frame="void" id="r355" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id36">[R355]</a></td>
<td><a class="reference external" href="http://en.wikipedia.org/wiki/Image_moment" target="_blank">http://en.wikipedia.org/wiki/Image_moment</a></td>
</tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; image = np.zeros((20, 20), dtype=np.double)
&gt;&gt;&gt; image[13:17, 13:17] = 1
&gt;&gt;&gt; m = moments(image)
&gt;&gt;&gt; cr = m[0, 1] / m[0, 0]
&gt;&gt;&gt; cc = m[1, 0] / m[0, 0]
&gt;&gt;&gt; mu = moments_central(image, cr, cc)
&gt;&gt;&gt; moments_normalized(mu)
array([[        nan,         nan,  0.078125  ,  0.        ],
       [        nan,  0.        ,  0.        ,  0.        ],
       [ 0.078125  ,  0.        ,  0.00610352,  0.        ],
       [ 0.        ,  0.        ,  0.        ,  0.        ]])
</pre> </dd>
</dl>   <h2 id="perimeter">perimeter</h2> <dl class="function"> <dt id="skimage.measure.perimeter">
<code>skimage.measure.perimeter(image, neighbourhood=4)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/measure/_regionprops.py#L557" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Calculate total perimeter of all objects in binary image.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>image</strong> : array</p>  <p>Binary image.</p>  <p><strong>neighbourhood</strong> : 4 or 8, optional</p>  <p>Neighborhood connectivity for border pixel determination.</p>  </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>perimeter</strong> : float</p>  <p>Total perimeter of all objects in binary image.</p>  </td> </tr>  </table> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="r356" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id37">[R356]</a></td>
<td>K. Benkrid, D. Crookes. Design and FPGA Implementation of a Perimeter Estimator. The Queen’s University of Belfast. <a class="reference external" href="http://www.cs.qub.ac.uk/~d.crookes/webpubs/papers/perimeter.doc" target="_blank">http://www.cs.qub.ac.uk/~d.crookes/webpubs/papers/perimeter.doc</a>
</td>
</tr>  </table> </dd>
</dl>   <h2 id="points-in-poly">points_in_poly</h2> <dl class="function"> <dt id="skimage.measure.points_in_poly">
<code>skimage.measure.points_in_poly(points, verts)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/measure/pnpoly.py#L32" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Test whether points lie inside a polygon.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>points</strong> : (N, 2) array</p>  <p>Input points, <code>(x, y)</code>.</p>  <p><strong>verts</strong> : (M, 2) array</p>  <p>Vertices of the polygon, sorted either clockwise or anti-clockwise. The first point may (but does not need to be) duplicated.</p>  </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>mask</strong> : (N,) array of bool</p>  <p>True if corresponding point is inside the polygon.</p>  </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <p class="last"><a class="reference internal" href="#skimage.measure.grid_points_in_poly" title="skimage.measure.grid_points_in_poly"><code>grid_points_in_poly</code></a></p> </div> </dd>
</dl>   <h2 id="profile-line">profile_line</h2> <dl class="function"> <dt id="skimage.measure.profile_line">
<code>skimage.measure.profile_line(img, src, dst, linewidth=1, order=1, mode='constant', cval=0.0)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/measure/profile.py#L5" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return the intensity profile of an image measured along a scan line.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>img</strong> : numeric array, shape (M, N[, C])</p>  <p>The image, either grayscale (2D array) or multichannel (3D array, where the final axis contains the channel information).</p>  <p><strong>src</strong> : 2-tuple of numeric scalar (float or int)</p>  <p>The start point of the scan line.</p>  <p><strong>dst</strong> : 2-tuple of numeric scalar (float or int)</p>  <p>The end point of the scan line. The destination point is <em>included</em> in the profile, in constrast to standard numpy indexing.</p>  <p><strong>linewidth</strong> : int, optional</p>  <p>Width of the scan, perpendicular to the line</p>  <p><strong>order</strong> : int in {0, 1, 2, 3, 4, 5}, optional</p>  <p>The order of the spline interpolation to compute image values at non-integer coordinates. 0 means nearest-neighbor interpolation.</p>  <p><strong>mode</strong> : {‘constant’, ‘nearest’, ‘reflect’, ‘mirror’, ‘wrap’}, optional</p>  <p>How to compute any values falling outside of the image.</p>  <p><strong>cval</strong> : float, optional</p>  <p>If <code>mode</code> is ‘constant’, what constant value to use outside the image.</p>  </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>return_value</strong> : array</p>  <p>The intensity profile along the scan line. The length of the profile is the ceil of the computed length of the scan line.</p>  </td> </tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; x = np.array([[1, 1, 1, 2, 2, 2]])
&gt;&gt;&gt; img = np.vstack([np.zeros_like(x), x, x, x, np.zeros_like(x)])
&gt;&gt;&gt; img
array([[0, 0, 0, 0, 0, 0],
       [1, 1, 1, 2, 2, 2],
       [1, 1, 1, 2, 2, 2],
       [1, 1, 1, 2, 2, 2],
       [0, 0, 0, 0, 0, 0]])
&gt;&gt;&gt; profile_line(img, (2, 1), (2, 4))
array([ 1.,  1.,  2.,  2.])
&gt;&gt;&gt; profile_line(img, (1, 0), (1, 6), cval=4)
array([ 1.,  1.,  1.,  2.,  2.,  2.,  4.])
</pre> <p>The destination point is included in the profile, in contrast to standard numpy indexing. For example: &gt;&gt;&gt; profile_line(img, (1, 0), (1, 6)) # The final point is out of bounds array([ 1., 1., 1., 2., 2., 2., 0.]) &gt;&gt;&gt; profile_line(img, (1, 0), (1, 5)) # This accesses the full first row array([ 1., 1., 1., 2., 2., 2.])</p> </dd>
</dl>   <h2 id="ransac">ransac</h2> <dl class="function"> <dt id="skimage.measure.ransac">
<code>skimage.measure.ransac(data, model_class, min_samples, residual_threshold, is_data_valid=None, is_model_valid=None, max_trials=100, stop_sample_num=inf, stop_residuals_sum=0, stop_probability=1, random_state=None)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/measure/fit.py#L719" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Fit a model to data with the RANSAC (random sample consensus) algorithm.</p> <p>RANSAC is an iterative algorithm for the robust estimation of parameters from a subset of inliers from the complete data set. Each iteration performs the following tasks:</p> <ol class="arabic simple"> <li>Select <code>min_samples</code> random samples from the original data and check whether the set of data is valid (see <code>is_data_valid</code>).</li> <li>Estimate a model to the random subset (<code>model_cls.estimate(*data[random_subset]</code>) and check whether the estimated model is valid (see <code>is_model_valid</code>).</li> <li>Classify all data as inliers or outliers by calculating the residuals to the estimated model (<code>model_cls.residuals(*data)</code>) - all data samples with residuals smaller than the <code>residual_threshold</code> are considered as inliers.</li> <li>Save estimated model as best model if number of inlier samples is maximal. In case the current estimated model has the same number of inliers, it is only considered as the best model if it has less sum of residuals.</li> </ol> <p>These steps are performed either a maximum number of times or until one of the special stop criteria are met. The final model is estimated using all inlier samples of the previously determined best model.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>data</strong> : [list, tuple of] (N, D) array</p>  <p>Data set to which the model is fitted, where N is the number of data points and D the dimensionality of the data. If the model class requires multiple input data arrays (e.g. source and destination coordinates of <code>skimage.transform.AffineTransform</code>), they can be optionally passed as tuple or list. Note, that in this case the functions <code>estimate(*data)</code>, <code>residuals(*data)</code>, <code>is_model_valid(model, *random_data)</code> and <code>is_data_valid(*random_data)</code> must all take each data array as separate arguments.</p>  <p><strong>model_class</strong> : object</p>  <p>Object with the following object methods:</p>  <ul class="simple"> <li><code>success = estimate(*data)</code></li> <li><code>residuals(*data)</code></li> </ul>  <p>where <code>success</code> indicates whether the model estimation succeeded (<code>True</code> or <code>None</code> for success, <code>False</code> for failure).</p>  <p><strong>min_samples</strong> : int</p>  <p>The minimum number of data points to fit a model to.</p>  <p><strong>residual_threshold</strong> : float</p>  <p>Maximum distance for a data point to be classified as an inlier.</p>  <p><strong>is_data_valid</strong> : function, optional</p>  <p>This function is called with the randomly selected data before the model is fitted to it: <code>is_data_valid(*random_data)</code>.</p>  <p><strong>is_model_valid</strong> : function, optional</p>  <p>This function is called with the estimated model and the randomly selected data: <code>is_model_valid(model, *random_data)</code>, .</p>  <p><strong>max_trials</strong> : int, optional</p>  <p>Maximum number of iterations for random sample selection.</p>  <p><strong>stop_sample_num</strong> : int, optional</p>  <p>Stop iteration if at least this number of inliers are found.</p>  <p><strong>stop_residuals_sum</strong> : float, optional</p>  <p>Stop iteration if sum of residuals is less than or equal to this threshold.</p>  <p><strong>stop_probability</strong> : float in range [0, 1], optional</p>  <p>RANSAC iteration stops if at least one outlier-free set of the training data is sampled with <code>probability &gt;= stop_probability</code>, depending on the current best model’s inlier ratio and the number of trials. This requires to generate at least N samples (trials):</p>  <p>N &gt;= log(1 - probability) / log(1 - e**m)</p>  <p>where the probability (confidence) is typically set to a high value such as 0.99, and e is the current fraction of inliers w.r.t. the total number of samples.</p>  <p><strong>random_state</strong> : int, RandomState instance or None, optional</p>  <p>If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by <code>np.random</code>.</p>  </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>model</strong> : object</p>  <p>Best model with largest consensus set.</p>  <p><strong>inliers</strong> : (N, ) array</p>  <p>Boolean mask of inliers classified as <code>True</code>.</p>  </td> </tr>  </table> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="r357" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id38">[R357]</a></td>
<td>“RANSAC”, Wikipedia, <a class="reference external" href="http://en.wikipedia.org/wiki/RANSAC" target="_blank">http://en.wikipedia.org/wiki/RANSAC</a>
</td>
</tr>  </table> <h4 class="rubric">Examples</h4> <p>Generate ellipse data without tilt and add noise:</p> <pre data-language="python">&gt;&gt;&gt; t = np.linspace(0, 2 * np.pi, 50)
&gt;&gt;&gt; xc, yc = 20, 30
&gt;&gt;&gt; a, b = 5, 10
&gt;&gt;&gt; x = xc + a * np.cos(t)
&gt;&gt;&gt; y = yc + b * np.sin(t)
&gt;&gt;&gt; data = np.column_stack([x, y])
&gt;&gt;&gt; np.random.seed(seed=1234)
&gt;&gt;&gt; data += np.random.normal(size=data.shape)
</pre> <p>Add some faulty data:</p> <pre data-language="python">&gt;&gt;&gt; data[0] = (100, 100)
&gt;&gt;&gt; data[1] = (110, 120)
&gt;&gt;&gt; data[2] = (120, 130)
&gt;&gt;&gt; data[3] = (140, 130)
</pre> <p>Estimate ellipse model using all available data:</p> <pre data-language="python">&gt;&gt;&gt; model = EllipseModel()
&gt;&gt;&gt; model.estimate(data)
True
&gt;&gt;&gt; np.round(model.params)  
array([ 72.,  75.,  77.,  14.,   1.])
</pre> <p>Estimate ellipse model using RANSAC:</p> <pre data-language="python">&gt;&gt;&gt; ransac_model, inliers = ransac(data, EllipseModel, 20, 3, max_trials=50)
&gt;&gt;&gt; abs(np.round(ransac_model.params))
array([ 20.,  30.,   5.,  10.,   0.])
&gt;&gt;&gt; inliers 
array([False, False, False, False,  True,  True,  True,  True,  True,
        True,  True,  True,  True,  True,  True,  True,  True,  True,
        True,  True,  True,  True,  True,  True,  True,  True,  True,
        True,  True,  True,  True,  True,  True,  True,  True,  True,
        True,  True,  True,  True,  True,  True,  True,  True,  True,
        True,  True,  True,  True,  True], dtype=bool)
&gt;&gt;&gt; sum(inliers) &gt; 40
True
</pre> <p>Robustly estimate geometric transformation:</p> <pre data-language="python">&gt;&gt;&gt; from skimage.transform import SimilarityTransform
&gt;&gt;&gt; np.random.seed(0)
&gt;&gt;&gt; src = 100 * np.random.rand(50, 2)
&gt;&gt;&gt; model0 = SimilarityTransform(scale=0.5, rotation=1,
...                              translation=(10, 20))
&gt;&gt;&gt; dst = model0(src)
&gt;&gt;&gt; dst[0] = (10000, 10000)
&gt;&gt;&gt; dst[1] = (-100, 100)
&gt;&gt;&gt; dst[2] = (50, 50)
&gt;&gt;&gt; model, inliers = ransac((src, dst), SimilarityTransform, 2, 10)
&gt;&gt;&gt; inliers
array([False, False, False,  True,  True,  True,  True,  True,  True,
        True,  True,  True,  True,  True,  True,  True,  True,  True,
        True,  True,  True,  True,  True,  True,  True,  True,  True,
        True,  True,  True,  True,  True,  True,  True,  True,  True,
        True,  True,  True,  True,  True,  True,  True,  True,  True,
        True,  True,  True,  True,  True], dtype=bool)
</pre> </dd>
</dl>   <h2 id="regionprops">regionprops</h2> <dl class="function"> <dt id="skimage.measure.regionprops">
<code>skimage.measure.regionprops(label_image, intensity_image=None, cache=True)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/measure/_regionprops.py#L350" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Measure properties of labeled image regions.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>label_image</strong> : (N, M) ndarray</p>  <p>Labeled input image. Labels with value 0 are ignored.</p>  <p><strong>intensity_image</strong> : (N, M) ndarray, optional</p>  <p>Intensity (i.e., input) image with same size as labeled image. Default is None.</p>  <p><strong>cache</strong> : bool, optional</p>  <p>Determine whether to cache calculated properties. The computation is much faster for cached properties, whereas the memory consumption increases.</p>  </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>properties</strong> : list of RegionProperties</p>  <p>Each item describes one labeled region, and can be accessed using the attributes listed below.</p>  </td> </tr>  </table> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <p class="last"><a class="reference internal" href="#skimage.measure.label" title="skimage.measure.label"><code>label</code></a></p> </div> <h4 class="rubric">Notes</h4> <p>The following properties can be accessed as attributes or keys:</p> <dl class="docutils"> <dt>
<code>area : int</code> </dt> <dd>Number of pixels of region.</dd> <dt>
<code>bbox : tuple</code> </dt> <dd>Bounding box <code>(min_row, min_col, max_row, max_col)</code>. Pixels belonging to the bounding box are in the half-open interval <code>[min_row; max_row)</code> and <code>[min_col; max_col)</code>.</dd> <dt>
<code>bbox_area : int</code> </dt> <dd>Number of pixels of bounding box.</dd> <dt>
<code>centroid : array</code> </dt> <dd>Centroid coordinate tuple <code>(row, col)</code>.</dd> <dt>
<code>convex_area : int</code> </dt> <dd>Number of pixels of convex hull image.</dd> <dt>
<code>convex_image : (H, J) ndarray</code> </dt> <dd>Binary convex hull image which has the same size as bounding box.</dd> <dt>
<code>coords : (N, 2) ndarray</code> </dt> <dd>Coordinate list <code>(row, col)</code> of the region.</dd> <dt>
<code>eccentricity : float</code> </dt> <dd>Eccentricity of the ellipse that has the same second-moments as the region. The eccentricity is the ratio of the focal distance (distance between focal points) over the major axis length. The value is in the interval [0, 1). When it is 0, the ellipse becomes a circle.</dd> <dt>
<code>equivalent_diameter : float</code> </dt> <dd>The diameter of a circle with the same area as the region.</dd> <dt>
<code>euler_number : int</code> </dt> <dd>Euler characteristic of region. Computed as number of objects (= 1) subtracted by number of holes (8-connectivity).</dd> <dt>
<code>extent : float</code> </dt> <dd>Ratio of pixels in the region to pixels in the total bounding box. Computed as <code>area / (rows * cols)</code>
</dd> <dt>
<code>filled_area : int</code> </dt> <dd>Number of pixels of filled region.</dd> <dt>
<code>filled_image : (H, J) ndarray</code> </dt> <dd>Binary region image with filled holes which has the same size as bounding box.</dd> <dt>
<code>image : (H, J) ndarray</code> </dt> <dd>Sliced binary region image which has the same size as bounding box.</dd> <dt>
<code>inertia_tensor : (2, 2) ndarray</code> </dt> <dd>Inertia tensor of the region for the rotation around its mass.</dd> <dt>
<code>inertia_tensor_eigvals : tuple</code> </dt> <dd>The two eigen values of the inertia tensor in decreasing order.</dd> <dt>
<code>intensity_image : ndarray</code> </dt> <dd>Image inside region bounding box.</dd> <dt>
<code>label : int</code> </dt> <dd>The label in the labeled input image.</dd> <dt>
<code>local_centroid : array</code> </dt> <dd>Centroid coordinate tuple <code>(row, col)</code>, relative to region bounding box.</dd> <dt>
<code>major_axis_length : float</code> </dt> <dd>The length of the major axis of the ellipse that has the same normalized second central moments as the region.</dd> <dt>
<code>max_intensity : float</code> </dt> <dd>Value with the greatest intensity in the region.</dd> <dt>
<code>mean_intensity : float</code> </dt> <dd>Value with the mean intensity in the region.</dd> <dt>
<code>min_intensity : float</code> </dt> <dd>Value with the least intensity in the region.</dd> <dt>
<code>minor_axis_length : float</code> </dt> <dd>The length of the minor axis of the ellipse that has the same normalized second central moments as the region.</dd> <dt>
<code>moments : (3, 3) ndarray</code> </dt> <dd>
<p class="first">Spatial moments up to 3rd order:</p> <pre data-language="python">m_ji = sum{ array(x, y) * x^j * y^i }
</pre> <p class="last">where the sum is over the <code>x</code>, <code>y</code> coordinates of the region.</p> </dd> <dt>
<code>moments_central : (3, 3) ndarray</code> </dt> <dd>
<p class="first">Central moments (translation invariant) up to 3rd order:</p> <pre data-language="python">mu_ji = sum{ array(x, y) * (x - x_c)^j * (y - y_c)^i }
</pre> <p class="last">where the sum is over the <code>x</code>, <code>y</code> coordinates of the region, and <code>x_c</code> and <code>y_c</code> are the coordinates of the region’s centroid.</p> </dd> <dt>
<code>moments_hu : tuple</code> </dt> <dd>Hu moments (translation, scale and rotation invariant).</dd> <dt>
<code>moments_normalized : (3, 3) ndarray</code> </dt> <dd>
<p class="first">Normalized moments (translation and scale invariant) up to 3rd order:</p> <pre data-language="python">nu_ji = mu_ji / m_00^[(i+j)/2 + 1]
</pre> <p class="last">where <code>m_00</code> is the zeroth spatial moment.</p> </dd> <dt>
<code>orientation : float</code> </dt> <dd>Angle between the X-axis and the major axis of the ellipse that has the same second-moments as the region. Ranging from <code>-pi/2</code> to <code>pi/2</code> in counter-clockwise direction.</dd> <dt>
<code>perimeter : float</code> </dt> <dd>Perimeter of object which approximates the contour as a line through the centers of border pixels using a 4-connectivity.</dd> <dt>
<code>solidity : float</code> </dt> <dd>Ratio of pixels in the region to pixels of the convex hull image.</dd> <dt>
<code>weighted_centroid : array</code> </dt> <dd>Centroid coordinate tuple <code>(row, col)</code> weighted with intensity image.</dd> <dt>
<code>weighted_local_centroid : array</code> </dt> <dd>Centroid coordinate tuple <code>(row, col)</code>, relative to region bounding box, weighted with intensity image.</dd> <dt>
<code>weighted_moments : (3, 3) ndarray</code> </dt> <dd>
<p class="first">Spatial moments of intensity image up to 3rd order:</p> <pre data-language="python">wm_ji = sum{ array(x, y) * x^j * y^i }
</pre> <p class="last">where the sum is over the <code>x</code>, <code>y</code> coordinates of the region.</p> </dd> <dt>
<code>weighted_moments_central : (3, 3) ndarray</code> </dt> <dd>
<p class="first">Central moments (translation invariant) of intensity image up to 3rd order:</p> <pre data-language="python">wmu_ji = sum{ array(x, y) * (x - x_c)^j * (y - y_c)^i }
</pre> <p class="last">where the sum is over the <code>x</code>, <code>y</code> coordinates of the region, and <code>x_c</code> and <code>y_c</code> are the coordinates of the region’s weighted centroid.</p> </dd> <dt>
<code>weighted_moments_hu : tuple</code> </dt> <dd>Hu moments (translation, scale and rotation invariant) of intensity image.</dd> <dt>
<code>weighted_moments_normalized : (3, 3) ndarray</code> </dt> <dd>
<p class="first">Normalized moments (translation and scale invariant) of intensity image up to 3rd order:</p> <pre data-language="python">wnu_ji = wmu_ji / wm_00^[(i+j)/2 + 1]
</pre> <p class="last">where <code>wm_00</code> is the zeroth spatial moment (intensity-weighted area).</p> </dd> </dl> <p>Each region also supports iteration, so that you can do:</p> <pre data-language="python">for prop in region:
    print(prop, region[prop])
</pre> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="r358" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id39">[R358]</a></td>
<td>Wilhelm Burger, Mark Burge. Principles of Digital Image Processing: Core Algorithms. Springer-Verlag, London, 2009.</td>
</tr>  </table> <table class="docutils citation" frame="void" id="r359" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id40">[R359]</a></td>
<td>B. Jähne. Digital Image Processing. Springer-Verlag, Berlin-Heidelberg, 6. edition, 2005.</td>
</tr>  </table> <table class="docutils citation" frame="void" id="r360" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id41">[R360]</a></td>
<td>T. H. Reiss. Recognizing Planar Objects Using Invariant Image Features, from Lecture notes in computer science, p. 676. Springer, Berlin, 1993.</td>
</tr>  </table> <table class="docutils citation" frame="void" id="r361" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id42">[R361]</a></td>
<td><a class="reference external" href="http://en.wikipedia.org/wiki/Image_moment" target="_blank">http://en.wikipedia.org/wiki/Image_moment</a></td>
</tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage import data, util
&gt;&gt;&gt; from skimage.measure import label
&gt;&gt;&gt; img = util.img_as_ubyte(data.coins()) &gt; 110
&gt;&gt;&gt; label_img = label(img, connectivity=img.ndim)
&gt;&gt;&gt; props = regionprops(label_img)
&gt;&gt;&gt; # centroid of first labeled object
&gt;&gt;&gt; props[0].centroid
(22.729879860483141, 81.912285234465827)
&gt;&gt;&gt; # centroid of first labeled object
&gt;&gt;&gt; props[0]['centroid']
(22.729879860483141, 81.912285234465827)
</pre> </dd>
</dl>   <h2 id="shannon-entropy">shannon_entropy</h2> <dl class="function"> <dt id="skimage.measure.shannon_entropy">
<code>skimage.measure.shannon_entropy(image, base=2)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/measure/entropy.py#L4" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Calculate the Shannon entropy of an image.</p> <p>The Shannon entropy is defined as S = -sum(pk * log(pk)), where pk are the number of pixels of value k.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>image</strong> : (N, M) ndarray</p>  <p>Grayscale input image.</p>  <p><strong>base</strong> : float, optional</p>  <p>The logarithmic base to use.</p>  </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first last"><strong>entropy</strong> : float</p> </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>The returned value is measured in bits or shannon (Sh) for base=2, natural unit (nat) for base=np.e and hartley (Hart) for base=10.</p> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="r362" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id43">[R362]</a></td>
<td>
<a class="reference external" href="https://en.wikipedia.org/wiki/Entropy_(information_theory" target="_blank">https://en.wikipedia.org/wiki/Entropy_(information_theory</a>)</td>
</tr>  </table> <table class="docutils citation" frame="void" id="r363" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id44">[R363]</a></td>
<td><a class="reference external" href="https://en.wiktionary.org/wiki/Shannon_entropy" target="_blank">https://en.wiktionary.org/wiki/Shannon_entropy</a></td>
</tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage import data
&gt;&gt;&gt; shannon_entropy(data.camera())
17.732031303342747
</pre> </dd>
</dl>   <h2 id="structural-similarity">structural_similarity</h2> <dl class="function"> <dt id="skimage.measure.structural_similarity">
<code>skimage.measure.structural_similarity(X, Y, win_size=None, gradient=False, dynamic_range=None, multichannel=False, gaussian_weights=False, full=False, **kwargs)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/_shared/utils.py#L59" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p><strong>Deprecated function</strong>. Use <code>compare_ssim</code> instead.</p> </dd>
</dl>   <h2 id="subdivide-polygon">subdivide_polygon</h2> <dl class="function"> <dt id="skimage.measure.subdivide_polygon">
<code>skimage.measure.subdivide_polygon(coords, degree=2, preserve_ends=False)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/measure/_polygon.py#L109" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Subdivision of polygonal curves using B-Splines.</p> <p>Note that the resulting curve is always within the convex hull of the original polygon. Circular polygons stay closed after subdivision.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>coords</strong> : (N, 2) array</p>  <p>Coordinate array.</p>  <p><strong>degree</strong> : {1, 2, 3, 4, 5, 6, 7}, optional</p>  <p>Degree of B-Spline. Default is 2.</p>  <p><strong>preserve_ends</strong> : bool, optional</p>  <p>Preserve first and last coordinate of non-circular polygon. Default is False.</p>  </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>coords</strong> : (M, 2) array</p>  <p>Subdivided coordinate array.</p>  </td> </tr>  </table> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="r364" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id45">[R364]</a></td>
<td><a class="reference external" href="http://mrl.nyu.edu/publications/subdiv-course2000/coursenotes00.pdf" target="_blank">http://mrl.nyu.edu/publications/subdiv-course2000/coursenotes00.pdf</a></td>
</tr>  </table> </dd>
</dl>   <h2 id="circlemodel">CircleModel</h2> <dl class="class"> <dt id="skimage.measure.CircleModel">
<code>class skimage.measure.CircleModel</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/measure/fit.py#L322" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <code>skimage.measure.fit.BaseModel</code></p> <p>Total least squares estimator for 2D circles.</p> <p>The functional model of the circle is:</p> <pre data-language="python">r**2 = (x - xc)**2 + (y - yc)**2
</pre> <p>This estimator minimizes the squared distances from all points to the circle:</p> <pre data-language="python">min{ sum((r - sqrt((x_i - xc)**2 + (y_i - yc)**2))**2) }
</pre> <p>A minimum number of 3 points is required to solve for the parameters.</p> <h4 class="rubric">Attributes</h4> <table class="docutils">   <tr>
<td>params</td> <td>(tuple) Circle model parameters in the following order <code>xc</code>, <code>yc</code>, <code>r</code>.</td> </tr>  </table> <dl class="method"> <dt id="skimage.measure.CircleModel.__init__">
<code>__init__()</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/measure/fit.py#L24" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="skimage.measure.CircleModel.estimate">
<code>estimate(data)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/measure/fit.py#L344" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Estimate circle model from data using total least squares.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>data</strong> : (N, 2) array</p>  <p>N points with <code>(x, y)</code> coordinates, respectively.</p>  </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>success</strong> : bool</p>  <p>True, if model estimation succeeds.</p>  </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="skimage.measure.CircleModel.predict_xy">
<code>predict_xy(t, params=None)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/measure/fit.py#L420" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Predict x- and y-coordinates using the estimated model.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>t</strong> : array</p>  <p>Angles in circle in radians. Angles start to count from positive x-axis to positive y-axis in a right-handed system.</p>  <p><strong>params</strong> : (3, ) array, optional</p>  <p>Optional custom parameter set.</p>  </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>xy</strong> : (…, 2) array</p>  <p>Predicted x- and y-coordinates.</p>  </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="skimage.measure.CircleModel.residuals">
<code>residuals(data)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/measure/fit.py#L394" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Determine residuals of data to model.</p> <p>For each point the shortest distance to the circle is returned.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>data</strong> : (N, 2) array</p>  <p>N points with <code>(x, y)</code> coordinates, respectively.</p>  </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>residuals</strong> : (N, ) array</p>  <p>Residual for each data point.</p>  </td> </tr>  </table> </dd>
</dl> </dd>
</dl>   <h2 id="ellipsemodel">EllipseModel</h2> <dl class="class"> <dt id="skimage.measure.EllipseModel">
<code>class skimage.measure.EllipseModel</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/measure/fit.py#L447" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <code>skimage.measure.fit.BaseModel</code></p> <p>Total least squares estimator for 2D ellipses.</p> <p>The functional model of the ellipse is:</p> <pre data-language="python">xt = xc + a*cos(theta)*cos(t) - b*sin(theta)*sin(t)
yt = yc + a*sin(theta)*cos(t) + b*cos(theta)*sin(t)
d = sqrt((x - xt)**2 + (y - yt)**2)
</pre> <p>where <code>(xt, yt)</code> is the closest point on the ellipse to <code>(x, y)</code>. Thus d is the shortest distance from the point to the ellipse.</p> <p>The estimator is based on a least squares minimization. The optimal solution is computed directly, no iterations are required. This leads to a simple, stable and robust fitting method.</p> <p>The <code>params</code> attribute contains the parameters in the following order:</p> <pre data-language="python">xc, yc, a, b, theta
</pre> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; xy = EllipseModel().predict_xy(np.linspace(0, 2 * np.pi, 25),
...                                params=(10, 15, 4, 8, np.deg2rad(30)))
&gt;&gt;&gt; ellipse = EllipseModel()
&gt;&gt;&gt; ellipse.estimate(xy)
True
&gt;&gt;&gt; np.round(ellipse.params, 2)
array([ 10.  ,  15.  ,   4.  ,   8.  ,   0.52])
&gt;&gt;&gt; np.round(abs(ellipse.residuals(xy)), 5)
array([ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,
        0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.])
</pre> <h4 class="rubric">Attributes</h4> <table class="docutils">   <tr>
<td>params</td> <td>(tuple) Ellipse model parameters in the following order <code>xc</code>, <code>yc</code>, <code>a</code>, <code>b</code>, <code>theta</code>.</td> </tr>  </table> <dl class="method"> <dt id="skimage.measure.EllipseModel.__init__">
<code>__init__()</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/measure/fit.py#L24" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="skimage.measure.EllipseModel.estimate">
<code>estimate(data)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/measure/fit.py#L488" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Estimate circle model from data using total least squares.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>data</strong> : (N, 2) array</p>  <p>N points with <code>(x, y)</code> coordinates, respectively.</p>  </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>success</strong> : bool</p>  <p>True, if model estimation succeeds.</p>  </td> </tr>  </table> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="r365" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id46">[R365]</a></td>
<td>Halir, R.; Flusser, J. “Numerically stable direct least squares fitting of ellipses”. In Proc. 6th International Conference in Central Europe on Computer Graphics and Visualization. WSCG (Vol. 98, pp. 125-132).</td>
</tr>  </table> </dd>
</dl> <dl class="method"> <dt id="skimage.measure.EllipseModel.predict_xy">
<code>predict_xy(t, params=None)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/measure/fit.py#L645" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Predict x- and y-coordinates using the estimated model.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>t</strong> : array</p>  <p>Angles in circle in radians. Angles start to count from positive x-axis to positive y-axis in a right-handed system.</p>  <p><strong>params</strong> : (5, ) array, optional</p>  <p>Optional custom parameter set.</p>  </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>xy</strong> : (…, 2) array</p>  <p>Predicted x- and y-coordinates.</p>  </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="skimage.measure.EllipseModel.residuals">
<code>residuals(data)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/measure/fit.py#L583" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Determine residuals of data to model.</p> <p>For each point the shortest distance to the ellipse is returned.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>data</strong> : (N, 2) array</p>  <p>N points with <code>(x, y)</code> coordinates, respectively.</p>  </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>residuals</strong> : (N, ) array</p>  <p>Residual for each data point.</p>  </td> </tr>  </table> </dd>
</dl> </dd>
</dl>   <h2 id="linemodel">LineModel</h2> <dl class="class"> <dt id="skimage.measure.LineModel">
<code>class skimage.measure.LineModel</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/measure/fit.py#L28" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <code>skimage.measure.fit.BaseModel</code></p> <p>Total least squares estimator for 2D lines.</p> <p>Lines are parameterized using polar coordinates as functional model:</p> <pre data-language="python">dist = x * cos(theta) + y * sin(theta)
</pre> <p>This parameterization is able to model vertical lines in contrast to the standard line model <code>y = a*x + b</code>.</p> <p>This estimator minimizes the squared distances from all points to the line:</p> <pre data-language="python">min{ sum((dist - x_i * cos(theta) + y_i * sin(theta))**2) }
</pre> <p>A minimum number of 2 points is required to solve for the parameters.</p> <p><strong>Deprecated class</strong>. Use <code>LineModelND</code> instead.</p> <h4 class="rubric">Attributes</h4> <table class="docutils">   <tr>
<td>params</td> <td>(tuple) Line model parameters in the following order <code>dist</code>, <code>theta</code>.</td> </tr>  </table> <dl class="method"> <dt id="skimage.measure.LineModel.__init__">
<code>__init__()</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/measure/fit.py#L55" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="skimage.measure.LineModel.estimate">
<code>estimate(data)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/measure/fit.py#L60" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Estimate line model from data using total least squares.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>data</strong> : (N, 2) array</p>  <p>N points with <code>(x, y)</code> coordinates, respectively.</p>  </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>success</strong> : bool</p>  <p>True, if model estimation succeeds.</p>  </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="skimage.measure.LineModel.predict_x">
<code>predict_x(y, params=None)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/measure/fit.py#L125" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Predict x-coordinates using the estimated model.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>y</strong> : array</p>  <p>y-coordinates.</p>  <p><strong>params</strong> : (2, ) array, optional</p>  <p>Optional custom parameter set.</p>  </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>x</strong> : array</p>  <p>Predicted x-coordinates.</p>  </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="skimage.measure.LineModel.predict_y">
<code>predict_y(x, params=None)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/measure/fit.py#L147" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Predict y-coordinates using the estimated model.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>x</strong> : array</p>  <p>x-coordinates.</p>  <p><strong>params</strong> : (2, ) array, optional</p>  <p>Optional custom parameter set.</p>  </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>y</strong> : array</p>  <p>Predicted y-coordinates.</p>  </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="skimage.measure.LineModel.residuals">
<code>residuals(data)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/measure/fit.py#L99" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Determine residuals of data to model.</p> <p>For each point the shortest distance to the line is returned.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>data</strong> : (N, 2) array</p>  <p>N points with <code>(x, y)</code> coordinates, respectively.</p>  </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>residuals</strong> : (N, ) array</p>  <p>Residual for each data point.</p>  </td> </tr>  </table> </dd>
</dl> </dd>
</dl>   <h2 id="linemodelnd">LineModelND</h2> <dl class="class"> <dt id="skimage.measure.LineModelND">
<code>class skimage.measure.LineModelND</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/measure/fit.py#L170" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <code>skimage.measure.fit.BaseModel</code></p> <p>Total least squares estimator for N-dimensional lines.</p> <p>Lines are defined by a point (origin) and a unit vector (direction) according to the following vector equation:</p> <pre data-language="python">X = origin + lambda * direction
</pre> <h4 class="rubric">Attributes</h4> <table class="docutils">   <tr>
<td>params</td> <td>(tuple) Line model parameters in the following order <code>origin</code>, <code>direction</code>.</td> </tr>  </table> <dl class="method"> <dt id="skimage.measure.LineModelND.__init__">
<code>__init__()</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/measure/fit.py#L24" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="skimage.measure.LineModelND.estimate">
<code>estimate(data)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/measure/fit.py#L185" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Estimate line model from data.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>data</strong> : (N, dim) array</p>  <p>N points in a space of dimensionality dim &gt;= 2.</p>  </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>success</strong> : bool</p>  <p>True, if model estimation succeeds.</p>  </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="skimage.measure.LineModelND.predict">
<code>predict(x, axis=0, params=None)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/measure/fit.py#L244" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Predict intersection of the estimated line model with a hyperplane orthogonal to a given axis.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>x</strong> : array</p>  <p>coordinates along an axis.</p>  <p><strong>axis</strong> : int</p>  <p>axis orthogonal to the hyperplane intersecting the line.</p>  <p><strong>params</strong> : (2, ) array, optional</p>  <p>Optional custom parameter set in the form (<code>origin</code>, <code>direction</code>).</p>  </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>y</strong> : array</p>  <p>Predicted coordinates.</p>  <p class="last">If the line is parallel to the given axis, a ValueError is raised.</p> </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="skimage.measure.LineModelND.predict_x">
<code>predict_x(y, params=None)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/measure/fit.py#L277" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Predict x-coordinates for 2D lines using the estimated model.</p> <p>Alias for:</p> <pre data-language="python">predict(y, axis=1)[:, 0]
</pre> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>y</strong> : array</p>  <p>y-coordinates.</p>  <p><strong>params</strong> : (2, ) array, optional</p>  <p>Optional custom parameter set in the form (<code>origin</code>, <code>direction</code>).</p>  </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>x</strong> : array</p>  <p>Predicted x-coordinates.</p>  </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="skimage.measure.LineModelND.predict_y">
<code>predict_y(x, params=None)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/measure/fit.py#L299" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Predict y-coordinates for 2D lines using the estimated model.</p> <p>Alias for:</p> <pre data-language="python">predict(x, axis=0)[:, 1]
</pre> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>x</strong> : array</p>  <p>x-coordinates.</p>  <p><strong>params</strong> : (2, ) array, optional</p>  <p>Optional custom parameter set in the form (<code>origin</code>, <code>direction</code>).</p>  </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>y</strong> : array</p>  <p>Predicted y-coordinates.</p>  </td> </tr>  </table> </dd>
</dl> <dl class="method"> <dt id="skimage.measure.LineModelND.residuals">
<code>residuals(data)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/measure/fit.py#L222" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Determine residuals of data to model.</p> <p>For each point the shortest distance to the line is returned. It is obtained by projecting the data onto the line.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>data</strong> : (N, dim) array</p>  <p>N points in a space of dimension dim.</p>  </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>residuals</strong> : (N, ) array</p>  <p>Residual for each data point.</p>  </td> </tr>  </table> </dd>
</dl> </dd>
</dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 2011 the scikit-image team<br>Licensed under the BSD 3-clause License.<br>
    <a href="http://scikit-image.org/docs/0.13.x/api/skimage.measure.html" class="_attribution-link" target="_blank">http://scikit-image.org/docs/0.13.x/api/skimage.measure.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
