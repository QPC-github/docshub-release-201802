
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Draw - Scikit-image - W3cubDocs</title>
  
  <meta name="description" content=" Generate Bezier curve coordinates. ">
  <meta name="keywords" content="module, draw, -, scikit-image, scikit_image">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/scikit_image/api/skimage.draw/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-e0f881b0fce8cbe96f33dadc355b7159d5d2912911231446d60eb8f9caffa802.css">
  <script type="text/javascript" src="/assets/application-8fc46316434047265cd383f02b8e7f434ed7dec4a59f920dd633deef8d488d1b.js"></script>
  <script src="/json/scikit_image.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/scikit_image/" class="_nav-link" title="" style="margin-left:0;">scikit-image</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _sphinx">
				
<h1 id="module-draw">Module: draw</h1> <table class="longtable docutils" id="module-skimage.draw">   <tr>
<td>
<a class="reference internal" href="#skimage.draw.bezier_curve" title="skimage.draw.bezier_curve"><code>skimage.draw.bezier_curve</code></a>(r0, c0, r1, c1, …)</td> <td>Generate Bezier curve coordinates.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.draw.circle" title="skimage.draw.circle"><code>skimage.draw.circle</code></a>(r, c, radius[, shape])</td> <td>Generate coordinates of pixels within circle.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.draw.circle_perimeter" title="skimage.draw.circle_perimeter"><code>skimage.draw.circle_perimeter</code></a>(r, c, radius)</td> <td>Generate circle perimeter coordinates.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.draw.circle_perimeter_aa" title="skimage.draw.circle_perimeter_aa"><code>skimage.draw.circle_perimeter_aa</code></a>(r, c, radius)</td> <td>Generate anti-aliased circle perimeter coordinates.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.draw.ellipse" title="skimage.draw.ellipse"><code>skimage.draw.ellipse</code></a>(r, c, r_radius, c_radius)</td> <td>Generate coordinates of pixels within ellipse.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.draw.ellipse_perimeter" title="skimage.draw.ellipse_perimeter"><code>skimage.draw.ellipse_perimeter</code></a>(r, c, …[, …])</td> <td>Generate ellipse perimeter coordinates.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.draw.ellipsoid" title="skimage.draw.ellipsoid"><code>skimage.draw.ellipsoid</code></a>(a, b, c[, spacing, …])</td> <td>Generates ellipsoid with semimajor axes aligned with grid dimensions on grid with specified <code>spacing</code>.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.draw.ellipsoid_stats" title="skimage.draw.ellipsoid_stats"><code>skimage.draw.ellipsoid_stats</code></a>(a, b, c)</td> <td>Calculates analytical surface area and volume for ellipsoid with semimajor axes aligned with grid dimensions of specified <code>spacing</code>.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.draw.line" title="skimage.draw.line"><code>skimage.draw.line</code></a>(r0, c0, r1, c1)</td> <td>Generate line pixel coordinates.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.draw.line_aa" title="skimage.draw.line_aa"><code>skimage.draw.line_aa</code></a>(r0, c0, r1, c1)</td> <td>Generate anti-aliased line pixel coordinates.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.draw.polygon" title="skimage.draw.polygon"><code>skimage.draw.polygon</code></a>(r, c[, shape])</td> <td>Generate coordinates of pixels within polygon.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.draw.polygon_perimeter" title="skimage.draw.polygon_perimeter"><code>skimage.draw.polygon_perimeter</code></a>(r, c[, …])</td> <td>Generate polygon perimeter coordinates.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.draw.set_color" title="skimage.draw.set_color"><code>skimage.draw.set_color</code></a>(img, coords, color[, …])</td> <td>Set pixel color in the image at the given coordinates.</td> </tr> <tr>
<td><code>skimage.draw.draw</code></td> <td></td> </tr> <tr>
<td><code>skimage.draw.draw3d</code></td> <td></td> </tr>  </table>  <h2 id="bezier-curve">bezier_curve</h2> <dl class="function"> <dt id="skimage.draw.bezier_curve">
<code>skimage.draw.bezier_curve(r0, c0, r1, c1, r2, c2, weight, shape=None)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/draw/draw.py#L641" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Generate Bezier curve coordinates.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>r0, c0</strong> : int</p>  <p>Coordinates of the first control point.</p>  <p><strong>r1, c1</strong> : int</p>  <p>Coordinates of the middle control point.</p>  <p><strong>r2, c2</strong> : int</p>  <p>Coordinates of the last control point.</p>  <p><strong>weight</strong> : double</p>  <p>Middle control point weight, it describes the line tension.</p>  <p><strong>shape</strong> : tuple, optional</p>  <p>Image shape which is used to determine the maximum extent of output pixel coordinates. This is useful for curves that exceed the image size. If None, the full extent of the curve is used.</p>  </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>rr, cc</strong> : (N,) ndarray of int</p>  <p>Indices of pixels that belong to the Bezier curve. May be used to directly index into an array, e.g. <code>img[rr, cc] = 1</code>.</p>  </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>The algorithm is the rational quadratic algorithm presented in reference <a class="reference internal" href="#r99" id="id1">[R99]</a>.</p> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="r99" rules="none">   <tr>
<td class="label">[R99]</td>
<td>
<em>(<a class="fn-backref" href="#id1">1</a>, <a class="fn-backref" href="#id2">2</a>)</em> A Rasterizing Algorithm for Drawing Curves, A. Zingl, 2012 <a class="reference external" href="http://members.chello.at/easyfilter/Bresenham.pdf" target="_blank">http://members.chello.at/easyfilter/Bresenham.pdf</a>
</td>
</tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from skimage.draw import bezier_curve
&gt;&gt;&gt; img = np.zeros((10, 10), dtype=np.uint8)
&gt;&gt;&gt; rr, cc = bezier_curve(1, 5, 5, -2, 8, 8, 2)
&gt;&gt;&gt; img[rr, cc] = 1
&gt;&gt;&gt; img
array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 1, 0, 0, 0, 0],
       [0, 0, 0, 1, 1, 0, 0, 0, 0, 0],
       [0, 0, 1, 0, 0, 0, 0, 0, 0, 0],
       [0, 1, 0, 0, 0, 0, 0, 0, 0, 0],
       [0, 1, 0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 1, 1, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 1, 1, 1, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 1, 1, 0],
       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype=uint8)
</pre> </dd>
</dl>   <h2 id="circle">circle</h2> <dl class="function"> <dt id="skimage.draw.circle">
<code>skimage.draw.circle(r, c, radius, shape=None)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/draw/draw.py#L144" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Generate coordinates of pixels within circle.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>r, c</strong> : double</p>  <p>Centre coordinate of circle.</p>  <p><strong>radius</strong> : double</p>  <p>Radius of circle.</p>  <p><strong>shape</strong> : tuple, optional</p>  <p>Image shape which is used to determine the maximum extent of output pixel coordinates. This is useful for circles that exceed the image size. If None, the full extent of the circle is used.</p>  </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>rr, cc</strong> : ndarray of int</p>  <p>Pixel coordinates of circle. May be used to directly index into an array, e.g. <code>img[rr, cc] = 1</code>.</p>  </td> </tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage.draw import circle
&gt;&gt;&gt; img = np.zeros((10, 10), dtype=np.uint8)
&gt;&gt;&gt; rr, cc = circle(4, 4, 5)
&gt;&gt;&gt; img[rr, cc] = 1
&gt;&gt;&gt; img
array([[0, 0, 1, 1, 1, 1, 1, 0, 0, 0],
       [0, 1, 1, 1, 1, 1, 1, 1, 0, 0],
       [1, 1, 1, 1, 1, 1, 1, 1, 1, 0],
       [1, 1, 1, 1, 1, 1, 1, 1, 1, 0],
       [1, 1, 1, 1, 1, 1, 1, 1, 1, 0],
       [1, 1, 1, 1, 1, 1, 1, 1, 1, 0],
       [1, 1, 1, 1, 1, 1, 1, 1, 1, 0],
       [0, 1, 1, 1, 1, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 1, 1, 1, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype=uint8)
</pre> </dd>
</dl>   <h2 id="circle-perimeter">circle_perimeter</h2> <dl class="function"> <dt id="skimage.draw.circle_perimeter">
<code>skimage.draw.circle_perimeter(r, c, radius, method='bresenham', shape=None)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/draw/draw.py#L460" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Generate circle perimeter coordinates.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>r, c</strong> : int</p>  <p>Centre coordinate of circle.</p>  <p><strong>radius: int</strong></p>  <p>Radius of circle.</p>  <p><strong>method</strong> : {‘bresenham’, ‘andres’}, optional</p>  <p>bresenham : Bresenham method (default) andres : Andres method</p>  <p><strong>shape</strong> : tuple, optional</p>  <p>Image shape which is used to determine the maximum extent of output pixel coordinates. This is useful for circles that exceed the image size. If None, the full extent of the circle is used.</p>  </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>rr, cc</strong> : (N,) ndarray of int</p>  <p>Bresenham and Andres’ method: Indices of pixels that belong to the circle perimeter. May be used to directly index into an array, e.g. <code>img[rr, cc] = 1</code>.</p>  </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>Andres method presents the advantage that concentric circles create a disc whereas Bresenham can make holes. There is also less distortions when Andres circles are rotated. Bresenham method is also known as midpoint circle algorithm. Anti-aliased circle generator is available with <code>circle_perimeter_aa</code>.</p> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="r100" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id3">[R100]</a></td>
<td>J.E. Bresenham, “Algorithm for computer control of a digital plotter”, IBM Systems journal, 4 (1965) 25-30.</td>
</tr>  </table> <table class="docutils citation" frame="void" id="r101" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id4">[R101]</a></td>
<td>E. Andres, “Discrete circles, rings and spheres”, Computers &amp; Graphics, 18 (1994) 695-706.</td>
</tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage.draw import circle_perimeter
&gt;&gt;&gt; img = np.zeros((10, 10), dtype=np.uint8)
&gt;&gt;&gt; rr, cc = circle_perimeter(4, 4, 3)
&gt;&gt;&gt; img[rr, cc] = 1
&gt;&gt;&gt; img
array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 1, 1, 1, 0, 0, 0, 0],
       [0, 0, 1, 0, 0, 0, 1, 0, 0, 0],
       [0, 1, 0, 0, 0, 0, 0, 1, 0, 0],
       [0, 1, 0, 0, 0, 0, 0, 1, 0, 0],
       [0, 1, 0, 0, 0, 0, 0, 1, 0, 0],
       [0, 0, 1, 0, 0, 0, 1, 0, 0, 0],
       [0, 0, 0, 1, 1, 1, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype=uint8)
</pre> </dd>
</dl>   <h2 id="circle-perimeter-aa">circle_perimeter_aa</h2> <dl class="function"> <dt id="skimage.draw.circle_perimeter_aa">
<code>skimage.draw.circle_perimeter_aa(r, c, radius, shape=None)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/draw/draw.py#L521" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Generate anti-aliased circle perimeter coordinates.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>r, c</strong> : int</p>  <p>Centre coordinate of circle.</p>  <p><strong>radius: int</strong></p>  <p>Radius of circle.</p>  <p><strong>shape</strong> : tuple, optional</p>  <p>Image shape which is used to determine the maximum extent of output pixel coordinates. This is useful for circles that exceed the image size. If None, the full extent of the circle is used.</p>  </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>rr, cc, val</strong> : (N,) ndarray (int, int, float)</p>  <p>Indices of pixels (<code>rr</code>, <code>cc</code>) and intensity values (<code>val</code>). <code>img[rr, cc] = val</code>.</p>  </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>Wu’s method draws anti-aliased circle. This implementation doesn’t use lookup table optimization.</p> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="r102" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id5">[R102]</a></td>
<td>X. Wu, “An efficient antialiasing technique”, In ACM SIGGRAPH Computer Graphics, 25 (1991) 143-152.</td>
</tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage.draw import circle_perimeter_aa
&gt;&gt;&gt; img = np.zeros((10, 10), dtype=np.uint8)
&gt;&gt;&gt; rr, cc, val = circle_perimeter_aa(4, 4, 3)
&gt;&gt;&gt; img[rr, cc] = val * 255
&gt;&gt;&gt; img
array([[  0,   0,   0,   0,   0,   0,   0,   0,   0,   0],
       [  0,   0,  60, 211, 255, 211,  60,   0,   0,   0],
       [  0,  60, 194,  43,   0,  43, 194,  60,   0,   0],
       [  0, 211,  43,   0,   0,   0,  43, 211,   0,   0],
       [  0, 255,   0,   0,   0,   0,   0, 255,   0,   0],
       [  0, 211,  43,   0,   0,   0,  43, 211,   0,   0],
       [  0,  60, 194,  43,   0,  43, 194,  60,   0,   0],
       [  0,   0,  60, 211, 255, 211,  60,   0,   0,   0],
       [  0,   0,   0,   0,   0,   0,   0,   0,   0,   0],
       [  0,   0,   0,   0,   0,   0,   0,   0,   0,   0]], dtype=uint8)
</pre> </dd>
</dl>   <h2 id="ellipse">ellipse</h2> <dl class="function"> <dt id="skimage.draw.ellipse">
<code>skimage.draw.ellipse(r, c, r_radius, c_radius, shape=None, rotation=0.0)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/draw/draw.py#L45" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Generate coordinates of pixels within ellipse.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>r, c</strong> : double</p>  <p>Centre coordinate of ellipse.</p>  <p><strong>r_radius, c_radius</strong> : double</p>  <p>Minor and major semi-axes. <code>(r/r_radius)**2 + (c/c_radius)**2 = 1</code>.</p>  <p><strong>shape</strong> : tuple, optional</p>  <p>Image shape which is used to determine the maximum extent of output pixel coordinates. This is useful for ellipses which exceed the image size. By default the full extent of the ellipse are used.</p>  <p><strong>rotation</strong> : float, optional (default 0.)</p>  <p>Set the ellipse rotation (rotation) in range (-PI, PI) in contra clock wise direction, so PI/2 degree means swap ellipse axis</p>  </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>rr, cc</strong> : ndarray of int</p>  <p>Pixel coordinates of ellipse. May be used to directly index into an array, e.g. <code>img[rr, cc] = 1</code>.</p>  </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>The ellipse equation:</p> <pre data-language="python">((x * cos(alpha) + y * sin(alpha)) / x_radius) ** 2 +
((x * sin(alpha) - y * cos(alpha)) / y_radius) ** 2 = 1
</pre> <p>Note that the positions of <code>ellipse</code> without specified <code>shape</code> can have also, negative values, as this is correct on the plane. On the other hand using these ellipse positions for an image afterwards may lead to appearing on the other side of image, because <code>image[-1, -1] = image[end-1, end-1]</code></p> <pre data-language="python">&gt;&gt;&gt; rr, cc = ellipse(1, 2, 3, 6)
&gt;&gt;&gt; img = np.zeros((6, 12), dtype=np.uint8)
&gt;&gt;&gt; img[rr, cc] = 1
&gt;&gt;&gt; img
array([[1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1],
       [1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1],
       [1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1],
       [1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1],
       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
       [1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1]], dtype=uint8)
</pre> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage.draw import ellipse
&gt;&gt;&gt; img = np.zeros((10, 12), dtype=np.uint8)
&gt;&gt;&gt; rr, cc = ellipse(5, 6, 3, 5, rotation=np.deg2rad(30))
&gt;&gt;&gt; img[rr, cc] = 1
&gt;&gt;&gt; img
array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0],
       [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0],
       [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0],
       [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0],
       [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0],
       [0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype=uint8)
</pre> </dd>
</dl>   <h2 id="ellipse-perimeter">ellipse_perimeter</h2> <dl class="function"> <dt id="skimage.draw.ellipse_perimeter">
<code>skimage.draw.ellipse_perimeter(r, c, r_radius, c_radius, orientation=0, shape=None)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/draw/draw.py#L572" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Generate ellipse perimeter coordinates.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>r, c</strong> : int</p>  <p>Centre coordinate of ellipse.</p>  <p><strong>r_radius, c_radius</strong> : int</p>  <p>Minor and major semi-axes. <code>(r/r_radius)**2 + (c/c_radius)**2 = 1</code>.</p>  <p><strong>orientation</strong> : double, optional</p>  <p>Major axis orientation in clockwise direction as radians.</p>  <p><strong>shape</strong> : tuple, optional</p>  <p>Image shape which is used to determine the maximum extent of output pixel coordinates. This is useful for ellipses that exceed the image size. If None, the full extent of the ellipse is used.</p>  </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>rr, cc</strong> : (N,) ndarray of int</p>  <p>Indices of pixels that belong to the ellipse perimeter. May be used to directly index into an array, e.g. <code>img[rr, cc] = 1</code>.</p>  </td> </tr>  </table> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="r103" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id6">[R103]</a></td>
<td>A Rasterizing Algorithm for Drawing Curves, A. Zingl, 2012 <a class="reference external" href="http://members.chello.at/easyfilter/Bresenham.pdf" target="_blank">http://members.chello.at/easyfilter/Bresenham.pdf</a>
</td>
</tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage.draw import ellipse_perimeter
&gt;&gt;&gt; img = np.zeros((10, 10), dtype=np.uint8)
&gt;&gt;&gt; rr, cc = ellipse_perimeter(5, 5, 3, 4)
&gt;&gt;&gt; img[rr, cc] = 1
&gt;&gt;&gt; img
array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 1, 1, 1, 1, 1, 0, 0],
       [0, 0, 1, 0, 0, 0, 0, 0, 1, 0],
       [0, 1, 0, 0, 0, 0, 0, 0, 0, 1],
       [0, 1, 0, 0, 0, 0, 0, 0, 0, 1],
       [0, 1, 0, 0, 0, 0, 0, 0, 0, 1],
       [0, 0, 1, 0, 0, 0, 0, 0, 1, 0],
       [0, 0, 0, 1, 1, 1, 1, 1, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype=uint8)
</pre> <p>Note that the positions of <code>ellipse</code> without specified <code>shape</code> can have also, negative values, as this is correct on the plane. On the other hand using these ellipse positions for an image afterwards may lead to appearing on the other side of image, because <code>image[-1, -1] = image[end-1, end-1]</code></p> <pre data-language="python">&gt;&gt;&gt; rr, cc = ellipse_perimeter(2, 3, 4, 5)
&gt;&gt;&gt; img = np.zeros((9, 12), dtype=np.uint8)
&gt;&gt;&gt; img[rr, cc] = 1
&gt;&gt;&gt; img
array([[0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],
       [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0],
       [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0],
       [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0],
       [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],
       [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
       [0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0],
       [0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0],
       [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]], dtype=uint8)
</pre> </dd>
</dl>   <h2 id="ellipsoid">ellipsoid</h2> <dl class="function"> <dt id="skimage.draw.ellipsoid">
<code>skimage.draw.ellipsoid(a, b, c, spacing=(1.0, 1.0, 1.0), levelset=False)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/draw/draw3d.py#L6" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Generates ellipsoid with semimajor axes aligned with grid dimensions on grid with specified <code>spacing</code>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>a</strong> : float</p>  <p>Length of semimajor axis aligned with x-axis.</p>  <p><strong>b</strong> : float</p>  <p>Length of semimajor axis aligned with y-axis.</p>  <p><strong>c</strong> : float</p>  <p>Length of semimajor axis aligned with z-axis.</p>  <p><strong>spacing</strong> : tuple of floats, length 3</p>  <p>Spacing in (x, y, z) spatial dimensions.</p>  <p><strong>levelset</strong> : bool</p>  <p>If True, returns the level set for this ellipsoid (signed level set about zero, with positive denoting interior) as np.float64. False returns a binarized version of said level set.</p>  </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>ellip</strong> : (N, M, P) array</p>  <p>Ellipsoid centered in a correctly sized array for given <code>spacing</code>. Boolean dtype unless <code>levelset=True</code>, in which case a float array is returned with the level set above 0.0 representing the ellipsoid.</p>  </td> </tr>  </table> </dd>
</dl>   <h2 id="ellipsoid-stats">ellipsoid_stats</h2> <dl class="function"> <dt id="skimage.draw.ellipsoid_stats">
<code>skimage.draw.ellipsoid_stats(a, b, c)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/draw/draw3d.py#L67" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Calculates analytical surface area and volume for ellipsoid with semimajor axes aligned with grid dimensions of specified <code>spacing</code>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>a</strong> : float</p>  <p>Length of semimajor axis aligned with x-axis.</p>  <p><strong>b</strong> : float</p>  <p>Length of semimajor axis aligned with y-axis.</p>  <p><strong>c</strong> : float</p>  <p>Length of semimajor axis aligned with z-axis.</p>  </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>vol</strong> : float</p>  <p>Calculated volume of ellipsoid.</p>  <p><strong>surf</strong> : float</p>  <p>Calculated surface area of ellipsoid.</p>  </td> </tr>  </table> </dd>
</dl>   <h2 id="line">line</h2> <dl class="function"> <dt id="skimage.draw.line">
<code>skimage.draw.line(r0, c0, r1, c1)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/draw/draw.py#L331" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Generate line pixel coordinates.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>r0, c0</strong> : int</p>  <p>Starting position (row, column).</p>  <p><strong>r1, c1</strong> : int</p>  <p>End position (row, column).</p>  </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>rr, cc</strong> : (N,) ndarray of int</p>  <p>Indices of pixels that belong to the line. May be used to directly index into an array, e.g. <code>img[rr, cc] = 1</code>.</p>  </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>Anti-aliased line generator is available with <code>line_aa</code>.</p> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage.draw import line
&gt;&gt;&gt; img = np.zeros((10, 10), dtype=np.uint8)
&gt;&gt;&gt; rr, cc = line(1, 1, 8, 8)
&gt;&gt;&gt; img[rr, cc] = 1
&gt;&gt;&gt; img
array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
       [0, 1, 0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 1, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 1, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 1, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 1, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 1, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype=uint8)
</pre> </dd>
</dl>   <h2 id="line-aa">line_aa</h2> <dl class="function"> <dt id="skimage.draw.line_aa">
<code>skimage.draw.line_aa(r0, c0, r1, c1)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/draw/draw.py#L373" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Generate anti-aliased line pixel coordinates.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>r0, c0</strong> : int</p>  <p>Starting position (row, column).</p>  <p><strong>r1, c1</strong> : int</p>  <p>End position (row, column).</p>  </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>rr, cc, val</strong> : (N,) ndarray (int, int, float)</p>  <p>Indices of pixels (<code>rr</code>, <code>cc</code>) and intensity values (<code>val</code>). <code>img[rr, cc] = val</code>.</p>  </td> </tr>  </table> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="r104" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id7">[R104]</a></td>
<td>A Rasterizing Algorithm for Drawing Curves, A. Zingl, 2012 <a class="reference external" href="http://members.chello.at/easyfilter/Bresenham.pdf" target="_blank">http://members.chello.at/easyfilter/Bresenham.pdf</a>
</td>
</tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage.draw import line_aa
&gt;&gt;&gt; img = np.zeros((10, 10), dtype=np.uint8)
&gt;&gt;&gt; rr, cc, val = line_aa(1, 1, 8, 8)
&gt;&gt;&gt; img[rr, cc] = val * 255
&gt;&gt;&gt; img
array([[  0,   0,   0,   0,   0,   0,   0,   0,   0,   0],
       [  0, 255,  74,   0,   0,   0,   0,   0,   0,   0],
       [  0,  74, 255,  74,   0,   0,   0,   0,   0,   0],
       [  0,   0,  74, 255,  74,   0,   0,   0,   0,   0],
       [  0,   0,   0,  74, 255,  74,   0,   0,   0,   0],
       [  0,   0,   0,   0,  74, 255,  74,   0,   0,   0],
       [  0,   0,   0,   0,   0,  74, 255,  74,   0,   0],
       [  0,   0,   0,   0,   0,   0,  74, 255,  74,   0],
       [  0,   0,   0,   0,   0,   0,   0,  74, 255,   0],
       [  0,   0,   0,   0,   0,   0,   0,   0,   0,   0]], dtype=uint8)
</pre> </dd>
</dl>   <h2 id="polygon">polygon</h2> <dl class="function"> <dt id="skimage.draw.polygon">
<code>skimage.draw.polygon(r, c, shape=None)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/draw/draw.py#L415" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Generate coordinates of pixels within polygon.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>r</strong> : (N,) ndarray</p>  <p>Row coordinates of vertices of polygon.</p>  <p><strong>c</strong> : (N,) ndarray</p>  <p>Column coordinates of vertices of polygon.</p>  <p><strong>shape</strong> : tuple, optional</p>  <p>Image shape which is used to determine the maximum extent of output pixel coordinates. This is useful for polygons that exceed the image size. If None, the full extent of the polygon is used.</p>  </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>rr, cc</strong> : ndarray of int</p>  <p>Pixel coordinates of polygon. May be used to directly index into an array, e.g. <code>img[rr, cc] = 1</code>.</p>  </td> </tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage.draw import polygon
&gt;&gt;&gt; img = np.zeros((10, 10), dtype=np.uint8)
&gt;&gt;&gt; r = np.array([1, 2, 8, 1])
&gt;&gt;&gt; c = np.array([1, 7, 4, 1])
&gt;&gt;&gt; rr, cc = polygon(r, c)
&gt;&gt;&gt; img[rr, cc] = 1
&gt;&gt;&gt; img
array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 1, 1, 1, 1, 1, 0, 0, 0],
       [0, 0, 1, 1, 1, 1, 1, 0, 0, 0],
       [0, 0, 0, 1, 1, 1, 0, 0, 0, 0],
       [0, 0, 0, 1, 1, 1, 0, 0, 0, 0],
       [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype=uint8)
</pre> </dd>
</dl>   <h2 id="polygon-perimeter">polygon_perimeter</h2> <dl class="function"> <dt id="skimage.draw.polygon_perimeter">
<code>skimage.draw.polygon_perimeter(r, c, shape=None, clip=False)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/draw/draw.py#L186" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Generate polygon perimeter coordinates.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>r</strong> : (N,) ndarray</p>  <p>Row coordinates of vertices of polygon.</p>  <p><strong>c</strong> : (N,) ndarray</p>  <p>Column coordinates of vertices of polygon.</p>  <p><strong>shape</strong> : tuple, optional</p>  <p>Image shape which is used to determine maximum extents of output pixel coordinates. This is useful for polygons that exceed the image size. If None, the full extents of the polygon is used.</p>  <p><strong>clip</strong> : bool, optional</p>  <p>Whether to clip the polygon to the provided shape. If this is set to True, the drawn figure will always be a closed polygon with all edges visible.</p>  </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>rr, cc</strong> : ndarray of int</p>  <p>Pixel coordinates of polygon. May be used to directly index into an array, e.g. <code>img[rr, cc] = 1</code>.</p>  </td> </tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage.draw import polygon_perimeter
&gt;&gt;&gt; img = np.zeros((10, 10), dtype=np.uint8)
&gt;&gt;&gt; rr, cc = polygon_perimeter([5, -1, 5, 10],
...                            [-1, 5, 11, 5],
...                            shape=img.shape, clip=True)
&gt;&gt;&gt; img[rr, cc] = 1
&gt;&gt;&gt; img
array([[0, 0, 0, 0, 1, 1, 1, 0, 0, 0],
       [0, 0, 0, 1, 0, 0, 0, 1, 0, 0],
       [0, 0, 1, 0, 0, 0, 0, 0, 1, 0],
       [0, 1, 0, 0, 0, 0, 0, 0, 0, 1],
       [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
       [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
       [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
       [0, 1, 1, 0, 0, 0, 0, 0, 0, 1],
       [0, 0, 0, 1, 0, 0, 0, 1, 1, 0],
       [0, 0, 0, 0, 1, 1, 1, 0, 0, 0]], dtype=uint8)
</pre> </dd>
</dl>   <h2 id="set-color">set_color</h2> <dl class="function"> <dt id="skimage.draw.set_color">
<code>skimage.draw.set_color(img, coords, color, alpha=1)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/draw/draw.py#L263" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set pixel color in the image at the given coordinates.</p> <p>Coordinates that exceed the shape of the image will be ignored.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>img</strong> : (M, N, D) ndarray</p>  <p>Image</p>  <p><strong>coords</strong> : tuple of ((P,) ndarray, (P,) ndarray)</p>  <p>Row and column coordinates of pixels to be colored.</p>  <p><strong>color</strong> : (D,) ndarray</p>  <p>Color to be assigned to coordinates in the image.</p>  <p><strong>alpha</strong> : scalar or (N,) ndarray</p>  <p>Alpha values used to blend color with image. 0 is transparent, 1 is opaque.</p>  </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>img</strong> : (M, N, D) ndarray</p>  <p>The updated image.</p>  </td> </tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage.draw import line, set_color
&gt;&gt;&gt; img = np.zeros((10, 10), dtype=np.uint8)
&gt;&gt;&gt; rr, cc = line(1, 1, 20, 20)
&gt;&gt;&gt; set_color(img, (rr, cc), 1)
&gt;&gt;&gt; img
array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
       [0, 1, 0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 1, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 1, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 1, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 1, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 1, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
       [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]], dtype=uint8)
</pre> </dd>
</dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 2011 the scikit-image team<br>Licensed under the BSD 3-clause License.<br>
    <a href="http://scikit-image.org/docs/0.13.x/api/skimage.draw.html" class="_attribution-link" target="_blank">http://scikit-image.org/docs/0.13.x/api/skimage.draw.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
