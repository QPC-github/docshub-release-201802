
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>future.graph - Scikit-image - W3cubDocs</title>
  
  <meta name="description" content=" Perform Normalized Graph cut on the Region Adjacency Graph. ">
  <meta name="keywords" content="module, future, graph, -, scikit-image, scikit_image">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/scikit_image/api/skimage.future.graph/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-e0f881b0fce8cbe96f33dadc355b7159d5d2912911231446d60eb8f9caffa802.css">
  <script type="text/javascript" src="/assets/application-8fc46316434047265cd383f02b8e7f434ed7dec4a59f920dd633deef8d488d1b.js"></script>
  <script src="/json/scikit_image.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/scikit_image/" class="_nav-link" title="" style="margin-left:0;">scikit-image</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _sphinx">
				
<h1 id="module-future-graph">Module: future.graph</h1> <table class="longtable docutils" id="module-skimage.future.graph">   <tr>
<td>
<a class="reference internal" href="#skimage.future.graph.cut_normalized" title="skimage.future.graph.cut_normalized"><code>skimage.future.graph.cut_normalized</code></a>(labels, rag)</td> <td>Perform Normalized Graph cut on the Region Adjacency Graph.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.future.graph.cut_threshold" title="skimage.future.graph.cut_threshold"><code>skimage.future.graph.cut_threshold</code></a>(labels, …)</td> <td>Combine regions separated by weight less than threshold.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.future.graph.merge_hierarchical" title="skimage.future.graph.merge_hierarchical"><code>skimage.future.graph.merge_hierarchical</code></a>(…)</td> <td>Perform hierarchical merging of a RAG.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.future.graph.ncut" title="skimage.future.graph.ncut"><code>skimage.future.graph.ncut</code></a>(labels, rag[, …])</td> <td>Perform Normalized Graph cut on the Region Adjacency Graph.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.future.graph.rag_boundary" title="skimage.future.graph.rag_boundary"><code>skimage.future.graph.rag_boundary</code></a>(labels, …)</td> <td>Comouter RAG based on region boundaries</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.future.graph.rag_mean_color" title="skimage.future.graph.rag_mean_color"><code>skimage.future.graph.rag_mean_color</code></a>(image, …)</td> <td>Compute the Region Adjacency Graph using mean colors.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.future.graph.show_rag" title="skimage.future.graph.show_rag"><code>skimage.future.graph.show_rag</code></a>(labels, rag, img)</td> <td>Show a Region Adjacency Graph on an image.</td> </tr> <tr>
<td>
<a class="reference internal" href="#skimage.future.graph.RAG" title="skimage.future.graph.RAG"><code>skimage.future.graph.RAG</code></a>([label_image, …])</td> <td>The Region Adjacency Graph (RAG) of an image, subclasses</td> </tr> <tr>
<td><code>skimage.future.graph.graph_cut</code></td> <td></td> </tr> <tr>
<td><code>skimage.future.graph.graph_merge</code></td> <td></td> </tr> <tr>
<td><code>skimage.future.graph.rag</code></td> <td></td> </tr>  </table>  <h2 id="cut-normalized">cut_normalized</h2> <dl class="function"> <dt id="skimage.future.graph.cut_normalized">
<code>skimage.future.graph.cut_normalized(labels, rag, thresh=0.001, num_cuts=10, in_place=True, max_edge=1.0)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/future/graph/graph_cut.py#L76" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Perform Normalized Graph cut on the Region Adjacency Graph.</p> <p>Given an image’s labels and its similarity RAG, recursively perform a 2-way normalized cut on it. All nodes belonging to a subgraph that cannot be cut further are assigned a unique label in the output.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>labels</strong> : ndarray</p>  <p>The array of labels.</p>  <p><strong>rag</strong> : RAG</p>  <p>The region adjacency graph.</p>  <p><strong>thresh</strong> : float</p>  <p>The threshold. A subgraph won’t be further subdivided if the value of the N-cut exceeds <code>thresh</code>.</p>  <p><strong>num_cuts</strong> : int</p>  <p>The number or N-cuts to perform before determining the optimal one.</p>  <p><strong>in_place</strong> : bool</p>  <p>If set, modifies <code>rag</code> in place. For each node <code>n</code> the function will set a new attribute <code>rag.node[n]['ncut label']</code>.</p>  <p><strong>max_edge</strong> : float, optional</p>  <p>The maximum possible value of an edge in the RAG. This corresponds to an edge between identical regions. This is used to put self edges in the RAG.</p>  </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>out</strong> : ndarray</p>  <p>The new labeled array.</p>  </td> </tr>  </table> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="r289" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id1">[R289]</a></td>
<td>Shi, J.; Malik, J., “Normalized cuts and image segmentation”, Pattern Analysis and Machine Intelligence, IEEE Transactions on, vol. 22, no. 8, pp. 888-905, August 2000.</td>
</tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage import data, segmentation
&gt;&gt;&gt; from skimage.future import graph
&gt;&gt;&gt; img = data.astronaut()
&gt;&gt;&gt; labels = segmentation.slic(img, compactness=30, n_segments=400)
&gt;&gt;&gt; rag = graph.rag_mean_color(img, labels, mode='similarity')
&gt;&gt;&gt; new_labels = graph.cut_normalized(labels, rag)
</pre> </dd>
</dl>   <h2 id="cut-threshold">cut_threshold</h2> <dl class="function"> <dt id="skimage.future.graph.cut_threshold">
<code>skimage.future.graph.cut_threshold(labels, rag, thresh, in_place=True)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/future/graph/graph_cut.py#L12" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Combine regions separated by weight less than threshold.</p> <p>Given an image’s labels and its RAG, output new labels by combining regions whose nodes are separated by a weight less than the given threshold.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>labels</strong> : ndarray</p>  <p>The array of labels.</p>  <p><strong>rag</strong> : RAG</p>  <p>The region adjacency graph.</p>  <p><strong>thresh</strong> : float</p>  <p>The threshold. Regions connected by edges with smaller weights are combined.</p>  <p><strong>in_place</strong> : bool</p>  <p>If set, modifies <code>rag</code> in place. The function will remove the edges with weights less that <code>thresh</code>. If set to <code>False</code> the function makes a copy of <code>rag</code> before proceeding.</p>  </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>out</strong> : ndarray</p>  <p>The new labelled array.</p>  </td> </tr>  </table> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="r290" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id2">[R290]</a></td>
<td>Alain Tremeau and Philippe Colantoni “Regions Adjacency Graph Applied To Color Image Segmentation” <a class="reference external" href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.11.5274" target="_blank">http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.11.5274</a>
</td>
</tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage import data, segmentation
&gt;&gt;&gt; from skimage.future import graph
&gt;&gt;&gt; img = data.astronaut()
&gt;&gt;&gt; labels = segmentation.slic(img)
&gt;&gt;&gt; rag = graph.rag_mean_color(img, labels)
&gt;&gt;&gt; new_labels = graph.cut_threshold(labels, rag, 10)
</pre> </dd>
</dl>   <h2 id="merge-hierarchical">merge_hierarchical</h2> <dl class="function"> <dt id="skimage.future.graph.merge_hierarchical">
<code>skimage.future.graph.merge_hierarchical(labels, rag, thresh, rag_copy, in_place_merge, merge_func, weight_func)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/future/graph/graph_merge.py#L59" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Perform hierarchical merging of a RAG.</p> <p>Greedily merges the most similar pair of nodes until no edges lower than <code>thresh</code> remain.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>labels</strong> : ndarray</p>  <p>The array of labels.</p>  <p><strong>rag</strong> : RAG</p>  <p>The Region Adjacency Graph.</p>  <p><strong>thresh</strong> : float</p>  <p>Regions connected by an edge with weight smaller than <code>thresh</code> are merged.</p>  <p><strong>rag_copy</strong> : bool</p>  <p>If set, the RAG copied before modifying.</p>  <p><strong>in_place_merge</strong> : bool</p>  <p>If set, the nodes are merged in place. Otherwise, a new node is created for each merge..</p>  <p><strong>merge_func</strong> : callable</p>  <p>This function is called before merging two nodes. For the RAG <code>graph</code> while merging <code>src</code> and <code>dst</code>, it is called as follows <code>merge_func(graph, src, dst)</code>.</p>  <p><strong>weight_func</strong> : callable</p>  <p>The function to compute the new weights of the nodes adjacent to the merged node. This is directly supplied as the argument <code>weight_func</code> to <code>merge_nodes</code>.</p>  </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>out</strong> : ndarray</p>  <p>The new labeled array.</p>  </td> </tr>  </table> </dd>
</dl>   <h2 id="ncut">ncut</h2> <dl class="function"> <dt id="skimage.future.graph.ncut">
<code>skimage.future.graph.ncut(labels, rag, thresh=0.001, num_cuts=10, in_place=True, max_edge=1.0)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/future/graph/graph_cut.py#L76" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Perform Normalized Graph cut on the Region Adjacency Graph.</p> <p>Given an image’s labels and its similarity RAG, recursively perform a 2-way normalized cut on it. All nodes belonging to a subgraph that cannot be cut further are assigned a unique label in the output.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>labels</strong> : ndarray</p>  <p>The array of labels.</p>  <p><strong>rag</strong> : RAG</p>  <p>The region adjacency graph.</p>  <p><strong>thresh</strong> : float</p>  <p>The threshold. A subgraph won’t be further subdivided if the value of the N-cut exceeds <code>thresh</code>.</p>  <p><strong>num_cuts</strong> : int</p>  <p>The number or N-cuts to perform before determining the optimal one.</p>  <p><strong>in_place</strong> : bool</p>  <p>If set, modifies <code>rag</code> in place. For each node <code>n</code> the function will set a new attribute <code>rag.node[n]['ncut label']</code>.</p>  <p><strong>max_edge</strong> : float, optional</p>  <p>The maximum possible value of an edge in the RAG. This corresponds to an edge between identical regions. This is used to put self edges in the RAG.</p>  </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>out</strong> : ndarray</p>  <p>The new labeled array.</p>  </td> </tr>  </table> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="r291" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id3">[R291]</a></td>
<td>Shi, J.; Malik, J., “Normalized cuts and image segmentation”, Pattern Analysis and Machine Intelligence, IEEE Transactions on, vol. 22, no. 8, pp. 888-905, August 2000.</td>
</tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage import data, segmentation
&gt;&gt;&gt; from skimage.future import graph
&gt;&gt;&gt; img = data.astronaut()
&gt;&gt;&gt; labels = segmentation.slic(img, compactness=30, n_segments=400)
&gt;&gt;&gt; rag = graph.rag_mean_color(img, labels, mode='similarity')
&gt;&gt;&gt; new_labels = graph.cut_normalized(labels, rag)
</pre> </dd>
</dl>   <h2 id="rag-boundary">rag_boundary</h2> <dl class="function"> <dt id="skimage.future.graph.rag_boundary">
<code>skimage.future.graph.rag_boundary(labels, edge_map, connectivity=2)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/future/graph/rag.py#L389" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Comouter RAG based on region boundaries</p> <p>Given an image’s initial segmentation and its edge map this method constructs the corresponding Region Adjacency Graph (RAG). Each node in the RAG represents a set of pixels within the image with the same label in <code>labels</code>. The weight between two adjacent regions is the average value in <code>edge_map</code> along their boundary.</p> <dl class="docutils"> <dt>
<code>labels : ndarray</code> </dt> <dd>The labelled image.</dd> <dt>
<code>edge_map : ndarray</code> </dt> <dd>This should have the same shape as that of <code>labels</code>. For all pixels along the boundary between 2 adjacent regions, the average value of the corresponding pixels in <code>edge_map</code> is the edge weight between them.</dd> <dt>
<code>connectivity : int, optional</code> </dt> <dd>Pixels with a squared distance less than <code>connectivity</code> from each other are considered adjacent. It can range from 1 to <code>labels.ndim</code>. Its behavior is the same as <code>connectivity</code> parameter in <code>scipy.ndimage.filters.generate_binary_structure</code>.</dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage import data, segmentation, filters, color
&gt;&gt;&gt; from skimage.future import graph
&gt;&gt;&gt; img = data.chelsea()
&gt;&gt;&gt; labels = segmentation.slic(img)
&gt;&gt;&gt; edge_map = filters.sobel(color.rgb2gray(img))
&gt;&gt;&gt; rag = graph.rag_boundary(labels, edge_map)
</pre> </dd>
</dl>   <h2 id="rag-mean-color">rag_mean_color</h2> <dl class="function"> <dt id="skimage.future.graph.rag_mean_color">
<code>skimage.future.graph.rag_mean_color(image, labels, connectivity=2, mode='distance', sigma=255.0)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/future/graph/rag.py#L298" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Compute the Region Adjacency Graph using mean colors.</p> <p>Given an image and its initial segmentation, this method constructs the corresponding Region Adjacency Graph (RAG). Each node in the RAG represents a set of pixels within <code>image</code> with the same label in <code>labels</code>. The weight between two adjacent regions represents how similar or dissimilar two regions are depending on the <code>mode</code> parameter.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>image</strong> : ndarray, shape(M, N, […, P,] 3)</p>  <p>Input image.</p>  <p><strong>labels</strong> : ndarray, shape(M, N, […, P])</p>  <p>The labelled image. This should have one dimension less than <code>image</code>. If <code>image</code> has dimensions <code>(M, N, 3)</code> <code>labels</code> should have dimensions <code>(M, N)</code>.</p>  <p><strong>connectivity</strong> : int, optional</p>  <p>Pixels with a squared distance less than <code>connectivity</code> from each other are considered adjacent. It can range from 1 to <code>labels.ndim</code>. Its behavior is the same as <code>connectivity</code> parameter in <code>scipy.ndimage.generate_binary_structure</code>.</p>  <p><strong>mode</strong> : {‘distance’, ‘similarity’}, optional</p>  <p>The strategy to assign edge weights.</p>  <p>‘distance’ : The weight between two adjacent regions is the <span class="math">\(|c_1 - c_2|\)</span>, where <span class="math">\(c_1\)</span> and <span class="math">\(c_2\)</span> are the mean colors of the two regions. It represents the Euclidean distance in their average color.</p> <p>‘similarity’ : The weight between two adjacent is <span class="math">\(e^{-d^2/sigma}\)</span> where <span class="math">\(d=|c_1 - c_2|\)</span>, where <span class="math">\(c_1\)</span> and <span class="math">\(c_2\)</span> are the mean colors of the two regions. It represents how similar two regions are.</p>   <p><strong>sigma</strong> : float, optional</p>  <p>Used for computation when <code>mode</code> is “similarity”. It governs how close to each other two colors should be, for their corresponding edge weight to be significant. A very large value of <code>sigma</code> could make any two colors behave as though they were similar.</p>  </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>out</strong> : RAG</p>  <p>The region adjacency graph.</p>  </td> </tr>  </table> <h4 class="rubric">References</h4> <table class="docutils citation" frame="void" id="r292" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id4">[R292]</a></td>
<td>Alain Tremeau and Philippe Colantoni “Regions Adjacency Graph Applied To Color Image Segmentation” <a class="reference external" href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.11.5274" target="_blank">http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.11.5274</a>
</td>
</tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage import data, segmentation
&gt;&gt;&gt; from skimage.future import graph
&gt;&gt;&gt; img = data.astronaut()
&gt;&gt;&gt; labels = segmentation.slic(img)
&gt;&gt;&gt; rag = graph.rag_mean_color(img, labels)
</pre> </dd>
</dl>   <h2 id="show-rag">show_rag</h2> <dl class="function"> <dt id="skimage.future.graph.show_rag">
<code>skimage.future.graph.show_rag(labels, rag, img, border_color='black', edge_width=1.5, edge_cmap='magma', img_cmap='bone', in_place=True, ax=None)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/future/graph/rag.py#L453" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Show a Region Adjacency Graph on an image.</p> <p>Given a labelled image and its corresponding RAG, show the nodes and edges of the RAG on the image with the specified colors. Edges are displayed between the centroid of the 2 adjacent regions in the image.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>labels</strong> : ndarray, shape (M, N)</p>  <p>The labelled image.</p>  <p><strong>rag</strong> : RAG</p>  <p>The Region Adjacency Graph.</p>  <p><strong>img</strong> : ndarray, shape (M, N[, 3])</p>  <p>Input image. If <code>colormap</code> is <code>None</code>, the image should be in RGB format.</p>  <p><strong>border_color</strong> : color spec, optional</p>  <p>Color with which the borders between regions are drawn.</p>  <p><strong>edge_width</strong> : float, optional</p>  <p>The thickness with which the RAG edges are drawn.</p>  <p><strong>edge_cmap</strong> : <a class="reference external" href="http://matplotlib.org/api/_as_gen/matplotlib.colors.Colormap.html#matplotlib.colors.Colormap" title="(in Matplotlib v2.1.0)" target="_blank"><code>matplotlib.colors.Colormap</code></a>, optional</p>  <p>Any matplotlib colormap with which the edges are drawn.</p>  <p><strong>img_cmap</strong> : <a class="reference external" href="http://matplotlib.org/api/_as_gen/matplotlib.colors.Colormap.html#matplotlib.colors.Colormap" title="(in Matplotlib v2.1.0)" target="_blank"><code>matplotlib.colors.Colormap</code></a>, optional</p>  <p>Any matplotlib colormap with which the image is draw. If set to <code>None</code> the image is drawn as it is.</p>  <p><strong>in_place</strong> : bool, optional</p>  <p>If set, the RAG is modified in place. For each node <code>n</code> the function will set a new attribute <code>rag.node[n]['centroid']</code>.</p>  <p><strong>ax</strong> : <a class="reference external" href="http://matplotlib.org/api/axes_api.html#matplotlib.axes.Axes" title="(in Matplotlib v2.1.0)" target="_blank"><code>matplotlib.axes.Axes</code></a>, optional</p>  <p>The axes to draw on. If not specified, new axes are created and drawn on.</p>  </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>lc</strong> : <a class="reference external" href="http://matplotlib.org/api/collections_api.html#matplotlib.collections.LineCollection" title="(in Matplotlib v2.1.0)" target="_blank"><code>matplotlib.collections.LineCollection</code></a></p>  <p>A colection of lines that represent the edges of the graph. It can be passed to the <a class="reference external" href="http://matplotlib.org/api/_as_gen/matplotlib.figure.Figure.html#matplotlib.figure.Figure.colorbar" title="(in Matplotlib v2.1.0)" target="_blank"><code>matplotlib.figure.Figure.colorbar()</code></a> function.</p>  </td> </tr>  </table> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage import data, segmentation
&gt;&gt;&gt; from skimage.future import graph
&gt;&gt;&gt; img = data.coffee()
&gt;&gt;&gt; labels = segmentation.slic(img)
&gt;&gt;&gt; g =  graph.rag_mean_color(img, labels)
&gt;&gt;&gt; lc = graph.show_rag(labels, g, img)
&gt;&gt;&gt; cbar = plt.colorbar(lc)
</pre> </dd>
</dl>   <h2 id="rag">RAG</h2> <dl class="class"> <dt id="skimage.future.graph.RAG">
<code>class skimage.future.graph.RAG(label_image=None, connectivity=1, data=None, **attr)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/future/graph/rag.py#L110" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Bases: <code>networkx.classes.graph.Graph</code></p> <p>The Region Adjacency Graph (RAG) of an image, subclasses <a class="reference external" href="http://networkx.github.io/documentation/latest/reference/classes.graph.html" target="_blank">networx.Graph</a></p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>label_image</strong> : array of int</p>  <p>An initial segmentation, with each region labeled as a different integer. Every unique value in <code>label_image</code> will correspond to a node in the graph.</p>  <p><strong>connectivity</strong> : int in {1, …, <code>label_image.ndim</code>}, optional</p>  <p>The connectivity between pixels in <code>label_image</code>. For a 2D image, a connectivity of 1 corresponds to immediate neighbors up, down, left, and right, while a connectivity of 2 also includes diagonal neighbors. See <code>scipy.ndimage.generate_binary_structure</code>.</p>  <p><strong>data</strong> : networkx Graph specification, optional</p>  <p>Initial or additional edges to pass to the NetworkX Graph constructor. See <code>networkx.Graph</code>. Valid edge specifications include edge list (list of tuples), NumPy arrays, and SciPy sparse matrices.</p>  <p><strong>**attr</strong> : keyword arguments, optional</p>  <p>Additional attributes to add to the graph.</p>  </td> </tr>  </table> <dl class="method"> <dt id="skimage.future.graph.RAG.__init__">
<code>__init__(label_image=None, connectivity=1, data=None, **attr)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/future/graph/rag.py#L136" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="method"> <dt id="skimage.future.graph.RAG.add_edge">
<code>add_edge(u, v, attr_dict=None, **attr)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/future/graph/rag.py#L236" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Add an edge between <code>u</code> and <code>v</code> while updating max node id.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <p class="last"><code>networkx.Graph.add_edge()</code>.</p> </div> </dd>
</dl> <dl class="method"> <dt id="skimage.future.graph.RAG.add_node">
<code>add_node(n, attr_dict=None, **attr)</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/future/graph/rag.py#L225" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Add node <code>n</code> while updating the maximum node id.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <p class="last"><code>networkx.Graph.add_node()</code>.</p> </div> </dd>
</dl> <dl class="method"> <dt id="skimage.future.graph.RAG.copy">
<code>copy()</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/future/graph/rag.py#L247" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Copy the graph with its max node id.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <p class="last"><code>networkx.Graph.copy()</code>.</p> </div> </dd>
</dl> <dl class="method"> <dt id="skimage.future.graph.RAG.fresh_copy">
<code>fresh_copy()</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/future/graph/rag.py#L255" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return a fresh copy graph with the same data structure.</p> <p>A fresh copy has no nodes, edges or graph attributes. It is the same data structure as the current graph. This method is typically used to create an empty version of the graph.</p> <p>This is required when subclassing Graph with networkx v2 and does not cause problems for v1. Here is more detail from the network migrating from 1.x to 2.x document:</p> <pre data-language="python">With the new GraphViews (SubGraph, ReversedGraph, etc)
you can't assume that ``G.__class__()`` will create a new
instance of the same graph type as ``G``. In fact, the
call signature for ``__class__`` differs depending on
whether ``G`` is a view or a base class. For v2.x you
should use ``G.fresh_copy()`` to create a null graph of
the correct type---ready to fill with nodes and edges.
</pre> </dd>
</dl> <dl class="method"> <dt id="skimage.future.graph.RAG.merge_nodes">
<code>merge_nodes(src, dst, weight_func=&lt;function min_weight&gt;, in_place=True, extra_arguments=[], extra_keywords={})</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/future/graph/rag.py#L163" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Merge node <code>src</code> and <code>dst</code>.</p> <p>The new combined node is adjacent to all the neighbors of <code>src</code> and <code>dst</code>. <code>weight_func</code> is called to decide the weight of edges incident on the new node.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Parameters:</th>
<td class="field-body">
<p class="first"><strong>src, dst</strong> : int</p>  <p>Nodes to be merged.</p>  <p><strong>weight_func</strong> : callable, optional</p>  <p>Function to decide the attributes of edges incident on the new node. For each neighbor <code>n</code> for <code>src and `dst</code>, <code>weight_func</code> will be called as follows: <code>weight_func(src, dst, n, *extra_arguments, **extra_keywords)</code>. <code>src</code>, <code>dst</code> and <code>n</code> are IDs of vertices in the RAG object which is in turn a subclass of <code>networkx.Graph</code>. It is expected to return a dict of attributes of the resulting edge.</p>  <p><strong>in_place</strong> : bool, optional</p>  <p>If set to <code>True</code>, the merged node has the id <code>dst</code>, else merged node has a new id which is returned.</p>  <p><strong>extra_arguments</strong> : sequence, optional</p>  <p>The sequence of extra positional arguments passed to <code>weight_func</code>.</p>  <p><strong>extra_keywords</strong> : dictionary, optional</p>  <p>The dict of keyword arguments passed to the <code>weight_func</code>.</p>  </td> </tr> <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>id</strong> : int</p>  <p>The id of the new node.</p>  </td> </tr>  </table> <h4 class="rubric">Notes</h4> <p>If <code>in_place</code> is <code>False</code> the resulting node has a new id, rather than <code>dst</code>.</p> </dd>
</dl> <dl class="method"> <dt id="skimage.future.graph.RAG.next_id">
<code>next_id()</code> <a class="reference external" href="http://github.com/scikit-image/scikit-image/blob/v0.13.1/skimage/future/graph/rag.py#L277" target="_blank"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Returns the <code>id</code> for the new node to be inserted.</p> <p>The current implementation returns one more than the maximum <code>id</code>.</p> <table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Returns:</th>
<td class="field-body">
<p class="first"><strong>id</strong> : int</p>  <p>The <code>id</code> of the new node to be inserted.</p>  </td> </tr>  </table> </dd>
</dl> </dd>
</dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 2011 the scikit-image team<br>Licensed under the BSD 3-clause License.<br>
    <a href="http://scikit-image.org/docs/0.13.x/api/skimage.future.graph.html" class="_attribution-link" target="_blank">http://scikit-image.org/docs/0.13.x/api/skimage.future.graph.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
