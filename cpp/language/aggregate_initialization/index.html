
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Aggregate Initialization - C++ - W3cubDocs</title>
  
  <meta name="description" content=" Initializes an aggregate from braced-init-list. ">
  <meta name="keywords" content="aggregate, initialization, -, c++, cpp">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/cpp/language/aggregate_initialization/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-e0f881b0fce8cbe96f33dadc355b7159d5d2912911231446d60eb8f9caffa802.css">
  <script type="text/javascript" src="/assets/application-8fc46316434047265cd383f02b8e7f434ed7dec4a59f920dd633deef8d488d1b.js"></script>
  <script src="/json/cpp.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/cpp/" class="_nav-link" title="" style="margin-left:0;">C++</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _c">
				
<h1 id="firstHeading" class="firstHeading">aggregate initialization</h1>            <p>Initializes an aggregate from braced-init-list.</p>
<h3 id="Syntax">Syntax</h3> <table class="t-sdsc-begin">  <tr class="t-sdsc"> <td> <span class="t-spar">T</span> <span class="t-spar">object</span> <code>= {</code><span class="t-spar">arg1, arg2, ...</span><code>};</code> </td> <td> (1) </td> <td class="t-sdsc-nopad"> </td>
</tr>  <tr class="t-sdsc"> <td> <span class="t-spar">T</span> <span class="t-spar">object</span> <code> {</code><span class="t-spar">arg1, arg2, ...</span><code>};</code> </td> <td> (2) </td> <td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td>
</tr> 
</table> <h3 id="Explanation">Explanation</h3> <p>Aggregate initialization is a form of <a href="../list_initialization/" title="cpp/language/list initialization">list-initialization</a>, which initializes <i>aggregates</i>.</p>
<p>An aggregate is one of the following types:</p>
<ul>
<li> array type </li>
<li> class type (typically, <code>struct</code> or <code>union</code>), that has </li>
<ul>
<li> no private or protected non-static data members </li>
<li> no user-provided<span class="t-rev-inl t-since-cxx17"><span>, inherited, or <code>explicit</code></span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span> constructors <span class="t-rev-inl t-since-cxx11"><span>(explicitly defaulted or deleted constructors are allowed)</span> <span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span> </li>
<li> no <span class="t-rev-inl t-since-cxx17"><span>virtual, private, or protected</span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span> base classes </li>
<li> no virtual member functions </li>
</ul>
</ul>  <table class="t-rev-begin"> <tr class="t-rev t-since-cxx11 t-until-cxx14">
<td> <ul><li> no <a href="../data_members/#Member_initialization" title="cpp/language/data members">default member initializers</a> </li></ul> </td> <td>
<span class="t-mark-rev t-since-cxx11">(since C++11)</span><br><span class="t-mark-rev t-until-cxx14">(until C++14)</span>
</td>
</tr> </table> <p>The effects of aggregate initialization are:</p>
<ul>
<li> Each <span class="t-rev-inl t-since-cxx17"><span>direct public base,</span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span> array element, or non-static class member, in order of array subscript/appearance in the class definition, is <a href="../copy_initialization/" title="cpp/language/copy initialization">copy-initialized</a> from the corresponding clause of the initializer list. </li>
<li> If the initializer clause is an expression, implicit conversions are allowed as per copy-initialization<span class="t-rev-inl t-since-cxx11"><span>, except if they are narrowing (as in <a href="../list_initialization/" title="cpp/language/list initialization">list-initialization</a>)</span> <span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span>. </li>
<li> If the initializer clause is a nested braced-init-list (which is not an expression), the corresponding class member <span class="t-rev-inl t-since-cxx17"><span>or public base</span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span> is <a href="../list_initialization/" title="cpp/language/list initialization">list-initialized</a> from that clause: aggregate initialization is recursive. </li>
<li> If the object is an array of unknown size, and the supplied brace-enclosed initializer list has <code>n</code> clauses, the size of the array is <code>n</code> </li>
<li> Static data members and unnamed bit-fields are skipped during aggregate initialization. </li>
<li> If the number of initializer clauses exceeds the number of members <span class="t-rev-inl t-since-cxx17"><span>and bases</span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span> to initialize, the program is ill-formed (compiler error) </li>
</ul>      <table class="t-rev-begin"> <tr class="t-rev t-until-cxx11">
<td> <ul><li> If the number of initializer clauses is less than the number of members or initializer list is completely empty, the remaining members are <a href="../value_initialization/" title="cpp/language/value initialization">value-initialized</a>. If a member of a reference type is one of these remaining members, the program is ill-formed. </li></ul> </td> <td><span class="t-mark-rev t-until-cxx11">(until C++11)</span></td>
</tr> <tr class="t-rev t-since-cxx11">
<td> <ul><li> If the number of initializer clauses is less than the number of members <span class="t-rev-inl t-since-cxx17"><span>and bases</span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span> or initializer list is completely empty, the remaining members <span class="t-rev-inl t-since-cxx17"><span>and bases</span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span> are initialized <span class="t-rev-inl t-since-cxx14"><span>by their <a href="../data_members/#Member_initialization" title="cpp/language/data members">default initializers</a>, if provided in the class definition, and otherwise</span> <span><span class="t-mark-rev t-since-cxx14">(since C++14)</span></span></span> by empty lists, in accordance with the usual <a href="../list_initialization/" title="cpp/language/list initialization">list-initialization</a> rules (which performs value-initialization for non-class types and non-aggregate classes with default constructors, and aggregate initialization for aggregates). If a member of a reference type is one of these remaining members, the program is ill-formed.</li></ul>
</td> <td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td>
</tr> </table> <ul>
<li> <span class="t-rev-inl t-until-cxx14"><span>If the aggregate initialization uses the form with the equal sign (<code>T a = {args..}</code>),</span> <span><span class="t-mark-rev t-until-cxx14">(until C++14)</span></span></span> the braces around the nested initializer lists may be elided (omitted), in which case as many initializer clauses as necessary are used to initialize every member or element of the corresponding subaggregate, and the subsequent initializer clauses are used to initialize the following members of the object. However, if the object has a sub-aggregate without any members (an empty struct, or a struct holding only static members), brace elision is not allowed, and an empty nested list <code>{} </code> must be used. </li>
<li> When a union is initialized by aggregate initialization, only its first non-static data member is initialized. </li>
</ul>  <h3 id="Character_arrays">Character arrays</h3> <p>Arrays of character types (<code>char</code>, <code>signed char</code>, <code>unsigned char</code>, <code>char16_t</code>, <code>char32_t</code>, <code>wchar_t</code>) can be initialized from an appropriate <a href="../string_literal/" title="cpp/language/string literal">string literal</a>, optionally enclosed in braces. Successive characters of the string literal (which includes the implicit terminating null character) initialize the elements of the array. If the size of the array is specified and it is larger than the number of characters in the string literal, the remaining characters are zero-initialized.</p>
<div class="cpp source-cpp"><pre data-language="cpp">char a[] = "abc";
// equivalent to char a[4] = {'a', 'b', 'c', '\0'};
 
//  unsigned char b[3] = "abc"; // Error: initializer string too long
unsigned char b[5]{"abc"};
// equivalent to unsigned char b[5] = {'a', 'b', 'c', '\0', '\0'};
 
wchar_t c[] = {L"кошка"}; // optional braces
// equivalent to wchar_t c[6] = {L'к', L'о', L'ш', L'к', L'а', L'\0'};</pre></div> <h3 id="Notes">Notes</h3> <p>An aggregate class or array may include non-aggregate <span class="t-rev-inl t-since-cxx17"><span>public bases</span> <span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span>, members, or elements, which are initialized as described above (e.g. copy-initialization from the corresponding initializer clause).</p>
<p>Until C++11, narrowing conversions were permitted in aggregate initialization, but they are no longer allowed.</p>
<p>Until C++11, aggregate initialization could not be used in a constructor initializer list due to syntax restrictions.</p>
<p>Until C++14, the direct-initialization form <code>T a {args..}</code> did not permit brace elision.</p>
<p>In C, character array of size one less than the size of the string literal may be initialized from a string literal; the resulting array is not null-terminated. This is not allowed in C++.</p>
<h3 id="Example">Example</h3> <div class="t-example"> <div class="cpp source-cpp"><pre data-language="cpp">#include &lt;string&gt;
#include &lt;array&gt;
struct S {
    int x;
    struct Foo {
        int i;
        int j;
        int a[3];
    } b;
};
 
union U {
    int a;
    const char* b;
};
 
int main()
{
    S s1 = { 1, { 2, 3, {4, 5, 6} } };
    S s2 = { 1, 2, 3, 4, 5, 6}; // same, but with brace elision
    S s3{1, {2, 3, {4, 5, 6} } }; // same, using direct-list-initialization syntax
    S s4{1, 2, 3, 4, 5, 6}; // error in C++11: brace-elision only allowed with equals sign
                            // okay in C++14
 
    int ar[] = {1,2,3}; // ar is int[3]
//  char cr[3] = {'a', 'b', 'c', 'd'}; // too many initializer clauses
    char cr[3] = {'a'}; // array initialized as {'a', '\0', '\0'}
 
    int ar2d1[2][2] = {{1, 2}, {3, 4}}; // fully-braced 2D array: {1, 2}
                                        //                        {3, 4}
    int ar2d2[2][2] = {1, 2, 3, 4}; // brace elision: {1, 2}
                                    //                {3, 4}
    int ar2d3[2][2] = {{1}, {2}};   // only first column: {1, 0}
                                    //                    {2, 0}
 
    std::array&lt;int, 3&gt; std_ar2{ {1,2,3} };    // std::array is an aggregate
    std::array&lt;int, 3&gt; std_ar1 = {1, 2, 3}; // brace-elision okay
 
    int ai[] = { 1, 2.0 }; // narrowing conversion from double to int:
                           // error in C++11, okay in C++03
 
    std::string ars[] = {std::string("one"), // copy-initialization
                         "two",              // conversion, then copy-initialization
                         {'t', 'h', 'r', 'e', 'e'} }; // list-initialization
 
    U u1 = {1}; // OK, first member of the union
//    U u2 = { 0, "asdf" }; // error: too many initializers for union
//    U u3 = { "asdf" }; // error: invalid conversion to int
 
}
 
// aggregate
struct base1 { int b1, b2 = 42; };
// non-aggregate
struct base2 {
  base2() : b3(42) {}
  int b3;
};
// aggregate in C++17
struct derived : base1, base2 { int d; };
derived d1{ {1, 2}, { }, 4}; // d1.b1 = 1, d1.b2 = 2,  d1.b3 = 42, d1.d = 4
derived d2{ {    }, { }, 4}; // d2.b1 = 0, d2.b2 = 42, d2.b3 = 42, d2.d = 4</pre></div> </div> <h3 id="See_also">See also</h3> <ul><li> <a href="../list_initialization/" title="cpp/language/list initialization">list initialization</a> </li></ul>           <div class="_attribution">
  <p class="_attribution-p">
    © cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="http://en.cppreference.com/w/cpp/language/aggregate_initialization" class="_attribution-link" target="_blank">http://en.cppreference.com/w/cpp/language/aggregate_initialization</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
