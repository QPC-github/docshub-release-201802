
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Ecto.Changeset - Phoenix - W3cubDocs</title>
  
  <meta name="description" content=" Changesets allow filtering, casting, validation and definition of constraints when manipulating structs. ">
  <meta name="keywords" content="ecto, changeset, summary, types, functions, -, phoenix">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/phoenix/ecto/ecto.changeset/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-e0f881b0fce8cbe96f33dadc355b7159d5d2912911231446d60eb8f9caffa802.css">
  <script type="text/javascript" src="/assets/application-8fc46316434047265cd383f02b8e7f434ed7dec4a59f920dd633deef8d488d1b.js"></script>
  <script src="/json/phoenix.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/phoenix/" class="_nav-link" title="" style="margin-left:0;">Phoenix</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _elixir">
				
<h1>  Ecto.Changeset  </h1>  <p>Changesets allow filtering, casting, validation and definition of constraints when manipulating structs.</p> <p>There is an example of working with changesets in the introductory documentation in the <a href="../ecto/"><code class="inline">Ecto</code></a> module. The functions <a href="#cast/4"><code class="inline">cast/4</code></a> and <a href="#change/2"><code class="inline">change/2</code></a> are the usual entry points for creating changesets. The first one is used to cast and validate external parameters, such as parameters sent through a form, API, command line, etc. The second one is used to change data directly from your application.</p> <p>The remaining functions in this module, such as validations, constraints, association handling, are about manipulating changesets. Let’s discuss some of this extra functionality.</p> <h2 id="module-external-vs-internal-data" class="section-heading">  External vs internal data </h2> <p>Changesets allow working with both kinds of data:</p> <ul> <li>
<p>internal to the application - for example programatically generated, or coming from other subsystems. This use case is primarily covered by the <a href="#change/2"><code class="inline">change/2</code></a> and <a href="#put_change/3"><code class="inline">put_change/3</code></a> functions.</p> </li> <li>
<p>external to the application - for example data provided by the user in a form that needs to be type-converted and properly validated. This use case is primarily covered by the <a href="#cast/4"><code class="inline">cast/4</code></a> function.</p> </li> </ul> <h2 id="module-validations-and-constraints" class="section-heading">  Validations and constraints </h2> <p>Ecto changesets provide both validations and constraints which are ultimately turned into errors in case something goes wrong.</p> <p>The difference between them is that most validations can be executed without a need to interact with the database and, therefore, are always executed before attempting to insert or update the entry in the database. Some validations may happen against the database but they are inherently unsafe. Those validations start with a <code class="inline">unsafe_</code> prefix, such as <a href="#unsafe_validate_unique/3"><code class="inline">unsafe_validate_unique/3</code></a>.</p> <p>On the other hand, constraints rely on the database and are always safe. As a consequence, validations are always checked before constraints. Constraints won’t even be checked in case validations failed.</p> <p>Let’s see an example:</p> <pre data-language="elixir"><code class="elixir">defmodule User do
  use Ecto.Schema
  import Ecto.Changeset

  schema "users" do
    field :name
    field :email
    field :age, :integer
  end

  def changeset(user, params \\ %{}) do
    user
    |&gt; cast(params, [:name, :email, :age])
    |&gt; validate_required([:name, :email])
    |&gt; validate_format(:email, ~r/@/)
    |&gt; validate_inclusion(:age, 18..100)
    |&gt; unique_constraint(:email)
  end
end</code></pre> <p>In the <code class="inline">changeset/2</code> function above, we define three validations. They check that <code class="inline">name</code> and <code class="inline">email</code> fields are present in the changeset, the e-mail is of the specified format, and the age is between 18 and 100 - as well as a unique constraint in the email field.</p> <p>Let’s suppose the e-mail is given but the age is invalid. The changeset would have the following errors:</p> <pre data-language="elixir"><code class="elixir">changeset = User.changeset(%User{}, %{age: 0, email: "mary@example.com"})
{:error, changeset} = Repo.insert(changeset)
changeset.errors #=&gt; [age: {"is invalid", []}, name: {"can't be blank", []}]</code></pre> <p>In this case, we haven’t checked the unique constraint in the e-mail field because the data did not validate. Let’s fix the age and assume, however, that the e-mail already exists in the database:</p> <pre data-language="elixir"><code class="elixir">changeset = User.changeset(%User{}, %{age: 42, email: "mary@example.com"})
{:error, changeset} = Repo.insert(changeset)
changeset.errors #=&gt; [email: {"has already been taken", []}]</code></pre> <p>Validations and constraints define an explicit boundary when the check happens. By moving constraints to the database, we also provide a safe, correct and data-race free means of checking the user input.</p> <h2 id="module-empty-values" class="section-heading">  Empty values </h2> <p>Many times, the data given on cast needs to be further pruned, specially regarding empty values. For example, if you are gathering data to be cast from the command line or through an HTML form or any other text-based format, it is likely those means cannot express nil values. For those reasons, changesets include the concept of empty values, which are values that will be automatically converted to the field’s default value on <a href="#cast/4"><code class="inline">cast/4</code></a>. Those values are stored in the changeset <code class="inline">empty_values</code> field and default to <code class="inline">[""]</code>.</p> <h2 id="module-associations-embeds-and-on-replace" class="section-heading">  Associations, embeds and on replace </h2> <p>Using changesets you can work with associations as well as with embedded structs. Changesets provide a convenient way to working with associations as whole values - for example considering the entire list of has_many associations and not focusing just on a single one. Two main functions that provide this functionality are <a href="#cast_assoc/3"><code class="inline">cast_assoc/3</code></a> for working with external data, and <a href="#put_assoc/3"><code class="inline">put_assoc/3</code></a> for working with internal data - the difference between those two functions is analogical to the difference between <a href="#cast/4"><code class="inline">cast/4</code></a> and <a href="#change/2"><code class="inline">change/2</code></a>.</p> <p>Sometimes related data may be replaced by incoming data and by default Ecto won’t allow such. Such behaviour can be changed when defining the relation by setting <code class="inline">:on_replace</code> option in your association/embed definition according to the values below:</p> <ul> <li>
<code class="inline">:raise</code> (default) - do not allow removing association or embedded data via parent changesets </li> <li>
<code class="inline">:mark_as_invalid</code> - if attempting to remove the association or embedded data via parent changeset - an error will be added to the parent changeset, and it will be marked as invalid </li> <li>
<code class="inline">:nilify</code> - sets owner reference column to <code class="inline">nil</code> (available only for associations) </li> <li>
<code class="inline">:update</code> - updates the association, available only for has_one and belongs_to. This option will update all the fields given to the changeset including the id for the association </li> <li>
<code class="inline">:delete</code> - removes the association or related data from the database. This option has to be used carefully </li> </ul> <p>The <code class="inline">:delete</code> option in particular must be used carefully as it would allow users to delete any associated data. If you need deletion, it is often preferred to add a separate boolean virtual field to the changeset function that will allow you to manually mark it for deletion, as in the example below:</p> <pre data-language="elixir"><code class="elixir">defmodule Comment do
  use Ecto.Schema
  import Ecto.Changeset

  schema "comments" do
    field :body, :string
    field :delete, :boolean, virtual: true
  end

  def changeset(comment, params) do
    cast(comment, params, [:body, :delete])
    |&gt; maybe_mark_for_deletion
  end

  defp maybe_mark_for_deletion(changeset) do
    if get_change(changeset, :delete) do
      %{changeset | action: :delete}
    else
      changeset
    end
  end
end</code></pre> <h2 id="module-schemaless-changesets" class="section-heading">  Schemaless changesets </h2> <p>In the changeset examples so far, we have always used changesets to validate and cast data contained in a struct, such as the <code class="inline">%User{}</code> struct defined by the <code class="inline">User</code> module.</p> <p>However, changesets can also be used with data in a plain map, by passing a tuple containing both the data and the supported types:</p> <pre data-language="elixir"><code class="elixir">data  = %{}
types = %{first_name: :string, last_name: :string, email: :string}

changeset =
  {data, types}
  |&gt; Ecto.Changeset.cast(params["sign_up"], Map.keys(types))
  |&gt; validate_required(...)
  |&gt; validate_length(...)</code></pre> <p>Such functionality makes Ecto extremely useful to cast, validate and prune data even if it is not meant to be persisted to the database.</p> <h3 id="module-changeset-actions" class="section-heading">  Changeset actions </h3> <p>Changesets have an action field which is usually set by <a href="../ecto.repo/"><code class="inline">Ecto.Repo</code></a> whenever one of the operations such as <code class="inline">insert</code> or <code class="inline">update</code> is called:</p> <pre data-language="elixir"><code class="elixir">changeset = User.changeset(%User{}, %{age: 42, email: "mary@example.com"})
{:error, changeset} = Repo.insert(changeset)
changeset.action
#=&gt; :insert</code></pre> <p>This means that when working with changesets that are not meant to be persisted to the database, such as schemaless changesets, you may need to explicitly set the action to one specific value. Frameworks such as Phoenix uses the action value to define how a HTML forms should act.</p> <p>Instead of setting the action manually, you may use <a href="#apply_action/2"><code class="inline">apply_action/2</code></a> that emulates operations such as <code class="inline">Repo.insert</code>. <a href="#apply_action/2"><code class="inline">apply_action/2</code></a> will return <code class="inline">{:ok, changes}</code> if the changeset is valid or <code class="inline">{:error, changeset}</code>, with the given <code class="inline">action</code> set in the changeset in case of errors.</p> <h2 id="module-the-ecto-changeset-struct" class="section-heading">  The Ecto.Changeset struct </h2> <p>The fields are:</p> <ul> <li>
<code class="inline">valid?</code> - Stores if the changeset is valid </li> <li>
<code class="inline">data</code> - The changeset source data, for example, a struct </li> <li>
<code class="inline">params</code> - The parameters as given on changeset creation </li> <li>
<code class="inline">changes</code> - The <code class="inline">changes</code> from parameters that were approved in casting </li> <li>
<code class="inline">errors</code> - All errors from validations </li> <li>
<code class="inline">validations</code> - All validations performed in the changeset </li> <li>
<code class="inline">constraints</code> - All constraints defined in the changeset </li> <li>
<code class="inline">required</code> - All required fields as a list of atoms </li> <li>
<code class="inline">filters</code> - Filters (as a map <code class="inline">%{field =&gt; value}</code>) to narrow the scope of update/delete queries </li> <li>
<code class="inline">action</code> - The action to be performed with the changeset </li> <li>
<code class="inline">types</code> - Cache of the data’s field types </li> <li>
<code class="inline">empty_values</code> - A list of values to be considered empty </li> <li>
<code class="inline">repo</code> - The repository applying the changeset (only set after a Repo function is called) </li> <li>
<code class="inline">repo_opts</code> - A keyword list of options given to the underlying repository operation </li> </ul>   <h1 class="section-heading" id="summary">  Summary </h1> <h2> Types </h2>
<dl class="summary-types summary">   <dt class="summary-signature"> <a href="#t:action/0">action()</a> </dt>   <dt class="summary-signature"> <a href="#t:constraint/0">constraint()</a> </dt>   <dt class="summary-signature"> <a href="#t:data/0">data()</a> </dt>   <dt class="summary-signature"> <a href="#t:error/0">error()</a> </dt>   <dt class="summary-signature"> <a href="#t:t/0">t()</a> </dt>   <dt class="summary-signature"> <a href="#t:types/0">types()</a> </dt>  </dl> <h2> Functions </h2>
<dl class="summary-functions summary">   <dt class="summary-signature"> <a href="#add_error/4">add_error(changeset, key, message, keys \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Adds an error to the changeset</p> </dd>   <dt class="summary-signature"> <a href="#apply_action/2">apply_action(changeset, action)</a> </dt> <dd class="summary-synopsis">
<p>Applies the changeset action only if the changes are valid</p> </dd>   <dt class="summary-signature"> <a href="#apply_changes/1">apply_changes(changeset)</a> </dt> <dd class="summary-synopsis">
<p>Applies the changeset changes to the changeset data</p> </dd>   <dt class="summary-signature"> <a href="#assoc_constraint/3">assoc_constraint(changeset, assoc, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Checks the associated field exists</p> </dd>   <dt class="summary-signature"> <a href="#cast/4">cast(data, params, permitted, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Applies the given <code class="inline">params</code> as changes for the given <code class="inline">data</code> according to the given set of keys. Returns a changeset</p> </dd>   <dt class="summary-signature"> <a href="#cast_assoc/3">cast_assoc(changeset, name, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Casts the given association with the changeset parameters</p> </dd>   <dt class="summary-signature"> <a href="#cast_embed/3">cast_embed(changeset, name, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Casts the given embed with the changeset parameters</p> </dd>   <dt class="summary-signature"> <a href="#change/2">change(data, changes \\ %{})</a> </dt> <dd class="summary-synopsis">
<p>Wraps the given data in a changeset or adds changes to a changeset</p> </dd>   <dt class="summary-signature"> <a href="#check_constraint/3">check_constraint(changeset, field, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Checks for a check constraint in the given field</p> </dd>   <dt class="summary-signature"> <a href="#delete_change/2">delete_change(changeset, key)</a> </dt> <dd class="summary-synopsis">
<p>Deletes a change with the given key</p> </dd>   <dt class="summary-signature"> <a href="#exclusion_constraint/3">exclusion_constraint(changeset, field, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Checks for an exclusion constraint in the given field</p> </dd>   <dt class="summary-signature"> <a href="#fetch_change/2">fetch_change(changeset, key)</a> </dt> <dd class="summary-synopsis">
<p>Fetches a change from the given changeset</p> </dd>   <dt class="summary-signature"> <a href="#fetch_field/2">fetch_field(changeset, key)</a> </dt> <dd class="summary-synopsis">
<p>Fetches the given field from changes or from the data</p> </dd>   <dt class="summary-signature"> <a href="#force_change/3">force_change(changeset, key, value)</a> </dt> <dd class="summary-synopsis">
<p>Forces a change on the given <code class="inline">key</code> with <code class="inline">value</code></p> </dd>   <dt class="summary-signature"> <a href="#foreign_key_constraint/3">foreign_key_constraint(changeset, field, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Checks for foreign key constraint in the given field</p> </dd>   <dt class="summary-signature"> <a href="#get_change/3">get_change(changeset, key, default \\ nil)</a> </dt> <dd class="summary-synopsis">
<p>Gets a change or returns a default value</p> </dd>   <dt class="summary-signature"> <a href="#get_field/3">get_field(changeset, key, default \\ nil)</a> </dt> <dd class="summary-synopsis">
<p>Gets a field from changes or from the data</p> </dd>   <dt class="summary-signature"> <a href="#merge/2">merge(changeset1, changeset2)</a> </dt> <dd class="summary-synopsis">
<p>Merges two changesets</p> </dd>   <dt class="summary-signature"> <a href="#no_assoc_constraint/3">no_assoc_constraint(changeset, assoc, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Checks the associated field does not exist</p> </dd>   <dt class="summary-signature"> <a href="#optimistic_lock/3">optimistic_lock(data_or_changeset, field, incrementer \\ &amp;(&amp;1 + 1))</a> </dt> <dd class="summary-synopsis">
<p>Applies optimistic locking to the changeset</p> </dd>   <dt class="summary-signature"> <a href="#prepare_changes/2">prepare_changes(changeset, function)</a> </dt> <dd class="summary-synopsis">
<p>Provides a function to run before emitting changes to the repository</p> </dd>   <dt class="summary-signature"> <a href="#put_assoc/4">put_assoc(changeset, name, value, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Puts the given association as a change in the changeset</p> </dd>   <dt class="summary-signature"> <a href="#put_change/3">put_change(changeset, key, value)</a> </dt> <dd class="summary-synopsis">
<p>Puts a change on the given <code class="inline">key</code> with <code class="inline">value</code></p> </dd>   <dt class="summary-signature"> <a href="#put_embed/4">put_embed(changeset, name, value, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Puts the given embed as a change in the changeset</p> </dd>   <dt class="summary-signature"> <a href="#traverse_errors/2">traverse_errors(changeset, msg_func)</a> </dt> <dd class="summary-synopsis">
<p>Traverses changeset errors and applies the given function to error messages</p> </dd>   <dt class="summary-signature"> <a href="#unique_constraint/3">unique_constraint(changeset, field, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Checks for a unique constraint in the given field</p> </dd>   <dt class="summary-signature"> <a href="#unsafe_validate_unique/4">unsafe_validate_unique(changeset, fields, repo, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Validates that no existing record with a different primary key has the same values for these fields</p> </dd>   <dt class="summary-signature"> <a href="#update_change/3">update_change(changeset, key, function)</a> </dt> <dd class="summary-synopsis">
<p>Updates a change</p> </dd>   <dt class="summary-signature"> <a href="#validate_acceptance/3">validate_acceptance(changeset, field, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Validates the given parameter was given as true</p> </dd>   <dt class="summary-signature"> <a href="#validate_change/3">validate_change(changeset, field, validator)</a> </dt> <dd class="summary-synopsis">
<p>Validates the given <code class="inline">field</code> change</p> </dd>   <dt class="summary-signature"> <a href="#validate_change/4">validate_change(changeset, field, metadata, validator)</a> </dt> <dd class="summary-synopsis">
<p>Stores the validation <code class="inline">metadata</code> and validates the given <code class="inline">field</code> change</p> </dd>   <dt class="summary-signature"> <a href="#validate_confirmation/3">validate_confirmation(changeset, field, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Validates that the given field matches the confirmation parameter of that field</p> </dd>   <dt class="summary-signature"> <a href="#validate_exclusion/4">validate_exclusion(changeset, field, data, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Validates a change is not included in the given enumerable</p> </dd>   <dt class="summary-signature"> <a href="#validate_format/4">validate_format(changeset, field, format, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Validates a change has the given format</p> </dd>   <dt class="summary-signature"> <a href="#validate_inclusion/4">validate_inclusion(changeset, field, data, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Validates a change is included in the given enumerable</p> </dd>   <dt class="summary-signature"> <a href="#validate_length/3">validate_length(changeset, field, opts)</a> </dt> <dd class="summary-synopsis">
<p>Validates a change is a string or list of the given length</p> </dd>   <dt class="summary-signature"> <a href="#validate_number/3">validate_number(changeset, field, opts)</a> </dt> <dd class="summary-synopsis">
<p>Validates the properties of a number</p> </dd>   <dt class="summary-signature"> <a href="#validate_required/3">validate_required(changeset, fields, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Validates that one or more fields are present in the changeset</p> </dd>   <dt class="summary-signature"> <a href="#validate_subset/4">validate_subset(changeset, field, data, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Validates a change, of type enum, is a subset of the given enumerable. Like validate_inclusion/4 for lists</p> </dd>  </dl>   <h1 class="section-heading" id="types">  Types </h1>   <h3 class="detail-header type" id="t:action/0">  <span class="signature">action()</span>     </h3>
<pre data-language="elixir">action() :: nil | :insert | :update | :delete | :replace | :ignore</pre>     <h3 class="detail-header type" id="t:constraint/0">  <span class="signature">constraint()</span>     </h3>
<pre data-language="elixir">constraint() :: %{type: :unique, constraint: <a href="https://hexdocs.pm/elixir/String.html#t:t/0" target="_blank">String.t</a>, match: :exact | :suffix, field: atom, message: <a href="#t:error/0">error</a>}</pre>     <h3 class="detail-header type" id="t:data/0">  <span class="signature">data()</span>     </h3>
<pre data-language="elixir">data() :: map</pre>     <h3 class="detail-header type" id="t:error/0">  <span class="signature">error()</span>     </h3>
<pre data-language="elixir">error() :: {<a href="https://hexdocs.pm/elixir/String.html#t:t/0" target="_blank">String.t</a>, <a href="https://hexdocs.pm/elixir/Keyword.html#t:t/0" target="_blank">Keyword.t</a>}</pre>     <h3 class="detail-header type" id="t:t/0">  <span class="signature">t()</span>     </h3>
<pre data-language="elixir">t() :: %Ecto.Changeset{action: <a href="#t:action/0">action</a>, changes: %{optional(atom) =&gt; term}, constraints: [<a href="#t:constraint/0">constraint</a>], data: <a href="../ecto.schema/#t:t/0">Ecto.Schema.t</a> | map | nil, empty_values: term, errors: [{atom, <a href="#t:error/0">error</a>}], filters: %{optional(atom) =&gt; term}, params: %{optional(<a href="https://hexdocs.pm/elixir/String.html#t:t/0" target="_blank">String.t</a>) =&gt; term} | nil, prepare: [(<a href="#t:t/0">t</a> -&gt; <a href="#t:t/0">t</a>)], repo: atom | nil, repo_opts: <a href="https://hexdocs.pm/elixir/Keyword.html#t:t/0" target="_blank">Keyword.t</a>, required: [atom], types: nil | %{optional(atom) =&gt; <a href="../ecto.type/#t:t/0">Ecto.Type.t</a>}, valid?: boolean, validations: <a href="https://hexdocs.pm/elixir/Keyword.html#t:t/0" target="_blank">Keyword.t</a>}</pre>     <h3 class="detail-header type" id="t:types/0">  <span class="signature">types()</span>     </h3>
<pre data-language="elixir">types() :: map</pre>       <h1 class="section-heading" id="functions">  Functions </h1>   <h3 class="detail-header function" id="add_error/4">  <span class="signature">add_error(changeset, key, message, keys \\ [])</span>     </h3>
<pre data-language="elixir">add_error(<a href="#t:t/0">t</a>, atom, <a href="https://hexdocs.pm/elixir/String.html#t:t/0" target="_blank">String.t</a>, <a href="https://hexdocs.pm/elixir/Keyword.html#t:t/0" target="_blank">Keyword.t</a>) :: <a href="#t:t/0">t</a></pre>  <p>Adds an error to the changeset.</p> <p>An additional keyword list <code class="inline">keys</code> can be passed to provide additional contextual information for the error. This is useful when using <a href="#traverse_errors/2"><code class="inline">traverse_errors/2</code></a></p> <h4 id="add_error/4-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; changeset = change(%Post{}, %{title: ""})
iex&gt; changeset = add_error(changeset, :title, "empty")
iex&gt; changeset.errors
[title: {"empty", []}]
iex&gt; changeset.valid?
false

iex&gt; changeset = change(%Post{}, %{title: ""})
iex&gt; changeset = add_error(changeset, :title, "empty", additional: "info")
iex&gt; changeset.errors
[title: {"empty", [additional: "info"]}]
iex&gt; changeset.valid?
false</code></pre>    <h3 class="detail-header function" id="apply_action/2">  <span class="signature">apply_action(changeset, action)</span>     </h3>
<pre data-language="elixir">apply_action(<a href="#t:t/0">t</a>, <a href="#t:action/0">action</a>) ::
  {:ok, <a href="../ecto.schema/#t:t/0">Ecto.Schema.t</a> | <a href="#t:data/0">data</a>} |
  {:error, <a href="#t:t/0">t</a>}</pre>  <p>Applies the changeset action only if the changes are valid.</p> <p>If the changes are valid, all changes are applied to the changeset data. If the changes are invalid, no changes are applied, and an error tuple is returned with the changeset containing the action that was attempted to be applied.</p> <p>The action may be one of <code class="inline">:insert</code>, <code class="inline">:update</code>, <code class="inline">:delete</code>, <code class="inline">:replace</code>.</p> <h4 id="apply_action/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; {:ok, data} = apply_action(changeset, :update)

iex&gt; {:error, changeset} = apply_action(changeset, :update)
%Ecto.Changeset{action: :update}</code></pre>    <h3 class="detail-header function" id="apply_changes/1">  <span class="signature">apply_changes(changeset)</span>     </h3>
<pre data-language="elixir">apply_changes(<a href="#t:t/0">t</a>) :: <a href="../ecto.schema/#t:t/0">Ecto.Schema.t</a> | <a href="#t:data/0">data</a></pre>  <p>Applies the changeset changes to the changeset data.</p> <p>This operation will return the underlying data with changes regardless if the changeset is valid or not.</p> <h4 id="apply_changes/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; changeset = change(%Post{author: "bar"}, %{title: "foo"})
iex&gt; apply_changes(changeset)
%Post{author: "bar", title: "foo"}</code></pre>     <h3 class="detail-header function" id="assoc_constraint/3">  <span class="signature">assoc_constraint(changeset, assoc, opts \\ [])</span>     </h3>
<pre data-language="elixir">assoc_constraint(<a href="#t:t/0">t</a>, atom, <a href="https://hexdocs.pm/elixir/Keyword.html#t:t/0" target="_blank">Keyword.t</a>) :: <a href="#t:t/0">t</a> | no_return</pre>  <p>Checks the associated field exists.</p> <p>This is similar to <a href="#foreign_key_constraint/3"><code class="inline">foreign_key_constraint/3</code></a> except that the field is inferred from the association definition. This is useful to guarantee that a child will only be created if the parent exists in the database too. Therefore, it only applies to <code class="inline">belongs_to</code> associations.</p> <p>As the name says, a constraint is required in the database for this function to work. Such constraint is often added as a reference to the child table:</p> <pre data-language="elixir"><code class="elixir">create table(:comments) do
  add :post_id, references(:posts)
end</code></pre> <p>Now, when inserting a comment, it is possible to forbid any comment to be added if the associated post does not exist:</p> <pre data-language="elixir"><code class="elixir">comment
|&gt; Ecto.Changeset.cast(params, [:post_id])
|&gt; Ecto.Changeset.assoc_constraint(:post)
|&gt; Repo.insert</code></pre> <h4 id="assoc_constraint/3-options" class="section-heading">  Options </h4> <ul> <li>
<code class="inline">:message</code> - the message in case the constraint check fails, defaults to “does not exist” </li> <li>
<code class="inline">:name</code> - the constraint name. By default, the constraint name is inferred from the table + association field. May be required explicitly for complex cases </li> </ul>     <h3 class="detail-header function" id="cast/4">  <span class="signature">cast(data, params, permitted, opts \\ [])</span>     </h3>
<pre data-language="elixir">cast(<a href="../ecto.schema/#t:t/0">Ecto.Schema.t</a> | <a href="#t:t/0">t</a> | {<a href="#t:data/0">data</a>, <a href="#t:types/0">types</a>}, %{optional(binary) =&gt; term} | %{optional(atom) =&gt; term} | :invalid, [<a href="https://hexdocs.pm/elixir/String.html#t:t/0" target="_blank">String.t</a> | atom], <a href="https://hexdocs.pm/elixir/Keyword.html#t:t/0" target="_blank">Keyword.t</a>) ::
  <a href="#t:t/0">t</a> |
  no_return</pre>  <p>Applies the given <code class="inline">params</code> as changes for the given <code class="inline">data</code> according to the given set of keys. Returns a changeset.</p> <p>The given <code class="inline">data</code> may be either a changeset, a schema struct or a <code class="inline">{data, types}</code> tuple. The second argument is a map of <code class="inline">params</code> that are cast according to the type information from <code class="inline">data</code>. <code class="inline">params</code> is a map with string keys or a map with atom keys containing potentially unsafe data.</p> <p>During casting, all <code class="inline">permitted</code> parameters will have their key name converted to an atom and stored as a change in the <code class="inline">:changes</code> field of the changeset. All parameters that are not explicitly permitted are ignored.</p> <p>If casting of all fields is successful, the changeset is returned as valid.</p> <h4 id="cast/4-options" class="section-heading">  Options </h4> <ul> <li>
<code class="inline">:empty_values</code> - a list of values to be considered as empty when casting. Defaults to the changeset value, which defaults to <code class="inline">[""]</code> </li> </ul> <h4 id="cast/4-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; changeset = cast(post, params, [:title])
iex&gt; if changeset.valid? do
...&gt;   Repo.update!(changeset)
...&gt; end</code></pre> <p>Passing a changeset as the first argument:</p> <pre data-language="elixir"><code class="iex elixir">iex&gt; changeset = cast(post, %{title: "Hello"}, [:title])
iex&gt; new_changeset = cast(changeset, %{title: "Foo", body: "Bar"}, [:body])
iex&gt; new_changeset.params
%{"title" =&gt; "Foo", "body" =&gt; "Bar"}</code></pre> <p>Or creating a changeset from a simple map with types:</p> <pre data-language="elixir"><code class="iex elixir">iex&gt; data = %{title: "hello"}
iex&gt; types = %{title: :string}
iex&gt; changeset = cast({data, types}, %{title: "world"}, [:title])
iex&gt; apply_changes(changeset)
%{title: "world"}</code></pre> <h4 id="cast/4-composing-casts" class="section-heading">  Composing casts </h4> <p><a href="#cast/4"><code class="inline">cast/4</code></a> also accepts a changeset as its first argument. In such cases, all the effects caused by the call to <a href="#cast/4"><code class="inline">cast/4</code></a> (additional errors and changes) are simply added to the ones already present in the argument changeset. Parameters are merged (<strong>not deep-merged</strong>) and the ones passed to <a href="#cast/4"><code class="inline">cast/4</code></a> take precedence over the ones already in the changeset.</p>     <h3 class="detail-header function" id="cast_assoc/3">  <span class="signature">cast_assoc(changeset, name, opts \\ [])</span>  </h3>  <p>Casts the given association with the changeset parameters.</p> <p>This function should be used when working with the entire association at once (and not a single element of a many-style association) and using data external to the application.</p> <p>When updating the data, this function requires the association to have been preloaded in the changeset struct. Missing data will invoke the <code class="inline">:on_replace</code> behaviour defined on the association. Preloading is not necessary for newly built structs.</p> <p>The parameters for the given association will be retrieved from <code class="inline">changeset.params</code>. Those parameters are expected to be a map with attributes, similar to the ones passed to <a href="#cast/4"><code class="inline">cast/4</code></a>. Once parameters are retrieved, <a href="#cast_assoc/3"><code class="inline">cast_assoc/3</code></a> will match those parameters with the associations already in the changeset record.</p> <p>For example, imagine a user has many addresses relationship where post data is sent as follows</p> <pre data-language="elixir"><code class="elixir">%{"name" =&gt; "john doe", "addresses" =&gt; [
  %{"street" =&gt; "somewhere", "country" =&gt; "brazil", "id" =&gt; 1},
  %{"street" =&gt; "elsewhere", "country" =&gt; "poland"},
]}</code></pre> <p>and then</p> <pre data-language="elixir"><code class="elixir">user
|&gt; Repo.preload(:addresses)
|&gt; Ecto.Changeset.cast(params, [])
|&gt; Ecto.Changeset.cast_assoc(:addresses)</code></pre> <p>Once <a href="#cast_assoc/3"><code class="inline">cast_assoc/3</code></a> is called, Ecto will compare those parameters with the addresses already associated with the user and act as follows:</p> <ul> <li>If the parameter does not contain an ID, the parameter data will be passed to <code class="inline">changeset/2</code> with a new struct and become an insert operation </li> <li>If the parameter contains an ID and there is no associated child with such ID, the parameter data will be passed to <code class="inline">changeset/2</code> with a new struct and become an insert operation </li> <li>If the parameter contains an ID and there is an associated child with such ID, the parameter data will be passed to <code class="inline">changeset/2</code> with the existing struct and become an update operation </li> <li>If there is an associated child with an ID and its ID is not given as parameter, the <code class="inline">:on_replace</code> callback for that association will be invoked (see the “On replace” section on the module documentation) </li> </ul> <p>Every time the <code class="inline">changeset/2</code> function is invoked, it must return a changeset. Note developers are allowed to explicitly set the <code class="inline">:action</code> field of a changeset to instruct Ecto how to act in certain situations. Let’s suppose that, if one of the associations has only empty fields, you want to ignore the entry altogether instead of showing an error. The changeset function could be written like this:</p> <pre data-language="elixir"><code class="elixir">def changeset(struct, params) do
  struct
  |&gt; cast(struct, params, [:title, :body])
  |&gt; validate_requited([:title, :body])
  |&gt; case do
    %{valid?: false, changes: changes} = changeset when changes == %{} -&gt;
      # If the changeset is invalid and has no changes, it is
      # because all required fields are missing, so we ignore it.
      %{changeset | action: :ignore}
    changeset -&gt;
      changeset
  end
end</code></pre> <h4 id="cast_assoc/3-alternatives-to-cast_assoc-3" class="section-heading">  Alternatives to cast_assoc/3 </h4> <p><a href="#cast_assoc/3"><code class="inline">cast_assoc/3</code></a> is useful when the associated data is managed alongside the parent struct, all at once.</p> <p>To work with a single element of an association, other functions are more appropriate. For example to insert a single associated struct for a <code class="inline">has_many</code> association it’s much easier to construct the associated struct with <a href="../ecto/#build_assoc/3"><code class="inline">Ecto.build_assoc/3</code></a> and persist it directly with <a href="../ecto.repo/#c:insert/2"><code class="inline">Ecto.Repo.insert/2</code></a>.</p> <p>Furthermore, if each side of the association is managed separately, it is preferable to use <a href="#put_assoc/3"><code class="inline">put_assoc/3</code></a> and directly instruct Ecto how the association should look like.</p> <p>For example, imagine you are receiving a set of tags you want to associate to an user. Those tags are meant to exist upfront. Using <a href="#cast_assoc/3"><code class="inline">cast_assoc/3</code></a> won’t work as desired because the tags are not managed alongside the user. In such cases, <a href="#put_assoc/3"><code class="inline">put_assoc/3</code></a> will work as desired. With the given parameters:</p> <pre data-language="elixir"><code class="elixir">%{"name" =&gt; "john doe", "tags" =&gt; ["learner"]}</code></pre> <p>and then:</p> <pre data-language="elixir"><code class="elixir">tags = Repo.all(from t in Tag, where: t.name in ^params["tags"])

user
|&gt; Repo.preload(:tags)
|&gt; Ecto.Changeset.cast(params) # No need to allow :tags as we put them directly
|&gt; Ecto.Changeset.put_assoc(:tags, tags) # Explicitly set the tags</code></pre> <p>Note the changeset must have been previously <code class="inline">cast</code> using <a href="#cast/4"><code class="inline">cast/4</code></a> before this function is invoked.</p> <h4 id="cast_assoc/3-options" class="section-heading">  Options </h4> <ul> <li>
<code class="inline">:with</code> - the function to build the changeset from params. Defaults to the changeset/2 function in the association module </li> <li>
<code class="inline">:required</code> - if the association is a required field </li> <li>
<code class="inline">:required_message</code> - the message on failure, defaults to “can’t be blank” </li> <li>
<code class="inline">:invalid_message</code> - the message on failure, defaults to “is invalid” </li> </ul>     <h3 class="detail-header function" id="cast_embed/3">  <span class="signature">cast_embed(changeset, name, opts \\ [])</span>  </h3>  <p>Casts the given embed with the changeset parameters.</p> <p>The parameters for the given embed will be retrieved from <code class="inline">changeset.params</code>. Those parameters are expected to be a map with attributes, similar to the ones passed to <a href="#cast/4"><code class="inline">cast/4</code></a>. Once parameters are retrieved, <a href="#cast_embed/3"><code class="inline">cast_embed/3</code></a> will match those parameters with the embeds already in the changeset record. See <a href="#cast_assoc/3"><code class="inline">cast_assoc/3</code></a> for an example of working with casts and associations which would also apply for embeds.</p> <p>The changeset must have been previously <code class="inline">cast</code> using <a href="#cast/4"><code class="inline">cast/4</code></a> before this function is invoked.</p> <h4 id="cast_embed/3-options" class="section-heading">  Options </h4> <ul> <li>
<code class="inline">:with</code> - the function to build the changeset from params. Defaults to the changeset/2 function in the embed module </li> <li>
<code class="inline">:required</code> - if the embed is a required field </li> <li>
<code class="inline">:required_message</code> - the message on failure, defaults to “can’t be blank” </li> <li>
<code class="inline">:invalid_message</code> - the message on failure, defaults to “is invalid” </li> </ul>     <h3 class="detail-header function" id="change/2">  <span class="signature">change(data, changes \\ %{})</span>     </h3>
<pre data-language="elixir">change(<a href="../ecto.schema/#t:t/0">Ecto.Schema.t</a> | <a href="#t:t/0">t</a> | {<a href="#t:data/0">data</a>, <a href="#t:types/0">types</a>}, %{optional(atom) =&gt; term} | <a href="https://hexdocs.pm/elixir/Keyword.html#t:t/0" target="_blank">Keyword.t</a>) ::
  <a href="#t:t/0">t</a> |
  no_return</pre>  <p>Wraps the given data in a changeset or adds changes to a changeset.</p> <p>Changed attributes will only be added if the change does not have the same value as the field in the data.</p> <p>This function is useful for:</p> <ul> <li>wrapping a struct inside a changeset </li> <li>directly changing a struct without performing castings nor validations </li> <li>directly bulk-adding changes to a changeset </li> </ul> <p>The function is meant for working with data internal to the application. Because of that neither validation nor casting is performed. This means <a href="#change/2"><code class="inline">change/2</code></a> expects the keys in the <code class="inline">changes</code> map or keyword to be atoms.</p> <p>When a changeset is passed as the first argument, the changes passed as the second argument are merged over the changes already in the changeset if they differ from the values in the struct. If <code class="inline">changes</code> is an empty map, this function is a no-op.</p> <p>When a <code class="inline">{data, types}</code> is passed as the first argument, a changeset is created with the given data and types and marked as valid.</p> <p>See <a href="#cast/4"><code class="inline">cast/4</code></a> if you’d prefer to cast and validate external parameters.</p> <h4 id="change/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; changeset = change(%Post{})
%Ecto.Changeset{...}
iex&gt; changeset.valid?
true
iex&gt; changeset.changes
%{}

iex&gt; changeset = change(%Post{author: "bar"}, title: "title")
iex&gt; changeset.changes
%{title: "title"}

iex&gt; changeset = change(%Post{title: "title"}, title: "title")
iex&gt; changeset.changes
%{}

iex&gt; changeset = change(changeset, %{title: "new title", body: "body"})
iex&gt; changeset.changes.title
"new title"
iex&gt; changeset.changes.body
"body"</code></pre>     <h3 class="detail-header function" id="check_constraint/3">  <span class="signature">check_constraint(changeset, field, opts \\ [])</span>  </h3>  <p>Checks for a check constraint in the given field.</p> <p>The check constraint works by relying on the database to check if the check constraint has been violated or not and, if so, Ecto converts it into a changeset error.</p> <h4 id="check_constraint/3-options" class="section-heading">  Options </h4> <ul> <li>
<code class="inline">:message</code> - the message in case the constraint check fails. Defaults to “is invalid” </li> <li>
<code class="inline">:name</code> - the name of the constraint. Required. </li> <li>
<code class="inline">:match</code> - how the changeset constraint name is matched against the repo constraint, may be <code class="inline">:exact</code> or <code class="inline">:suffix</code>. Defaults to <code class="inline">:exact</code>. <code class="inline">:suffix</code> matches any repo constraint which <code class="inline">ends_with?</code> <code class="inline">:name</code> to this changeset constraint. </li> </ul>    <h3 class="detail-header function" id="delete_change/2">  <span class="signature">delete_change(changeset, key)</span>     </h3>
<pre data-language="elixir">delete_change(<a href="#t:t/0">t</a>, atom) :: <a href="#t:t/0">t</a></pre>  <p>Deletes a change with the given key.</p> <h4 id="delete_change/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; changeset = change(%Post{}, %{title: "foo"})
iex&gt; changeset = delete_change(changeset, :title)
iex&gt; get_change(changeset, :title)
nil</code></pre>     <h3 class="detail-header function" id="exclusion_constraint/3">  <span class="signature">exclusion_constraint(changeset, field, opts \\ [])</span>  </h3>  <p>Checks for an exclusion constraint in the given field.</p> <p>The exclusion constraint works by relying on the database to check if the exclusion constraint has been violated or not and, if so, Ecto converts it into a changeset error.</p> <h4 id="exclusion_constraint/3-options" class="section-heading">  Options </h4> <ul> <li>
<code class="inline">:message</code> - the message in case the constraint check fails, defaults to “violates an exclusion constraint” </li> <li>
<code class="inline">:name</code> - the constraint name. By default, the constraint name is inferred from the table + field. May be required explicitly for complex cases </li> <li>
<code class="inline">:match</code> - how the changeset constraint name is matched against the repo constraint, may be <code class="inline">:exact</code> or <code class="inline">:suffix</code>. Defaults to <code class="inline">:exact</code>. <code class="inline">:suffix</code> matches any repo constraint which <code class="inline">ends_with?</code> <code class="inline">:name</code> to this changeset constraint. </li> </ul>    <h3 class="detail-header function" id="fetch_change/2">  <span class="signature">fetch_change(changeset, key)</span>     </h3>
<pre data-language="elixir">fetch_change(<a href="#t:t/0">t</a>, atom) :: {:ok, term} | :error</pre>  <p>Fetches a change from the given changeset.</p> <p>This function only looks at the <code class="inline">:changes</code> field of the given <code class="inline">changeset</code> and returns <code class="inline">{:ok, value}</code> if the change is present or <code class="inline">:error</code> if it’s not.</p> <h4 id="fetch_change/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; changeset = change(%Post{body: "foo"}, %{title: "bar"})
iex&gt; fetch_change(changeset, :title)
{:ok, "bar"}
iex&gt; fetch_change(changeset, :body)
:error</code></pre>    <h3 class="detail-header function" id="fetch_field/2">  <span class="signature">fetch_field(changeset, key)</span>     </h3>
<pre data-language="elixir">fetch_field(<a href="#t:t/0">t</a>, atom) ::
  {:changes, term} |
  {:data, term} |
  :error</pre>  <p>Fetches the given field from changes or from the data.</p> <p>While <a href="#fetch_change/2"><code class="inline">fetch_change/2</code></a> only looks at the current <code class="inline">changes</code> to retrieve a value, this function looks at the changes and then falls back on the data, finally returning <code class="inline">:error</code> if no value is available.</p> <p>For relations, these functions will return the changeset original data with changes applied. To retrieve raw changesets, please use <a href="#fetch_change/2"><code class="inline">fetch_change/2</code></a>.</p> <h4 id="fetch_field/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; post = %Post{title: "Foo", body: "Bar baz bong"}
iex&gt; changeset = change(post, %{title: "New title"})
iex&gt; fetch_field(changeset, :title)
{:changes, "New title"}
iex&gt; fetch_field(changeset, :body)
{:data, "Bar baz bong"}
iex&gt; fetch_field(changeset, :not_a_field)
:error</code></pre>    <h3 class="detail-header function" id="force_change/3">  <span class="signature">force_change(changeset, key, value)</span>     </h3>
<pre data-language="elixir">force_change(<a href="#t:t/0">t</a>, atom, term) :: <a href="#t:t/0">t</a> | no_return</pre>  <p>Forces a change on the given <code class="inline">key</code> with <code class="inline">value</code>.</p> <p>If the change is already present, it is overridden with the new value.</p> <h4 id="force_change/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; changeset = change(%Post{author: "bar"}, %{title: "foo"})
iex&gt; changeset = force_change(changeset, :title, "bar")
iex&gt; changeset.changes
%{title: "bar"}

iex&gt; changeset = force_change(changeset, :author, "bar")
iex&gt; changeset.changes
%{title: "bar", author: "bar"}</code></pre>     <h3 class="detail-header function" id="foreign_key_constraint/3">  <span class="signature">foreign_key_constraint(changeset, field, opts \\ [])</span>     </h3>
<pre data-language="elixir">foreign_key_constraint(<a href="#t:t/0">t</a>, atom, <a href="https://hexdocs.pm/elixir/Keyword.html#t:t/0" target="_blank">Keyword.t</a>) :: <a href="#t:t/0">t</a></pre>  <p>Checks for foreign key constraint in the given field.</p> <p>The foreign key constraint works by relying on the database to check if the associated data exists or not. This is useful to guarantee that a child will only be created if the parent exists in the database too.</p> <p>In order to use the foreign key constraint the first step is to define the foreign key in a migration. This is often done with references. For example, imagine you are creating a comments table that belongs to posts. One would have:</p> <pre data-language="elixir"><code class="elixir">create table(:comments) do
  add :post_id, references(:posts)
end</code></pre> <p>By default, Ecto will generate a foreign key constraint with name “comments_post_id_fkey” (the name is configurable).</p> <p>Now that a constraint exists, when creating comments, we could annotate the changeset with foreign key constraint so Ecto knows how to convert it into an error message:</p> <pre data-language="elixir"><code class="elixir">cast(comment, params, [:post_id])
|&gt; foreign_key_constraint(:post_id)</code></pre> <p>Now, when invoking <code class="inline">Repo.insert/2</code> or <code class="inline">Repo.update/2</code>, if the associated post does not exist, it will be converted into an error and <code class="inline">{:error, changeset}</code> returned by the repository.</p> <h4 id="foreign_key_constraint/3-options" class="section-heading">  Options </h4> <ul> <li>
<code class="inline">:message</code> - the message in case the constraint check fails, defaults to “does not exist” </li> <li>
<code class="inline">:name</code> - the constraint name. By default, the constraint name is inferred from the table + field. May be required explicitly for complex cases </li> </ul>     <h3 class="detail-header function" id="get_change/3">  <span class="signature">get_change(changeset, key, default \\ nil)</span>     </h3>
<pre data-language="elixir">get_change(<a href="#t:t/0">t</a>, atom, term) :: term</pre>  <p>Gets a change or returns a default value.</p> <h4 id="get_change/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; changeset = change(%Post{body: "foo"}, %{title: "bar"})
iex&gt; get_change(changeset, :title)
"bar"
iex&gt; get_change(changeset, :body)
nil</code></pre>     <h3 class="detail-header function" id="get_field/3">  <span class="signature">get_field(changeset, key, default \\ nil)</span>     </h3>
<pre data-language="elixir">get_field(<a href="#t:t/0">t</a>, atom, term) :: term</pre>  <p>Gets a field from changes or from the data.</p> <p>While <a href="#get_change/3"><code class="inline">get_change/3</code></a> only looks at the current <code class="inline">changes</code> to retrieve a value, this function looks at the changes and then falls back on the data, finally returning <code class="inline">default</code> if no value is available.</p> <p>For relations, these functions will return the changeset data with changes applied. To retrieve raw changesets, please use <a href="#get_change/3"><code class="inline">get_change/3</code></a>.</p> <pre data-language="elixir"><code class="iex elixir">iex&gt; post = %Post{title: "A title", body: "My body is a cage"}
iex&gt; changeset = change(post, %{title: "A new title"})
iex&gt; get_field(changeset, :title)
"A new title"
iex&gt; get_field(changeset, :not_a_field, "Told you, not a field!")
"Told you, not a field!"</code></pre>    <h3 class="detail-header function" id="merge/2">  <span class="signature">merge(changeset1, changeset2)</span>     </h3>
<pre data-language="elixir">merge(<a href="#t:t/0">t</a>, <a href="#t:t/0">t</a>) :: <a href="#t:t/0">t</a> | no_return</pre>  <p>Merges two changesets.</p> <p>This function merges two changesets provided they have been applied to the same data (their <code class="inline">:data</code> field is equal); if the data differs, an <a href="https://hexdocs.pm/elixir/ArgumentError.html" target="_blank"><code class="inline">ArgumentError</code></a> exception is raised. If one of the changesets has a <code class="inline">:repo</code> field which is not <code class="inline">nil</code>, then the value of that field is used as the <code class="inline">:repo</code> field of the resulting changeset; if both changesets have a non-<code class="inline">nil</code> and different <code class="inline">:repo</code> field, an <a href="https://hexdocs.pm/elixir/ArgumentError.html" target="_blank"><code class="inline">ArgumentError</code></a> exception is raised.</p> <p>The other fields are merged with the following criteria:</p> <ul> <li>
<code class="inline">params</code> - params are merged (not deep-merged) giving precedence to the params of <code class="inline">changeset2</code> in case of a conflict. If both changesets have their <code class="inline">:params</code> fields set to <code class="inline">nil</code>, the resulting changeset will have its params set to <code class="inline">nil</code> too. </li> <li>
<code class="inline">changes</code> - changes are merged giving precedence to the <code class="inline">changeset2</code> changes. </li> <li>
<code class="inline">errors</code> and <code class="inline">validations</code> - they are simply concatenated. </li> <li>
<code class="inline">required</code> - required fields are merged; all the fields that appear in the required list of both changesets are moved to the required list of the resulting changeset. </li> </ul> <h4 id="merge/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; changeset1 = cast(%Post{}, %{title: "Title"}, [:title])
iex&gt; changeset2 = cast(%Post{}, %{title: "New title", body: "Body"}, [:title, :body])
iex&gt; changeset = merge(changeset1, changeset2)
iex&gt; changeset.changes
%{body: "Body", title: "New title"}

iex&gt; changeset1 = cast(%Post{body: "Body"}, %{title: "Title"}, [:title])
iex&gt; changeset2 = cast(%Post{}, %{title: "New title"}, [:title])
iex&gt; merge(changeset1, changeset2)
** (ArgumentError) different :data when merging changesets</code></pre>     <h3 class="detail-header function" id="no_assoc_constraint/3">  <span class="signature">no_assoc_constraint(changeset, assoc, opts \\ [])</span>     </h3>
<pre data-language="elixir">no_assoc_constraint(<a href="#t:t/0">t</a>, atom, <a href="https://hexdocs.pm/elixir/Keyword.html#t:t/0" target="_blank">Keyword.t</a>) :: <a href="#t:t/0">t</a> | no_return</pre>  <p>Checks the associated field does not exist.</p> <p>This is similar to <a href="#foreign_key_constraint/3"><code class="inline">foreign_key_constraint/3</code></a> except that the field is inferred from the association definition. This is useful to guarantee that parent can only be deleted (or have its primary key changed) if no child exists in the database. Therefore, it only applies to <code class="inline">has_*</code> associations.</p> <p>As the name says, a constraint is required in the database for this function to work. Such constraint is often added as a reference to the child table:</p> <pre data-language="elixir"><code class="elixir">create table(:comments) do
  add :post_id, references(:posts)
end</code></pre> <p>Now, when deleting the post, it is possible to forbid any post to be deleted if they still have comments attached to it:</p> <pre data-language="elixir"><code class="elixir">post
|&gt; Ecto.Changeset.change
|&gt; Ecto.Changeset.no_assoc_constraint(:comments)
|&gt; Repo.delete</code></pre> <h4 id="no_assoc_constraint/3-options" class="section-heading">  Options </h4> <ul> <li>
<code class="inline">:message</code> - the message in case the constraint check fails, defaults to “is still associated with this entry” (for has_one) and “are still associated with this entry” (for has_many) </li> <li>
<code class="inline">:name</code> - the constraint name. By default, the constraint name is inferred from the association table + association field. May be required explicitly for complex cases </li> </ul>     <h3 class="detail-header function" id="optimistic_lock/3">  <span class="signature">optimistic_lock(data_or_changeset, field, incrementer \\ &amp;(&amp;1 + 1))</span>     </h3>
<pre data-language="elixir">optimistic_lock(<a href="../ecto.schema/#t:t/0">Ecto.Schema.t</a> | <a href="#t:t/0">t</a>, atom, (integer -&gt; integer)) ::
  <a href="#t:t/0">t</a> |
  no_return</pre>  <p>Applies optimistic locking to the changeset.</p> <p><a href="http://en.wikipedia.org/wiki/Optimistic_concurrency_control" target="_blank">Optimistic locking</a> (or <em>optimistic concurrency control</em>) is a technique that allows concurrent edits on a single record. While pessimistic locking works by locking a resource for an entire transaction, optimistic locking only checks if the resource changed before updating it.</p> <p>This is done by regularly fetching the record from the database, then checking whether another user has made changes to the record <em>only when updating the record</em>. This behaviour is ideal in situations where the chances of concurrent updates to the same record are low; if they’re not, pessimistic locking or other concurrency patterns may be more suited.</p> <h4 id="optimistic_lock/3-usage" class="section-heading">  Usage </h4> <p>Optimistic locking works by keeping a “version” counter for each record; this counter gets incremented each time a modification is made to a record. Hence, in order to use optimistic locking, a field must exist in your schema for versioning purpose. Such field is usually an integer but other types are supported.</p> <h4 id="optimistic_lock/3-examples" class="section-heading">  Examples </h4> <p>Assuming we have a <code class="inline">Post</code> schema (stored in the <code class="inline">posts</code> table), the first step is to add a version column to the <code class="inline">posts</code> table:</p> <pre data-language="elixir"><code class="elixir">alter table(:posts) do
  add :lock_version, :integer, default: 1
end</code></pre> <p>The column name is arbitrary and doesn’t need to be <code class="inline">:lock_version</code>. Now add a field to the schema too:</p> <pre data-language="elixir"><code class="elixir">defmodule Post do
  use Ecto.Schema

  schema "posts" do
    field :title, :string
    field :lock_version, :integer, default: 1
  end

  def changeset(:update, struct, params \\ %{}) do
    struct
    |&gt; Ecto.Changeset.cast(params, [:title])
    |&gt; Ecto.Changeset.optimistic_lock(:lock_version)
  end
end</code></pre> <p>Now let’s take optimistic locking for a spin:</p> <pre data-language="elixir"><code class="iex elixir">iex&gt; post = Repo.insert!(%Post{title: "foo"})
%Post{id: 1, title: "foo", lock_version: 1}
iex&gt; valid_change = Post.changeset(:update, post, %{title: "bar"})
iex&gt; stale_change = Post.changeset(:update, post, %{title: "baz"})
iex&gt; Repo.update!(valid_change)
%Post{id: 1, title: "bar", lock_version: 2}
iex&gt; Repo.update!(stale_change)
** (Ecto.StaleEntryError) attempted to update a stale entry:

%Post{id: 1, title: "baz", lock_version: 1}</code></pre> <p>When a conflict happens (a record which has been previously fetched is being updated, but that same record has been modified since it was fetched), an <a href="../ecto.staleentryerror/"><code class="inline">Ecto.StaleEntryError</code></a> exception is raised.</p> <p>Optimistic locking also works with delete operations. Just call the <a href="#optimistic_lock/3"><code class="inline">optimistic_lock/3</code></a> function with the data before delete:</p> <pre data-language="elixir"><code class="iex elixir">iex&gt; changeset = Ecto.Changeset.optimistic_lock(post, :lock_version)
iex&gt; Repo.delete(changeset)</code></pre> <p><a href="#optimistic_lock/3"><code class="inline">optimistic_lock/3</code></a> by default assumes the field being used as a lock is an integer. If you want to use another type, you need to pass the third argument customizing how the next value is generated:</p> <pre data-language="elixir"><code class="iex elixir">iex&gt; Ecto.Changeset.optimistic_lock(post, :lock_uuid, fn _ -&gt; Ecto.UUID.generate end)</code></pre>    <h3 class="detail-header function" id="prepare_changes/2">  <span class="signature">prepare_changes(changeset, function)</span>     </h3>
<pre data-language="elixir">prepare_changes(<a href="#t:t/0">t</a>, (<a href="#t:t/0">t</a> -&gt; <a href="#t:t/0">t</a>)) :: <a href="#t:t/0">t</a></pre>  <p>Provides a function to run before emitting changes to the repository.</p> <p>Such function receives the changeset and must return a changeset, allowing developers to do final adjustments to the changeset or to issue data consistency commands.</p> <p>The given function is guaranteed to run inside the same transaction as the changeset operation for databases that do support transactions.</p> <h4 id="prepare_changes/2-example" class="section-heading">  Example </h4> <p>A common use case is updating a counter cache, in this case updating a post’s comment count when a comment is created:</p> <pre data-language="elixir"><code class="elixir">def create_comment(comment, params) do
  comment
  |&gt; cast(params, [:body, :post_id])
  |&gt; prepare_changes(fn changeset -&gt;
    assoc(changeset.data, :post)
    |&gt; changeset.repo.update_all(inc: [comment_count: 1])
    changeset
  end)
end</code></pre> <p>We retrieve the repo from the comment changeset itself and use update_all to update the counter cache in one query. Finally, the original changeset must be returned.</p>     <h3 class="detail-header function" id="put_assoc/4">  <span class="signature">put_assoc(changeset, name, value, opts \\ [])</span>  </h3>  <p>Puts the given association as a change in the changeset.</p> <p>This function should be used when working with the entire association at once (and not a single element of a many-style association) and using data internal to the application.</p> <p>When updating the data, this function requires the association to have been preloaded in the changeset struct. Missing data will invoke the <code class="inline">:on_replace</code> behaviour defined on the association. Preloading is not necessary for newly built structs.</p> <p>The given value may either be the association struct, a changeset for the given association or a map or keyword list of changes to be applied to the current association. On all cases, it is expected the keys to be atoms. If a map or keyword list are given and there is no association, one will be created.</p> <p>If the association has no changes, it will be skipped. If the association is invalid, the changeset will be marked as invalid. If the given value is not any of the above, it will raise.</p> <p>Also see <a href="#cast_assoc/3"><code class="inline">cast_assoc/3</code></a> for a discussion of when to use <a href="#cast_assoc/3"><code class="inline">cast_assoc/3</code></a> and <a href="#put_assoc/3"><code class="inline">put_assoc/3</code></a>.</p> <p>Although it accepts an <code class="inline">opts</code> argument, there are no options currently supported by <a href="#put_assoc/4"><code class="inline">put_assoc/4</code></a>.</p>    <h3 class="detail-header function" id="put_change/3">  <span class="signature">put_change(changeset, key, value)</span>     </h3>
<pre data-language="elixir">put_change(<a href="#t:t/0">t</a>, atom, term) :: <a href="#t:t/0">t</a> | no_return</pre>  <p>Puts a change on the given <code class="inline">key</code> with <code class="inline">value</code>.</p> <p>If the change is already present, it is overridden with the new value, also, if the change has the same value as in the changeset data, it is not added to the list of changes.</p> <p>The function is meant for working with data internal to the application.</p> <h4 id="put_change/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; changeset = change(%Post{author: "bar"}, %{title: "foo"})
iex&gt; changeset = put_change(changeset, :title, "bar")
iex&gt; changeset.changes
%{title: "bar"}

iex&gt; changeset = put_change(changeset, :author, "bar")
iex&gt; changeset.changes
%{title: "bar"}</code></pre>     <h3 class="detail-header function" id="put_embed/4">  <span class="signature">put_embed(changeset, name, value, opts \\ [])</span>  </h3>  <p>Puts the given embed as a change in the changeset.</p> <p>The given value may either be the embed struct, a changeset for the given embed or a map or keyword list of changes to be applied to the current embed. On all cases, it is expected the keys to be atoms. If a map or keyword list are given and there is no embed, one will be created.</p> <p>If the embed has no changes, it will be skipped. If the embed is invalid, the changeset will be marked as invalid. If the given value is not an embed struct or changeset, it will raise.</p> <p>Also see <a href="#cast_assoc/3"><code class="inline">cast_assoc/3</code></a> for a discussion of when to use <a href="#cast_assoc/3"><code class="inline">cast_assoc/3</code></a> and <a href="#put_assoc/3"><code class="inline">put_assoc/3</code></a> which also applies to <a href="#put_embed/3"><code class="inline">put_embed/3</code></a>.</p> <p>Although it accepts an <code class="inline">opts</code> argument, there are no options currently supported by <a href="#put_embed/4"><code class="inline">put_embed/4</code></a>.</p>    <h3 class="detail-header function" id="traverse_errors/2">  <span class="signature">traverse_errors(changeset, msg_func)</span>     </h3>
<pre data-language="elixir">traverse_errors(<a href="#t:t/0">t</a>, (<a href="#t:error/0">error</a> -&gt; <a href="https://hexdocs.pm/elixir/String.html#t:t/0" target="_blank">String.t</a>) | (<a href="../ecto.changeset/#t:t/0">Ecto.Changeset.t</a>, atom, <a href="#t:error/0">error</a> -&gt; <a href="https://hexdocs.pm/elixir/String.html#t:t/0" target="_blank">String.t</a>)) :: %{optional(atom) =&gt; [<a href="https://hexdocs.pm/elixir/String.html#t:t/0" target="_blank">String.t</a>]}</pre>  <p>Traverses changeset errors and applies the given function to error messages.</p> <p>This function is particularly useful when associations and embeds are cast in the changeset as it will traverse all associations and embeds and place all errors in a series of nested maps.</p> <p>A changeset is supplied along with a function to apply to each error message as the changeset is traversed. The error message function receives an error tuple <code class="inline">{msg, opts}</code>, for example:</p> <pre data-language="elixir"><code class="elixir">{"should be at least %{count} characters", [count: 3, validation: :length, min: 3]}</code></pre> <h4 id="traverse_errors/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; traverse_errors(changeset, fn {msg, opts} -&gt;
...&gt;   Enum.reduce(opts, msg, fn {key, value}, acc -&gt;
...&gt;     String.replace(acc, "%{#{key}}", to_string(value))
...&gt;   end)
...&gt; end)
%{title: ["should be at least 3 characters"]}</code></pre> <p>Optionally function can accept three arguments: <code class="inline">changeset</code>, <code class="inline">field</code> and error tuple <code class="inline">{msg, opts}</code>. It is useful whenever you want to extract validations rules from <code class="inline">changeset.validations</code> to build detailed error description.</p>     <h3 class="detail-header function" id="unique_constraint/3">  <span class="signature">unique_constraint(changeset, field, opts \\ [])</span>     </h3>
<pre data-language="elixir">unique_constraint(<a href="#t:t/0">t</a>, atom, <a href="https://hexdocs.pm/elixir/Keyword.html#t:t/0" target="_blank">Keyword.t</a>) :: <a href="#t:t/0">t</a></pre>  <p>Checks for a unique constraint in the given field.</p> <p>The unique constraint works by relying on the database to check if the unique constraint has been violated or not and, if so, Ecto converts it into a changeset error.</p> <p>In order to use the uniqueness constraint, the first step is to define the unique index in a migration:</p> <pre data-language="elixir"><code class="elixir">create unique_index(:users, [:email])</code></pre> <p>Now that a constraint exists, when modifying users, we could annotate the changeset with unique constraint so Ecto knows how to convert it into an error message:</p> <pre data-language="elixir"><code class="elixir">cast(user, params, [:email])
|&gt; unique_constraint(:email)</code></pre> <p>Now, when invoking <code class="inline">Repo.insert/2</code> or <code class="inline">Repo.update/2</code>, if the email already exists, it will be converted into an error and <code class="inline">{:error, changeset}</code> returned by the repository. Note that the error will occur only after hitting the database so it will not be visible until all other validations pass.</p> <h4 id="unique_constraint/3-options" class="section-heading">  Options </h4> <ul> <li>
<code class="inline">:message</code> - the message in case the constraint check fails, defaults to “has already been taken” </li> <li>
<code class="inline">:name</code> - the constraint name. By default, the constraint name is inferred from the table + field. May be required explicitly for complex cases </li> <li>
<code class="inline">:match</code> - how the changeset constraint name is matched against the repo constraint, may be <code class="inline">:exact</code> or <code class="inline">:suffix</code>. Defaults to <code class="inline">:exact</code>. <code class="inline">:suffix</code> matches any repo constraint which <code class="inline">ends_with?</code> <code class="inline">:name</code> to this changeset constraint. </li> </ul> <h4 id="unique_constraint/3-complex-constraints" class="section-heading">  Complex constraints </h4> <p>Because the constraint logic is in the database, we can leverage all the database functionality when defining them. For example, let’s suppose the e-mails are scoped by company id. We would write in a migration:</p> <pre data-language="elixir"><code class="elixir">create unique_index(:users, [:email, :company_id])</code></pre> <p>Because such indexes have usually more complex names, we need to explicitly tell the changeset which constraint name to use (here we’re using the naming convention that <code class="inline">unique_index</code> uses):</p> <pre data-language="elixir"><code class="elixir">cast(user, params, [:email])
|&gt; unique_constraint(:email, name: :users_email_company_id_index)</code></pre> <p>Notice that the first param is just one of the unique index fields, this will be used as the error key to the changeset errors keyword list. For example, the above <a href="#unique_constraint/3"><code class="inline">unique_constraint/3</code></a> would generate something like:</p> <pre data-language="elixir"><code class="elixir">Repo.insert!(%User{email: "john@elixir.org", company_id: 1})
changeset = User.changeset(%User{}, %{email: "john@elixir.org", company_id: 1})
{:error, changeset} = Repo.insert(changeset)
changeset.errors #=&gt; [email: {"has already been taken", []}]</code></pre> <p>Alternatively, you can give both <code class="inline">unique_index</code> and <code class="inline">unique_constraint</code> the same name:</p> <pre data-language="elixir"><code class="elixir"># In the migration
create unique_index(:users, [:email, :company_id], name: :users_email_company_id_index)

# In the changeset function
cast(user, params, [:email])
|&gt; unique_constraint(:email, name: :users_email_company_id_index)</code></pre> <h4 id="unique_constraint/3-case-sensitivity" class="section-heading">  Case sensitivity </h4> <p>Unfortunately, different databases provide different guarantees when it comes to case-sensitiveness. For example, in MySQL, comparisons are case-insensitive by default. In Postgres, users can define case insensitive column by using the <code class="inline">:citext</code> type/extension. In your migration:</p> <pre data-language="elixir"><code class="elixir">execute "CREATE EXTENSION IF NOT EXISTS citext"
create table(:users) do
  ...
  add :email, :citext
  ...
end</code></pre> <p>If for some reason your database does not support case insensitive columns, you can explicitly downcase values before inserting/updating them:</p> <pre data-language="elixir"><code class="elixir">cast(data, params, [:email])
|&gt; update_change(:email, &amp;String.downcase/1)
|&gt; unique_constraint(:email)</code></pre>     <h3 class="detail-header function" id="unsafe_validate_unique/4">  <span class="signature">unsafe_validate_unique(changeset, fields, repo, opts \\ [])</span>  </h3>  <p>Validates that no existing record with a different primary key has the same values for these fields.</p> <p>This function exists to provide quick feedback to users of your application. It should not be relied on for any data guarantee as it has race conditions and is inherently unsafe. For example, if this check happens twice in the same time interval (because the user submitted a form twice), both checks may pass and you may end-up with duplicate entries in the database. Therefore, a <a href="#unique_constraint/3"><code class="inline">unique_constraint/3</code></a> should also be used to ensure your data won’t get corrupted.</p> <p>However, because constraints are only checked if all validations succeed, this function can be used as an early check to provide early feedback to users, since most conflicting data will have been inserted prior to the current validation phase.</p> <h4 id="unsafe_validate_unique/4-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="elixir">unsafe_validate_unique(changeset, [:email], repo)
unsafe_validate_unique(changeset, [:city_name, :state_name], repo)
unsafe_validate_unique(changeset, [:city_name, :state_name], repo, "city must be unique within state")</code></pre>    <h3 class="detail-header function" id="update_change/3">  <span class="signature">update_change(changeset, key, function)</span>     </h3>
<pre data-language="elixir">update_change(<a href="#t:t/0">t</a>, atom, (term -&gt; term)) :: <a href="#t:t/0">t</a></pre>  <p>Updates a change.</p> <p>The given <code class="inline">function</code> is invoked with the change value only if there is a change for the given <code class="inline">key</code>. Note that the value of the change can still be <code class="inline">nil</code> (unless the field was marked as required on <a href="#validate_required/3"><code class="inline">validate_required/3</code></a>).</p> <h4 id="update_change/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; changeset = change(%Post{}, %{impressions: 1})
iex&gt; changeset = update_change(changeset, :impressions, &amp;(&amp;1 + 1))
iex&gt; changeset.changes.impressions
2</code></pre>     <h3 class="detail-header function" id="validate_acceptance/3">  <span class="signature">validate_acceptance(changeset, field, opts \\ [])</span>     </h3>
<pre data-language="elixir">validate_acceptance(<a href="#t:t/0">t</a>, atom, <a href="https://hexdocs.pm/elixir/Keyword.html#t:t/0" target="_blank">Keyword.t</a>) :: <a href="#t:t/0">t</a></pre>  <p>Validates the given parameter was given as true.</p> <p>This validation is used to check for one specific parameter being true and as such does not require the field to effectively exist in the schema or the data being validated.</p> <h4 id="validate_acceptance/3-options" class="section-heading">  Options </h4> <ul> <li>
<code class="inline">:message</code> - the message on failure, defaults to “must be accepted” </li> </ul> <h4 id="validate_acceptance/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="elixir">validate_acceptance(changeset, :terms_of_service)
validate_acceptance(changeset, :rules, message: "please accept rules")</code></pre>    <h3 class="detail-header function" id="validate_change/3">  <span class="signature">validate_change(changeset, field, validator)</span>     </h3>
<pre data-language="elixir">validate_change(<a href="#t:t/0">t</a>, atom, (atom, term -&gt; [<a href="#t:error/0">error</a>])) :: <a href="#t:t/0">t</a></pre>  <p>Validates the given <code class="inline">field</code> change.</p> <p>It invokes the <code class="inline">validator</code> function to perform the validation only if a change for the given <code class="inline">field</code> exists and the change value is not <code class="inline">nil</code>. The function must return a list of errors (with an empty list meaning no errors).</p> <p>In case there’s at least one error, the list of errors will be appended to the <code class="inline">:errors</code> field of the changeset and the <code class="inline">:valid?</code> flag will be set to <code class="inline">false</code>.</p> <h4 id="validate_change/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; changeset = change(%Post{}, %{title: "foo"})
iex&gt; changeset = validate_change changeset, :title, fn :title, title  -&gt;
...&gt;   # Value must not be "foo"!
...&gt;   if title == "foo" do
...&gt;     [title: "cannot be foo"]
...&gt;   else
...&gt;     []
...&gt;   end
...&gt; end
iex&gt; changeset.errors
[title: {"cannot be foo", []}]</code></pre>    <h3 class="detail-header function" id="validate_change/4">  <span class="signature">validate_change(changeset, field, metadata, validator)</span>     </h3>
<pre data-language="elixir">validate_change(<a href="#t:t/0">t</a>, atom, term, (atom, term -&gt; [<a href="#t:error/0">error</a>])) :: <a href="#t:t/0">t</a></pre>  <p>Stores the validation <code class="inline">metadata</code> and validates the given <code class="inline">field</code> change.</p> <p>Similar to <a href="#validate_change/3"><code class="inline">validate_change/3</code></a> but stores the validation metadata into the changeset validators. The validator metadata is often used as a reflection mechanism, to automatically generate code based on the available validations.</p> <h4 id="validate_change/4-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; changeset = change(%Post{}, %{title: "foo"})
iex&gt; changeset = validate_change changeset, :title, :useless_validator, fn
...&gt;   _, _ -&gt; []
...&gt; end
iex&gt; changeset.validations
[title: :useless_validator]</code></pre>     <h3 class="detail-header function" id="validate_confirmation/3">  <span class="signature">validate_confirmation(changeset, field, opts \\ [])</span>     </h3>
<pre data-language="elixir">validate_confirmation(<a href="#t:t/0">t</a>, atom, <a href="https://hexdocs.pm/elixir/Keyword.html#t:t/0" target="_blank">Keyword.t</a>) :: <a href="#t:t/0">t</a></pre>  <p>Validates that the given field matches the confirmation parameter of that field.</p> <p>By calling <code class="inline">validate_confirmation(changeset, :email)</code>, this validation will check if both “email” and “email_confirmation” in the parameter map matches.</p> <p>Note that if the confirmation field is nil or missing, by default this does not add a validation error. You can specify that the confirmation field is required in the options (see below). Note “email_confirmation” does not need to be added as a virtual field in your schema.</p> <h4 id="validate_confirmation/3-options" class="section-heading">  Options </h4> <ul> <li>
<code class="inline">:message</code> - the message on failure, defaults to “does not match” </li> <li>
<code class="inline">:required</code> - boolean, sets whether existence of confirmation parameter is required for addition of error. Defaults to false </li> </ul> <h4 id="validate_confirmation/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="elixir">validate_confirmation(changeset, :email)
validate_confirmation(changeset, :password, message: "does not match password")

cast(data, params, [:password])
|&gt; validate_confirmation(:password, message: "does not match password")</code></pre>     <h3 class="detail-header function" id="validate_exclusion/4">  <span class="signature">validate_exclusion(changeset, field, data, opts \\ [])</span>     </h3>
<pre data-language="elixir">validate_exclusion(<a href="#t:t/0">t</a>, atom, <a href="https://hexdocs.pm/elixir/Enum.html#t:t/0" target="_blank">Enum.t</a>, <a href="https://hexdocs.pm/elixir/Keyword.html#t:t/0" target="_blank">Keyword.t</a>) :: <a href="#t:t/0">t</a></pre>  <p>Validates a change is not included in the given enumerable.</p> <h4 id="validate_exclusion/4-options" class="section-heading">  Options </h4> <ul> <li>
<code class="inline">:message</code> - the message on failure, defaults to “is reserved” </li> </ul> <h4 id="validate_exclusion/4-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="elixir">validate_exclusion(changeset, :name, ~w(admin superadmin))</code></pre>     <h3 class="detail-header function" id="validate_format/4">  <span class="signature">validate_format(changeset, field, format, opts \\ [])</span>     </h3>
<pre data-language="elixir">validate_format(<a href="#t:t/0">t</a>, atom, <a href="https://hexdocs.pm/elixir/Regex.html#t:t/0" target="_blank">Regex.t</a>, <a href="https://hexdocs.pm/elixir/Keyword.html#t:t/0" target="_blank">Keyword.t</a>) :: <a href="#t:t/0">t</a></pre>  <p>Validates a change has the given format.</p> <p>The format has to be expressed as a regular expression.</p> <h4 id="validate_format/4-options" class="section-heading">  Options </h4> <ul> <li>
<code class="inline">:message</code> - the message on failure, defaults to “has invalid format” </li> </ul> <h4 id="validate_format/4-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="elixir">validate_format(changeset, :email, ~r/@/)</code></pre>     <h3 class="detail-header function" id="validate_inclusion/4">  <span class="signature">validate_inclusion(changeset, field, data, opts \\ [])</span>     </h3>
<pre data-language="elixir">validate_inclusion(<a href="#t:t/0">t</a>, atom, <a href="https://hexdocs.pm/elixir/Enum.html#t:t/0" target="_blank">Enum.t</a>, <a href="https://hexdocs.pm/elixir/Keyword.html#t:t/0" target="_blank">Keyword.t</a>) :: <a href="#t:t/0">t</a></pre>  <p>Validates a change is included in the given enumerable.</p> <h4 id="validate_inclusion/4-options" class="section-heading">  Options </h4> <ul> <li>
<code class="inline">:message</code> - the message on failure, defaults to “is invalid” </li> </ul> <h4 id="validate_inclusion/4-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="elixir">validate_inclusion(changeset, :gender, ["man", "woman", "other", "prefer not to say"])
validate_inclusion(changeset, :age, 0..99)</code></pre>    <h3 class="detail-header function" id="validate_length/3">  <span class="signature">validate_length(changeset, field, opts)</span>     </h3>
<pre data-language="elixir">validate_length(<a href="#t:t/0">t</a>, atom, <a href="https://hexdocs.pm/elixir/Keyword.html#t:t/0" target="_blank">Keyword.t</a>) :: <a href="#t:t/0">t</a></pre>  <p>Validates a change is a string or list of the given length.</p> <h4 id="validate_length/3-options" class="section-heading">  Options </h4> <ul> <li>
<code class="inline">:is</code> - the length must be exactly this value </li> <li>
<code class="inline">:min</code> - the length must be greater than or equal to this value </li> <li>
<code class="inline">:max</code> - the length must be less than or equal to this value </li> <li>
<p><code class="inline">:message</code> - the message on failure, depending on the validation, is one of:</p> <ul> <li>
<p>for strings:</p> <ul> <li>“should be %{count} character(s)” </li> <li>“should be at least %{count} character(s)” </li> <li>“should be at most %{count} character(s)” </li> </ul> </li> <li>
<p>for lists:</p> <ul> <li>“should have %{count} item(s)” </li> <li>“should have at least %{count} item(s)” </li> <li>“should have at most %{count} item(s)” </li> </ul> </li> </ul> </li> </ul> <h4 id="validate_length/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="elixir">validate_length(changeset, :title, min: 3)
validate_length(changeset, :title, max: 100)
validate_length(changeset, :title, min: 3, max: 100)
validate_length(changeset, :code, is: 9)
validate_length(changeset, :topics, is: 2)</code></pre>    <h3 class="detail-header function" id="validate_number/3">  <span class="signature">validate_number(changeset, field, opts)</span>     </h3>
<pre data-language="elixir">validate_number(<a href="#t:t/0">t</a>, atom, <a href="https://hexdocs.pm/elixir/Keyword.html#t:t/0" target="_blank">Keyword.t</a>) :: <a href="#t:t/0">t</a> | no_return</pre>  <p>Validates the properties of a number.</p> <h4 id="validate_number/3-options" class="section-heading">  Options </h4> <ul> <li>
<code class="inline">:less_than</code> </li> <li>
<code class="inline">:greater_than</code> </li> <li>
<code class="inline">:less_than_or_equal_to</code> </li> <li>
<code class="inline">:greater_than_or_equal_to</code> </li> <li>
<code class="inline">:equal_to</code> </li> <li>
<p><code class="inline">:message</code> - the message on failure, defaults to one of:</p> <ul> <li>“must be less than %{number}” </li> <li>“must be greater than %{number}” </li> <li>“must be less than or equal to %{number}” </li> <li>“must be greater than or equal to %{number}” </li> <li>“must be equal to %{number}” </li> </ul> </li> </ul> <h4 id="validate_number/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="elixir">validate_number(changeset, :count, less_than: 3)
validate_number(changeset, :pi, greater_than: 3, less_than: 4)
validate_number(changeset, :the_answer_to_life_the_universe_and_everything, equal_to: 42)</code></pre>     <h3 class="detail-header function" id="validate_required/3">  <span class="signature">validate_required(changeset, fields, opts \\ [])</span>     </h3>
<pre data-language="elixir">validate_required(<a href="#t:t/0">t</a>, list | atom, <a href="https://hexdocs.pm/elixir/Keyword.html#t:t/0" target="_blank">Keyword.t</a>) :: <a href="#t:t/0">t</a></pre>  <p>Validates that one or more fields are present in the changeset.</p> <p>If the value of a field is <code class="inline">nil</code> or a string made only of whitespace, the changeset is marked as invalid and an error is added. Note the error won’t be added though if the field already has an error.</p> <p>You can pass a single field name or a list of field names that are required.</p> <p>Do not use this function to validate associations are required, instead pass the <code class="inline">:required</code> option to <a href="#cast_assoc/3"><code class="inline">cast_assoc/3</code></a>.</p> <h4 id="validate_required/3-options" class="section-heading">  Options </h4> <ul> <li>
<code class="inline">:message</code> - the message on failure, defaults to “can’t be blank” </li> </ul> <h4 id="validate_required/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="elixir">validate_required(changeset, :title)
validate_required(changeset, [:title, :body])</code></pre>     <h3 class="detail-header function" id="validate_subset/4">  <span class="signature">validate_subset(changeset, field, data, opts \\ [])</span>     </h3>
<pre data-language="elixir">validate_subset(<a href="#t:t/0">t</a>, atom, <a href="https://hexdocs.pm/elixir/Enum.html#t:t/0" target="_blank">Enum.t</a>, <a href="https://hexdocs.pm/elixir/Keyword.html#t:t/0" target="_blank">Keyword.t</a>) :: <a href="#t:t/0">t</a></pre>  <p>Validates a change, of type enum, is a subset of the given enumerable. Like validate_inclusion/4 for lists.</p> <h4 id="validate_subset/4-options" class="section-heading">  Options </h4> <ul> <li>
<code class="inline">:message</code> - the message on failure, defaults to “has an invalid entry” </li> </ul> <h4 id="validate_subset/4-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="elixir">validate_subset(changeset, :pets, ["cat", "dog", "parrot"])
validate_subset(changeset, :lottery_numbers, 0..99)</code></pre>
<div class="_attribution">
  <p class="_attribution-p">
    © 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://hexdocs.pm/ecto/Ecto.Changeset.html" class="_attribution-link" target="_blank">https://hexdocs.pm/ecto/Ecto.Changeset.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
