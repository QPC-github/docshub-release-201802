
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Ecto.Adapter - Phoenix - W3cubDocs</title>
  
  <meta name="description" content=" This module specifies the adapter API that an adapter is required to implement. ">
  <meta name="keywords" content="ecto, adapter, summary, types, callbacks, -, phoenix">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/phoenix/ecto/ecto.adapter/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-e0f881b0fce8cbe96f33dadc355b7159d5d2912911231446d60eb8f9caffa802.css">
  <script type="text/javascript" src="/assets/application-8fc46316434047265cd383f02b8e7f434ed7dec4a59f920dd633deef8d488d1b.js"></script>
  <script src="/json/phoenix.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/phoenix/" class="_nav-link" title="" style="margin-left:0;">Phoenix</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _elixir">
				
<h1>  Ecto.Adapter <small>behaviour</small>  </h1>  <p>This module specifies the adapter API that an adapter is required to implement.</p>   <h1 class="section-heading" id="summary">  Summary </h1> <h2> Types </h2>
<dl class="summary-types summary">   <dt class="summary-signature"> <a href="#t:cached/0">cached()</a> </dt>   <dt class="summary-signature"> <a href="#t:constraints/0">constraints()</a> </dt>   <dt class="summary-signature"> <a href="#t:fields/0">fields()</a> </dt>   <dt class="summary-signature"> <a href="#t:filters/0">filters()</a> </dt>   <dt class="summary-signature"> <a href="#t:on_conflict/0">on_conflict()</a> </dt>   <dt class="summary-signature"> <a href="#t:prepared/0">prepared()</a> </dt>   <dt class="summary-signature"> <a href="#t:process/0">process()</a> </dt>   <dt class="summary-signature"> <a href="#t:query_meta/0">query_meta()</a> </dt> <dd class="summary-synopsis">
<p>Ecto.Query metadata fields (stored in cache)</p> </dd>   <dt class="summary-signature"> <a href="#t:returning/0">returning()</a> </dt>   <dt class="summary-signature"> <a href="#t:schema_meta/0">schema_meta()</a> </dt> <dd class="summary-synopsis">
<p>Ecto.Schema metadata fields</p> </dd>   <dt class="summary-signature"> <a href="#t:source/0">source()</a> </dt>   <dt class="summary-signature"> <a href="#t:t/0">t()</a> </dt>  </dl> <h2> Callbacks </h2>
<dl class="summary-callbacks summary">   <dt class="summary-signature"> <a href="#c:__before_compile__/1">__before_compile__(env)</a> </dt> <dd class="summary-synopsis">
<p>The callback invoked in case the adapter needs to inject code</p> </dd>   <dt class="summary-signature"> <a href="#c:autogenerate/1">autogenerate(field_type)</a> </dt> <dd class="summary-synopsis">
<p>Called to autogenerate a value for id/embed_id/binary_id</p> </dd>   <dt class="summary-signature"> <a href="#c:child_spec/2">child_spec(repo, options)</a> </dt> <dd class="summary-synopsis">
<p>Returns the childspec that starts the adapter process</p> </dd>   <dt class="summary-signature"> <a href="#c:delete/4">delete(repo, schema_meta, filters, options)</a> </dt> <dd class="summary-synopsis">
<p>Deletes a single struct with the given filters</p> </dd>   <dt class="summary-signature"> <a href="#c:dumpers/2">dumpers(primitive_type, ecto_type)</a> </dt> <dd class="summary-synopsis">
<p>Returns the dumpers for a given type</p> </dd>   <dt class="summary-signature"> <a href="#c:ensure_all_started/2">ensure_all_started(repo, type)</a> </dt> <dd class="summary-synopsis">
<p>Ensure all applications necessary to run the adapter are started</p> </dd>   <dt class="summary-signature"> <a href="#c:execute/6">execute(repo, query_meta, query, params, arg4, options)</a> </dt> <dd class="summary-synopsis">
<p>Executes a previously prepared query</p> </dd>   <dt class="summary-signature"> <a href="#c:insert/6">insert(repo, schema_meta, fields, on_conflict, returning, options)</a> </dt> <dd class="summary-synopsis">
<p>Inserts a single new struct in the data store</p> </dd>   <dt class="summary-signature"> <a href="#c:insert_all/7">insert_all(repo, schema_meta, header, list, on_conflict, returning, options)</a> </dt> <dd class="summary-synopsis">
<p>Inserts multiple entries into the data store</p> </dd>   <dt class="summary-signature"> <a href="#c:loaders/2">loaders(primitive_type, ecto_type)</a> </dt> <dd class="summary-synopsis">
<p>Returns the loaders for a given type</p> </dd>   <dt class="summary-signature"> <a href="#c:prepare/2">prepare(atom, query)</a> </dt> <dd class="summary-synopsis">
<p>Commands invoked to prepare a query for <code class="inline">all</code>, <code class="inline">update_all</code> and <code class="inline">delete_all</code></p> </dd>   <dt class="summary-signature"> <a href="#c:update/6">update(repo, schema_meta, fields, filters, returning, options)</a> </dt> <dd class="summary-synopsis">
<p>Updates a single struct with the given filters</p> </dd>  </dl>   <h1 class="section-heading" id="types">  Types </h1>   <h3 class="detail-header type" id="t:cached/0">  <span class="signature">cached()</span>     </h3>
<pre data-language="elixir">cached() :: term</pre>     <h3 class="detail-header type" id="t:constraints/0">  <span class="signature">constraints()</span>     </h3>
<pre data-language="elixir">constraints() :: <a href="https://hexdocs.pm/elixir/Keyword.html#t:t/0" target="_blank">Keyword.t</a></pre>     <h3 class="detail-header type" id="t:fields/0">  <span class="signature">fields()</span>     </h3>
<pre data-language="elixir">fields() :: <a href="https://hexdocs.pm/elixir/Keyword.html#t:t/0" target="_blank">Keyword.t</a></pre>     <h3 class="detail-header type" id="t:filters/0">  <span class="signature">filters()</span>     </h3>
<pre data-language="elixir">filters() :: <a href="https://hexdocs.pm/elixir/Keyword.html#t:t/0" target="_blank">Keyword.t</a></pre>     <h3 class="detail-header type" id="t:on_conflict/0">  <span class="signature">on_conflict()</span>     </h3>
<pre data-language="elixir"><a href="#t:on_conflict/0">on_conflict</a> ::
  {:raise, list, []} |
  {:nothing, list, [atom]} |
  {<a href="../ecto.query/#t:t/0">Ecto.Query.t</a>, list, [atom]}</pre>     <h3 class="detail-header type" id="t:prepared/0">  <span class="signature">prepared()</span>     </h3>
<pre data-language="elixir">prepared() :: term</pre>     <h3 class="detail-header type" id="t:process/0">  <span class="signature">process()</span>     </h3>
<pre data-language="elixir">process() :: (term -&gt; term)</pre>     <h3 class="detail-header type" id="t:query_meta/0">  <span class="signature">query_meta()</span>     </h3>
<pre data-language="elixir">query_meta() :: %{prefix: binary | nil, sources: tuple, preloads: term, select: map}</pre>  <p>Ecto.Query metadata fields (stored in cache)</p>    <h3 class="detail-header type" id="t:returning/0">  <span class="signature">returning()</span>     </h3>
<pre data-language="elixir">returning() :: [atom]</pre>     <h3 class="detail-header type" id="t:schema_meta/0">  <span class="signature">schema_meta()</span>     </h3>
<pre data-language="elixir">schema_meta() :: %{source: <a href="#t:source/0">source</a>, schema: atom, context: term, autogenerate_id: {atom, :id | :binary_id}}</pre>  <p>Ecto.Schema metadata fields</p>    <h3 class="detail-header type" id="t:source/0">  <span class="signature">source()</span>     </h3>
<pre data-language="elixir">source() :: {prefix :: binary | nil, table :: binary}</pre>     <h3 class="detail-header type" id="t:t/0">  <span class="signature">t()</span>     </h3>
<pre data-language="elixir">t() :: module</pre>       <h1 class="section-heading" id="callbacks">  Callbacks </h1>  <h3 class="detail-header callback" id="c:__before_compile__/1">  <span class="signature">__before_compile__(env)</span>     </h3>
<pre data-language="elixir">__before_compile__(term, env :: <a href="https://hexdocs.pm/elixir/Macro.Env.html#t:t/0" target="_blank">Macro.Env.t</a>) :: <a href="https://hexdocs.pm/elixir/Macro.html#t:t/0" target="_blank">Macro.t</a></pre>  <p>The callback invoked in case the adapter needs to inject code.</p>    <h3 class="detail-header callback" id="c:autogenerate/1">  <span class="signature">autogenerate(field_type)</span>     </h3>
<pre data-language="elixir">autogenerate(field_type :: :id | :binary_id | :embed_id) ::
  term |
  nil |
  no_return</pre>  <p>Called to autogenerate a value for id/embed_id/binary_id.</p> <p>Returns the autogenerated value, or nil if it must be autogenerated inside the storage or raise if not supported.</p>    <h3 class="detail-header callback" id="c:child_spec/2">  <span class="signature">child_spec(repo, options)</span>     </h3>
<pre data-language="elixir">child_spec(repo, options) :: :supervisor.child_spec</pre>  <p>Returns the childspec that starts the adapter process.</p>    <h3 class="detail-header callback" id="c:delete/4">  <span class="signature">delete(repo, schema_meta, filters, options)</span>     </h3>
<pre data-language="elixir">delete(repo, <a href="#t:schema_meta/0">schema_meta</a>, <a href="#t:filters/0">filters</a>, options) ::
  {:ok, <a href="#t:fields/0">fields</a>} |
  {:invalid, <a href="#t:constraints/0">constraints</a>} |
  {:error, :stale} |
  no_return</pre>  <p>Deletes a single struct with the given filters.</p> <p>While <code class="inline">filters</code> can be any record column, it is expected that at least the primary key (or any other key that uniquely identifies an existing record) be given as a filter. Therefore, in case there is no record matching the given filters, <code class="inline">{:error, :stale}</code> is returned.</p>    <h3 class="detail-header callback" id="c:dumpers/2">  <span class="signature">dumpers(primitive_type, ecto_type)</span>     </h3>
<pre data-language="elixir">dumpers(primitive_type :: <a href="../ecto.type/#t:primitive/0">Ecto.Type.primitive</a>, ecto_type :: <a href="../ecto.type/#t:t/0">Ecto.Type.t</a>) :: [(term -&gt; {:ok, term} | :error) | <a href="../ecto.type/#t:t/0">Ecto.Type.t</a>]</pre>  <p>Returns the dumpers for a given type.</p> <p>It receives the primitive type and the Ecto type (which may be primitive as well). It returns a list of dumpers with the given type usually at the beginning.</p> <p>This allows developers to properly translate values coming from the Ecto into adapter ones. For example, if the database does not support booleans but instead returns 0 and 1 for them, you could add:</p> <pre data-language="elixir"><code class="elixir">def dumpers(:boolean, type), do: [type, &amp;bool_encode/1]
def dumpers(_primitive, type), do: [type]

defp bool_encode(false), do: {:ok, 0}
defp bool_encode(true), do: {:ok, 1}</code></pre> <p>All adapters are required to implement a clause or :binary_id types, since they are adapter specific. If your adapter does not provide binary ids, you may simply use Ecto.UUID:</p> <pre data-language="elixir"><code class="elixir">def dumpers(:binary_id, type), do: [type, Ecto.UUID]
def dumpers(_primitive, type), do: [type]</code></pre>    <h3 class="detail-header callback" id="c:ensure_all_started/2">  <span class="signature">ensure_all_started(repo, type)</span>     </h3>
<pre data-language="elixir">ensure_all_started(repo, type :: :application.restart_type) ::
  {:ok, [atom]} |
  {:error, atom}</pre>  <p>Ensure all applications necessary to run the adapter are started.</p>    <h3 class="detail-header callback" id="c:execute/6">  <span class="signature">execute(repo, query_meta, query, params, arg4, options)</span>     </h3>
<pre data-language="elixir">execute(repo, <a href="#t:query_meta/0">query_meta</a>, query, params :: list, <a href="#t:process/0">process</a> | nil, options) :: result when result: {integer, [[term]] | nil} | no_return, query: {:nocache, <a href="#t:prepared/0">prepared</a>} | {:cached, (<a href="#t:prepared/0">prepared</a> -&gt; :ok), <a href="#t:cached/0">cached</a>} | {:cache, (<a href="#t:cached/0">cached</a> -&gt; :ok), <a href="#t:prepared/0">prepared</a>}</pre>  <p>Executes a previously prepared query.</p> <p>It must return a tuple containing the number of entries and the result set as a list of lists. The result set may also be <code class="inline">nil</code> if a particular operation does not support them.</p> <p>The <code class="inline">meta</code> field is a map containing some of the fields found in the <a href="../ecto.query/"><code class="inline">Ecto.Query</code></a> struct.</p> <p>It receives a process function that should be invoked for each selected field in the query result in order to convert them to the expected Ecto type. The <code class="inline">process</code> function will be nil if no result set is expected from the query.</p>    <h3 class="detail-header callback" id="c:insert/6">  <span class="signature">insert(repo, schema_meta, fields, on_conflict, returning, options)</span>     </h3>
<pre data-language="elixir">insert(repo, <a href="#t:schema_meta/0">schema_meta</a>, <a href="#t:fields/0">fields</a>, <a href="#t:on_conflict/0">on_conflict</a>, <a href="#t:returning/0">returning</a>, options) ::
  {:ok, <a href="#t:fields/0">fields</a>} |
  {:invalid, <a href="#t:constraints/0">constraints</a>} |
  no_return</pre>  <p>Inserts a single new struct in the data store.</p> <h4 id="c:insert/6-autogenerate" class="section-heading">  Autogenerate </h4> <p>The primary key will be automatically included in <code class="inline">returning</code> if the field has type <code class="inline">:id</code> or <code class="inline">:binary_id</code> and no value was set by the developer or none was autogenerated by the adapter.</p>    <h3 class="detail-header callback" id="c:insert_all/7">  <span class="signature">insert_all(repo, schema_meta, header, list, on_conflict, returning, options)</span>     </h3>
<pre data-language="elixir">insert_all(repo, <a href="#t:schema_meta/0">schema_meta</a>, header :: [atom], [<a href="#t:fields/0">fields</a>], <a href="#t:on_conflict/0">on_conflict</a>, <a href="#t:returning/0">returning</a>, options) ::
  {integer, [[term]] | nil} |
  no_return</pre>  <p>Inserts multiple entries into the data store.</p>    <h3 class="detail-header callback" id="c:loaders/2">  <span class="signature">loaders(primitive_type, ecto_type)</span>     </h3>
<pre data-language="elixir">loaders(primitive_type :: <a href="../ecto.type/#t:primitive/0">Ecto.Type.primitive</a>, ecto_type :: <a href="../ecto.type/#t:t/0">Ecto.Type.t</a>) :: [(term -&gt; {:ok, term} | :error) | <a href="../ecto.type/#t:t/0">Ecto.Type.t</a>]</pre>  <p>Returns the loaders for a given type.</p> <p>It receives the primitive type and the Ecto type (which may be primitive as well). It returns a list of loaders with the given type usually at the end.</p> <p>This allows developers to properly translate values coming from the adapters into Ecto ones. For example, if the database does not support booleans but instead returns 0 and 1 for them, you could add:</p> <pre data-language="elixir"><code class="elixir">def loaders(:boolean, type), do: [&amp;bool_decode/1, type]
def loaders(_primitive, type), do: [type]

defp bool_decode(0), do: {:ok, false}
defp bool_decode(1), do: {:ok, true}</code></pre> <p>All adapters are required to implement a clause for <code class="inline">:binary_id</code> types, since they are adapter specific. If your adapter does not provide binary ids, you may simply use Ecto.UUID:</p> <pre data-language="elixir"><code class="elixir">def loaders(:binary_id, type), do: [Ecto.UUID, type]
def loaders(_primitive, type), do: [type]</code></pre>    <h3 class="detail-header callback" id="c:prepare/2">  <span class="signature">prepare(atom, query)</span>     </h3>
<pre data-language="elixir">prepare(atom :: :all | :update_all | :delete_all, query :: <a href="../ecto.query/#t:t/0">Ecto.Query.t</a>) ::
  {:cache, <a href="#t:prepared/0">prepared</a>} |
  {:nocache, <a href="#t:prepared/0">prepared</a>}</pre>  <p>Commands invoked to prepare a query for <code class="inline">all</code>, <code class="inline">update_all</code> and <code class="inline">delete_all</code>.</p> <p>The returned result is given to <code class="inline">execute/6</code>.</p>    <h3 class="detail-header callback" id="c:update/6">  <span class="signature">update(repo, schema_meta, fields, filters, returning, options)</span>     </h3>
<pre data-language="elixir">update(repo, <a href="#t:schema_meta/0">schema_meta</a>, <a href="#t:fields/0">fields</a>, <a href="#t:filters/0">filters</a>, <a href="#t:returning/0">returning</a>, options) ::
  {:ok, <a href="#t:fields/0">fields</a>} |
  {:invalid, <a href="#t:constraints/0">constraints</a>} |
  {:error, :stale} |
  no_return</pre>  <p>Updates a single struct with the given filters.</p> <p>While <code class="inline">filters</code> can be any record column, it is expected that at least the primary key (or any other key that uniquely identifies an existing record) be given as a filter. Therefore, in case there is no record matching the given filters, <code class="inline">{:error, :stale}</code> is returned.</p>
<div class="_attribution">
  <p class="_attribution-p">
    © 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://hexdocs.pm/ecto/Ecto.Adapter.html" class="_attribution-link" target="_blank">https://hexdocs.pm/ecto/Ecto.Adapter.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
