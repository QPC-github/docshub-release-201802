
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>std&#58;&#58;heap&#58;&#58;Alloc - Rust - W3cubDocs</title>
  
  <meta name="description" content=" An implementation of Alloc can allocate, reallocate, and deallocate arbitrary blocks of data described via Layout. ">
  <meta name="keywords" content="trait, std, heap, alloc, -, rust">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/rust/std/heap/trait.alloc/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-e0f881b0fce8cbe96f33dadc355b7159d5d2912911231446d60eb8f9caffa802.css">
  <script type="text/javascript" src="/assets/application-8fc46316434047265cd383f02b8e7f434ed7dec4a59f920dd633deef8d488d1b.js"></script>
  <script src="/json/rust.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/rust/" class="_nav-link" title="" style="margin-left:0;">Rust</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _rust">
				
<h1 class="fqn">Trait std::heap::Alloc</h1> <pre class="rust trait" data-language="rust">pub unsafe trait Alloc {
    unsafe fn alloc(&amp;mut self, layout: Layout) -&gt; Result&lt;*mut u8, AllocErr&gt;;
    unsafe fn dealloc(&amp;mut self, ptr: *mut u8, layout: Layout);

    fn oom(&amp;mut self, AllocErr) -&gt; ! { ... }
    fn usable_size(&amp;self, layout: &amp;Layout) -&gt; (usize, usize) { ... }
    unsafe fn realloc(Â Â Â Â Â Â Â Â &amp;mut self, Â Â Â Â Â Â Â Â ptr: *mut u8, Â Â Â Â Â Â Â Â layout: Layout, Â Â Â Â Â Â Â Â new_layout: LayoutÂ Â Â Â ) -&gt; Result&lt;*mut u8, AllocErr&gt; { ... }
    unsafe fn alloc_zeroed(Â Â Â Â Â Â Â Â &amp;mut self, Â Â Â Â Â Â Â Â layout: LayoutÂ Â Â Â ) -&gt; Result&lt;*mut u8, AllocErr&gt; { ... }
    unsafe fn alloc_excess(Â Â Â Â Â Â Â Â &amp;mut self, Â Â Â Â Â Â Â Â layout: LayoutÂ Â Â Â ) -&gt; Result&lt;Excess, AllocErr&gt; { ... }
    unsafe fn realloc_excess(Â Â Â Â Â Â Â Â &amp;mut self, Â Â Â Â Â Â Â Â ptr: *mut u8, Â Â Â Â Â Â Â Â layout: Layout, Â Â Â Â Â Â Â Â new_layout: LayoutÂ Â Â Â ) -&gt; Result&lt;Excess, AllocErr&gt; { ... }
    unsafe fn grow_in_place(Â Â Â Â Â Â Â Â &amp;mut self, Â Â Â Â Â Â Â Â ptr: *mut u8, Â Â Â Â Â Â Â Â layout: Layout, Â Â Â Â Â Â Â Â new_layout: LayoutÂ Â Â Â ) -&gt; Result&lt;(), CannotReallocInPlace&gt; { ... }
    unsafe fn shrink_in_place(Â Â Â Â Â Â Â Â &amp;mut self, Â Â Â Â Â Â Â Â ptr: *mut u8, Â Â Â Â Â Â Â Â layout: Layout, Â Â Â Â Â Â Â Â new_layout: LayoutÂ Â Â Â ) -&gt; Result&lt;(), CannotReallocInPlace&gt; { ... }
    fn alloc_one&lt;T&gt;(&amp;mut self) -&gt; Result&lt;Unique&lt;T&gt;, AllocErr&gt; { ... }
    unsafe fn dealloc_one&lt;T&gt;(&amp;mut self, ptr: Unique&lt;T&gt;) { ... }
    fn alloc_array&lt;T&gt;(&amp;mut self, n: usize) -&gt; Result&lt;Unique&lt;T&gt;, AllocErr&gt; { ... }
    unsafe fn realloc_array&lt;T&gt;(Â Â Â Â Â Â Â Â &amp;mut self, Â Â Â Â Â Â Â Â ptr: Unique&lt;T&gt;, Â Â Â Â Â Â Â Â n_old: usize, Â Â Â Â Â Â Â Â n_new: usizeÂ Â Â Â ) -&gt; Result&lt;Unique&lt;T&gt;, AllocErr&gt; { ... }
    unsafe fn dealloc_array&lt;T&gt;(Â Â Â Â Â Â Â Â &amp;mut self, Â Â Â Â Â Â Â Â ptr: Unique&lt;T&gt;, Â Â Â Â Â Â Â Â n: usizeÂ Â Â Â ) -&gt; Result&lt;(), AllocErr&gt; { ... }
}</pre>
<div class="stability"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (allocator_api #32838)the precise API and guarantees it provides may be tweaked slightly, especially to possibly take into account the types being stored to make room for a future tracing garbage collector </span></div>
<p>An implementation of <code>Alloc</code> can allocate, reallocate, and deallocate arbitrary blocks of data described via <code>Layout</code>.</p> <p>Some of the methods require that a memory block be <em>currently allocated</em> via an allocator. This means that:</p> <ul> <li><p>the starting address for that memory block was previously returned by a previous call to an allocation method (<code>alloc</code>, <code>alloc_zeroed</code>, <code>alloc_excess</code>, <code>alloc_one</code>, <code>alloc_array</code>) or reallocation method (<code>realloc</code>, <code>realloc_excess</code>, or <code>realloc_array</code>), and</p></li> <li><p>the memory block has not been subsequently deallocated, where blocks are deallocated either by being passed to a deallocation method (<code>dealloc</code>, <code>dealloc_one</code>, <code>dealloc_array</code>) or by being passed to a reallocation method (see above) that returns <code>Ok</code>.</p></li> </ul> <p>A note regarding zero-sized types and zero-sized layouts: many methods in the <code>Alloc</code> trait state that allocation requests must be non-zero size, or else undefined behavior can result.</p> <ul> <li><p>However, some higher-level allocation methods (<code>alloc_one</code>, <code>alloc_array</code>) are well-defined on zero-sized types and can optionally support them: it is left up to the implementor whether to return <code>Err</code>, or to return <code>Ok</code> with some pointer.</p></li> <li><p>If an <code>Alloc</code> implementation chooses to return <code>Ok</code> in this case (i.e. the pointer denotes a zero-sized inaccessible block) then that returned pointer must be considered "currently allocated". On such an allocator, <em>all</em> methods that take currently-allocated pointers as inputs must accept these zero-sized pointers, <em>without</em> causing undefined behavior.</p></li> <li><p>In other words, if a zero-sized pointer can flow out of an allocator, then that allocator must likewise accept that pointer flowing back into its deallocation and reallocation methods.</p></li> </ul> <p>Some of the methods require that a layout <em>fit</em> a memory block. What it means for a layout to "fit" a memory block means (or equivalently, for a memory block to "fit" a layout) is that the following two conditions must hold:</p> <ol> <li><p>The block's starting address must be aligned to <code>layout.align()</code>.</p></li> <li>
<p>The block's size must fall in the range <code>[use_min, use_max]</code>, where:</p> <ul> <li><p><code>use_min</code> is <code>self.usable_size(layout).0</code>, and</p></li> <li><p><code>use_max</code> is the capacity that was (or would have been) returned when (if) the block was allocated via a call to <code>alloc_excess</code> or <code>realloc_excess</code>.</p></li> </ul>
</li> </ol> <p>Note that:</p> <ul> <li><p>the size of the layout most recently used to allocate the block is guaranteed to be in the range <code>[use_min, use_max]</code>, and</p></li> <li><p>a lower-bound on <code>use_max</code> can be safely approximated by a call to <code>usable_size</code>.</p></li> <li><p>if a layout <code>k</code> fits a memory block (denoted by <code>ptr</code>) currently allocated via an allocator <code>a</code>, then it is legal to use that layout to deallocate it, i.e. <code>a.dealloc(ptr, k);</code>.</p></li> </ul> <h4 id="unsafety" class="section-header">Unsafety</h4> <p>The <code>Alloc</code> trait is an <code>unsafe</code> trait for a number of reasons, and implementors must ensure that they adhere to these contracts:</p> <ul> <li><p>Pointers returned from allocation functions must point to valid memory and retain their validity until at least the instance of <code>Alloc</code> is dropped itself.</p></li> <li><p>It's undefined behavior if global allocators unwind. This restriction may be lifted in the future, but currently a panic from any of these functions may lead to memory unsafety. Note that as of the time of this writing allocators <em>not</em> intending to be global allocators can still panic in their implementation without violating memory safety.</p></li> <li><p><code>Layout</code> queries and calculations in general must be correct. Callers of this trait are allowed to rely on the contracts defined on each method, and implementors must ensure such contracts remain true.</p></li> </ul> <p>Note that this list may get tweaked over time as clarifications are made in the future. Additionally global allocators may gain unique requirements for how to safely implement one in the future as well.</p>  <h2 id="required-methods" class="small-section-header"> Required Methods </h2> <div class="methods"> <h3 id="tymethod.alloc" class="method"><span id="alloc.v" class="invisible"><code>unsafe fn <a href="#tymethod.alloc" class="fnname">alloc</a>(&amp;mut self, layout: <a class="struct" href="../struct.layout/" title="struct std::heap::Layout">Layout</a>) -&gt; <a class="enum" href="../../result/enum.result/" title="enum std::result::Result">Result</a>&lt;<a class="primitive" href="../../primitive.pointer/">*mut </a><a class="primitive" href="../../primitive.u8/">u8</a>, <a class="enum" href="../enum.allocerr/" title="enum std::heap::AllocErr">AllocErr</a>&gt;</code></span></h3>
<div class="stability"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (allocator_api #32838)the precise API and guarantees it provides may be tweaked slightly, especially to possibly take into account the types being stored to make room for a future tracing garbage collector </span></div>
<div class="docblock">
<p>Returns a pointer meeting the size and alignment guarantees of <code>layout</code>.</p> <p>If this method returns an <code>Ok(addr)</code>, then the <code>addr</code> returned will be non-null address pointing to a block of storage suitable for holding an instance of <code>layout</code>.</p> <p>The returned block of storage may or may not have its contents initialized. (Extension subtraits might restrict this behavior, e.g. to ensure initialization to particular sets of bit patterns.)</p> <h4 id="safety" class="section-header">Safety</h4> <p>This function is unsafe because undefined behavior can result if the caller does not ensure that <code>layout</code> has non-zero size.</p> <p>(Extension subtraits might provide more specific bounds on behavior, e.g. guarantee a sentinel address or a null pointer in response to a zero-size allocation request.)</p> <h4 id="errors" class="section-header">Errors</h4> <p>Returning <code>Err</code> indicates that either memory is exhausted or <code>layout</code> does not meet allocator's size or alignment constraints.</p> <p>Implementations are encouraged to return <code>Err</code> on memory exhaustion rather than panicking or aborting, but this is not a strict requirement. (Specifically: it is <em>legal</em> to implement this trait atop an underlying native allocation library that aborts on memory exhaustion.)</p> <p>Clients wishing to abort computation in response to an allocation error are encouraged to call the allocator's <code>oom</code> method, rather than directly invoking <code>panic!</code> or similar.</p> </div>
<h3 id="tymethod.dealloc" class="method"><span id="dealloc.v" class="invisible"><code>unsafe fn <a href="#tymethod.dealloc" class="fnname">dealloc</a>(&amp;mut self, ptr: <a class="primitive" href="../../primitive.pointer/">*mut </a><a class="primitive" href="../../primitive.u8/">u8</a>, layout: <a class="struct" href="../struct.layout/" title="struct std::heap::Layout">Layout</a>)</code></span></h3>
<div class="stability"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (allocator_api #32838)the precise API and guarantees it provides may be tweaked slightly, especially to possibly take into account the types being stored to make room for a future tracing garbage collector </span></div>
<div class="docblock">
<p>Deallocate the memory referenced by <code>ptr</code>.</p> <h4 id="safety-1" class="section-header">Safety</h4> <p>This function is unsafe because undefined behavior can result if the caller does not ensure all of the following:</p> <ul> <li><p><code>ptr</code> must denote a block of memory currently allocated via this allocator,</p></li> <li><p><code>layout</code> must <em>fit</em> that block of memory,</p></li> <li><p>In addition to fitting the block of memory <code>layout</code>, the alignment of the <code>layout</code> must match the alignment used to allocate that block of memory.</p></li> </ul> </div>
</div> <h2 id="provided-methods" class="small-section-header"> Provided Methods </h2> <div class="methods"> <h3 id="method.oom" class="method"><span id="oom.v" class="invisible"><code>fn <a href="#method.oom" class="fnname">oom</a>(&amp;mut self, <a class="enum" href="../enum.allocerr/" title="enum std::heap::AllocErr">AllocErr</a>) -&gt; !</code></span></h3>
<div class="stability"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (allocator_api #32838)the precise API and guarantees it provides may be tweaked slightly, especially to possibly take into account the types being stored to make room for a future tracing garbage collector </span></div>
<div class="docblock">
<p>Allocator-specific method for signaling an out-of-memory condition.</p> <p><code>oom</code> aborts the thread or process, optionally performing cleanup or logging diagnostic information before panicking or aborting.</p> <p><code>oom</code> is meant to be used by clients unable to cope with an unsatisfied allocation request (signaled by an error such as <code>AllocErr::Exhausted</code>), and wish to abandon computation rather than attempt to recover locally. Such clients should pass the signaling error value back into <code>oom</code>, where the allocator may incorporate that error value into its diagnostic report before aborting.</p> <p>Implementations of the <code>oom</code> method are discouraged from infinitely regressing in nested calls to <code>oom</code>. In practice this means implementors should eschew allocating, especially from <code>self</code> (directly or indirectly).</p> <p>Implementations of the allocation and reallocation methods (e.g. <code>alloc</code>, <code>alloc_one</code>, <code>realloc</code>) are discouraged from panicking (or aborting) in the event of memory exhaustion; instead they should return an appropriate error from the invoked method, and let the client decide whether to invoke this <code>oom</code> method in response.</p> </div>
<h3 id="method.usable_size" class="method"><span id="usable_size.v" class="invisible"><code>fn <a href="#method.usable_size" class="fnname">usable_size</a>(&amp;self, layout: &amp;<a class="struct" href="../struct.layout/" title="struct std::heap::Layout">Layout</a>) -&gt; <a class="primitive" href="../../primitive.tuple/">(</a><a class="primitive" href="../../primitive.usize/">usize</a>, <a class="primitive" href="../../primitive.usize/">usize</a><a class="primitive" href="../../primitive.tuple/">)</a></code></span></h3>
<div class="stability"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (allocator_api #32838)the precise API and guarantees it provides may be tweaked slightly, especially to possibly take into account the types being stored to make room for a future tracing garbage collector </span></div>
<div class="docblock">
<p>Returns bounds on the guaranteed usable size of a successful allocation created with the specified <code>layout</code>.</p> <p>In particular, if one has a memory block allocated via a given allocator <code>a</code> and layout <code>k</code> where <code>a.usable_size(k)</code> returns <code>(l, u)</code>, then one can pass that block to <code>a.dealloc()</code> with a layout in the size range [l, u].</p> <p>(All implementors of <code>usable_size</code> must ensure that <code>l &lt;= k.size() &lt;= u</code>)</p> <p>Both the lower- and upper-bounds (<code>l</code> and <code>u</code> respectively) are provided, because an allocator based on size classes could misbehave if one attempts to deallocate a block without providing a correct value for its size (i.e., one within the range <code>[l, u]</code>).</p> <p>Clients who wish to make use of excess capacity are encouraged to use the <code>alloc_excess</code> and <code>realloc_excess</code> instead, as this method is constrained to report conservative values that serve as valid bounds for <em>all possible</em> allocation method calls.</p> <p>However, for clients that do not wish to track the capacity returned by <code>alloc_excess</code> locally, this method is likely to produce useful results.</p> </div>
<h3 id="method.realloc" class="method"><span id="realloc.v" class="invisible"><code>unsafe fn <a href="#method.realloc" class="fnname">realloc</a>(<br>Â Â Â Â &amp;mut self, <br>Â Â Â Â ptr: <a class="primitive" href="../../primitive.pointer/">*mut </a><a class="primitive" href="../../primitive.u8/">u8</a>, <br>Â Â Â Â layout: <a class="struct" href="../struct.layout/" title="struct std::heap::Layout">Layout</a>, <br>Â Â Â Â new_layout: <a class="struct" href="../struct.layout/" title="struct std::heap::Layout">Layout</a><br>) -&gt; <a class="enum" href="../../result/enum.result/" title="enum std::result::Result">Result</a>&lt;<a class="primitive" href="../../primitive.pointer/">*mut </a><a class="primitive" href="../../primitive.u8/">u8</a>, <a class="enum" href="../enum.allocerr/" title="enum std::heap::AllocErr">AllocErr</a>&gt;</code></span></h3>
<div class="stability"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (allocator_api #32838)the precise API and guarantees it provides may be tweaked slightly, especially to possibly take into account the types being stored to make room for a future tracing garbage collector </span></div>
<div class="docblock">
<p>Returns a pointer suitable for holding data described by <code>new_layout</code>, meeting its size and alignment guarantees. To accomplish this, this may extend or shrink the allocation referenced by <code>ptr</code> to fit <code>new_layout</code>.</p> <p>If this returns <code>Ok</code>, then ownership of the memory block referenced by <code>ptr</code> has been transferred to this allocator. The memory may or may not have been freed, and should be considered unusable (unless of course it was transferred back to the caller again via the return value of this method).</p> <p>If this method returns <code>Err</code>, then ownership of the memory block has not been transferred to this allocator, and the contents of the memory block are unaltered.</p> <p>For best results, <code>new_layout</code> should not impose a different alignment constraint than <code>layout</code>. (In other words, <code>new_layout.align()</code> should equal <code>layout.align()</code>.) However, behavior is well-defined (though underspecified) when this constraint is violated; further discussion below.</p> <h4 id="safety-2" class="section-header">Safety</h4> <p>This function is unsafe because undefined behavior can result if the caller does not ensure all of the following:</p> <ul> <li><p><code>ptr</code> must be currently allocated via this allocator,</p></li> <li><p><code>layout</code> must <em>fit</em> the <code>ptr</code> (see above). (The <code>new_layout</code> argument need not fit it.)</p></li> <li><p><code>new_layout</code> must have size greater than zero.</p></li> <li><p>the alignment of <code>new_layout</code> is non-zero.</p></li> </ul> <p>(Extension subtraits might provide more specific bounds on behavior, e.g. guarantee a sentinel address or a null pointer in response to a zero-size allocation request.)</p> <h4 id="errors-1" class="section-header">Errors</h4> <p>Returns <code>Err</code> only if <code>new_layout</code> does not match the alignment of <code>layout</code>, or does not meet the allocator's size and alignment constraints of the allocator, or if reallocation otherwise fails.</p> <p>(Note the previous sentence did not say "if and only if" -- in particular, an implementation of this method <em>can</em> return <code>Ok</code> if <code>new_layout.align() != old_layout.align()</code>; or it can return <code>Err</code> in that scenario, depending on whether this allocator can dynamically adjust the alignment constraint for the block.)</p> <p>Implementations are encouraged to return <code>Err</code> on memory exhaustion rather than panicking or aborting, but this is not a strict requirement. (Specifically: it is <em>legal</em> to implement this trait atop an underlying native allocation library that aborts on memory exhaustion.)</p> <p>Clients wishing to abort computation in response to an reallocation error are encouraged to call the allocator's <code>oom</code> method, rather than directly invoking <code>panic!</code> or similar.</p> </div>
<h3 id="method.alloc_zeroed" class="method"><span id="alloc_zeroed.v" class="invisible"><code>unsafe fn <a href="#method.alloc_zeroed" class="fnname">alloc_zeroed</a>(&amp;mut self, layout: <a class="struct" href="../struct.layout/" title="struct std::heap::Layout">Layout</a>) -&gt; <a class="enum" href="../../result/enum.result/" title="enum std::result::Result">Result</a>&lt;<a class="primitive" href="../../primitive.pointer/">*mut </a><a class="primitive" href="../../primitive.u8/">u8</a>, <a class="enum" href="../enum.allocerr/" title="enum std::heap::AllocErr">AllocErr</a>&gt;</code></span></h3>
<div class="stability"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (allocator_api #32838)the precise API and guarantees it provides may be tweaked slightly, especially to possibly take into account the types being stored to make room for a future tracing garbage collector </span></div>
<div class="docblock">
<p>Behaves like <code>alloc</code>, but also ensures that the contents are set to zero before being returned.</p> <h4 id="safety-3" class="section-header">Safety</h4> <p>This function is unsafe for the same reasons that <code>alloc</code> is.</p> <h4 id="errors-2" class="section-header">Errors</h4> <p>Returning <code>Err</code> indicates that either memory is exhausted or <code>layout</code> does not meet allocator's size or alignment constraints, just as in <code>alloc</code>.</p> <p>Clients wishing to abort computation in response to an allocation error are encouraged to call the allocator's <code>oom</code> method, rather than directly invoking <code>panic!</code> or similar.</p> </div>
<h3 id="method.alloc_excess" class="method"><span id="alloc_excess.v" class="invisible"><code>unsafe fn <a href="#method.alloc_excess" class="fnname">alloc_excess</a>(&amp;mut self, layout: <a class="struct" href="../struct.layout/" title="struct std::heap::Layout">Layout</a>) -&gt; <a class="enum" href="../../result/enum.result/" title="enum std::result::Result">Result</a>&lt;<a class="struct" href="../struct.excess/" title="struct std::heap::Excess">Excess</a>, <a class="enum" href="../enum.allocerr/" title="enum std::heap::AllocErr">AllocErr</a>&gt;</code></span></h3>
<div class="stability"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (allocator_api #32838)the precise API and guarantees it provides may be tweaked slightly, especially to possibly take into account the types being stored to make room for a future tracing garbage collector </span></div>
<div class="docblock">
<p>Behaves like <code>alloc</code>, but also returns the whole size of the returned block. For some <code>layout</code> inputs, like arrays, this may include extra storage usable for additional data.</p> <h4 id="safety-4" class="section-header">Safety</h4> <p>This function is unsafe for the same reasons that <code>alloc</code> is.</p> <h4 id="errors-3" class="section-header">Errors</h4> <p>Returning <code>Err</code> indicates that either memory is exhausted or <code>layout</code> does not meet allocator's size or alignment constraints, just as in <code>alloc</code>.</p> <p>Clients wishing to abort computation in response to an allocation error are encouraged to call the allocator's <code>oom</code> method, rather than directly invoking <code>panic!</code> or similar.</p> </div>
<h3 id="method.realloc_excess" class="method"><span id="realloc_excess.v" class="invisible"><code>unsafe fn <a href="#method.realloc_excess" class="fnname">realloc_excess</a>(<br>Â Â Â Â &amp;mut self, <br>Â Â Â Â ptr: <a class="primitive" href="../../primitive.pointer/">*mut </a><a class="primitive" href="../../primitive.u8/">u8</a>, <br>Â Â Â Â layout: <a class="struct" href="../struct.layout/" title="struct std::heap::Layout">Layout</a>, <br>Â Â Â Â new_layout: <a class="struct" href="../struct.layout/" title="struct std::heap::Layout">Layout</a><br>) -&gt; <a class="enum" href="../../result/enum.result/" title="enum std::result::Result">Result</a>&lt;<a class="struct" href="../struct.excess/" title="struct std::heap::Excess">Excess</a>, <a class="enum" href="../enum.allocerr/" title="enum std::heap::AllocErr">AllocErr</a>&gt;</code></span></h3>
<div class="stability"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (allocator_api #32838)the precise API and guarantees it provides may be tweaked slightly, especially to possibly take into account the types being stored to make room for a future tracing garbage collector </span></div>
<div class="docblock">
<p>Behaves like <code>realloc</code>, but also returns the whole size of the returned block. For some <code>layout</code> inputs, like arrays, this may include extra storage usable for additional data.</p> <h4 id="safety-5" class="section-header">Safety</h4> <p>This function is unsafe for the same reasons that <code>realloc</code> is.</p> <h4 id="errors-4" class="section-header">Errors</h4> <p>Returning <code>Err</code> indicates that either memory is exhausted or <code>layout</code> does not meet allocator's size or alignment constraints, just as in <code>realloc</code>.</p> <p>Clients wishing to abort computation in response to an reallocation error are encouraged to call the allocator's <code>oom</code> method, rather than directly invoking <code>panic!</code> or similar.</p> </div>
<h3 id="method.grow_in_place" class="method"><span id="grow_in_place.v" class="invisible"><code>unsafe fn <a href="#method.grow_in_place" class="fnname">grow_in_place</a>(<br>Â Â Â Â &amp;mut self, <br>Â Â Â Â ptr: <a class="primitive" href="../../primitive.pointer/">*mut </a><a class="primitive" href="../../primitive.u8/">u8</a>, <br>Â Â Â Â layout: <a class="struct" href="../struct.layout/" title="struct std::heap::Layout">Layout</a>, <br>Â Â Â Â new_layout: <a class="struct" href="../struct.layout/" title="struct std::heap::Layout">Layout</a><br>) -&gt; <a class="enum" href="../../result/enum.result/" title="enum std::result::Result">Result</a>&lt;<a class="primitive" href="../../primitive.unit/">()</a>, <a class="struct" href="../struct.cannotreallocinplace/" title="struct std::heap::CannotReallocInPlace">CannotReallocInPlace</a>&gt;</code></span></h3>
<div class="stability"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (allocator_api #32838)the precise API and guarantees it provides may be tweaked slightly, especially to possibly take into account the types being stored to make room for a future tracing garbage collector </span></div>
<div class="docblock">
<p>Attempts to extend the allocation referenced by <code>ptr</code> to fit <code>new_layout</code>.</p> <p>If this returns <code>Ok</code>, then the allocator has asserted that the memory block referenced by <code>ptr</code> now fits <code>new_layout</code>, and thus can be used to carry data of that layout. (The allocator is allowed to expend effort to accomplish this, such as extending the memory block to include successor blocks, or virtual memory tricks.)</p> <p>Regardless of what this method returns, ownership of the memory block referenced by <code>ptr</code> has not been transferred, and the contents of the memory block are unaltered.</p> <h4 id="safety-6" class="section-header">Safety</h4> <p>This function is unsafe because undefined behavior can result if the caller does not ensure all of the following:</p> <ul> <li><p><code>ptr</code> must be currently allocated via this allocator,</p></li> <li><p><code>layout</code> must <em>fit</em> the <code>ptr</code> (see above); note the <code>new_layout</code> argument need not fit it,</p></li> <li><p><code>new_layout.size()</code> must not be less than <code>layout.size()</code>,</p></li> <li><p><code>new_layout.align()</code> must equal <code>layout.align()</code>.</p></li> </ul> <h4 id="errors-5" class="section-header">Errors</h4> <p>Returns <code>Err(CannotReallocInPlace)</code> when the allocator is unable to assert that the memory block referenced by <code>ptr</code> could fit <code>layout</code>.</p> <p>Note that one cannot pass <code>CannotReallocInPlace</code> to the <code>oom</code> method; clients are expected either to be able to recover from <code>grow_in_place</code> failures without aborting, or to fall back on another reallocation method before resorting to an abort.</p> </div>
<h3 id="method.shrink_in_place" class="method"><span id="shrink_in_place.v" class="invisible"><code>unsafe fn <a href="#method.shrink_in_place" class="fnname">shrink_in_place</a>(<br>Â Â Â Â &amp;mut self, <br>Â Â Â Â ptr: <a class="primitive" href="../../primitive.pointer/">*mut </a><a class="primitive" href="../../primitive.u8/">u8</a>, <br>Â Â Â Â layout: <a class="struct" href="../struct.layout/" title="struct std::heap::Layout">Layout</a>, <br>Â Â Â Â new_layout: <a class="struct" href="../struct.layout/" title="struct std::heap::Layout">Layout</a><br>) -&gt; <a class="enum" href="../../result/enum.result/" title="enum std::result::Result">Result</a>&lt;<a class="primitive" href="../../primitive.unit/">()</a>, <a class="struct" href="../struct.cannotreallocinplace/" title="struct std::heap::CannotReallocInPlace">CannotReallocInPlace</a>&gt;</code></span></h3>
<div class="stability"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (allocator_api #32838)the precise API and guarantees it provides may be tweaked slightly, especially to possibly take into account the types being stored to make room for a future tracing garbage collector </span></div>
<div class="docblock">
<p>Attempts to shrink the allocation referenced by <code>ptr</code> to fit <code>new_layout</code>.</p> <p>If this returns <code>Ok</code>, then the allocator has asserted that the memory block referenced by <code>ptr</code> now fits <code>new_layout</code>, and thus can only be used to carry data of that smaller layout. (The allocator is allowed to take advantage of this, carving off portions of the block for reuse elsewhere.) The truncated contents of the block within the smaller layout are unaltered, and ownership of block has not been transferred.</p> <p>If this returns <code>Err</code>, then the memory block is considered to still represent the original (larger) <code>layout</code>. None of the block has been carved off for reuse elsewhere, ownership of the memory block has not been transferred, and the contents of the memory block are unaltered.</p> <h4 id="safety-7" class="section-header">Safety</h4> <p>This function is unsafe because undefined behavior can result if the caller does not ensure all of the following:</p> <ul> <li><p><code>ptr</code> must be currently allocated via this allocator,</p></li> <li><p><code>layout</code> must <em>fit</em> the <code>ptr</code> (see above); note the <code>new_layout</code> argument need not fit it,</p></li> <li><p><code>new_layout.size()</code> must not be greater than <code>layout.size()</code> (and must be greater than zero),</p></li> <li><p><code>new_layout.align()</code> must equal <code>layout.align()</code>.</p></li> </ul> <h4 id="errors-6" class="section-header">Errors</h4> <p>Returns <code>Err(CannotReallocInPlace)</code> when the allocator is unable to assert that the memory block referenced by <code>ptr</code> could fit <code>layout</code>.</p> <p>Note that one cannot pass <code>CannotReallocInPlace</code> to the <code>oom</code> method; clients are expected either to be able to recover from <code>shrink_in_place</code> failures without aborting, or to fall back on another reallocation method before resorting to an abort.</p> </div>
<h3 id="method.alloc_one" class="method"><span id="alloc_one.v" class="invisible"><code>fn <a href="#method.alloc_one" class="fnname">alloc_one</a>&lt;T&gt;(&amp;mut self) -&gt; <a class="enum" href="../../result/enum.result/" title="enum std::result::Result">Result</a>&lt;<a class="struct" href="../../ptr/struct.unique/" title="struct std::ptr::Unique">Unique</a>&lt;T&gt;, <a class="enum" href="../enum.allocerr/" title="enum std::heap::AllocErr">AllocErr</a>&gt;</code></span></h3>
<div class="stability"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (allocator_api #32838)the precise API and guarantees it provides may be tweaked slightly, especially to possibly take into account the types being stored to make room for a future tracing garbage collector </span></div>
<div class="docblock">
<p>Allocates a block suitable for holding an instance of <code>T</code>.</p> <p>Captures a common usage pattern for allocators.</p> <p>The returned block is suitable for passing to the <code>alloc</code>/<code>realloc</code> methods of this allocator.</p> <p>Note to implementors: If this returns <code>Ok(ptr)</code>, then <code>ptr</code> must be considered "currently allocated" and must be acceptable input to methods such as <code>realloc</code> or <code>dealloc</code>, <em>even if</em> <code>T</code> is a zero-sized type. In other words, if your <code>Alloc</code> implementation overrides this method in a manner that can return a zero-sized <code>ptr</code>, then all reallocation and deallocation methods need to be similarly overridden to accept such values as input.</p> <h4 id="errors-7" class="section-header">Errors</h4> <p>Returning <code>Err</code> indicates that either memory is exhausted or <code>T</code> does not meet allocator's size or alignment constraints.</p> <p>For zero-sized <code>T</code>, may return either of <code>Ok</code> or <code>Err</code>, but will <em>not</em> yield undefined behavior.</p> <p>Clients wishing to abort computation in response to an allocation error are encouraged to call the allocator's <code>oom</code> method, rather than directly invoking <code>panic!</code> or similar.</p> </div>
<h3 id="method.dealloc_one" class="method"><span id="dealloc_one.v" class="invisible"><code>unsafe fn <a href="#method.dealloc_one" class="fnname">dealloc_one</a>&lt;T&gt;(&amp;mut self, ptr: <a class="struct" href="../../ptr/struct.unique/" title="struct std::ptr::Unique">Unique</a>&lt;T&gt;)</code></span></h3>
<div class="stability"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (allocator_api #32838)the precise API and guarantees it provides may be tweaked slightly, especially to possibly take into account the types being stored to make room for a future tracing garbage collector </span></div>
<div class="docblock">
<p>Deallocates a block suitable for holding an instance of <code>T</code>.</p> <p>The given block must have been produced by this allocator, and must be suitable for storing a <code>T</code> (in terms of alignment as well as minimum and maximum size); otherwise yields undefined behavior.</p> <p>Captures a common usage pattern for allocators.</p> <h4 id="safety-8" class="section-header">Safety</h4> <p>This function is unsafe because undefined behavior can result if the caller does not ensure both:</p> <ul> <li><p><code>ptr</code> must denote a block of memory currently allocated via this allocator</p></li> <li><p>the layout of <code>T</code> must <em>fit</em> that block of memory.</p></li> </ul> </div>
<h3 id="method.alloc_array" class="method"><span id="alloc_array.v" class="invisible"><code>fn <a href="#method.alloc_array" class="fnname">alloc_array</a>&lt;T&gt;(&amp;mut self, n: <a class="primitive" href="../../primitive.usize/">usize</a>) -&gt; <a class="enum" href="../../result/enum.result/" title="enum std::result::Result">Result</a>&lt;<a class="struct" href="../../ptr/struct.unique/" title="struct std::ptr::Unique">Unique</a>&lt;T&gt;, <a class="enum" href="../enum.allocerr/" title="enum std::heap::AllocErr">AllocErr</a>&gt;</code></span></h3>
<div class="stability"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (allocator_api #32838)the precise API and guarantees it provides may be tweaked slightly, especially to possibly take into account the types being stored to make room for a future tracing garbage collector </span></div>
<div class="docblock">
<p>Allocates a block suitable for holding <code>n</code> instances of <code>T</code>.</p> <p>Captures a common usage pattern for allocators.</p> <p>The returned block is suitable for passing to the <code>alloc</code>/<code>realloc</code> methods of this allocator.</p> <p>Note to implementors: If this returns <code>Ok(ptr)</code>, then <code>ptr</code> must be considered "currently allocated" and must be acceptable input to methods such as <code>realloc</code> or <code>dealloc</code>, <em>even if</em> <code>T</code> is a zero-sized type. In other words, if your <code>Alloc</code> implementation overrides this method in a manner that can return a zero-sized <code>ptr</code>, then all reallocation and deallocation methods need to be similarly overridden to accept such values as input.</p> <h4 id="errors-8" class="section-header">Errors</h4> <p>Returning <code>Err</code> indicates that either memory is exhausted or <code>[T; n]</code> does not meet allocator's size or alignment constraints.</p> <p>For zero-sized <code>T</code> or <code>n == 0</code>, may return either of <code>Ok</code> or <code>Err</code>, but will <em>not</em> yield undefined behavior.</p> <p>Always returns <code>Err</code> on arithmetic overflow.</p> <p>Clients wishing to abort computation in response to an allocation error are encouraged to call the allocator's <code>oom</code> method, rather than directly invoking <code>panic!</code> or similar.</p> </div>
<h3 id="method.realloc_array" class="method"><span id="realloc_array.v" class="invisible"><code>unsafe fn <a href="#method.realloc_array" class="fnname">realloc_array</a>&lt;T&gt;(<br>Â Â Â Â &amp;mut self, <br>Â Â Â Â ptr: <a class="struct" href="../../ptr/struct.unique/" title="struct std::ptr::Unique">Unique</a>&lt;T&gt;, <br>Â Â Â Â n_old: <a class="primitive" href="../../primitive.usize/">usize</a>, <br>Â Â Â Â n_new: <a class="primitive" href="../../primitive.usize/">usize</a><br>) -&gt; <a class="enum" href="../../result/enum.result/" title="enum std::result::Result">Result</a>&lt;<a class="struct" href="../../ptr/struct.unique/" title="struct std::ptr::Unique">Unique</a>&lt;T&gt;, <a class="enum" href="../enum.allocerr/" title="enum std::heap::AllocErr">AllocErr</a>&gt;</code></span></h3>
<div class="stability"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (allocator_api #32838)the precise API and guarantees it provides may be tweaked slightly, especially to possibly take into account the types being stored to make room for a future tracing garbage collector </span></div>
<div class="docblock">
<p>Reallocates a block previously suitable for holding <code>n_old</code> instances of <code>T</code>, returning a block suitable for holding <code>n_new</code> instances of <code>T</code>.</p> <p>Captures a common usage pattern for allocators.</p> <p>The returned block is suitable for passing to the <code>alloc</code>/<code>realloc</code> methods of this allocator.</p> <h4 id="safety-9" class="section-header">Safety</h4> <p>This function is unsafe because undefined behavior can result if the caller does not ensure all of the following:</p> <ul> <li><p><code>ptr</code> must be currently allocated via this allocator,</p></li> <li><p>the layout of <code>[T; n_old]</code> must <em>fit</em> that block of memory.</p></li> </ul> <h4 id="errors-9" class="section-header">Errors</h4> <p>Returning <code>Err</code> indicates that either memory is exhausted or <code>[T; n_new]</code> does not meet allocator's size or alignment constraints.</p> <p>For zero-sized <code>T</code> or <code>n_new == 0</code>, may return either of <code>Ok</code> or <code>Err</code>, but will <em>not</em> yield undefined behavior.</p> <p>Always returns <code>Err</code> on arithmetic overflow.</p> <p>Clients wishing to abort computation in response to an reallocation error are encouraged to call the allocator's <code>oom</code> method, rather than directly invoking <code>panic!</code> or similar.</p> </div>
<h3 id="method.dealloc_array" class="method"><span id="dealloc_array.v" class="invisible"><code>unsafe fn <a href="#method.dealloc_array" class="fnname">dealloc_array</a>&lt;T&gt;(<br>Â Â Â Â &amp;mut self, <br>Â Â Â Â ptr: <a class="struct" href="../../ptr/struct.unique/" title="struct std::ptr::Unique">Unique</a>&lt;T&gt;, <br>Â Â Â Â n: <a class="primitive" href="../../primitive.usize/">usize</a><br>) -&gt; <a class="enum" href="../../result/enum.result/" title="enum std::result::Result">Result</a>&lt;<a class="primitive" href="../../primitive.unit/">()</a>, <a class="enum" href="../enum.allocerr/" title="enum std::heap::AllocErr">AllocErr</a>&gt;</code></span></h3>
<div class="stability"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (allocator_api #32838)the precise API and guarantees it provides may be tweaked slightly, especially to possibly take into account the types being stored to make room for a future tracing garbage collector </span></div>
<div class="docblock">
<p>Deallocates a block suitable for holding <code>n</code> instances of <code>T</code>.</p> <p>Captures a common usage pattern for allocators.</p> <h4 id="safety-10" class="section-header">Safety</h4> <p>This function is unsafe because undefined behavior can result if the caller does not ensure both:</p> <ul> <li><p><code>ptr</code> must denote a block of memory currently allocated via this allocator</p></li> <li><p>the layout of <code>[T; n]</code> must <em>fit</em> that block of memory.</p></li> </ul> <h4 id="errors-10" class="section-header">Errors</h4> <p>Returning <code>Err</code> indicates that either <code>[T; n]</code> or the given memory block does not meet allocator's size or alignment constraints.</p> <p>Always returns <code>Err</code> on arithmetic overflow.</p> </div>
</div> <h2 id="implementors" class="small-section-header"> Implementors </h2> <ul class="item-list" id="implementors-list"> <li>
<div class="out-of-band"><a class="srclink" href="https://doc.rust-lang.org/src/alloc/heap.rs.html#80-229" title="goto source code" target="_blank">[src]</a></div>
<code>impl Alloc for <a class="struct" href="../struct.heap/" title="struct std::heap::Heap">Heap</a></code>
</li> <li><code>impl&lt;'a&gt; Alloc for &amp;'a <a class="struct" href="../struct.system/" title="struct std::heap::System">System</a></code></li> <li><code>impl Alloc for <a class="struct" href="../struct.system/" title="struct std::heap::System">System</a></code></li> </ul>
<div class="_attribution">
  <p class="_attribution-p">
    Â© 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/std/heap/trait.Alloc.html" class="_attribution-link" target="_blank">https://doc.rust-lang.org/std/heap/trait.Alloc.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
