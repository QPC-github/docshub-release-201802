
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>std&#58;&#58;sync&#58;&#58;atomic&#58;&#58;AtomicBool - Rust - W3cubDocs</title>
  
  <meta name="description" content=" A boolean type which can be safely shared between threads. ">
  <meta name="keywords" content="struct, std, sync, atomic, atomicbool, -, rust">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/rust/std/sync/atomic/struct.atomicbool/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-e0f881b0fce8cbe96f33dadc355b7159d5d2912911231446d60eb8f9caffa802.css">
  <script type="text/javascript" src="/assets/application-8fc46316434047265cd383f02b8e7f434ed7dec4a59f920dd633deef8d488d1b.js"></script>
  <script src="/json/rust.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/rust/" class="_nav-link" title="" style="margin-left:0;">Rust</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _rust">
				
<h1 class="fqn">Struct std::sync::atomic::AtomicBool</h1> <pre class="rust struct" data-language="rust">pub struct AtomicBool { /* fields omitted */ }</pre>
<p>A boolean type which can be safely shared between threads.</p> <p>This type has the same in-memory representation as a <a href="../../../primitive.bool/"><code>bool</code></a>.</p>  <h2 id="methods" class="small-section-header"> Methods </h2> <h3 id="impl" class="impl">
<span class="in-band"><code>impl <a class="struct" href="../struct.atomicbool/" title="struct std::sync::atomic::AtomicBool">AtomicBool</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/core/sync/atomic.rs.html#233-644" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.new" class="method">
<span id="new.v" class="invisible"><code>const fn <a href="#method.new" class="fnname">new</a>(v: <a class="primitive" href="../../../primitive.bool/">bool</a>) -&gt; <a class="struct" href="../struct.atomicbool/" title="struct std::sync::atomic::AtomicBool">AtomicBool</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/core/sync/atomic.rs.html#247-249" title="goto source code" target="_blank">[src]</a></span>
</h4> <div class="docblock">
<p>Creates a new <code>AtomicBool</code>.</p> <h4 id="examples" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::sync::atomic::AtomicBool;

let atomic_true  = AtomicBool::new(true);
let atomic_false = AtomicBool::new(false);</pre> </div>
<h4 id="method.get_mut" class="method">
<span id="get_mut.v" class="invisible"><code>fn <a href="#method.get_mut" class="fnname">get_mut</a>(&amp;mut self) -&gt; &amp;mut <a class="primitive" href="../../../primitive.bool/">bool</a></code></span><span class="out-of-band">
<div class="since" title="Stable since Rust version 1.15.0">1.15.0</div>
<a class="srclink" href="https://doc.rust-lang.org/src/core/sync/atomic.rs.html#270-272" title="goto source code" target="_blank">[src]</a></span>
</h4> <div class="docblock">
<p>Returns a mutable reference to the underlying <a href="../../../primitive.bool/"><code>bool</code></a>.</p> <p>This is safe because the mutable reference guarantees that no other threads are concurrently accessing the atomic data.</p> <h4 id="examples-1" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::sync::atomic::{AtomicBool, Ordering};

let mut some_bool = AtomicBool::new(true);
assert_eq!(*some_bool.get_mut(), true);
*some_bool.get_mut() = false;
assert_eq!(some_bool.load(Ordering::SeqCst), false);</pre> </div>
<h4 id="method.into_inner" class="method">
<span id="into_inner.v" class="invisible"><code>fn <a href="#method.into_inner" class="fnname">into_inner</a>(self) -&gt; <a class="primitive" href="../../../primitive.bool/">bool</a></code></span><span class="out-of-band">
<div class="since" title="Stable since Rust version 1.15.0">1.15.0</div>
<a class="srclink" href="https://doc.rust-lang.org/src/core/sync/atomic.rs.html#289-291" title="goto source code" target="_blank">[src]</a></span>
</h4> <div class="docblock">
<p>Consumes the atomic and returns the contained value.</p> <p>This is safe because passing <code>self</code> by value guarantees that no other threads are concurrently accessing the atomic data.</p> <h4 id="examples-2" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::sync::atomic::AtomicBool;

let some_bool = AtomicBool::new(true);
assert_eq!(some_bool.into_inner(), true);</pre> </div>
<h4 id="method.load" class="method">
<span id="load.v" class="invisible"><code>fn <a href="#method.load" class="fnname">load</a>(&amp;self, order: <a class="enum" href="../enum.ordering/" title="enum std::sync::atomic::Ordering">Ordering</a>) -&gt; <a class="primitive" href="../../../primitive.bool/">bool</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/core/sync/atomic.rs.html#317-319" title="goto source code" target="_blank">[src]</a></span>
</h4> <div class="docblock">
<p>Loads a value from the bool.</p> <p><code>load</code> takes an <a href="../enum.ordering/"><code>Ordering</code></a> argument which describes the memory ordering of this operation.</p> <h4 id="panics" class="section-header">Panics</h4> <p>Panics if <code>order</code> is <a href="../enum.ordering/#variant.Release"><code>Release</code></a> or <a href="../enum.ordering/#variant.AcqRel"><code>AcqRel</code></a>.</p> <h4 id="examples-3" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::sync::atomic::{AtomicBool, Ordering};

let some_bool = AtomicBool::new(true);

assert_eq!(some_bool.load(Ordering::Relaxed), true);</pre> </div>
<h4 id="method.store" class="method">
<span id="store.v" class="invisible"><code>fn <a href="#method.store" class="fnname">store</a>(&amp;self, val: <a class="primitive" href="../../../primitive.bool/">bool</a>, order: <a class="enum" href="../enum.ordering/" title="enum std::sync::atomic::Ordering">Ordering</a>)</code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/core/sync/atomic.rs.html#347-351" title="goto source code" target="_blank">[src]</a></span>
</h4> <div class="docblock">
<p>Stores a value into the bool.</p> <p><code>store</code> takes an <a href="../enum.ordering/"><code>Ordering</code></a> argument which describes the memory ordering of this operation.</p> <h4 id="examples-4" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::sync::atomic::{AtomicBool, Ordering};

let some_bool = AtomicBool::new(true);

some_bool.store(false, Ordering::Relaxed);
assert_eq!(some_bool.load(Ordering::Relaxed), false);</pre> <h4 id="panics-1" class="section-header">Panics</h4> <p>Panics if <code>order</code> is <a href="../enum.ordering/#variant.Acquire"><code>Acquire</code></a> or <a href="../enum.ordering/#variant.AcqRel"><code>AcqRel</code></a>.</p> </div>
<h4 id="method.swap" class="method">
<span id="swap.v" class="invisible"><code>fn <a href="#method.swap" class="fnname">swap</a>(&amp;self, val: <a class="primitive" href="../../../primitive.bool/">bool</a>, order: <a class="enum" href="../enum.ordering/" title="enum std::sync::atomic::Ordering">Ordering</a>) -&gt; <a class="primitive" href="../../../primitive.bool/">bool</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/core/sync/atomic.rs.html#372-374" title="goto source code" target="_blank">[src]</a></span>
</h4> <div class="docblock">
<p>Stores a value into the bool, returning the previous value.</p> <p><code>swap</code> takes an <a href="../enum.ordering/"><code>Ordering</code></a> argument which describes the memory ordering of this operation.</p> <h4 id="examples-5" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::sync::atomic::{AtomicBool, Ordering};

let some_bool = AtomicBool::new(true);

assert_eq!(some_bool.swap(false, Ordering::Relaxed), true);
assert_eq!(some_bool.load(Ordering::Relaxed), false);</pre> </div>
<h4 id="method.compare_and_swap" class="method">
<span id="compare_and_swap.v" class="invisible"><code>fn <a href="#method.compare_and_swap" class="fnname">compare_and_swap</a>(&amp;self, current: <a class="primitive" href="../../../primitive.bool/">bool</a>, new: <a class="primitive" href="../../../primitive.bool/">bool</a>, order: <a class="enum" href="../enum.ordering/" title="enum std::sync::atomic::Ordering">Ordering</a>) -&gt; <a class="primitive" href="../../../primitive.bool/">bool</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/core/sync/atomic.rs.html#402-407" title="goto source code" target="_blank">[src]</a></span>
</h4> <div class="docblock">
<p>Stores a value into the <a href="../../../primitive.bool/"><code>bool</code></a> if the current value is the same as the <code>current</code> value.</p> <p>The return value is always the previous value. If it is equal to <code>current</code>, then the value was updated.</p> <p><code>compare_and_swap</code> also takes an <a href="../enum.ordering/"><code>Ordering</code></a> argument which describes the memory ordering of this operation.</p> <h4 id="examples-6" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::sync::atomic::{AtomicBool, Ordering};

let some_bool = AtomicBool::new(true);

assert_eq!(some_bool.compare_and_swap(true, false, Ordering::Relaxed), true);
assert_eq!(some_bool.load(Ordering::Relaxed), false);

assert_eq!(some_bool.compare_and_swap(true, true, Ordering::Relaxed), false);
assert_eq!(some_bool.load(Ordering::Relaxed), false);</pre> </div>
<h4 id="method.compare_exchange" class="method">
<span id="compare_exchange.v" class="invisible"><code>fn <a href="#method.compare_exchange" class="fnname">compare_exchange</a>(<br>    &amp;self, <br>    current: <a class="primitive" href="../../../primitive.bool/">bool</a>, <br>    new: <a class="primitive" href="../../../primitive.bool/">bool</a>, <br>    success: <a class="enum" href="../enum.ordering/" title="enum std::sync::atomic::Ordering">Ordering</a>, <br>    failure: <a class="enum" href="../enum.ordering/" title="enum std::sync::atomic::Ordering">Ordering</a><br>) -&gt; <a class="enum" href="../../../result/enum.result/" title="enum std::result::Result">Result</a>&lt;<a class="primitive" href="../../../primitive.bool/">bool</a>, <a class="primitive" href="../../../primitive.bool/">bool</a>&gt;</code></span><span class="out-of-band">
<div class="since" title="Stable since Rust version 1.10.0">1.10.0</div>
<a class="srclink" href="https://doc.rust-lang.org/src/core/sync/atomic.rs.html#447-459" title="goto source code" target="_blank">[src]</a></span>
</h4> <div class="docblock">
<p>Stores a value into the <a href="../../../primitive.bool/"><code>bool</code></a> if the current value is the same as the <code>current</code> value.</p> <p>The return value is a result indicating whether the new value was written and containing the previous value. On success this value is guaranteed to be equal to <code>current</code>.</p> <p><code>compare_exchange</code> takes two <a href="../enum.ordering/"><code>Ordering</code></a> arguments to describe the memory ordering of this operation. The first describes the required ordering if the operation succeeds while the second describes the required ordering when the operation fails. The failure ordering can't be <a href="../enum.ordering/#variant.Release"><code>Release</code></a> or <a href="../enum.ordering/#variant.Release"><code>AcqRel</code></a> and must be equivalent or weaker than the success ordering.</p> <h4 id="examples-7" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::sync::atomic::{AtomicBool, Ordering};

let some_bool = AtomicBool::new(true);

assert_eq!(some_bool.compare_exchange(true,
                                      false,
                                      Ordering::Acquire,
                                      Ordering::Relaxed),
           Ok(true));
assert_eq!(some_bool.load(Ordering::Relaxed), false);

assert_eq!(some_bool.compare_exchange(true, true,
                                      Ordering::SeqCst,
                                      Ordering::Acquire),
           Err(false));
assert_eq!(some_bool.load(Ordering::Relaxed), false);</pre> </div>
<h4 id="method.compare_exchange_weak" class="method">
<span id="compare_exchange_weak.v" class="invisible"><code>fn <a href="#method.compare_exchange_weak" class="fnname">compare_exchange_weak</a>(<br>    &amp;self, <br>    current: <a class="primitive" href="../../../primitive.bool/">bool</a>, <br>    new: <a class="primitive" href="../../../primitive.bool/">bool</a>, <br>    success: <a class="enum" href="../enum.ordering/" title="enum std::sync::atomic::Ordering">Ordering</a>, <br>    failure: <a class="enum" href="../enum.ordering/" title="enum std::sync::atomic::Ordering">Ordering</a><br>) -&gt; <a class="enum" href="../../../result/enum.result/" title="enum std::result::Result">Result</a>&lt;<a class="primitive" href="../../../primitive.bool/">bool</a>, <a class="primitive" href="../../../primitive.bool/">bool</a>&gt;</code></span><span class="out-of-band">
<div class="since" title="Stable since Rust version 1.10.0">1.10.0</div>
<a class="srclink" href="https://doc.rust-lang.org/src/core/sync/atomic.rs.html#498-510" title="goto source code" target="_blank">[src]</a></span>
</h4> <div class="docblock">
<p>Stores a value into the <a href="../../../primitive.bool/"><code>bool</code></a> if the current value is the same as the <code>current</code> value.</p> <p>Unlike <a href="#method.compare_exchange"><code>compare_exchange</code></a>, this function is allowed to spuriously fail even when the comparison succeeds, which can result in more efficient code on some platforms. The return value is a result indicating whether the new value was written and containing the previous value.</p> <p><code>compare_exchange_weak</code> takes two <a href="../enum.ordering/"><code>Ordering</code></a> arguments to describe the memory ordering of this operation. The first describes the required ordering if the operation succeeds while the second describes the required ordering when the operation fails. The failure ordering can't be <a href="../enum.ordering/#variant.Release"><code>Release</code></a> or <a href="../enum.ordering/#variant.Release"><code>AcqRel</code></a> and must be equivalent or weaker than the success ordering.</p> <h4 id="examples-8" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::sync::atomic::{AtomicBool, Ordering};

let val = AtomicBool::new(false);

let new = true;
let mut old = val.load(Ordering::Relaxed);
loop {
    match val.compare_exchange_weak(old, new, Ordering::SeqCst, Ordering::Relaxed) {
        Ok(_) =&gt; break,
        Err(x) =&gt; old = x,
    }
}</pre> </div>
<h4 id="method.fetch_and" class="method">
<span id="fetch_and.v" class="invisible"><code>fn <a href="#method.fetch_and" class="fnname">fetch_and</a>(&amp;self, val: <a class="primitive" href="../../../primitive.bool/">bool</a>, order: <a class="enum" href="../enum.ordering/" title="enum std::sync::atomic::Ordering">Ordering</a>) -&gt; <a class="primitive" href="../../../primitive.bool/">bool</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/core/sync/atomic.rs.html#538-540" title="goto source code" target="_blank">[src]</a></span>
</h4> <div class="docblock">
<p>Logical "and" with a boolean value.</p> <p>Performs a logical "and" operation on the current value and the argument <code>val</code>, and sets the new value to the result.</p> <p>Returns the previous value.</p> <h4 id="examples-9" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::sync::atomic::{AtomicBool, Ordering};

let foo = AtomicBool::new(true);
assert_eq!(foo.fetch_and(false, Ordering::SeqCst), true);
assert_eq!(foo.load(Ordering::SeqCst), false);

let foo = AtomicBool::new(true);
assert_eq!(foo.fetch_and(true, Ordering::SeqCst), true);
assert_eq!(foo.load(Ordering::SeqCst), true);

let foo = AtomicBool::new(false);
assert_eq!(foo.fetch_and(false, Ordering::SeqCst), false);
assert_eq!(foo.load(Ordering::SeqCst), false);</pre> </div>
<h4 id="method.fetch_nand" class="method">
<span id="fetch_nand.v" class="invisible"><code>fn <a href="#method.fetch_nand" class="fnname">fetch_nand</a>(&amp;self, val: <a class="primitive" href="../../../primitive.bool/">bool</a>, order: <a class="enum" href="../enum.ordering/" title="enum std::sync::atomic::Ordering">Ordering</a>) -&gt; <a class="primitive" href="../../../primitive.bool/">bool</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/core/sync/atomic.rs.html#569-583" title="goto source code" target="_blank">[src]</a></span>
</h4> <div class="docblock">
<p>Logical "nand" with a boolean value.</p> <p>Performs a logical "nand" operation on the current value and the argument <code>val</code>, and sets the new value to the result.</p> <p>Returns the previous value.</p> <h4 id="examples-10" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::sync::atomic::{AtomicBool, Ordering};

let foo = AtomicBool::new(true);
assert_eq!(foo.fetch_nand(false, Ordering::SeqCst), true);
assert_eq!(foo.load(Ordering::SeqCst), true);

let foo = AtomicBool::new(true);
assert_eq!(foo.fetch_nand(true, Ordering::SeqCst), true);
assert_eq!(foo.load(Ordering::SeqCst) as usize, 0);
assert_eq!(foo.load(Ordering::SeqCst), false);

let foo = AtomicBool::new(false);
assert_eq!(foo.fetch_nand(false, Ordering::SeqCst), false);
assert_eq!(foo.load(Ordering::SeqCst), true);</pre> </div>
<h4 id="method.fetch_or" class="method">
<span id="fetch_or.v" class="invisible"><code>fn <a href="#method.fetch_or" class="fnname">fetch_or</a>(&amp;self, val: <a class="primitive" href="../../../primitive.bool/">bool</a>, order: <a class="enum" href="../enum.ordering/" title="enum std::sync::atomic::Ordering">Ordering</a>) -&gt; <a class="primitive" href="../../../primitive.bool/">bool</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/core/sync/atomic.rs.html#611-613" title="goto source code" target="_blank">[src]</a></span>
</h4> <div class="docblock">
<p>Logical "or" with a boolean value.</p> <p>Performs a logical "or" operation on the current value and the argument <code>val</code>, and sets the new value to the result.</p> <p>Returns the previous value.</p> <h4 id="examples-11" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::sync::atomic::{AtomicBool, Ordering};

let foo = AtomicBool::new(true);
assert_eq!(foo.fetch_or(false, Ordering::SeqCst), true);
assert_eq!(foo.load(Ordering::SeqCst), true);

let foo = AtomicBool::new(true);
assert_eq!(foo.fetch_or(true, Ordering::SeqCst), true);
assert_eq!(foo.load(Ordering::SeqCst), true);

let foo = AtomicBool::new(false);
assert_eq!(foo.fetch_or(false, Ordering::SeqCst), false);
assert_eq!(foo.load(Ordering::SeqCst), false);</pre> </div>
<h4 id="method.fetch_xor" class="method">
<span id="fetch_xor.v" class="invisible"><code>fn <a href="#method.fetch_xor" class="fnname">fetch_xor</a>(&amp;self, val: <a class="primitive" href="../../../primitive.bool/">bool</a>, order: <a class="enum" href="../enum.ordering/" title="enum std::sync::atomic::Ordering">Ordering</a>) -&gt; <a class="primitive" href="../../../primitive.bool/">bool</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/core/sync/atomic.rs.html#641-643" title="goto source code" target="_blank">[src]</a></span>
</h4> <div class="docblock">
<p>Logical "xor" with a boolean value.</p> <p>Performs a logical "xor" operation on the current value and the argument <code>val</code>, and sets the new value to the result.</p> <p>Returns the previous value.</p> <h4 id="examples-12" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::sync::atomic::{AtomicBool, Ordering};

let foo = AtomicBool::new(true);
assert_eq!(foo.fetch_xor(false, Ordering::SeqCst), true);
assert_eq!(foo.load(Ordering::SeqCst), true);

let foo = AtomicBool::new(true);
assert_eq!(foo.fetch_xor(true, Ordering::SeqCst), true);
assert_eq!(foo.load(Ordering::SeqCst), false);

let foo = AtomicBool::new(false);
assert_eq!(foo.fetch_xor(false, Ordering::SeqCst), false);
assert_eq!(foo.load(Ordering::SeqCst), false);</pre> </div> <h2 id="implementations" class="small-section-header"> Trait Implementations </h2> <h3 id="impl-Default" class="impl">
<span class="in-band"><code>impl <a class="trait" href="../../../default/trait.default/" title="trait std::default::Default">Default</a> for <a class="struct" href="../struct.atomicbool/" title="struct std::sync::atomic::AtomicBool">AtomicBool</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/core/sync/atomic.rs.html#133-138" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.default" class="method">
<span id="default.v" class="invisible"><code>fn <a href="../../../default/trait.default/#tymethod.default" class="fnname">default</a>() -&gt; <a class="struct" href="../struct.atomicbool/" title="struct std::sync::atomic::AtomicBool">AtomicBool</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/core/sync/atomic.rs.html#135-137" title="goto source code" target="_blank">[src]</a></span>
</h4> <div class="docblock">
<p>Creates an <code>AtomicBool</code> initialized to <code>false</code>.</p> </div>
<h3 id="impl-Sync" class="impl">
<span class="in-band"><code>impl <a class="trait" href="../../../marker/trait.sync/" title="trait std::marker::Sync">Sync</a> for <a class="struct" href="../struct.atomicbool/" title="struct std::sync::atomic::AtomicBool">AtomicBool</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/core/sync/atomic.rs.html#143" title="goto source code" target="_blank">[src]</a></span>
</h3> <h3 id="impl-Debug" class="impl">
<span class="in-band"><code>impl <a class="trait" href="../../../fmt/trait.debug/" title="trait std::fmt::Debug">Debug</a> for <a class="struct" href="../struct.atomicbool/" title="struct std::sync::atomic::AtomicBool">AtomicBool</a></code></span><span class="out-of-band">
<div class="since" title="Stable since Rust version 1.3.0">1.3.0</div>
<a class="srclink" href="https://doc.rust-lang.org/src/core/sync/atomic.rs.html#1816-1820" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.fmt" class="method">
<span id="fmt.v" class="invisible"><code>fn <a href="../../../fmt/trait.debug/#tymethod.fmt" class="fnname">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="../../../fmt/struct.formatter/" title="struct std::fmt::Formatter">Formatter</a>) -&gt; <a class="enum" href="../../../result/enum.result/" title="enum std::result::Result">Result</a>&lt;<a class="primitive" href="../../../primitive.unit/">()</a>, <a class="struct" href="../../../fmt/struct.error/" title="struct std::fmt::Error">Error</a>&gt;</code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/core/sync/atomic.rs.html#1817-1819" title="goto source code" target="_blank">[src]</a></span>
</h4> <div class="docblock">
<p>Formats the value using the given formatter. <a href="../../../fmt/trait.debug/#tymethod.fmt">Read more</a></p> </div>
<h3 id="impl-RefUnwindSafe" class="impl">
<span class="in-band"><code>impl <a class="trait" href="../../../panic/trait.refunwindsafe/" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="../struct.atomicbool/" title="struct std::sync::atomic::AtomicBool">AtomicBool</a></code></span><span class="out-of-band">
<div class="since" title="Stable since Rust version 1.14.0">1.14.0</div>
<a class="srclink" href="https://doc.rust-lang.org/src/std/panic.rs.html#273" title="goto source code" target="_blank">[src]</a></span>
</h3>
<div class="_attribution">
  <p class="_attribution-p">
    © 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/std/sync/atomic/struct.AtomicBool.html" class="_attribution-link" target="_blank">https://doc.rust-lang.org/std/sync/atomic/struct.AtomicBool.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
