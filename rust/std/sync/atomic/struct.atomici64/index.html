
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>std&#58;&#58;sync&#58;&#58;atomic&#58;&#58;AtomicI64 - Rust - W3cubDocs</title>
  
  <meta name="description" content=" An integer type which can be safely shared between threads. ">
  <meta name="keywords" content="struct, std, sync, atomic, atomici, -, rust">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/rust/std/sync/atomic/struct.atomici64/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-e0f881b0fce8cbe96f33dadc355b7159d5d2912911231446d60eb8f9caffa802.css">
  <script type="text/javascript" src="/assets/application-8fc46316434047265cd383f02b8e7f434ed7dec4a59f920dd633deef8d488d1b.js"></script>
  <script src="/json/rust.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/rust/" class="_nav-link" title="" style="margin-left:0;">Rust</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _rust">
				
<h1 class="fqn">Struct std::sync::atomic::AtomicI64</h1> <pre class="rust struct" data-language="rust">pub struct AtomicI64 { /* fields omitted */ }</pre>
<div class="stability"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (integer_atomics #32976)</span></div>
<p>An integer type which can be safely shared between threads.</p> <p>This type has the same in-memory representation as the underlying integer type, <a href="../../../primitive.i64/"><code>i64</code></a>. For more about the differences between atomic types and non-atomic types, please see the <a href="../">module-level documentation</a>.</p> <p>Please note that examples are shared between atomic variants of primitive integer types, so it's normal that they are all demonstrating <a href="../struct.atomicisize/"><code>AtomicIsize</code></a>.</p>  <h2 id="methods" class="small-section-header"> Methods </h2> <h3 id="impl" class="impl">
<span class="in-band"><code>impl <a class="struct" href="../struct.atomici64/" title="struct std::sync::atomic::AtomicI64">AtomicI64</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/core/sync/atomic.rs.html#996-1365" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.new" class="method">
<span id="new.v" class="invisible"><code>const fn <a href="#method.new" class="fnname">new</a>(v: <a class="primitive" href="../../../primitive.i64/">i64</a>) -&gt; <a class="struct" href="../struct.atomici64/" title="struct std::sync::atomic::AtomicI64">AtomicI64</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/core/sync/atomic.rs.html#1009-1011" title="goto source code" target="_blank">[src]</a></span>
</h4> <div class="stability"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (integer_atomics #32976)</span></div>
<div class="docblock">
<p>Creates a new atomic integer.</p> <h4 id="examples" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::sync::atomic::AtomicIsize;

let atomic_forty_two  = AtomicIsize::new(42);</pre> </div>
<h4 id="method.get_mut" class="method">
<span id="get_mut.v" class="invisible"><code>fn <a href="#method.get_mut" class="fnname">get_mut</a>(&amp;mut self) -&gt; &amp;mut <a class="primitive" href="../../../primitive.i64/">i64</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/core/sync/atomic.rs.html#1030-1032" title="goto source code" target="_blank">[src]</a></span>
</h4> <div class="stability"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (integer_atomics #32976)</span></div>
<div class="docblock">
<p>Returns a mutable reference to the underlying integer.</p> <p>This is safe because the mutable reference guarantees that no other threads are concurrently accessing the atomic data.</p> <h4 id="examples-1" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::sync::atomic::{AtomicIsize, Ordering};

let mut some_isize = AtomicIsize::new(10);
assert_eq!(*some_isize.get_mut(), 10);
*some_isize.get_mut() = 5;
assert_eq!(some_isize.load(Ordering::SeqCst), 5);</pre> </div>
<h4 id="method.into_inner" class="method">
<span id="into_inner.v" class="invisible"><code>fn <a href="#method.into_inner" class="fnname">into_inner</a>(self) -&gt; <a class="primitive" href="../../../primitive.i64/">i64</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/core/sync/atomic.rs.html#1049-1051" title="goto source code" target="_blank">[src]</a></span>
</h4> <div class="stability"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (integer_atomics #32976)</span></div>
<div class="docblock">
<p>Consumes the atomic and returns the contained value.</p> <p>This is safe because passing <code>self</code> by value guarantees that no other threads are concurrently accessing the atomic data.</p> <h4 id="examples-2" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::sync::atomic::AtomicIsize;

let some_isize = AtomicIsize::new(5);
assert_eq!(some_isize.into_inner(), 5);</pre> </div>
<h4 id="method.load" class="method">
<span id="load.v" class="invisible"><code>fn <a href="#method.load" class="fnname">load</a>(&amp;self, order: <a class="enum" href="../enum.ordering/" title="enum std::sync::atomic::Ordering">Ordering</a>) -&gt; <a class="primitive" href="../../../primitive.i64/">i64</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/core/sync/atomic.rs.html#1077-1079" title="goto source code" target="_blank">[src]</a></span>
</h4> <div class="stability"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (integer_atomics #32976)</span></div>
<div class="docblock">
<p>Loads a value from the atomic integer.</p> <p><code>load</code> takes an <a href="../enum.ordering/"><code>Ordering</code></a> argument which describes the memory ordering of this operation.</p> <h4 id="panics" class="section-header">Panics</h4> <p>Panics if <code>order</code> is <a href="../enum.ordering/#variant.Release"><code>Release</code></a> or <a href="../enum.ordering/#variant.AcqRel"><code>AcqRel</code></a>.</p> <h4 id="examples-3" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::sync::atomic::{AtomicIsize, Ordering};

let some_isize = AtomicIsize::new(5);

assert_eq!(some_isize.load(Ordering::Relaxed), 5);</pre> </div>
<h4 id="method.store" class="method">
<span id="store.v" class="invisible"><code>fn <a href="#method.store" class="fnname">store</a>(&amp;self, val: <a class="primitive" href="../../../primitive.i64/">i64</a>, order: <a class="enum" href="../enum.ordering/" title="enum std::sync::atomic::Ordering">Ordering</a>)</code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/core/sync/atomic.rs.html#1107-1109" title="goto source code" target="_blank">[src]</a></span>
</h4> <div class="stability"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (integer_atomics #32976)</span></div>
<div class="docblock">
<p>Stores a value into the atomic integer.</p> <p><code>store</code> takes an <a href="../enum.ordering/"><code>Ordering</code></a> argument which describes the memory ordering of this operation.</p> <h4 id="examples-4" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::sync::atomic::{AtomicIsize, Ordering};

let some_isize = AtomicIsize::new(5);

some_isize.store(10, Ordering::Relaxed);
assert_eq!(some_isize.load(Ordering::Relaxed), 10);</pre> <h4 id="panics-1" class="section-header">Panics</h4> <p>Panics if <code>order</code> is <a href="../enum.ordering/#variant.Acquire"><code>Acquire</code></a> or <a href="../enum.ordering/#variant.AcqRel"><code>AcqRel</code></a>.</p> </div>
<h4 id="method.swap" class="method">
<span id="swap.v" class="invisible"><code>fn <a href="#method.swap" class="fnname">swap</a>(&amp;self, val: <a class="primitive" href="../../../primitive.i64/">i64</a>, order: <a class="enum" href="../enum.ordering/" title="enum std::sync::atomic::Ordering">Ordering</a>) -&gt; <a class="primitive" href="../../../primitive.i64/">i64</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/core/sync/atomic.rs.html#1129-1131" title="goto source code" target="_blank">[src]</a></span>
</h4> <div class="stability"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (integer_atomics #32976)</span></div>
<div class="docblock">
<p>Stores a value into the atomic integer, returning the previous value.</p> <p><code>swap</code> takes an <a href="../enum.ordering/"><code>Ordering</code></a> argument which describes the memory ordering of this operation.</p> <h4 id="examples-5" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::sync::atomic::{AtomicIsize, Ordering};

let some_isize = AtomicIsize::new(5);

assert_eq!(some_isize.swap(10, Ordering::Relaxed), 5);</pre> </div>
<h4 id="method.compare_and_swap" class="method">
<span id="compare_and_swap.v" class="invisible"><code>fn <a href="#method.compare_and_swap" class="fnname">compare_and_swap</a>(&amp;self, current: <a class="primitive" href="../../../primitive.i64/">i64</a>, new: <a class="primitive" href="../../../primitive.i64/">i64</a>, order: <a class="enum" href="../enum.ordering/" title="enum std::sync::atomic::Ordering">Ordering</a>) -&gt; <a class="primitive" href="../../../primitive.i64/">i64</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/core/sync/atomic.rs.html#1159-1170" title="goto source code" target="_blank">[src]</a></span>
</h4> <div class="stability"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (integer_atomics #32976)</span></div>
<div class="docblock">
<p>Stores a value into the atomic integer if the current value is the same as the <code>current</code> value.</p> <p>The return value is always the previous value. If it is equal to <code>current</code>, then the value was updated.</p> <p><code>compare_and_swap</code> also takes an <a href="../enum.ordering/"><code>Ordering</code></a> argument which describes the memory ordering of this operation.</p> <h4 id="examples-6" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::sync::atomic::{AtomicIsize, Ordering};

let some_isize = AtomicIsize::new(5);

assert_eq!(some_isize.compare_and_swap(5, 10, Ordering::Relaxed), 5);
assert_eq!(some_isize.load(Ordering::Relaxed), 10);

assert_eq!(some_isize.compare_and_swap(6, 12, Ordering::Relaxed), 10);
assert_eq!(some_isize.load(Ordering::Relaxed), 10);</pre> </div>
<h4 id="method.compare_exchange" class="method">
<span id="compare_exchange.v" class="invisible"><code>fn <a href="#method.compare_exchange" class="fnname">compare_exchange</a>(<br>Â Â Â Â &amp;self, <br>Â Â Â Â current: <a class="primitive" href="../../../primitive.i64/">i64</a>, <br>Â Â Â Â new: <a class="primitive" href="../../../primitive.i64/">i64</a>, <br>Â Â Â Â success: <a class="enum" href="../enum.ordering/" title="enum std::sync::atomic::Ordering">Ordering</a>, <br>Â Â Â Â failure: <a class="enum" href="../enum.ordering/" title="enum std::sync::atomic::Ordering">Ordering</a><br>) -&gt; <a class="enum" href="../../../result/enum.result/" title="enum std::result::Result">Result</a>&lt;<a class="primitive" href="../../../primitive.i64/">i64</a>, <a class="primitive" href="../../../primitive.i64/">i64</a>&gt;</code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/core/sync/atomic.rs.html#1210-1216" title="goto source code" target="_blank">[src]</a></span>
</h4> <div class="stability"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (integer_atomics #32976)</span></div>
<div class="docblock">
<p>Stores a value into the atomic integer if the current value is the same as the <code>current</code> value.</p> <p>The return value is a result indicating whether the new value was written and containing the previous value. On success this value is guaranteed to be equal to <code>current</code>.</p> <p><code>compare_exchange</code> takes two <a href="../enum.ordering/"><code>Ordering</code></a> arguments to describe the memory ordering of this operation. The first describes the required ordering if the operation succeeds while the second describes the required ordering when the operation fails. The failure ordering can't be <a href="../enum.ordering/#variant.Release"><code>Release</code></a> or <a href="../enum.ordering/#variant.AcqRel"><code>AcqRel</code></a> and must be equivalent or weaker than the success ordering.</p> <h4 id="examples-7" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::sync::atomic::{AtomicIsize, Ordering};

let some_isize = AtomicIsize::new(5);

assert_eq!(some_isize.compare_exchange(5, 10,
                                       Ordering::Acquire,
                                       Ordering::Relaxed),
           Ok(5));
assert_eq!(some_isize.load(Ordering::Relaxed), 10);

assert_eq!(some_isize.compare_exchange(6, 12,
                                       Ordering::SeqCst,
                                       Ordering::Acquire),
           Err(10));
assert_eq!(some_isize.load(Ordering::Relaxed), 10);</pre> </div>
<h4 id="method.compare_exchange_weak" class="method">
<span id="compare_exchange_weak.v" class="invisible"><code>fn <a href="#method.compare_exchange_weak" class="fnname">compare_exchange_weak</a>(<br>Â Â Â Â &amp;self, <br>Â Â Â Â current: <a class="primitive" href="../../../primitive.i64/">i64</a>, <br>Â Â Â Â new: <a class="primitive" href="../../../primitive.i64/">i64</a>, <br>Â Â Â Â success: <a class="enum" href="../enum.ordering/" title="enum std::sync::atomic::Ordering">Ordering</a>, <br>Â Â Â Â failure: <a class="enum" href="../enum.ordering/" title="enum std::sync::atomic::Ordering">Ordering</a><br>) -&gt; <a class="enum" href="../../../result/enum.result/" title="enum std::result::Result">Result</a>&lt;<a class="primitive" href="../../../primitive.i64/">i64</a>, <a class="primitive" href="../../../primitive.i64/">i64</a>&gt;</code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/core/sync/atomic.rs.html#1255-1263" title="goto source code" target="_blank">[src]</a></span>
</h4> <div class="stability"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (integer_atomics #32976)</span></div>
<div class="docblock">
<p>Stores a value into the atomic integer if the current value is the same as the <code>current</code> value.</p> <p>Unlike <a href="#method.compare_exchange"><code>compare_exchange</code></a>, this function is allowed to spuriously fail even when the comparison succeeds, which can result in more efficient code on some platforms. The return value is a result indicating whether the new value was written and containing the previous value.</p> <p><code>compare_exchange_weak</code> takes two <a href="../enum.ordering/"><code>Ordering</code></a> arguments to describe the memory ordering of this operation. The first describes the required ordering if the operation succeeds while the second describes the required ordering when the operation fails. The failure ordering can't be <a href="../enum.ordering/#variant.Release"><code>Release</code></a> or <a href="../enum.ordering/#variant.AcqRel"><code>AcqRel</code></a> and must be equivalent or weaker than the success ordering.</p> <h4 id="examples-8" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::sync::atomic::{AtomicIsize, Ordering};

let val = AtomicIsize::new(4);

let mut old = val.load(Ordering::Relaxed);
loop {
    let new = old * 2;
    match val.compare_exchange_weak(old, new, Ordering::SeqCst, Ordering::Relaxed) {
        Ok(_) =&gt; break,
        Err(x) =&gt; old = x,
    }
}</pre> </div>
<h4 id="method.fetch_add" class="method">
<span id="fetch_add.v" class="invisible"><code>fn <a href="#method.fetch_add" class="fnname">fetch_add</a>(&amp;self, val: <a class="primitive" href="../../../primitive.i64/">i64</a>, order: <a class="enum" href="../enum.ordering/" title="enum std::sync::atomic::Ordering">Ordering</a>) -&gt; <a class="primitive" href="../../../primitive.i64/">i64</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/core/sync/atomic.rs.html#1280-1282" title="goto source code" target="_blank">[src]</a></span>
</h4> <div class="stability"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (integer_atomics #32976)</span></div>
<div class="docblock">
<p>Adds to the current value, returning the previous value.</p> <p>This operation wraps around on overflow.</p> <h4 id="examples-9" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::sync::atomic::{AtomicIsize, Ordering};

let foo = AtomicIsize::new(0);
assert_eq!(foo.fetch_add(10, Ordering::SeqCst), 0);
assert_eq!(foo.load(Ordering::SeqCst), 10);</pre> </div>
<h4 id="method.fetch_sub" class="method">
<span id="fetch_sub.v" class="invisible"><code>fn <a href="#method.fetch_sub" class="fnname">fetch_sub</a>(&amp;self, val: <a class="primitive" href="../../../primitive.i64/">i64</a>, order: <a class="enum" href="../enum.ordering/" title="enum std::sync::atomic::Ordering">Ordering</a>) -&gt; <a class="primitive" href="../../../primitive.i64/">i64</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/core/sync/atomic.rs.html#1299-1301" title="goto source code" target="_blank">[src]</a></span>
</h4> <div class="stability"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (integer_atomics #32976)</span></div>
<div class="docblock">
<p>Subtracts from the current value, returning the previous value.</p> <p>This operation wraps around on overflow.</p> <h4 id="examples-10" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::sync::atomic::{AtomicIsize, Ordering};

let foo = AtomicIsize::new(0);
assert_eq!(foo.fetch_sub(10, Ordering::SeqCst), 0);
assert_eq!(foo.load(Ordering::SeqCst), -10);</pre> </div>
<h4 id="method.fetch_and" class="method">
<span id="fetch_and.v" class="invisible"><code>fn <a href="#method.fetch_and" class="fnname">fetch_and</a>(&amp;self, val: <a class="primitive" href="../../../primitive.i64/">i64</a>, order: <a class="enum" href="../enum.ordering/" title="enum std::sync::atomic::Ordering">Ordering</a>) -&gt; <a class="primitive" href="../../../primitive.i64/">i64</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/core/sync/atomic.rs.html#1320-1322" title="goto source code" target="_blank">[src]</a></span>
</h4> <div class="stability"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (integer_atomics #32976)</span></div>
<div class="docblock">
<p>Bitwise "and" with the current value.</p> <p>Performs a bitwise "and" operation on the current value and the argument <code>val</code>, and sets the new value to the result.</p> <p>Returns the previous value.</p> <h4 id="examples-11" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::sync::atomic::{AtomicIsize, Ordering};

let foo = AtomicIsize::new(0b101101);
assert_eq!(foo.fetch_and(0b110011, Ordering::SeqCst), 0b101101);
assert_eq!(foo.load(Ordering::SeqCst), 0b100001);</pre> </div>
<h4 id="method.fetch_or" class="method">
<span id="fetch_or.v" class="invisible"><code>fn <a href="#method.fetch_or" class="fnname">fetch_or</a>(&amp;self, val: <a class="primitive" href="../../../primitive.i64/">i64</a>, order: <a class="enum" href="../enum.ordering/" title="enum std::sync::atomic::Ordering">Ordering</a>) -&gt; <a class="primitive" href="../../../primitive.i64/">i64</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/core/sync/atomic.rs.html#1341-1343" title="goto source code" target="_blank">[src]</a></span>
</h4> <div class="stability"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (integer_atomics #32976)</span></div>
<div class="docblock">
<p>Bitwise "or" with the current value.</p> <p>Performs a bitwise "or" operation on the current value and the argument <code>val</code>, and sets the new value to the result.</p> <p>Returns the previous value.</p> <h4 id="examples-12" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::sync::atomic::{AtomicIsize, Ordering};

let foo = AtomicIsize::new(0b101101);
assert_eq!(foo.fetch_or(0b110011, Ordering::SeqCst), 0b101101);
assert_eq!(foo.load(Ordering::SeqCst), 0b111111);</pre> </div>
<h4 id="method.fetch_xor" class="method">
<span id="fetch_xor.v" class="invisible"><code>fn <a href="#method.fetch_xor" class="fnname">fetch_xor</a>(&amp;self, val: <a class="primitive" href="../../../primitive.i64/">i64</a>, order: <a class="enum" href="../enum.ordering/" title="enum std::sync::atomic::Ordering">Ordering</a>) -&gt; <a class="primitive" href="../../../primitive.i64/">i64</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/core/sync/atomic.rs.html#1362-1364" title="goto source code" target="_blank">[src]</a></span>
</h4> <div class="stability"><span class="stab unstable">ðŸ”¬ This is a nightly-only experimental API. (integer_atomics #32976)</span></div>
<div class="docblock">
<p>Bitwise "xor" with the current value.</p> <p>Performs a bitwise "xor" operation on the current value and the argument <code>val</code>, and sets the new value to the result.</p> <p>Returns the previous value.</p> <h4 id="examples-13" class="section-header">Examples</h4> <pre class="rust rust-example-rendered" data-language="rust">
use std::sync::atomic::{AtomicIsize, Ordering};

let foo = AtomicIsize::new(0b101101);
assert_eq!(foo.fetch_xor(0b110011, Ordering::SeqCst), 0b101101);
assert_eq!(foo.load(Ordering::SeqCst), 0b011110);</pre> </div> <h2 id="implementations" class="small-section-header"> Trait Implementations </h2> <h3 id="impl-Default" class="impl">
<span class="in-band"><code>impl <a class="trait" href="../../../default/trait.default/" title="trait std::default::Default">Default</a> for <a class="struct" href="../struct.atomici64/" title="struct std::sync::atomic::AtomicI64">AtomicI64</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/core/sync/atomic.rs.html#971-975" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.default" class="method">
<span id="default.v" class="invisible"><code>fn <a href="../../../default/trait.default/#tymethod.default" class="fnname">default</a>() -&gt; <a class="struct" href="../struct.atomici64/" title="struct std::sync::atomic::AtomicI64">AtomicI64</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/core/sync/atomic.rs.html#972-974" title="goto source code" target="_blank">[src]</a></span>
</h4> <div class="docblock">
<p>Returns the "default value" for a type. <a href="../../../default/trait.default/#tymethod.default">Read more</a></p> </div>
<h3 id="impl-From%3Ci64%3E" class="impl">
<span class="in-band"><code>impl <a class="trait" href="../../../convert/trait.from/" title="trait std::convert::From">From</a>&lt;<a class="primitive" href="../../../primitive.i64/">i64</a>&gt; for <a class="struct" href="../struct.atomici64/" title="struct std::sync::atomic::AtomicI64">AtomicI64</a></code></span><span class="out-of-band">
<div class="since" title="Stable since Rust version 1.23.0">1.23.0</div>
<a class="srclink" href="https://doc.rust-lang.org/src/core/sync/atomic.rs.html#978-981" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.from" class="method">
<span id="from.v" class="invisible"><code>fn <a href="../../../convert/trait.from/#tymethod.from" class="fnname">from</a>(v: <a class="primitive" href="../../../primitive.i64/">i64</a>) -&gt; <a class="struct" href="../struct.atomici64/" title="struct std::sync::atomic::AtomicI64">AtomicI64</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/core/sync/atomic.rs.html#980" title="goto source code" target="_blank">[src]</a></span>
</h4> <div class="docblock">
<p>Performs the conversion.</p> </div>
<h3 id="impl-Sync" class="impl">
<span class="in-band"><code>impl <a class="trait" href="../../../marker/trait.sync/" title="trait std::marker::Sync">Sync</a> for <a class="struct" href="../struct.atomici64/" title="struct std::sync::atomic::AtomicI64">AtomicI64</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/core/sync/atomic.rs.html#994" title="goto source code" target="_blank">[src]</a></span>
</h3> <h3 id="impl-Debug" class="impl">
<span class="in-band"><code>impl <a class="trait" href="../../../fmt/trait.debug/" title="trait std::fmt::Debug">Debug</a> for <a class="struct" href="../struct.atomici64/" title="struct std::sync::atomic::AtomicI64">AtomicI64</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/core/sync/atomic.rs.html#984-990" title="goto source code" target="_blank">[src]</a></span>
</h3> <h4 id="method.fmt" class="method">
<span id="fmt.v" class="invisible"><code>fn <a href="../../../fmt/trait.debug/#tymethod.fmt" class="fnname">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="../../../fmt/struct.formatter/" title="struct std::fmt::Formatter">Formatter</a>) -&gt; <a class="enum" href="../../../result/enum.result/" title="enum std::result::Result">Result</a>&lt;<a class="primitive" href="../../../primitive.unit/">()</a>, <a class="struct" href="../../../fmt/struct.error/" title="struct std::fmt::Error">Error</a>&gt;</code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/core/sync/atomic.rs.html#985-989" title="goto source code" target="_blank">[src]</a></span>
</h4> <div class="docblock">
<p>Formats the value using the given formatter. <a href="../../../fmt/trait.debug/#tymethod.fmt">Read more</a></p> </div>
<h3 id="impl-RefUnwindSafe" class="impl">
<span class="in-band"><code>impl <a class="trait" href="../../../panic/trait.refunwindsafe/" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="../struct.atomici64/" title="struct std::sync::atomic::AtomicI64">AtomicI64</a></code></span><span class="out-of-band">
<a class="srclink" href="https://doc.rust-lang.org/src/std/panic.rs.html#253" title="goto source code" target="_blank">[src]</a></span>
</h3>
<div class="_attribution">
  <p class="_attribution-p">
    Â© 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/std/sync/atomic/struct.AtomicI64.html" class="_attribution-link" target="_blank">https://doc.rust-lang.org/std/sync/atomic/struct.AtomicI64.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
