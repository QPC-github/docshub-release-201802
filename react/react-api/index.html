
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>React Top-Level API - React - W3cubDocs</title>
  
  <meta name="description" content="React is the entry point to the React library. If you load React from a &#60;script&#62; tag, these top-level APIs are available on the React global &hellip;">
  <meta name="keywords" content="react, top-level, api, -">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/react/react-api/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-e0f881b0fce8cbe96f33dadc355b7159d5d2912911231446d60eb8f9caffa802.css">
  <script type="text/javascript" src="/assets/application-8fc46316434047265cd383f02b8e7f434ed7dec4a59f920dd633deef8d488d1b.js"></script>
  <script src="/json/react.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/react/" class="_nav-link" title="" style="margin-left:0;">React</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _simple">
				
<h1 class="css-1a9m1x6">React Top-Level API</h1>
<p><code>React</code> is the entry point to the React library. If you load React from a <code>&lt;script&gt;</code> tag, these top-level APIs are available on the <code>React</code> global. If you use ES6 with npm, you can write <code>import React from 'react'</code>. If you use ES5 with npm, you can write <code>var React = require('react')</code>.</p> <h2 id="overview">Overview</h2> <h3 id="components">Components</h3> <p>React components let you split the UI into independent, reusable pieces, and think about each piece in isolation. React components can be defined by subclassing <code>React.Component</code> or <code>React.PureComponent</code>.</p> <ul> <li><a href="#reactcomponent"><code>React.Component</code></a></li> <li><a href="#reactpurecomponent"><code>React.PureComponent</code></a></li> </ul> <p>If you don’t use ES6 classes, you may use the <code>create-react-class</code> module instead. See <a href="../react-without-es6/">Using React without ES6</a> for more information.</p> <h3 id="creating-react-elements">Creating React Elements</h3> <p>We recommend <a href="../introducing-jsx/">using JSX</a> to describe what your UI should look like. Each JSX element is just syntactic sugar for calling <a href="#createelement"><code>React.createElement()</code></a>. You will not typically invoke the following methods directly if you are using JSX.</p> <ul> <li><a href="#createelement"><code>createElement()</code></a></li> <li><a href="#createfactory"><code>createFactory()</code></a></li> </ul> <p>See <a href="../react-without-jsx/">Using React without JSX</a> for more information.</p> <h3 id="transforming-elements">Transforming Elements</h3> <p><code>React</code> provides several APIs for manipulating elements:</p> <ul> <li><a href="#cloneelement"><code>cloneElement()</code></a></li> <li><a href="#isvalidelement"><code>isValidElement()</code></a></li> <li><a href="#reactchildren"><code>React.Children</code></a></li> </ul> <h3 id="fragments">Fragments</h3> <p><code>React</code> also provides a component for rendering a multiple elements without a wrapper.</p> <ul> <li><a href="#reactfragment"><code>React.Fragment</code></a></li> </ul>  <h2 id="reference">Reference</h2> <h3 id="reactcomponent"><code>React.Component</code></h3> <p><code>React.Component</code> is the base class for React components when they are defined using <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes" target="_blank">ES6 classes</a>:</p> <pre data-language="jsx">class Greeting extends React.Component {
  render() {
    return &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;;
  }
}
</pre> <p>See the <a href="../react-component/">React.Component API Reference</a> for a list of methods and properties related to the base <code>React.Component</code> class.</p>  <h3 id="reactpurecomponent"><code>React.PureComponent</code></h3> <p><code>React.PureComponent</code> is similar to <a href="#reactcomponent"><code>React.Component</code></a>. The difference between them is that <a href="#reactcomponent"><code>React.Component</code></a> doesn’t implement <a href="../react-component/#shouldcomponentupdate"><code>shouldComponentUpdate()</code></a>, but <code>React.PureComponent</code> implements it with a shallow prop and state comparison. </p> <p>If your React component’s <code>render()</code> function renders the same result given the same props and state, you can use <code>React.PureComponent</code> for a performance boost in some cases.</p> <blockquote> <p>Note</p> <p><code>React.PureComponent</code>’s <code>shouldComponentUpdate()</code> only shallowly compares the objects. If these contain complex data structures, it may produce false-negatives for deeper differences. Only extend <code>PureComponent</code> when you expect to have simple props and state, or use <a href="../react-component/#forceupdate"><code>forceUpdate()</code></a> when you know deep data structures have changed. Or, consider using <a href="https://facebook.github.io/immutable-js/" target="_blank">immutable objects</a> to facilitate fast comparisons of nested data.</p> <p>Furthermore, <code>React.PureComponent</code>’s <code>shouldComponentUpdate()</code> skips prop updates for the whole component subtree. Make sure all the children components are also “pure”.</p> </blockquote>  <h3 id="createelement"><code>createElement()</code></h3> <pre data-language="jsx">React.createElement(
  type,
  [props],
  [...children]
)
</pre> <p>Create and return a new <a href="../rendering-elements/">React element</a> of the given type. The type argument can be either a tag name string (such as <code>'div'</code> or <code>'span'</code>), a <a href="../components-and-props/">React component</a> type (a class or a function), or a <a href="#reactfragment">React fragment</a> type.</p> <p>Code written with <a href="../introducing-jsx/">JSX</a> will be converted to use <code>React.createElement()</code>. You will not typically invoke <code>React.createElement()</code> directly if you are using JSX. See <a href="../react-without-jsx/">React Without JSX</a> to learn more.</p>  <h3 id="cloneelement"><code>cloneElement()</code></h3> <pre data-language="none">React.cloneElement(
  element,
  [props],
  [...children]
)</pre> <p>Clone and return a new React element using <code>element</code> as the starting point. The resulting element will have the original element’s props with the new props merged in shallowly. New children will replace existing children. <code>key</code> and <code>ref</code> from the original element will be preserved.</p> <p><code>React.cloneElement()</code> is almost equivalent to:</p> <pre data-language="jsx">&lt;element.type {...element.props} {...props}&gt;{children}&lt;/element.type&gt;
</pre> <p>However, it also preserves <code>ref</code>s. This means that if you get a child with a <code>ref</code> on it, you won’t accidentally steal it from your ancestor. You will get the same <code>ref</code> attached to your new element.</p> <p>This API was introduced as a replacement of the deprecated <code>React.addons.cloneWithProps()</code>.</p>  <h3 id="createfactory"><code>createFactory()</code></h3> <pre data-language="jsx">React.createFactory(type)
</pre> <p>Return a function that produces React elements of a given type. Like <a href="#createElement"><code>React.createElement()</code></a>, the type argument can be either a tag name string (such as <code>'div'</code> or <code>'span'</code>), a <a href="../components-and-props/">React component</a> type (a class or a function), or a <a href="#reactfragment">React fragment</a> type.</p> <p>This helper is considered legacy, and we encourage you to either use JSX or use <code>React.createElement()</code> directly instead.</p> <p>You will not typically invoke <code>React.createFactory()</code> directly if you are using JSX. See <a href="../react-without-jsx/">React Without JSX</a> to learn more.</p>  <h3 id="isvalidelement"><code>isValidElement()</code></h3> <pre data-language="jsx">React.isValidElement(object)
</pre> <p>Verifies the object is a React element. Returns <code>true</code> or <code>false</code>.</p>  <h3 id="reactchildren"><code>React.Children</code></h3> <p><code>React.Children</code> provides utilities for dealing with the <code>this.props.children</code> opaque data structure.</p> <h4 id="reactchildrenmap"><code>React.Children.map</code></h4> <pre data-language="jsx">React.Children.map(children, function[(thisArg)])
</pre> <p>Invokes a function on every immediate child contained within <code>children</code> with <code>this</code> set to <code>thisArg</code>. If <code>children</code> is a keyed fragment or array it will be traversed: the function will never be passed the container objects. If children is <code>null</code> or <code>undefined</code>, returns <code>null</code> or <code>undefined</code> rather than an array.</p> <h4 id="reactchildrenforeach"><code>React.Children.forEach</code></h4> <pre data-language="jsx">React.Children.forEach(children, function[(thisArg)])
</pre> <p>Like <a href="#reactchildrenmap"><code>React.Children.map()</code></a> but does not return an array.</p> <h4 id="reactchildrencount"><code>React.Children.count</code></h4> <pre data-language="jsx">React.Children.count(children)
</pre> <p>Returns the total number of components in <code>children</code>, equal to the number of times that a callback passed to <code>map</code> or <code>forEach</code> would be invoked.</p> <h4 id="reactchildrenonly"><code>React.Children.only</code></h4> <pre data-language="jsx">React.Children.only(children)
</pre> <p>Verifies that <code>children</code> has only one child (a React element) and returns it. Otherwise this method throws an error.</p> <blockquote> <p>Note:</p> <p><code>React.Children.only()</code> does not accept the return value of <a href="#reactchildrenmap"><code>React.Children.map()</code></a> because it is an array rather than a React element.</p> </blockquote> <h4 id="reactchildrentoarray"><code>React.Children.toArray</code></h4> <pre data-language="jsx">React.Children.toArray(children)
</pre> <p>Returns the <code>children</code> opaque data structure as a flat array with keys assigned to each child. Useful if you want to manipulate collections of children in your render methods, especially if you want to reorder or slice <code>this.props.children</code> before passing it down.</p> <blockquote> <p>Note:</p> <p><code>React.Children.toArray()</code> changes keys to preserve the semantics of nested arrays when flattening lists of children. That is, <code>toArray</code> prefixes each key in the returned array so that each element’s key is scoped to the input array containing it.</p> </blockquote>  <h3 id="reactfragment"><code>React.Fragment</code></h3> <p>The <code>React.Fragment</code> component lets you return multiple elements in a <code>render()</code> method without creating an additional DOM element:</p> <pre data-language="jsx">render() {
  return (
    &lt;React.Fragment&gt;
      Some text.
      &lt;h2&gt;A heading&lt;/h2&gt;
    &lt;/React.Fragment&gt;
  );
}
</pre> <p>You can also use it with the shorthand <code>&lt;&gt;&lt;/&gt;</code> syntax. For more information, see <a href="https://reactjs.org/blog/2017/11/28/react-v16.2.0-fragment-support.html" target="_blank">React v16.2.0: Improved Support for Fragments</a>.</p>
<div class="_attribution">
  <p class="_attribution-p">
    © 2013–present Facebook Inc.<br>Licensed under the Creative Commons Attribution 4.0 International Public License.<br>
    <a href="https://reactjs.org/docs/react-api.html" class="_attribution-link" target="_blank">https://reactjs.org/docs/react-api.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
