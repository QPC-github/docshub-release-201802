
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Mathematics - Julia 0.6 - W3cubDocs</title>
  
  <meta name="description" content=" Unary minus operator. ">
  <meta name="keywords" content="mathematics, -, julia, julia~0.6">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/julia~0.6/stdlib/math/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-e0f881b0fce8cbe96f33dadc355b7159d5d2912911231446d60eb8f9caffa802.css">
  <script type="text/javascript" src="/assets/application-8fc46316434047265cd383f02b8e7f434ed7dec4a59f920dd633deef8d488d1b.js"></script>
  <script src="/json/julia~0.6.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/julia~0.6/" class="_nav-link" title="" style="margin-left:0;">Julia 0.6</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _julia">
				
<h1 id="Mathematics-1">Mathematics</h1>
<h2 id="math-ops-1">Mathematical Operators</h2>
<h3 id="Base.:--Tuple{Any}">
<code>Base.:-</code><span class="docstring-category">Method</span>
</h3>
<pre>-(x)</pre>
<p>Unary minus operator.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L66-L70">source</a><br><h3 id="Base.:+">
<code>Base.:+</code><span class="docstring-category">Function</span>
</h3>
<pre>+(x, y...)</pre>
<p>Addition operator. <code>x+y+z+...</code> calls this function with all arguments, i.e. <code>+(x, y, z, ...)</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2281-L2285">source</a><br><h3 id="Base.:--Tuple{Any,Any}">
<code>Base.:-</code><span class="docstring-category">Method</span>
</h3>
<pre>-(x, y)</pre>
<p>Subtraction operator.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L73-L77">source</a><br><h3 id="Base.:*-Tuple{Any,Vararg{Any,N} where N}">
<code>Base.:*</code><span class="docstring-category">Method</span>
</h3>
<pre>*(x, y...)</pre>
<p>Multiplication operator. <code>x*y*z*...</code> calls this function with all arguments, i.e. <code>*(x, y, z, ...)</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1917-L1923">source</a><br><h3 id="Base.:/">
<code>Base.:/</code><span class="docstring-category">Function</span>
</h3>
<pre>/(x, y)</pre>
<p>Right division operator: multiplication of <code>x</code> by the inverse of <code>y</code> on the right. Gives floating-point results for integer arguments.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L522-L527">source</a><br><h3 id="Base.:\\-Tuple{Any,Any}">
<code>Base.:\</code><span class="docstring-category">Method</span>
</h3>
<pre>\(x, y)</pre>
<p>Left division operator: multiplication of <code>y</code> by the inverse of <code>x</code> on the left. Gives floating-point results for integer arguments.</p>
<pre>julia&gt; 3 \ 6
2.0

julia&gt; inv(3) * 6
2.0

julia&gt; A = [1 2; 3 4]; x = [5, 6];

julia&gt; A \ x
2-element Array{Float64,1}:
 -4.0
  4.5

julia&gt; inv(A) * x
2-element Array{Float64,1}:
 -4.0
  4.5</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L431-L456">source</a><br><h3 id="Base.:^-Tuple{Number,Number}">
<code>Base.:^</code><span class="docstring-category">Method</span>
</h3>
<pre>^(x, y)</pre>
<p>Exponentiation operator. If <code>x</code> is a matrix, computes matrix exponentiation.</p>
<p>If <code>y</code> is an <code>Int</code> literal (e.g. <code>2</code> in <code>x^2</code> or <code>-3</code> in <code>x^-3</code>), the Julia code <code>x^y</code> is transformed by the compiler to <code>Base.literal_pow(^, x, Val{y})</code>, to enable compile-time specialization on the value of the exponent. (As a default fallback we have <code>Base.literal_pow(^, x, Val{y}) = ^(x,y)</code>, where usually <code>^ == Base.^</code> unless <code>^</code> has been defined in the calling namespace.)</p>
<pre>julia&gt; 3^5
243

julia&gt; A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; A^3
2×2 Array{Int64,2}:
 37   54
 81  118</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/promotion.jl#L254-L280">source</a><br><h3 id="Base.fma">
<code>Base.fma</code><span class="docstring-category">Function</span>
</h3>
<pre>fma(x, y, z)</pre>
<p>Computes <code>x*y+z</code> without rounding the intermediate result <code>x*y</code>. On some systems this is significantly more expensive than <code>x*y+z</code>. <code>fma</code> is used to improve accuracy in certain algorithms. See <a href="#Base.muladd"><code>muladd</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2264-L2270">source</a><br><h3 id="Base.muladd">
<code>Base.muladd</code><span class="docstring-category">Function</span>
</h3>
<pre>muladd(x, y, z)</pre>
<p>Combined multiply-add, computes <code>x*y+z</code> in an efficient manner. This may on some systems be equivalent to <code>x*y+z</code>, or to <code>fma(x,y,z)</code>. <code>muladd</code> is used to improve performance. See <a href="#Base.fma"><code>fma</code></a>.</p>
<p><strong>Example</strong></p>
<pre>julia&gt; muladd(3, 2, 1)
7

julia&gt; 3 * 2 + 1
7</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L927-L942">source</a><br><h3 id="Base.div">
<code>Base.div</code><span class="docstring-category">Function</span>
</h3>
<pre>div(x, y)
÷(x, y)</pre>
<p>The quotient from Euclidean division. Computes <code>x/y</code>, truncated to an integer.</p>
<pre>julia&gt; 9 ÷ 4
2

julia&gt; -5 ÷ 3
-1</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L616-L629">source</a><br><h3 id="Base.fld">
<code>Base.fld</code><span class="docstring-category">Function</span>
</h3>
<pre>fld(x, y)</pre>
<p>Largest integer less than or equal to <code>x/y</code>.</p>
<pre>julia&gt; fld(7.3,5.5)
1.0</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L568-L577">source</a><br><h3 id="Base.cld">
<code>Base.cld</code><span class="docstring-category">Function</span>
</h3>
<pre>cld(x, y)</pre>
<p>Smallest integer larger than or equal to <code>x/y</code>.</p>
<pre>julia&gt; cld(5.5,2.2)
3.0</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L580-L588">source</a><br><h3 id="Base.mod">
<code>Base.mod</code><span class="docstring-category">Function</span>
</h3>
<pre>mod(x, y)
rem(x, y, RoundDown)</pre>
<p>The reduction of <code>x</code> modulo <code>y</code>, or equivalently, the remainder of <code>x</code> after floored division by <code>y</code>, i.e.</p>
<pre>x - y*fld(x,y)</pre>
<p>if computed without intermediate rounding.</p>
<p>The result will have the same sign as <code>y</code>, and magnitude less than <code>abs(y)</code> (with some exceptions, see note below).</p>
<div class="admonition note">
<div class="admonition-title">Note</div>
<div class="admonition-text"><p>When used with floating point values, the exact result may not be representable by the type, and so rounding error may occur. In particular, if the exact result is very close to <code>y</code>, then it may be rounded to <code>y</code>.</p></div>
</div>
<pre>julia&gt; mod(8, 3)
2

julia&gt; mod(9, 3)
0

julia&gt; mod(8.9, 3)
2.9000000000000004

julia&gt; mod(eps(), 3)
2.220446049250313e-16

julia&gt; mod(-eps(), 3)
3.0</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/int.jl#L132-L168">source</a><br><pre>rem(x::Integer, T::Type{&lt;:Integer}) -&gt; T
mod(x::Integer, T::Type{&lt;:Integer}) -&gt; T
%(x::Integer, T::Type{&lt;:Integer}) -&gt; T</pre>
<p>Find <code>y::T</code> such that <code>x</code> ≡ <code>y</code> (mod n), where n is the number of integers representable in <code>T</code>, and <code>y</code> is an integer in <code>[typemin(T),typemax(T)]</code>. If <code>T</code> can represent any integer (e.g. <code>T == BigInt</code>), then this operation corresponds to a conversion to <code>T</code>.</p>
<pre>julia&gt; 129 % Int8
-127</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/int.jl#L369-L383">source</a><br><h3 id="Base.rem">
<code>Base.rem</code><span class="docstring-category">Function</span>
</h3>
<pre>rem(x, y)
%(x, y)</pre>
<p>Remainder from Euclidean division, returning a value of the same sign as <code>x</code>, and smaller in magnitude than <code>y</code>. This value is always exact.</p>
<pre>julia&gt; x = 15; y = 4;

julia&gt; x % y
3

julia&gt; x == div(x, y) * y + rem(x, y)
true</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L596-L612">source</a><br><h3 id="Base.Math.rem2pi">
<code>Base.Math.rem2pi</code><span class="docstring-category">Function</span>
</h3>
<pre>rem2pi(x, r::RoundingMode)</pre>
<p>Compute the remainder of <code>x</code> after integer division by <code>2π</code>, with the quotient rounded according to the rounding mode <code>r</code>. In other words, the quantity</p>
<pre>x - 2π*round(x/(2π),r)</pre>
<p>without any intermediate rounding. This internally uses a high precision approximation of 2π, and so will give a more accurate result than <code>rem(x,2π,r)</code></p>
<ul>
<li><p>if <code>r == RoundNearest</code>, then the result is in the interval <span>$[-π, π]$</span>. This will generally be the most accurate result.</p></li>
<li><p>if <code>r == RoundToZero</code>, then the result is in the interval <span>$[0, 2π]$</span> if <code>x</code> is positive,. or <span>$[-2π, 0]$</span> otherwise.</p></li>
<li><p>if <code>r == RoundDown</code>, then the result is in the interval <span>$[0, 2π]$</span>.</p></li>
<li><p>if <code>r == RoundUp</code>, then the result is in the interval <span>$[-2π, 0]$</span>.</p></li>
</ul>
<p><strong>Example</strong></p>
<pre>julia&gt; rem2pi(7pi/4, RoundNearest)
-0.7853981633974485

julia&gt; rem2pi(7pi/4, RoundDown)
5.497787143782138</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L761-L790">source</a><br><h3 id="Base.Math.mod2pi">
<code>Base.Math.mod2pi</code><span class="docstring-category">Function</span>
</h3>
<pre>mod2pi(x)</pre>
<p>Modulus after division by <code>2π</code>, returning in the range <span>$[0,2π)$</span>.</p>
<p>This function computes a floating point representation of the modulus after division by numerically exact <code>2π</code>, and is therefore not exactly the same as <code>mod(x,2π)</code>, which would compute the modulus of <code>x</code> relative to division by the floating-point number <code>2π</code>.</p>
<p><strong>Example</strong></p>
<pre>julia&gt; mod2pi(9*pi/4)
0.7853981633974481</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L908-L922">source</a><br><h3 id="Base.divrem">
<code>Base.divrem</code><span class="docstring-category">Function</span>
</h3>
<pre>divrem(x, y)</pre>
<p>The quotient and remainder from Euclidean division. Equivalent to <code>(div(x,y), rem(x,y))</code> or <code>(x÷y, x%y)</code>.</p>
<pre>julia&gt; divrem(3,7)
(0, 3)

julia&gt; divrem(7,3)
(2, 1)</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/number.jl#L50-L63">source</a><br><h3 id="Base.fldmod">
<code>Base.fldmod</code><span class="docstring-category">Function</span>
</h3>
<pre>fldmod(x, y)</pre>
<p>The floored quotient and modulus after division. Equivalent to <code>(fld(x,y), mod(x,y))</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/number.jl#L66-L70">source</a><br><h3 id="Base.fld1">
<code>Base.fld1</code><span class="docstring-category">Function</span>
</h3>
<pre>fld1(x, y)</pre>
<p>Flooring division, returning a value consistent with <code>mod1(x,y)</code></p>
<p>See also: <a href="#Base.mod1"><code>mod1</code></a>.</p>
<pre>julia&gt; x = 15; y = 4;

julia&gt; fld1(x, y)
4

julia&gt; x == fld(x, y) * y + mod(x, y)
true

julia&gt; x == (fld1(x, y) - 1) * y + mod1(x, y)
true</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L652-L671">source</a><br><h3 id="Base.mod1">
<code>Base.mod1</code><span class="docstring-category">Function</span>
</h3>
<pre>mod1(x, y)</pre>
<p>Modulus after flooring division, returning a value <code>r</code> such that <code>mod(r, y) == mod(x, y)</code> in the range <span>$(0, y]$</span> for positive <code>y</code> and in the range <span>$[y,0)$</span> for negative <code>y</code>.</p>
<pre>julia&gt; mod1(4, 2)
2

julia&gt; mod1(4, 3)
1</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L633-L646">source</a><br><h3 id="Base.fldmod1">
<code>Base.fldmod1</code><span class="docstring-category">Function</span>
</h3>
<pre>fldmod1(x, y)</pre>
<p>Return <code>(fld1(x,y), mod1(x,y))</code>.</p>
<p>See also: <a href="#Base.fld1"><code>fld1</code></a>, <a href="#Base.mod1"><code>mod1</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L676-L682">source</a><br><h3 id="Base.://">
<code>Base.://</code><span class="docstring-category">Function</span>
</h3>
<pre>//(num, den)</pre>
<p>Divide two integers or rational numbers, giving a <a href="../numbers/#Base.Rational"><code>Rational</code></a> result.</p>
<pre>julia&gt; 3 // 5
3//5

julia&gt; (3 // 5) // (2 // 1)
3//10</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/rational.jl#L27-L39">source</a><br><h3 id="Base.rationalize">
<code>Base.rationalize</code><span class="docstring-category">Function</span>
</h3>
<pre>rationalize([T&lt;:Integer=Int,] x; tol::Real=eps(x))</pre>
<p>Approximate floating point number <code>x</code> as a <a href="../numbers/#Base.Rational"><code>Rational</code></a> number with components of the given integer type. The result will differ from <code>x</code> by no more than <code>tol</code>. If <code>T</code> is not provided, it defaults to <code>Int</code>.</p>
<pre>julia&gt; rationalize(5.6)
28//5

julia&gt; a = rationalize(BigInt, 10.3)
103//10

julia&gt; typeof(numerator(a))
BigInt</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/rational.jl#L109-L126">source</a><br><h3 id="Base.numerator">
<code>Base.numerator</code><span class="docstring-category">Function</span>
</h3>
<pre>numerator(x)</pre>
<p>Numerator of the rational representation of <code>x</code>.</p>
<pre>julia&gt; numerator(2//3)
2

julia&gt; numerator(4)
4</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/rational.jl#L189-L201">source</a><br><h3 id="Base.denominator">
<code>Base.denominator</code><span class="docstring-category">Function</span>
</h3>
<pre>denominator(x)</pre>
<p>Denominator of the rational representation of <code>x</code>.</p>
<pre>julia&gt; denominator(2//3)
3

julia&gt; denominator(4)
1</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/rational.jl#L205-L217">source</a><br><h3 id="Base.:&lt;&lt;">
<code>Base.:&lt;&lt;</code><span class="docstring-category">Function</span>
</h3>
<pre>&lt;&lt;(x, n)</pre>
<p>Left bit shift operator, <code>x &lt;&lt; n</code>. For <code>n &gt;= 0</code>, the result is <code>x</code> shifted left by <code>n</code> bits, filling with <code>0</code>s. This is equivalent to <code>x * 2^n</code>. For <code>n &lt; 0</code>, this is equivalent to <code>x &gt;&gt; -n</code>.</p>
<pre>julia&gt; Int8(3) &lt;&lt; 2
12

julia&gt; bits(Int8(3))
"00000011"

julia&gt; bits(Int8(12))
"00001100"</pre>
<p>See also <a href="#Base.:&gt;&gt;"><code>&gt;&gt;</code></a>, <a href="#Base.:&gt;&gt;&gt;"><code>&gt;&gt;&gt;</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L463-L481">source</a><br><pre>&lt;&lt;(B::BitVector, n) -&gt; BitVector</pre>
<p>Left bit shift operator, <code>B &lt;&lt; n</code>. For <code>n &gt;= 0</code>, the result is <code>B</code> with elements shifted <code>n</code> positions backwards, filling with <code>false</code> values. If <code>n &lt; 0</code>, elements are shifted forwards. Equivalent to <code>B &gt;&gt; -n</code>.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; B = BitVector([true, false, true, false, false])
5-element BitArray{1}:
  true
 false
  true
 false
 false

julia&gt; B &lt;&lt; 1
5-element BitArray{1}:
 false
  true
 false
 false
 false

julia&gt; B &lt;&lt; -1
5-element BitArray{1}:
 false
  true
 false
  true
 false</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/bitarray.jl#L1422-L1457">source</a><br><h3 id="Base.:&gt;&gt;">
<code>Base.:&gt;&gt;</code><span class="docstring-category">Function</span>
</h3>
<pre>&gt;&gt;(x, n)</pre>
<p>Right bit shift operator, <code>x &gt;&gt; n</code>. For <code>n &gt;= 0</code>, the result is <code>x</code> shifted right by <code>n</code> bits, where <code>n &gt;= 0</code>, filling with <code>0</code>s if <code>x &gt;= 0</code>, <code>1</code>s if <code>x &lt; 0</code>, preserving the sign of <code>x</code>. This is equivalent to <code>fld(x, 2^n)</code>. For <code>n &lt; 0</code>, this is equivalent to <code>x &lt;&lt; -n</code>.</p>
<pre>julia&gt; Int8(13) &gt;&gt; 2
3

julia&gt; bits(Int8(13))
"00001101"

julia&gt; bits(Int8(3))
"00000011"

julia&gt; Int8(-14) &gt;&gt; 2
-4

julia&gt; bits(Int8(-14))
"11110010"

julia&gt; bits(Int8(-4))
"11111100"</pre>
<p>See also <a href="#Base.:&gt;&gt;&gt;"><code>&gt;&gt;&gt;</code></a>, <a href="#Base.:&lt;&lt;"><code>&lt;&lt;</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L491-L520">source</a><br><pre>&gt;&gt;(B::BitVector, n) -&gt; BitVector</pre>
<p>Right bit shift operator, <code>B &gt;&gt; n</code>. For <code>n &gt;= 0</code>, the result is <code>B</code> with elements shifted <code>n</code> positions forward, filling with <code>false</code> values. If <code>n &lt; 0</code>, elements are shifted backwards. Equivalent to <code>B &lt;&lt; -n</code>.</p>
<p><strong>Example</strong></p>
<pre>julia&gt; B = BitVector([true, false, true, false, false])
5-element BitArray{1}:
  true
 false
  true
 false
 false

julia&gt; B &gt;&gt; 1
5-element BitArray{1}:
 false
  true
 false
  true
 false

julia&gt; B &gt;&gt; -1
5-element BitArray{1}:
 false
  true
 false
 false
 false</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/bitarray.jl#L1383-L1418">source</a><br><h3 id="Base.:&gt;&gt;&gt;">
<code>Base.:&gt;&gt;&gt;</code><span class="docstring-category">Function</span>
</h3>
<pre>&gt;&gt;&gt;(x, n)</pre>
<p>Unsigned right bit shift operator, <code>x &gt;&gt;&gt; n</code>. For <code>n &gt;= 0</code>, the result is <code>x</code> shifted right by <code>n</code> bits, where <code>n &gt;= 0</code>, filling with <code>0</code>s. For <code>n &lt; 0</code>, this is equivalent to <code>x &lt;&lt; -n</code>.</p>
<p>For <a href="../numbers/#Core.Unsigned"><code>Unsigned</code></a> integer types, this is equivalent to <a href="#Base.:&gt;&gt;"><code>&gt;&gt;</code></a>. For <a href="../numbers/#Core.Signed"><code>Signed</code></a> integer types, this is equivalent to <code>signed(unsigned(x) &gt;&gt; n)</code>.</p>
<pre>julia&gt; Int8(-14) &gt;&gt;&gt; 2
60

julia&gt; bits(Int8(-14))
"11110010"

julia&gt; bits(Int8(60))
"00111100"</pre>
<p><a href="../numbers/#Base.GMP.BigInt"><code>BigInt</code></a>s are treated as if having infinite size, so no filling is required and this is equivalent to <a href="#Base.:&gt;&gt;"><code>&gt;&gt;</code></a>.</p>
<p>See also <a href="#Base.:&gt;&gt;"><code>&gt;&gt;</code></a>, <a href="#Base.:&lt;&lt;"><code>&lt;&lt;</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L530-L555">source</a><br><pre>&gt;&gt;&gt;(B::BitVector, n) -&gt; BitVector</pre>
<p>Unsigned right bitshift operator, <code>B &gt;&gt;&gt; n</code>. Equivalent to <code>B &gt;&gt; n</code>. See <a href="#Base.:&gt;&gt;"><code>&gt;&gt;</code></a> for details and examples.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/bitarray.jl#L1460-L1465">source</a><br><h3 id="Base.colon">
<code>Base.colon</code><span class="docstring-category">Function</span>
</h3>
<pre>colon(start, [step], stop)</pre>
<p>Called by <code>:</code> syntax for constructing ranges.</p>
<pre>julia&gt; colon(1, 2, 5)
1:2:5</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/range.jl#L18-L27">source</a><br><pre>:(start, [step], stop)</pre>
<p>Range operator. <code>a:b</code> constructs a range from <code>a</code> to <code>b</code> with a step size of 1, and <code>a:s:b</code> is similar but uses a step size of <code>s</code>. These syntaxes call the function <code>colon</code>. The colon is also used in indexing to select whole dimensions.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/range.jl#L39-L45">source</a><br><h3 id="Base.range">
<code>Base.range</code><span class="docstring-category">Function</span>
</h3>
<pre>range(start, [step], length)</pre>
<p>Construct a range by length, given a starting value and optional step (defaults to 1).</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/range.jl#L55-L59">source</a><br><h3 id="Base.OneTo">
<code>Base.OneTo</code><span class="docstring-category">Type</span>
</h3>
<pre>Base.OneTo(n)</pre>
<p>Define an <code>AbstractUnitRange</code> that behaves like <code>1:n</code>, with the added distinction that the lower limit is guaranteed (by the type system) to be 1.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/range.jl#L166-L172">source</a><br><h3 id="Base.StepRangeLen">
<code>Base.StepRangeLen</code><span class="docstring-category">Type</span>
</h3>
<pre>StepRangeLen{T,R,S}(ref::R, step::S, len, [offset=1])</pre>
<p>A range <code>r</code> where <code>r[i]</code> produces values of type <code>T</code>, parametrized by a <code>ref</code>erence value, a <code>step</code>, and the <code>len</code>gth. By default <code>ref</code> is the starting value <code>r[1]</code>, but alternatively you can supply it as the value of <code>r[offset]</code> for some other index <code>1 &lt;= offset &lt;= len</code>. In conjunction with <code>TwicePrecision</code> this can be used to implement ranges that are free of roundoff error.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/range.jl#L181-L190">source</a><br><h3 id="Base.:==">
<code>Base.:==</code><span class="docstring-category">Function</span>
</h3>
<pre>==(x, y)</pre>
<p>Generic equality operator, giving a single <a href="../numbers/#Core.Bool"><code>Bool</code></a> result. Falls back to <code>===</code>. Should be implemented for all types with a notion of equality, based on the abstract value that an instance represents. For example, all numeric types are compared by numeric value, ignoring type. Strings are compared as sequences of characters, ignoring encoding.</p>
<p>Follows IEEE semantics for floating-point numbers.</p>
<p>Collections should generally implement <code>==</code> by calling <code>==</code> recursively on all contents.</p>
<p>New numeric types should implement this function for two arguments of the new type, and handle comparison to other types via promotion rules where possible.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1674-L1688">source</a><br><h3 id="Base.:!=">
<code>Base.:!=</code><span class="docstring-category">Function</span>
</h3>
<pre>!=(x, y)
≠(x,y)</pre>
<p>Not-equals comparison operator. Always gives the opposite answer as <code>==</code>. New types should generally not implement this, and rely on the fallback definition <code>!=(x,y) = !(x==y)</code> instead.</p>
<pre>julia&gt; 3 != 2
true

julia&gt; "foo" ≠ "foo"
false</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L114-L128">source</a><br><h3 id="Base.:!==">
<code>Base.:!==</code><span class="docstring-category">Function</span>
</h3>
<pre>!==(x, y)
≢(x,y)</pre>
<p>Equivalent to <code>!(x === y)</code>.</p>
<pre>julia&gt; a = [1, 2]; b = [1, 2];

julia&gt; a ≢ b
true

julia&gt; a ≢ a
false</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L156-L171">source</a><br><h3 id="Base.:&lt;">
<code>Base.:&lt;</code><span class="docstring-category">Function</span>
</h3>
<pre>&lt;(x, y)</pre>
<p>Less-than comparison operator. New numeric types should implement this function for two arguments of the new type. Because of the behavior of floating-point NaN values, <code>&lt;</code> implements a partial order. Types with a canonical partial order should implement <code>&lt;</code>, and types with a canonical total order should implement <code>isless</code>.</p>
<pre>julia&gt; 'a' &lt; 'b'
true

julia&gt; "abc" &lt; "abd"
true

julia&gt; 5 &lt; 3
false</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L175-L193">source</a><br><h3 id="Base.:&lt;=">
<code>Base.:&lt;=</code><span class="docstring-category">Function</span>
</h3>
<pre>&lt;=(x, y)
≤(x,y)</pre>
<p>Less-than-or-equals comparison operator.</p>
<pre>julia&gt; 'a' &lt;= 'b'
true

julia&gt; 7 ≤ 7 ≤ 9
true

julia&gt; "abc" ≤ "abc"
true

julia&gt; 5 &lt;= 3
false</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L218-L237">source</a><br><h3 id="Base.:&gt;">
<code>Base.:&gt;</code><span class="docstring-category">Function</span>
</h3>
<pre>&gt;(x, y)</pre>
<p>Greater-than comparison operator. Generally, new types should implement <code>&lt;</code> instead of this function, and rely on the fallback definition <code>&gt;(x, y) = y &lt; x</code>.</p>
<pre>julia&gt; 'a' &gt; 'b'
false

julia&gt; 7 &gt; 3 &gt; 1
true

julia&gt; "abc" &gt; "abd"
false

julia&gt; 5 &gt; 3
true</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L196-L215">source</a><br><h3 id="Base.:&gt;=">
<code>Base.:&gt;=</code><span class="docstring-category">Function</span>
</h3>
<pre>&gt;=(x, y)
≥(x,y)</pre>
<p>Greater-than-or-equals comparison operator.</p>
<pre>julia&gt; 'a' &gt;= 'b'
false

julia&gt; 7 ≥ 7 ≥ 3
true

julia&gt; "abc" ≥ "abc"
true

julia&gt; 5 &gt;= 3
true</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L241-L260">source</a><br><h3 id="Base.cmp">
<code>Base.cmp</code><span class="docstring-category">Function</span>
</h3>
<pre>cmp(x,y)</pre>
<p>Return -1, 0, or 1 depending on whether <code>x</code> is less than, equal to, or greater than <code>y</code>, respectively. Uses the total order implemented by <code>isless</code>. For floating-point numbers, uses <code>&lt;</code> but throws an error for unordered arguments.</p>
<pre>julia&gt; cmp(1, 2)
-1

julia&gt; cmp(2, 1)
1

julia&gt; cmp(2+im, 3-im)
ERROR: MethodError: no method matching isless(::Complex{Int64}, ::Complex{Int64})
[...]</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L284-L302">source</a><br><h3 id="Base.:~">
<code>Base.:~</code><span class="docstring-category">Function</span>
</h3>
<pre>~(x)</pre>
<p>Bitwise not.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; ~4
-5

julia&gt; ~10
-11

julia&gt; ~true
false</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1275-L1291">source</a><br><h3 id="Base.:&amp;">
<code>Base.:&amp;</code><span class="docstring-category">Function</span>
</h3>
<pre>&amp;(x, y)</pre>
<p>Bitwise and.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; 4 &amp; 10
0

julia&gt; 4 &amp; 12
4</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L639-L652">source</a><br><h3 id="Base.:|">
<code>Base.:|</code><span class="docstring-category">Function</span>
</h3>
<pre>|(x, y)</pre>
<p>Bitwise or.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; 4 | 10
14

julia&gt; 4 | 1
5</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2584-L2597">source</a><br><h3 id="Base.xor">
<code>Base.xor</code><span class="docstring-category">Function</span>
</h3>
<pre>xor(x, y)
⊻(x, y)</pre>
<p>Bitwise exclusive or of <code>x</code> and <code>y</code>. The infix operation <code>a ⊻ b</code> is a synonym for <code>xor(a,b)</code>, and <code>⊻</code> can be typed by tab-completing <code>\xor</code> or <code>\veebar</code> in the Julia REPL.</p>
<pre>julia&gt; [true; true; false] .⊻ [true; false; false]
3-element BitArray{1}:
 false
  true
 false</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/bool.jl#L44-L60">source</a><br><h3 id="Base.:!">
<code>Base.:!</code><span class="docstring-category">Function</span>
</h3>
<pre>!(x)</pre>
<p>Boolean not.</p>
<pre>julia&gt; !true
false

julia&gt; !false
true

julia&gt; .![true false true]
1×3 BitArray{2}:
 false  true  false</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/bool.jl#L17-L33">source</a><br><pre>!f::Function</pre>
<p>Predicate function negation: when the argument of <code>!</code> is a function, it returns a function which computes the boolean negation of <code>f</code>. Example:</p>
<pre>julia&gt; str = "∀ ε &gt; 0, ∃ δ &gt; 0: |x-y| &lt; δ ⇒ |f(x)-f(y)| &lt; ε"
"∀ ε &gt; 0, ∃ δ &gt; 0: |x-y| &lt; δ ⇒ |f(x)-f(y)| &lt; ε"

julia&gt; filter(isalpha, str)
"εδxyδfxfyε"

julia&gt; filter(!isalpha, str)
"∀  &gt; 0, ∃  &gt; 0: |-| &lt;  ⇒ |()-()| &lt; "</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L887-L903">source</a><br><h3 id="&amp;&amp;">
<code>&amp;&amp;</code><span class="docstring-category">Keyword</span>
</h3>
<pre>x &amp;&amp; y</pre>
<p>Short-circuiting boolean AND.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/basedocs.jl#L543-L547">source</a><br><h3 id="||">
<code>||</code><span class="docstring-category">Keyword</span>
</h3>
<pre>x || y</pre>
<p>Short-circuiting boolean OR.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/basedocs.jl#L550-L554">source</a><br><h2 id="Mathematical-Functions-1">Mathematical Functions</h2>
<h3 id="Base.isapprox">
<code>Base.isapprox</code><span class="docstring-category">Function</span>
</h3>
<pre>isapprox(x, y; rtol::Real=sqrt(eps), atol::Real=0, nans::Bool=false, norm::Function)</pre>
<p>Inexact equality comparison: <code>true</code> if <code>norm(x-y) &lt;= atol + rtol*max(norm(x), norm(y))</code>. The default <code>atol</code> is zero and the default <code>rtol</code> depends on the types of <code>x</code> and <code>y</code>. The keyword argument <code>nans</code> determines whether or not NaN values are considered equal (defaults to false).</p>
<p>For real or complex floating-point values, <code>rtol</code> defaults to <code>sqrt(eps(typeof(real(x-y))))</code>. This corresponds to requiring equality of about half of the significand digits. For other types, <code>rtol</code> defaults to zero.</p>
<p><code>x</code> and <code>y</code> may also be arrays of numbers, in which case <code>norm</code> defaults to <code>vecnorm</code> but may be changed by passing a <code>norm::Function</code> keyword argument. (For numbers, <code>norm</code> is the same thing as <code>abs</code>.) When <code>x</code> and <code>y</code> are arrays, if <code>norm(x-y)</code> is not finite (i.e. <code>±Inf</code> or <code>NaN</code>), the comparison falls back to checking whether all elements of <code>x</code> and <code>y</code> are approximately equal component-wise.</p>
<p>The binary operator <code>≈</code> is equivalent to <code>isapprox</code> with the default arguments, and <code>x ≉ y</code> is equivalent to <code>!isapprox(x,y)</code>.</p>
<pre>julia&gt; 0.1 ≈ (0.1 - 1e-10)
true

julia&gt; isapprox(10, 11; atol = 2)
true

julia&gt; isapprox([10.0^9, 1.0], [10.0^9, 2.0])
true</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/floatfuncs.jl#L173-L203">source</a><br><h3 id="Base.sin">
<code>Base.sin</code><span class="docstring-category">Function</span>
</h3>
<pre>sin(x)</pre>
<p>Compute sine of <code>x</code>, where <code>x</code> is in radians.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L303-L307">source</a><br><h3 id="Base.cos">
<code>Base.cos</code><span class="docstring-category">Function</span>
</h3>
<pre>cos(x)</pre>
<p>Compute cosine of <code>x</code>, where <code>x</code> is in radians.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L310-L314">source</a><br><h3 id="Base.tan">
<code>Base.tan</code><span class="docstring-category">Function</span>
</h3>
<pre>tan(x)</pre>
<p>Compute tangent of <code>x</code>, where <code>x</code> is in radians.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L317-L321">source</a><br><h3 id="Base.Math.sind">
<code>Base.Math.sind</code><span class="docstring-category">Function</span>
</h3>
<pre>sind(x)</pre>
<p>Compute sine of <code>x</code>, where <code>x</code> is in degrees. </p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/trig.jl#L413-L415">source</a><br><h3 id="Base.Math.cosd">
<code>Base.Math.cosd</code><span class="docstring-category">Function</span>
</h3>
<pre>cosd(x)</pre>
<p>Compute cosine of <code>x</code>, where <code>x</code> is in degrees. </p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/trig.jl#L413-L415">source</a><br><h3 id="Base.Math.tand">
<code>Base.Math.tand</code><span class="docstring-category">Function</span>
</h3>
<pre>tand(x)</pre>
<p>Compute tangent of <code>x</code>, where <code>x</code> is in degrees. </p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/trig.jl#L413-L415">source</a><br><h3 id="Base.Math.sinpi">
<code>Base.Math.sinpi</code><span class="docstring-category">Function</span>
</h3>
<pre>sinpi(x)</pre>
<p>Compute <span>$\sin(\pi x)$</span> more accurately than <code>sin(pi*x)</code>, especially for large <code>x</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/trig.jl#L101-L105">source</a><br><h3 id="Base.Math.cospi">
<code>Base.Math.cospi</code><span class="docstring-category">Function</span>
</h3>
<pre>cospi(x)</pre>
<p>Compute <span>$\cos(\pi x)$</span> more accurately than <code>cos(pi*x)</code>, especially for large <code>x</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/trig.jl#L164-L168">source</a><br><h3 id="Base.sinh">
<code>Base.sinh</code><span class="docstring-category">Function</span>
</h3>
<pre>sinh(x)</pre>
<p>Compute hyperbolic sine of <code>x</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L195-L199">source</a><br><h3 id="Base.cosh">
<code>Base.cosh</code><span class="docstring-category">Function</span>
</h3>
<pre>cosh(x)</pre>
<p>Compute hyperbolic cosine of <code>x</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L202-L206">source</a><br><h3 id="Base.tanh">
<code>Base.tanh</code><span class="docstring-category">Function</span>
</h3>
<pre>tanh(x)</pre>
<p>Compute hyperbolic tangent of <code>x</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L209-L213">source</a><br><h3 id="Base.asin">
<code>Base.asin</code><span class="docstring-category">Function</span>
</h3>
<pre>asin(x)</pre>
<p>Compute the inverse sine of <code>x</code>, where the output is in radians.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L324-L328">source</a><br><h3 id="Base.acos">
<code>Base.acos</code><span class="docstring-category">Function</span>
</h3>
<pre>acos(x)</pre>
<p>Compute the inverse cosine of <code>x</code>, where the output is in radians</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L331-L335">source</a><br><h3 id="Base.atan">
<code>Base.atan</code><span class="docstring-category">Function</span>
</h3>
<pre>atan(x)</pre>
<p>Compute the inverse tangent of <code>x</code>, where the output is in radians.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L216-L220">source</a><br><h3 id="Base.Math.atan2">
<code>Base.Math.atan2</code><span class="docstring-category">Function</span>
</h3>
<pre>atan2(y, x)</pre>
<p>Compute the inverse tangent of <code>y/x</code>, using the signs of both <code>x</code> and <code>y</code> to determine the quadrant of the return value.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L488-L493">source</a><br><h3 id="Base.Math.asind">
<code>Base.Math.asind</code><span class="docstring-category">Function</span>
</h3>
<pre>asind(x)</pre>
<p>Compute the inverse sine of <code>x</code>, where the output is in degrees. </p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/trig.jl#L423-L426">source</a><br><h3 id="Base.Math.acosd">
<code>Base.Math.acosd</code><span class="docstring-category">Function</span>
</h3>
<pre>acosd(x)</pre>
<p>Compute the inverse cosine of <code>x</code>, where the output is in degrees. </p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/trig.jl#L423-L426">source</a><br><h3 id="Base.Math.atand">
<code>Base.Math.atand</code><span class="docstring-category">Function</span>
</h3>
<pre>atand(x)</pre>
<p>Compute the inverse tangent of <code>x</code>, where the output is in degrees. </p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/trig.jl#L423-L426">source</a><br><h3 id="Base.Math.sec">
<code>Base.Math.sec</code><span class="docstring-category">Function</span>
</h3>
<pre>sec(x)</pre>
<p>Compute the secant of <code>x</code>, where <code>x</code> is in radians.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1895-L1899">source</a><br><h3 id="Base.Math.csc">
<code>Base.Math.csc</code><span class="docstring-category">Function</span>
</h3>
<pre>csc(x)</pre>
<p>Compute the cosecant of <code>x</code>, where <code>x</code> is in radians.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1462-L1466">source</a><br><h3 id="Base.Math.cot">
<code>Base.Math.cot</code><span class="docstring-category">Function</span>
</h3>
<pre>cot(x)</pre>
<p>Compute the cotangent of <code>x</code>, where <code>x</code> is in radians.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1411-L1415">source</a><br><h3 id="Base.Math.secd">
<code>Base.Math.secd</code><span class="docstring-category">Function</span>
</h3>
<pre>secd(x)</pre>
<p>Compute the secant of <code>x</code>, where <code>x</code> is in degrees.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1815-L1819">source</a><br><h3 id="Base.Math.cscd">
<code>Base.Math.cscd</code><span class="docstring-category">Function</span>
</h3>
<pre>cscd(x)</pre>
<p>Compute the cosecant of <code>x</code>, where <code>x</code> is in degrees.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2471-L2475">source</a><br><h3 id="Base.Math.cotd">
<code>Base.Math.cotd</code><span class="docstring-category">Function</span>
</h3>
<pre>cotd(x)</pre>
<p>Compute the cotangent of <code>x</code>, where <code>x</code> is in degrees.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1537-L1541">source</a><br><h3 id="Base.Math.asec">
<code>Base.Math.asec</code><span class="docstring-category">Function</span>
</h3>
<pre>asec(x)</pre>
<p>Compute the inverse secant of <code>x</code>, where the output is in radians. </p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/trig.jl#L323-L325">source</a><br><h3 id="Base.Math.acsc">
<code>Base.Math.acsc</code><span class="docstring-category">Function</span>
</h3>
<pre>acsc(x)</pre>
<p>Compute the inverse cosecant of <code>x</code>, where the output is in radians. </p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/trig.jl#L323-L325">source</a><br><h3 id="Base.Math.acot">
<code>Base.Math.acot</code><span class="docstring-category">Function</span>
</h3>
<pre>acot(x)</pre>
<p>Compute the inverse cotangent of <code>x</code>, where the output is in radians. </p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/trig.jl#L323-L325">source</a><br><h3 id="Base.Math.asecd">
<code>Base.Math.asecd</code><span class="docstring-category">Function</span>
</h3>
<pre>asecd(x)</pre>
<p>Compute the inverse secant of <code>x</code>, where the output is in degrees. </p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/trig.jl#L423-L426">source</a><br><h3 id="Base.Math.acscd">
<code>Base.Math.acscd</code><span class="docstring-category">Function</span>
</h3>
<pre>acscd(x)</pre>
<p>Compute the inverse cosecant of <code>x</code>, where the output is in degrees. </p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/trig.jl#L423-L426">source</a><br><h3 id="Base.Math.acotd">
<code>Base.Math.acotd</code><span class="docstring-category">Function</span>
</h3>
<pre>acotd(x)</pre>
<p>Compute the inverse cotangent of <code>x</code>, where the output is in degrees. </p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/trig.jl#L423-L426">source</a><br><h3 id="Base.Math.sech">
<code>Base.Math.sech</code><span class="docstring-category">Function</span>
</h3>
<pre>sech(x)</pre>
<p>Compute the hyperbolic secant of <code>x</code></p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L190-L194">source</a><br><h3 id="Base.Math.csch">
<code>Base.Math.csch</code><span class="docstring-category">Function</span>
</h3>
<pre>csch(x)</pre>
<p>Compute the hyperbolic cosecant of <code>x</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1888-L1892">source</a><br><h3 id="Base.Math.coth">
<code>Base.Math.coth</code><span class="docstring-category">Function</span>
</h3>
<pre>coth(x)</pre>
<p>Compute the hyperbolic cotangent of <code>x</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2112-L2116">source</a><br><h3 id="Base.asinh">
<code>Base.asinh</code><span class="docstring-category">Function</span>
</h3>
<pre>asinh(x)</pre>
<p>Compute the inverse hyperbolic sine of <code>x</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L223-L227">source</a><br><h3 id="Base.acosh">
<code>Base.acosh</code><span class="docstring-category">Function</span>
</h3>
<pre>acosh(x)</pre>
<p>Compute the inverse hyperbolic cosine of <code>x</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L338-L342">source</a><br><h3 id="Base.atanh">
<code>Base.atanh</code><span class="docstring-category">Function</span>
</h3>
<pre>atanh(x)</pre>
<p>Compute the inverse hyperbolic tangent of <code>x</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L345-L349">source</a><br><h3 id="Base.Math.asech">
<code>Base.Math.asech</code><span class="docstring-category">Function</span>
</h3>
<pre>asech(x)</pre>
<p>Compute the inverse hyperbolic secant of <code>x</code>. </p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/trig.jl#L326-L328">source</a><br><h3 id="Base.Math.acsch">
<code>Base.Math.acsch</code><span class="docstring-category">Function</span>
</h3>
<pre>acsch(x)</pre>
<p>Compute the inverse hyperbolic cosecant of <code>x</code>. </p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/trig.jl#L326-L328">source</a><br><h3 id="Base.Math.acoth">
<code>Base.Math.acoth</code><span class="docstring-category">Function</span>
</h3>
<pre>acoth(x)</pre>
<p>Compute the inverse hyperbolic cotangent of <code>x</code>. </p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/trig.jl#L326-L328">source</a><br><h3 id="Base.Math.sinc">
<code>Base.Math.sinc</code><span class="docstring-category">Function</span>
</h3>
<pre>sinc(x)</pre>
<p>Compute <span>$\sin(\pi x) / (\pi x)$</span> if <span>$x \neq 0$</span>, and <span>$1$</span> if <span>$x = 0$</span>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/trig.jl#L288-L292">source</a><br><h3 id="Base.Math.cosc">
<code>Base.Math.cosc</code><span class="docstring-category">Function</span>
</h3>
<pre>cosc(x)</pre>
<p>Compute <span>$\cos(\pi x) / x - \sin(\pi x) / (\pi x^2)$</span> if <span>$x \neq 0$</span>, and <span>$0$</span> if <span>$x = 0$</span>. This is the derivative of <code>sinc(x)</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/trig.jl#L298-L303">source</a><br><h3 id="Base.Math.deg2rad">
<code>Base.Math.deg2rad</code><span class="docstring-category">Function</span>
</h3>
<pre>deg2rad(x)</pre>
<p>Convert <code>x</code> from degrees to radians.</p>
<pre>julia&gt; deg2rad(90)
1.5707963267948966</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L145-L154">source</a><br><h3 id="Base.Math.rad2deg">
<code>Base.Math.rad2deg</code><span class="docstring-category">Function</span>
</h3>
<pre>rad2deg(x)</pre>
<p>Convert <code>x</code> from radians to degrees.</p>
<pre>julia&gt; rad2deg(pi)
180.0</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L133-L142">source</a><br><h3 id="Base.Math.hypot">
<code>Base.Math.hypot</code><span class="docstring-category">Function</span>
</h3>
<pre>hypot(x, y)</pre>
<p>Compute the hypotenuse <span>$\sqrt{x^2+y^2}$</span> avoiding overflow and underflow.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; a = 10^10;

julia&gt; hypot(a, a)
1.4142135623730951e10

julia&gt; √(a^2 + a^2) # a^2 overflows
ERROR: DomainError:
sqrt will only return a complex result if called with a complex argument. Try sqrt(complex(x)).
Stacktrace:
 [1] sqrt(::Int64) at ./math.jl:434</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L436-L454">source</a><br><pre>hypot(x...)</pre>
<p>Compute the hypotenuse <span>$\sqrt{\sum x_i^2}$</span> avoiding overflow and underflow.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L481-L485">source</a><br><h3 id="Base.log-Tuple{Any}">
<code>Base.log</code><span class="docstring-category">Method</span>
</h3>
<pre>log(x)</pre>
<p>Compute the natural logarithm of <code>x</code>. Throws <a href="../base/#Core.DomainError"><code>DomainError</code></a> for negative <a href="../numbers/#Core.Real"><code>Real</code></a> arguments. Use complex negative arguments to obtain complex results.</p>
<p>There is an experimental variant in the <code>Base.Math.JuliaLibm</code> module, which is typically faster and more accurate.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L352-L360">source</a><br><h3 id="Base.log-Tuple{Number,Number}">
<code>Base.log</code><span class="docstring-category">Method</span>
</h3>
<pre>log(b,x)</pre>
<p>Compute the base <code>b</code> logarithm of <code>x</code>. Throws <a href="../base/#Core.DomainError"><code>DomainError</code></a> for negative <a href="../numbers/#Core.Real"><code>Real</code></a> arguments.</p>
<pre>julia&gt; log(4,8)
1.5

julia&gt; log(4,2)
0.5</pre>
<div class="admonition note">
<div class="admonition-title">Note</div>
<div class="admonition-text">
<p>If <code>b</code> is a power of 2 or 10, <a href="#Base.log2"><code>log2</code></a> or <a href="#Base.log10"><code>log10</code></a> should be used, as these will typically be faster and more accurate. For example,</p>
<pre>julia&gt; log(100,1000000)
2.9999999999999996

julia&gt; log10(1000000)/2
3.0</pre>
</div>
</div>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L161-L186">source</a><br><h3 id="Base.log2">
<code>Base.log2</code><span class="docstring-category">Function</span>
</h3>
<pre>log2(x)</pre>
<p>Compute the logarithm of <code>x</code> to base 2. Throws <a href="../base/#Core.DomainError"><code>DomainError</code></a> for negative <a href="../numbers/#Core.Real"><code>Real</code></a> arguments.</p>
<p><strong>Example</strong></p>
<pre>julia&gt; log2(4)
2.0

julia&gt; log2(10)
3.321928094887362</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L363-L377">source</a><br><h3 id="Base.log10">
<code>Base.log10</code><span class="docstring-category">Function</span>
</h3>
<pre>log10(x)</pre>
<p>Compute the logarithm of <code>x</code> to base 10. Throws <a href="../base/#Core.DomainError"><code>DomainError</code></a> for negative <a href="../numbers/#Core.Real"><code>Real</code></a> arguments.</p>
<p><strong>Example</strong></p>
<pre>julia&gt; log10(100)
2.0

julia&gt; log10(2)
0.3010299956639812</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L380-L394">source</a><br><h3 id="Base.log1p">
<code>Base.log1p</code><span class="docstring-category">Function</span>
</h3>
<pre>log1p(x)</pre>
<p>Accurate natural logarithm of <code>1+x</code>. Throws <a href="../base/#Core.DomainError"><code>DomainError</code></a> for <a href="../numbers/#Core.Real"><code>Real</code></a> arguments less than -1.</p>
<p>There is an experimental variant in the <code>Base.Math.JuliaLibm</code> module, which is typically faster and more accurate.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; log1p(-0.5)
-0.6931471805599453

julia&gt; log1p(0)
0.0</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L397-L414">source</a><br><h3 id="Base.Math.frexp">
<code>Base.Math.frexp</code><span class="docstring-category">Function</span>
</h3>
<pre>frexp(val)</pre>
<p>Return <code>(x,exp)</code> such that <code>x</code> has a magnitude in the interval <span>$[1/2, 1)$</span> or 0, and <code>val</code> is equal to <span>$x \times 2^{exp}$</span>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L614-L619">source</a><br><h3 id="Base.exp">
<code>Base.exp</code><span class="docstring-category">Function</span>
</h3>
<pre>exp(x)</pre>
<p>Compute the natural base exponential of <code>x</code>, in other words <span>$e^x$</span>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/exp.jl#L62-L66">source</a><br><h3 id="Base.exp2">
<code>Base.exp2</code><span class="docstring-category">Function</span>
</h3>
<pre>exp2(x)</pre>
<p>Compute <span>$2^x$</span>.</p>
<pre>julia&gt; exp2(5)
32.0</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L262-L271">source</a><br><h3 id="Base.exp10">
<code>Base.exp10</code><span class="docstring-category">Function</span>
</h3>
<pre>exp10(x)</pre>
<p>Compute <span>$10^x$</span>.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; exp10(2)
100.0

julia&gt; exp10(0.2)
1.5848931924611136</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L623-L636">source</a><br><h3 id="Base.Math.ldexp">
<code>Base.Math.ldexp</code><span class="docstring-category">Function</span>
</h3>
<pre>ldexp(x, n)</pre>
<p>Compute <span>$x \times 2^n$</span>.</p>
<p><strong>Example</strong></p>
<pre>julia&gt; ldexp(5., 2)
20.0</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L512-L522">source</a><br><h3 id="Base.Math.modf">
<code>Base.Math.modf</code><span class="docstring-category">Function</span>
</h3>
<pre>modf(x)</pre>
<p>Return a tuple (fpart,ipart) of the fractional and integral parts of a number. Both parts have the same sign as the argument.</p>
<p><strong>Example</strong></p>
<pre>julia&gt; modf(3.5)
(0.5, 3.0)</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L673-L684">source</a><br><h3 id="Base.expm1">
<code>Base.expm1</code><span class="docstring-category">Function</span>
</h3>
<pre>expm1(x)</pre>
<p>Accurately compute <span>$e^x-1$</span>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L230-L234">source</a><br><h3 id="Base.round-Tuple{Type,Any}">
<code>Base.round</code><span class="docstring-category">Method</span>
</h3>
<pre>round([T,] x, [digits, [base]], [r::RoundingMode])</pre>
<p>Rounds <code>x</code> to an integer value according to the provided <a href="#Base.Rounding.RoundingMode"><code>RoundingMode</code></a>, returning a value of the same type as <code>x</code>. When not specifying a rounding mode the global mode will be used (see <a href="../numbers/#Base.Rounding.rounding"><code>rounding</code></a>), which by default is round to the nearest integer (<a href="#Base.Rounding.RoundNearest"><code>RoundNearest</code></a> mode), with ties (fractional values of 0.5) being rounded to the nearest even integer.</p>
<pre>julia&gt; round(1.7)
2.0

julia&gt; round(1.5)
2.0

julia&gt; round(2.5)
2.0</pre>
<p>The optional <a href="#Base.Rounding.RoundingMode"><code>RoundingMode</code></a> argument will change how the number gets rounded.</p>
<p><code>round(T, x, [r::RoundingMode])</code> converts the result to type <code>T</code>, throwing an <a href="../base/#Core.InexactError"><code>InexactError</code></a> if the value is not representable.</p>
<p><code>round(x, digits)</code> rounds to the specified number of digits after the decimal place (or before if negative). <code>round(x, digits, base)</code> rounds using a base other than 10.</p>
<pre>julia&gt; round(pi, 2)
3.14

julia&gt; round(pi, 3, 2)
3.125</pre>
<div class="admonition note">
<div class="admonition-title">Note</div>
<div class="admonition-text">
<p>Rounding to specified digits in bases other than 2 can be inexact when operating on binary floating point numbers. For example, the <a href="../numbers/#Core.Float64"><code>Float64</code></a> value represented by <code>1.15</code> is actually <em>less</em> than 1.15, yet will be rounded to 1.2.</p>
<pre>julia&gt; x = 1.15
1.15

julia&gt; @sprintf "%.20f" x
"1.14999999999999991118"

julia&gt; x &lt; 115//100
true

julia&gt; round(x, 1)
1.2</pre>
</div>
</div>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/floatfuncs.jl#L42-L99">source</a><br><h3 id="Base.Rounding.RoundingMode">
<code>Base.Rounding.RoundingMode</code><span class="docstring-category">Type</span>
</h3>
<pre>RoundingMode</pre>
<p>A type used for controlling the rounding mode of floating point operations (via <a href="../numbers/#Base.Rounding.rounding"><code>rounding</code></a>/<a href="#"><code>setrounding</code></a> functions), or as optional arguments for rounding to the nearest integer (via the <a href="#"><code>round</code></a> function).</p>
<p>Currently supported rounding modes are:</p>
<ul>
<li><p><a href="#Base.Rounding.RoundNearest"><code>RoundNearest</code></a> (default)</p></li>
<li><p><a href="#Base.Rounding.RoundNearestTiesAway"><code>RoundNearestTiesAway</code></a></p></li>
<li><p><a href="#Base.Rounding.RoundNearestTiesUp"><code>RoundNearestTiesUp</code></a></p></li>
<li><p><a href="#Base.Rounding.RoundToZero"><code>RoundToZero</code></a></p></li>
<li><p><code>RoundFromZero</code> (<a href="../numbers/#Base.MPFR.BigFloat"><code>BigFloat</code></a> only)</p></li>
<li><p><a href="#Base.Rounding.RoundUp"><code>RoundUp</code></a></p></li>
<li><p><a href="#Base.Rounding.RoundDown"><code>RoundDown</code></a></p></li>
</ul>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/rounding.jl#L26-L43">source</a><br><h3 id="Base.Rounding.RoundNearest">
<code>Base.Rounding.RoundNearest</code><span class="docstring-category">Constant</span>
</h3>
<pre>RoundNearest</pre>
<p>The default rounding mode. Rounds to the nearest integer, with ties (fractional values of 0.5) being rounded to the nearest even integer.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/rounding.jl#L46-L51">source</a><br><h3 id="Base.Rounding.RoundNearestTiesAway">
<code>Base.Rounding.RoundNearestTiesAway</code><span class="docstring-category">Constant</span>
</h3>
<pre>RoundNearestTiesAway</pre>
<p>Rounds to nearest integer, with ties rounded away from zero (C/C++ <a href="#"><code>round</code></a> behaviour).</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/rounding.jl#L77-L82">source</a><br><h3 id="Base.Rounding.RoundNearestTiesUp">
<code>Base.Rounding.RoundNearestTiesUp</code><span class="docstring-category">Constant</span>
</h3>
<pre>RoundNearestTiesUp</pre>
<p>Rounds to nearest integer, with ties rounded toward positive infinity (Java/JavaScript <a href="#"><code>round</code></a> behaviour).</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/rounding.jl#L85-L90">source</a><br><h3 id="Base.Rounding.RoundToZero">
<code>Base.Rounding.RoundToZero</code><span class="docstring-category">Constant</span>
</h3>
<pre>RoundToZero</pre>
<p><a href="#"><code>round</code></a> using this rounding mode is an alias for <a href="#Base.trunc"><code>trunc</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/rounding.jl#L54-L58">source</a><br><h3 id="Base.Rounding.RoundUp">
<code>Base.Rounding.RoundUp</code><span class="docstring-category">Constant</span>
</h3>
<pre>RoundUp</pre>
<p><a href="#"><code>round</code></a> using this rounding mode is an alias for <a href="#Base.ceil"><code>ceil</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/rounding.jl#L61-L65">source</a><br><h3 id="Base.Rounding.RoundDown">
<code>Base.Rounding.RoundDown</code><span class="docstring-category">Constant</span>
</h3>
<pre>RoundDown</pre>
<p><a href="#"><code>round</code></a> using this rounding mode is an alias for <a href="#Base.floor"><code>floor</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/rounding.jl#L68-L72">source</a><br><h3 id="Base.round-Union{Tuple{Complex{T},RoundingMode{MR},RoundingMode{MI}}, Tuple{MI}, Tuple{MR}, Tuple{T}} where MI where MR where T&lt;:AbstractFloat">
<code>Base.round</code><span class="docstring-category">Method</span>
</h3>
<pre>round(z, RoundingModeReal, RoundingModeImaginary)</pre>
<p>Returns the nearest integral value of the same type as the complex-valued <code>z</code> to <code>z</code>, breaking ties using the specified <a href="#Base.Rounding.RoundingMode"><code>RoundingMode</code></a>s. The first <a href="#Base.Rounding.RoundingMode"><code>RoundingMode</code></a> is used for rounding the real components while the second is used for rounding the imaginary components.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/complex.jl#L876-L883">source</a><br><h3 id="Base.ceil">
<code>Base.ceil</code><span class="docstring-category">Function</span>
</h3>
<pre>ceil([T,] x, [digits, [base]])</pre>
<p><code>ceil(x)</code> returns the nearest integral value of the same type as <code>x</code> that is greater than or equal to <code>x</code>.</p>
<p><code>ceil(T, x)</code> converts the result to type <code>T</code>, throwing an <code>InexactError</code> if the value is not representable.</p>
<p><code>digits</code> and <code>base</code> work as for <a href="#"><code>round</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L364-L374">source</a><br><h3 id="Base.floor">
<code>Base.floor</code><span class="docstring-category">Function</span>
</h3>
<pre>floor([T,] x, [digits, [base]])</pre>
<p><code>floor(x)</code> returns the nearest integral value of the same type as <code>x</code> that is less than or equal to <code>x</code>.</p>
<p><code>floor(T, x)</code> converts the result to type <code>T</code>, throwing an <code>InexactError</code> if the value is not representable.</p>
<p><code>digits</code> and <code>base</code> work as for <a href="#"><code>round</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L680-L690">source</a><br><h3 id="Base.trunc">
<code>Base.trunc</code><span class="docstring-category">Function</span>
</h3>
<pre>trunc([T,] x, [digits, [base]])</pre>
<p><code>trunc(x)</code> returns the nearest integral value of the same type as <code>x</code> whose absolute value is less than or equal to <code>x</code>.</p>
<p><code>trunc(T, x)</code> converts the result to type <code>T</code>, throwing an <code>InexactError</code> if the value is not representable.</p>
<p><code>digits</code> and <code>base</code> work as for <a href="#"><code>round</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1024-L1034">source</a><br><h3 id="Base.unsafe_trunc">
<code>Base.unsafe_trunc</code><span class="docstring-category">Function</span>
</h3>
<pre>unsafe_trunc(T, x)</pre>
<p><code>unsafe_trunc(T, x)</code> returns the nearest integral value of type <code>T</code> whose absolute value is less than or equal to <code>x</code>. If the value is not representable by <code>T</code>, an arbitrary value will be returned.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1789-L1795">source</a><br><h3 id="Base.signif">
<code>Base.signif</code><span class="docstring-category">Function</span>
</h3>
<pre>signif(x, digits, [base])</pre>
<p>Rounds (in the sense of <a href="#"><code>round</code></a>) <code>x</code> so that there are <code>digits</code> significant digits, under a base <code>base</code> representation, default 10. E.g., <code>signif(123.456, 2)</code> is <code>120.0</code>, and <code>signif(357.913, 4, 2)</code> is <code>352.0</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2303-L2309">source</a><br><h3 id="Base.min">
<code>Base.min</code><span class="docstring-category">Function</span>
</h3>
<pre>min(x, y, ...)</pre>
<p>Return the minimum of the arguments. See also the <a href="#"><code>minimum</code></a> function to take the minimum element from a collection.</p>
<pre>julia&gt; min(2, 5, 1)
1</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L350-L360">source</a><br><h3 id="Base.max">
<code>Base.max</code><span class="docstring-category">Function</span>
</h3>
<pre>max(x, y, ...)</pre>
<p>Return the maximum of the arguments. See also the <a href="#"><code>maximum</code></a> function to take the maximum element from a collection.</p>
<pre>julia&gt; max(2, 5, 1)
5</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L337-L347">source</a><br><h3 id="Base.minmax">
<code>Base.minmax</code><span class="docstring-category">Function</span>
</h3>
<pre>minmax(x, y)</pre>
<p>Return <code>(min(x,y), max(x,y))</code>. See also: <a href="#"><code>extrema</code></a> that returns <code>(minimum(x), maximum(x))</code>.</p>
<pre>julia&gt; minmax('c','b')
('b', 'c')</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/operators.jl#L363-L372">source</a><br><h3 id="Base.Math.clamp">
<code>Base.Math.clamp</code><span class="docstring-category">Function</span>
</h3>
<pre>clamp(x, lo, hi)</pre>
<p>Return <code>x</code> if <code>lo &lt;= x &lt;= hi</code>. If <code>x &lt; lo</code>, return <code>lo</code>. If <code>x &gt; hi</code>, return <code>hi</code>. Arguments are promoted to a common type.</p>
<pre>julia&gt; clamp.([pi, 1.0, big(10.)], 2., 9.)
3-element Array{BigFloat,1}:
 3.141592653589793238462643383279502884197169399375105820974944592307816406286198
 2.000000000000000000000000000000000000000000000000000000000000000000000000000000
 9.000000000000000000000000000000000000000000000000000000000000000000000000000000</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L42-L55">source</a><br><h3 id="Base.Math.clamp!">
<code>Base.Math.clamp!</code><span class="docstring-category">Function</span>
</h3>
<pre>clamp!(array::AbstractArray, lo, hi)</pre>
<p>Restrict values in <code>array</code> to the specified range, in-place. See also <a href="#Base.Math.clamp"><code>clamp</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L62-L67">source</a><br><h3 id="Base.abs">
<code>Base.abs</code><span class="docstring-category">Function</span>
</h3>
<pre>abs(x)</pre>
<p>The absolute value of <code>x</code>.</p>
<p>When <code>abs</code> is applied to signed integers, overflow may occur, resulting in the return of a negative value. This overflow occurs only when <code>abs</code> is applied to the minimum representable value of a signed integer. That is, when <code>x == typemin(typeof(x))</code>, <code>abs(x) == x &lt; 0</code>, not <code>-x</code> as might be expected.</p>
<pre>julia&gt; abs(-3)
3

julia&gt; abs(1 + im)
1.4142135623730951

julia&gt; abs(typemin(Int64))
-9223372036854775808</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/int.jl#L87-L108">source</a><br><h3 id="Base.Checked.checked_abs">
<code>Base.Checked.checked_abs</code><span class="docstring-category">Function</span>
</h3>
<pre>Base.checked_abs(x)</pre>
<p>Calculates <code>abs(x)</code>, checking for overflow errors where applicable. For example, standard two's complement signed integers (e.g. <code>Int</code>) cannot represent <code>abs(typemin(Int))</code>, thus leading to an overflow.</p>
<p>The overflow protection may impose a perceptible performance penalty.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/checked.jl#L107-L115">source</a><br><h3 id="Base.Checked.checked_neg">
<code>Base.Checked.checked_neg</code><span class="docstring-category">Function</span>
</h3>
<pre>Base.checked_neg(x)</pre>
<p>Calculates <code>-x</code>, checking for overflow errors where applicable. For example, standard two's complement signed integers (e.g. <code>Int</code>) cannot represent <code>-typemin(Int)</code>, thus leading to an overflow.</p>
<p>The overflow protection may impose a perceptible performance penalty.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/checked.jl#L81-L89">source</a><br><h3 id="Base.Checked.checked_add">
<code>Base.Checked.checked_add</code><span class="docstring-category">Function</span>
</h3>
<pre>Base.checked_add(x, y)</pre>
<p>Calculates <code>x+y</code>, checking for overflow errors where applicable.</p>
<p>The overflow protection may impose a perceptible performance penalty.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/checked.jl#L155-L161">source</a><br><h3 id="Base.Checked.checked_sub">
<code>Base.Checked.checked_sub</code><span class="docstring-category">Function</span>
</h3>
<pre>Base.checked_sub(x, y)</pre>
<p>Calculates <code>x-y</code>, checking for overflow errors where applicable.</p>
<p>The overflow protection may impose a perceptible performance penalty.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/checked.jl#L212-L218">source</a><br><h3 id="Base.Checked.checked_mul">
<code>Base.Checked.checked_mul</code><span class="docstring-category">Function</span>
</h3>
<pre>Base.checked_mul(x, y)</pre>
<p>Calculates <code>x*y</code>, checking for overflow errors where applicable.</p>
<p>The overflow protection may impose a perceptible performance penalty.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/checked.jl#L277-L283">source</a><br><h3 id="Base.Checked.checked_div">
<code>Base.Checked.checked_div</code><span class="docstring-category">Function</span>
</h3>
<pre>Base.checked_div(x, y)</pre>
<p>Calculates <code>div(x,y)</code>, checking for overflow errors where applicable.</p>
<p>The overflow protection may impose a perceptible performance penalty.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/checked.jl#L306-L312">source</a><br><h3 id="Base.Checked.checked_rem">
<code>Base.Checked.checked_rem</code><span class="docstring-category">Function</span>
</h3>
<pre>Base.checked_rem(x, y)</pre>
<p>Calculates <code>x%y</code>, checking for overflow errors where applicable.</p>
<p>The overflow protection may impose a perceptible performance penalty.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/checked.jl#L315-L321">source</a><br><h3 id="Base.Checked.checked_fld">
<code>Base.Checked.checked_fld</code><span class="docstring-category">Function</span>
</h3>
<pre>Base.checked_fld(x, y)</pre>
<p>Calculates <code>fld(x,y)</code>, checking for overflow errors where applicable.</p>
<p>The overflow protection may impose a perceptible performance penalty.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/checked.jl#L324-L330">source</a><br><h3 id="Base.Checked.checked_mod">
<code>Base.Checked.checked_mod</code><span class="docstring-category">Function</span>
</h3>
<pre>Base.checked_mod(x, y)</pre>
<p>Calculates <code>mod(x,y)</code>, checking for overflow errors where applicable.</p>
<p>The overflow protection may impose a perceptible performance penalty.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/checked.jl#L333-L339">source</a><br><h3 id="Base.Checked.checked_cld">
<code>Base.Checked.checked_cld</code><span class="docstring-category">Function</span>
</h3>
<pre>Base.checked_cld(x, y)</pre>
<p>Calculates <code>cld(x,y)</code>, checking for overflow errors where applicable.</p>
<p>The overflow protection may impose a perceptible performance penalty.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/checked.jl#L342-L348">source</a><br><h3 id="Base.Checked.add_with_overflow">
<code>Base.Checked.add_with_overflow</code><span class="docstring-category">Function</span>
</h3>
<pre>Base.add_with_overflow(x, y) -&gt; (r, f)</pre>
<p>Calculates <code>r = x+y</code>, with the flag <code>f</code> indicating whether overflow has occurred.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/checked.jl#L128-L132">source</a><br><h3 id="Base.Checked.sub_with_overflow">
<code>Base.Checked.sub_with_overflow</code><span class="docstring-category">Function</span>
</h3>
<pre>Base.sub_with_overflow(x, y) -&gt; (r, f)</pre>
<p>Calculates <code>r = x-y</code>, with the flag <code>f</code> indicating whether overflow has occurred.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/checked.jl#L187-L191">source</a><br><h3 id="Base.Checked.mul_with_overflow">
<code>Base.Checked.mul_with_overflow</code><span class="docstring-category">Function</span>
</h3>
<pre>Base.mul_with_overflow(x, y) -&gt; (r, f)</pre>
<p>Calculates <code>r = x*y</code>, with the flag <code>f</code> indicating whether overflow has occurred.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/checked.jl#L227-L231">source</a><br><h3 id="Base.abs2">
<code>Base.abs2</code><span class="docstring-category">Function</span>
</h3>
<pre>abs2(x)</pre>
<p>Squared absolute value of <code>x</code>.</p>
<pre>julia&gt; abs2(-3)
9</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/number.jl#L84-L93">source</a><br><h3 id="Base.copysign">
<code>Base.copysign</code><span class="docstring-category">Function</span>
</h3>
<pre>copysign(x, y) -&gt; z</pre>
<p>Return <code>z</code> which has the magnitude of <code>x</code> and the same sign as <code>y</code>.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; copysign(1, -2)
-1

julia&gt; copysign(-1, 2)
1</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L799-L812">source</a><br><h3 id="Base.sign">
<code>Base.sign</code><span class="docstring-category">Function</span>
</h3>
<pre>sign(x)</pre>
<p>Return zero if <code>x==0</code> and <span>$x/|x|$</span> otherwise (i.e., ±1 for real <code>x</code>).</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/number.jl#L74-L78">source</a><br><h3 id="Base.signbit">
<code>Base.signbit</code><span class="docstring-category">Function</span>
</h3>
<pre>signbit(x)</pre>
<p>Returns <code>true</code> if the value of the sign of <code>x</code> is negative, otherwise <code>false</code>.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; signbit(-4)
true

julia&gt; signbit(5)
false

julia&gt; signbit(5.5)
false

julia&gt; signbit(-4.1)
true</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2449-L2468">source</a><br><h3 id="Base.flipsign">
<code>Base.flipsign</code><span class="docstring-category">Function</span>
</h3>
<pre>flipsign(x, y)</pre>
<p>Return <code>x</code> with its sign flipped if <code>y</code> is negative. For example <code>abs(x) = flipsign(x,x)</code>.</p>
<pre>julia&gt; flipsign(5, 3)
5

julia&gt; flipsign(5, -3)
-5</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/number.jl#L96-L108">source</a><br><h3 id="Base.sqrt">
<code>Base.sqrt</code><span class="docstring-category">Function</span>
</h3>
<pre>sqrt(x)</pre>
<p>Return <span>$\sqrt{x}$</span>. Throws <a href="../base/#Core.DomainError"><code>DomainError</code></a> for negative <a href="../numbers/#Core.Real"><code>Real</code></a> arguments. Use complex negative arguments instead. The prefix operator <code>√</code> is equivalent to <code>sqrt</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L428-L433">source</a><br><h3 id="Base.isqrt">
<code>Base.isqrt</code><span class="docstring-category">Function</span>
</h3>
<pre>isqrt(n::Integer)</pre>
<p>Integer square root: the largest integer <code>m</code> such that <code>m*m &lt;= n</code>.</p>
<pre>julia&gt; isqrt(5)
2</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/intfuncs.jl#L745-L754">source</a><br><h3 id="Base.Math.cbrt">
<code>Base.Math.cbrt</code><span class="docstring-category">Function</span>
</h3>
<pre>cbrt(x::Real)</pre>
<p>Return the cube root of <code>x</code>, i.e. <span>$x^{1/3}$</span>. Negative values are accepted (returning the negative real root when <span>$x &lt; 0$</span>).</p>
<p>The prefix operator <code>∛</code> is equivalent to <code>cbrt</code>.</p>
<pre>julia&gt; cbrt(big(27))
3.000000000000000000000000000000000000000000000000000000000000000000000000000000</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L247-L259">source</a><br><h3 id="Base.real-Tuple{Complex}">
<code>Base.real</code><span class="docstring-category">Method</span>
</h3>
<pre>real(z)</pre>
<p>Return the real part of the complex number <code>z</code>.</p>
<pre>julia&gt; real(1 + 3im)
1</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/complex.jl#L44-L53">source</a><br><h3 id="Base.imag">
<code>Base.imag</code><span class="docstring-category">Function</span>
</h3>
<pre>imag(z)</pre>
<p>Return the imaginary part of the complex number <code>z</code>.</p>
<pre>julia&gt; imag(1 + 3im)
3</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/complex.jl#L56-L65">source</a><br><h3 id="Base.reim">
<code>Base.reim</code><span class="docstring-category">Function</span>
</h3>
<pre>reim(z)</pre>
<p>Return both the real and imaginary parts of the complex number <code>z</code>.</p>
<pre>julia&gt; reim(1 + 3im)
(1, 3)</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/complex.jl#L70-L79">source</a><br><h3 id="Base.conj">
<code>Base.conj</code><span class="docstring-category">Function</span>
</h3>
<pre>conj(z)</pre>
<p>Compute the complex conjugate of a complex number <code>z</code>.</p>
<pre>julia&gt; conj(1 + 3im)
1 - 3im</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/complex.jl#L204-L213">source</a><br><pre>conj(v::RowVector)</pre>
<p>Returns a <a href="../linalg/#Base.LinAlg.ConjArray"><code>ConjArray</code></a> lazy view of the input, where each element is conjugated.</p>
<p><strong>Example</strong></p>
<pre>julia&gt; v = [1+im, 1-im].'
1×2 RowVector{Complex{Int64},Array{Complex{Int64},1}}:
 1+1im  1-1im

julia&gt; conj(v)
1×2 RowVector{Complex{Int64},ConjArray{Complex{Int64},1,Array{Complex{Int64},1}}}:
 1-1im  1+1im</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/linalg/rowvector.jl#L88-L104">source</a><br><h3 id="Base.angle">
<code>Base.angle</code><span class="docstring-category">Function</span>
</h3>
<pre>angle(z)</pre>
<p>Compute the phase angle in radians of a complex number <code>z</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/complex.jl#L444-L448">source</a><br><h3 id="Base.cis">
<code>Base.cis</code><span class="docstring-category">Function</span>
</h3>
<pre>cis(z)</pre>
<p>Return <span>$\exp(iz)$</span>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/complex.jl#L434-L438">source</a><br><h3 id="Base.binomial">
<code>Base.binomial</code><span class="docstring-category">Function</span>
</h3>
<pre>binomial(n, k)</pre>
<p>Number of ways to choose <code>k</code> out of <code>n</code> items.</p>
<p><strong>Example</strong></p>
<pre>julia&gt; binomial(5, 3)
10

julia&gt; factorial(5) ÷ (factorial(5-3) * factorial(3))
10</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/intfuncs.jl#L776-L789">source</a><br><h3 id="Base.factorial">
<code>Base.factorial</code><span class="docstring-category">Function</span>
</h3>
<pre>factorial(n)</pre>
<p>Factorial of <code>n</code>. If <code>n</code> is an <a href="../numbers/#Core.Integer"><code>Integer</code></a>, the factorial is computed as an integer (promoted to at least 64 bits). Note that this may overflow if <code>n</code> is not small, but you can use <code>factorial(big(n))</code> to compute the result exactly in arbitrary precision. If <code>n</code> is not an <code>Integer</code>, <code>factorial(n)</code> is equivalent to <a href="#Base.Math.gamma"><code>gamma(n+1)</code></a>.</p>
<pre>julia&gt; factorial(6)
720

julia&gt; factorial(21)
ERROR: OverflowError()
[...]

julia&gt; factorial(21.0)
5.109094217170944e19

julia&gt; factorial(big(21))
51090942171709440000</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/number.jl#L216-L238">source</a><br><h3 id="Base.gcd">
<code>Base.gcd</code><span class="docstring-category">Function</span>
</h3>
<pre>gcd(x,y)</pre>
<p>Greatest common (positive) divisor (or zero if <code>x</code> and <code>y</code> are both zero).</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; gcd(6,9)
3

julia&gt; gcd(6,-9)
3</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/intfuncs.jl#L5-L18">source</a><br><h3 id="Base.lcm">
<code>Base.lcm</code><span class="docstring-category">Function</span>
</h3>
<pre>lcm(x,y)</pre>
<p>Least common (non-negative) multiple.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; lcm(2,3)
6

julia&gt; lcm(-2,3)
6</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/intfuncs.jl#L51-L64">source</a><br><h3 id="Base.gcdx">
<code>Base.gcdx</code><span class="docstring-category">Function</span>
</h3>
<pre>gcdx(x,y)</pre>
<p>Computes the greatest common (positive) divisor of <code>x</code> and <code>y</code> and their Bézout coefficients, i.e. the integer coefficients <code>u</code> and <code>v</code> that satisfy <span>$ux+vy = d = gcd(x,y)$</span>. <span>$gcdx(x,y)$</span> returns <span>$(d,u,v)$</span>.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; gcdx(12, 42)
(6, -3, 1)

julia&gt; gcdx(240, 46)
(2, -9, 47)</pre>
<div class="admonition note">
<div class="admonition-title">Note</div>
<div class="admonition-text"><p>Bézout coefficients are <em>not</em> uniquely defined. <code>gcdx</code> returns the minimal Bézout coefficients that are computed by the extended Euclidean algorithm. (Ref: D. Knuth, TAoCP, 2/e, p. 325, Algorithm X.) For signed integers, these coefficients <code>u</code> and <code>v</code> are minimal in the sense that <span>$|u| &lt; |y/d|$</span> and <span>$|v| &lt; |x/d|$</span>. Furthermore, the signs of <code>u</code> and <code>v</code> are chosen so that <code>d</code> is positive. For unsigned integers, the coefficients <code>u</code> and <code>v</code> might be near their <code>typemax</code>, and the identity then holds only via the unsigned integers' modulo arithmetic.</p></div>
</div>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/intfuncs.jl#L85-L111">source</a><br><h3 id="Base.ispow2">
<code>Base.ispow2</code><span class="docstring-category">Function</span>
</h3>
<pre>ispow2(n::Integer) -&gt; Bool</pre>
<p>Test whether <code>n</code> is a power of two.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; ispow2(4)
true

julia&gt; ispow2(5)
false</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/intfuncs.jl#L311-L324">source</a><br><h3 id="Base.nextpow2">
<code>Base.nextpow2</code><span class="docstring-category">Function</span>
</h3>
<pre>nextpow2(n::Integer)</pre>
<p>The smallest power of two not less than <code>n</code>. Returns 0 for <code>n==0</code>, and returns <code>-nextpow2(-n)</code> for negative arguments.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; nextpow2(16)
16

julia&gt; nextpow2(17)
32</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/intfuncs.jl#L275-L289">source</a><br><h3 id="Base.prevpow2">
<code>Base.prevpow2</code><span class="docstring-category">Function</span>
</h3>
<pre>prevpow2(n::Integer)</pre>
<p>The largest power of two not greater than <code>n</code>. Returns 0 for <code>n==0</code>, and returns <code>-prevpow2(-n)</code> for negative arguments.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; prevpow2(5)
4

julia&gt; prevpow2(0)
0</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/intfuncs.jl#L293-L307">source</a><br><h3 id="Base.nextpow">
<code>Base.nextpow</code><span class="docstring-category">Function</span>
</h3>
<pre>nextpow(a, x)</pre>
<p>The smallest <code>a^n</code> not less than <code>x</code>, where <code>n</code> is a non-negative integer. <code>a</code> must be greater than 1, and <code>x</code> must be greater than 0.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; nextpow(2, 7)
8

julia&gt; nextpow(2, 9)
16

julia&gt; nextpow(5, 20)
25

julia&gt; nextpow(4, 16)
16</pre>
<p>See also <a href="#Base.prevpow"><code>prevpow</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/intfuncs.jl#L327-L349">source</a><br><h3 id="Base.prevpow">
<code>Base.prevpow</code><span class="docstring-category">Function</span>
</h3>
<pre>prevpow(a, x)</pre>
<p>The largest <code>a^n</code> not greater than <code>x</code>, where <code>n</code> is a non-negative integer. <code>a</code> must be greater than 1, and <code>x</code> must not be less than 1.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; prevpow(2, 7)
4

julia&gt; prevpow(2, 9)
8

julia&gt; prevpow(5, 20)
5

julia&gt; prevpow(4, 16)
16</pre>
<p>See also <a href="#Base.nextpow"><code>nextpow</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/intfuncs.jl#L359-L380">source</a><br><h3 id="Base.nextprod">
<code>Base.nextprod</code><span class="docstring-category">Function</span>
</h3>
<pre>nextprod([k_1, k_2,...], n)</pre>
<p>Next integer greater than or equal to <code>n</code> that can be written as <span>$\prod k_i^{p_i}$</span> for integers <span>$p_1$</span>, <span>$p_2$</span>, etc.</p>
<p><strong>Example</strong></p>
<pre>julia&gt; nextprod([2, 3], 105)
108

julia&gt; 2^2 * 3^3
108</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/combinatorics.jl#L234-L248">source</a><br><h3 id="Base.invmod">
<code>Base.invmod</code><span class="docstring-category">Function</span>
</h3>
<pre>invmod(x,m)</pre>
<p>Take the inverse of <code>x</code> modulo <code>m</code>: <code>y</code> such that <span>$x y = 1 \pmod m$</span>, with <span>$div(x,y) = 0$</span>. This is undefined for <span>$m = 0$</span>, or if <span>$gcd(x,m) \neq 1$</span>.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; invmod(2,5)
3

julia&gt; invmod(2,3)
2

julia&gt; invmod(5,6)
5</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/intfuncs.jl#L129-L147">source</a><br><h3 id="Base.powermod">
<code>Base.powermod</code><span class="docstring-category">Function</span>
</h3>
<pre>powermod(x::Integer, p::Integer, m)</pre>
<p>Compute <span>$x^p \pmod m$</span>.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; powermod(2, 6, 5)
4

julia&gt; mod(2^6, 5)
4

julia&gt; powermod(5, 2, 20)
5

julia&gt; powermod(5, 2, 19)
6

julia&gt; powermod(5, 3, 19)
11</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/intfuncs.jl#L226-L248">source</a><br><h3 id="Base.Math.gamma">
<code>Base.Math.gamma</code><span class="docstring-category">Function</span>
</h3>
<pre>gamma(x)</pre>
<p>Compute the gamma function of <code>x</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/gamma.jl#L6-L10">source</a><br><h3 id="Base.Math.lgamma">
<code>Base.Math.lgamma</code><span class="docstring-category">Function</span>
</h3>
<pre>lgamma(x)</pre>
<p>Compute the logarithm of the absolute value of <a href="#Base.Math.gamma"><code>gamma</code></a> for <a href="../numbers/#Core.Real"><code>Real</code></a> <code>x</code>, while for <a href="../numbers/#Base.Complex"><code>Complex</code></a> <code>x</code> compute the principal branch cut of the logarithm of <code>gamma(x)</code> (defined for negative <code>real(x)</code> by analytic continuation from positive <code>real(x)</code>).</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/gamma.jl#L36-L43">source</a><br><h3 id="Base.Math.lfact">
<code>Base.Math.lfact</code><span class="docstring-category">Function</span>
</h3>
<pre>lfact(x)</pre>
<p>Compute the logarithmic factorial of a nonnegative integer <code>x</code>. Equivalent to <a href="#Base.Math.lgamma"><code>lgamma</code></a> of <code>x + 1</code>, but <code>lgamma</code> extends this function to non-integer <code>x</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/gamma.jl#L27-L33">source</a><br><h3 id="Base.Math.beta">
<code>Base.Math.beta</code><span class="docstring-category">Function</span>
</h3>
<pre>beta(x, y)</pre>
<p>Euler integral of the first kind <span>$\operatorname{B}(x,y) = \Gamma(x)\Gamma(y)/\Gamma(x+y)$</span>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/gamma.jl#L139-L143">source</a><br><h3 id="Base.Math.lbeta">
<code>Base.Math.lbeta</code><span class="docstring-category">Function</span>
</h3>
<pre>lbeta(x, y)</pre>
<p>Natural logarithm of the absolute value of the <a href="#Base.Math.beta"><code>beta</code></a> function <span>$\log(|\operatorname{B}(x,y)|)$</span>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/special/gamma.jl#L151-L156">source</a><br><h3 id="Base.ndigits">
<code>Base.ndigits</code><span class="docstring-category">Function</span>
</h3>
<pre>ndigits(n::Integer, b::Integer=10)</pre>
<p>Compute the number of digits in integer <code>n</code> written in base <code>b</code>. The base <code>b</code> must not be in <code>[-1, 0, 1]</code>.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; ndigits(12345)
5

julia&gt; ndigits(1022, 16)
3

julia&gt; base(16, 1022)
"3fe"</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/intfuncs.jl#L481-L498">source</a><br><h3 id="Base.widemul">
<code>Base.widemul</code><span class="docstring-category">Function</span>
</h3>
<pre>widemul(x, y)</pre>
<p>Multiply <code>x</code> and <code>y</code>, giving the result as a larger type.</p>
<pre>julia&gt; widemul(Float32(3.), 4.)
1.200000000000000000000000000000000000000000000000000000000000000000000000000000e+01</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/number.jl#L118-L127">source</a><br><h3 id="Base.Math.@evalpoly">
<code>Base.Math.@evalpoly</code><span class="docstring-category">Macro</span>
</h3>
<pre>@evalpoly(z, c...)</pre>
<p>Evaluate the polynomial <span>$\sum_k c[k] z^{k-1}$</span> for the coefficients <code>c[1]</code>, <code>c[2]</code>, ...; that is, the coefficients are given in ascending order by power of <code>z</code>. This macro expands to efficient inline code that uses either Horner's method or, for complex <code>z</code>, a more efficient Goertzel-like algorithm.</p>
<pre>julia&gt; @evalpoly(3, 1, 0, 1)
10

julia&gt; @evalpoly(2, 1, 0, 1)
5

julia&gt; @evalpoly(2, 1, 1, 1)
7</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L89-L107">source</a><br><h2 id="Statistics-1">Statistics</h2>
<h3 id="Base.mean">
<code>Base.mean</code><span class="docstring-category">Function</span>
</h3>
<pre>mean(f::Function, v)</pre>
<p>Apply the function <code>f</code> to each element of <code>v</code> and take the mean.</p>
<pre>julia&gt; mean(√, [1, 2, 3])
1.3820881233139908

julia&gt; mean([√1, √2, √3])
1.3820881233139908</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/statistics.jl#L5-L17">source</a><br><pre>mean(v[, region])</pre>
<p>Compute the mean of whole array <code>v</code>, or optionally along the dimensions in <code>region</code>.</p>
<div class="admonition note">
<div class="admonition-title">Note</div>
<div class="admonition-text"><p>Julia does not ignore <code>NaN</code> values in the computation. For applications requiring the handling of missing data, the <code>DataArrays.jl</code> package is recommended.</p></div>
</div>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/statistics.jl#L48-L56">source</a><br><h3 id="Base.mean!">
<code>Base.mean!</code><span class="docstring-category">Function</span>
</h3>
<pre>mean!(r, v)</pre>
<p>Compute the mean of <code>v</code> over the singleton dimensions of <code>r</code>, and write results to <code>r</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1736-L1740">source</a><br><h3 id="Base.std">
<code>Base.std</code><span class="docstring-category">Function</span>
</h3>
<pre>std(v[, region]; corrected::Bool=true, mean=nothing)</pre>
<p>Compute the sample standard deviation of a vector or array <code>v</code>, optionally along dimensions in <code>region</code>. The algorithm returns an estimator of the generative distribution's standard deviation under the assumption that each entry of <code>v</code> is an IID drawn from that generative distribution. This computation is equivalent to calculating <code>sqrt(sum((v - mean(v)).^2) / (length(v) - 1))</code>. A pre-computed <code>mean</code> may be provided. If <code>corrected</code> is <code>true</code>, then the sum is scaled with <code>n-1</code>, whereas the sum is scaled with <code>n</code> if <code>corrected</code> is <code>false</code> where <code>n = length(x)</code>.</p>
<div class="admonition note">
<div class="admonition-title">Note</div>
<div class="admonition-text"><p>Julia does not ignore <code>NaN</code> values in the computation. For applications requiring the handling of missing data, the <code>DataArrays.jl</code> package is recommended.</p></div>
</div>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/statistics.jl#L249-L264">source</a><br><h3 id="Base.stdm">
<code>Base.stdm</code><span class="docstring-category">Function</span>
</h3>
<pre>stdm(v, m::Number; corrected::Bool=true)</pre>
<p>Compute the sample standard deviation of a vector <code>v</code> with known mean <code>m</code>. If <code>corrected</code> is <code>true</code>, then the sum is scaled with <code>n-1</code>, whereas the sum is scaled with <code>n</code> if <code>corrected</code> is <code>false</code> where <code>n = length(x)</code>.</p>
<div class="admonition note">
<div class="admonition-title">Note</div>
<div class="admonition-text"><p>Julia does not ignore <code>NaN</code> values in the computation. For applications requiring the handling of missing data, the <code>DataArrays.jl</code> package is recommended.</p></div>
</div>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/statistics.jl#L271-L283">source</a><br><h3 id="Base.var">
<code>Base.var</code><span class="docstring-category">Function</span>
</h3>
<pre>var(v[, region]; corrected::Bool=true, mean=nothing)</pre>
<p>Compute the sample variance of a vector or array <code>v</code>, optionally along dimensions in <code>region</code>. The algorithm will return an estimator of the generative distribution's variance under the assumption that each entry of <code>v</code> is an IID drawn from that generative distribution. This computation is equivalent to calculating <code>sum(abs2, v - mean(v)) / (length(v) - 1)</code>. If <code>corrected</code> is <code>true</code>, then the sum is scaled with <code>n-1</code>, whereas the sum is scaled with <code>n</code> if <code>corrected</code> is <code>false</code> where <code>n = length(x)</code>. The mean <code>mean</code> over the region may be provided.</p>
<div class="admonition note">
<div class="admonition-title">Note</div>
<div class="admonition-text"><p>Julia does not ignore <code>NaN</code> values in the computation. For applications requiring the handling of missing data, the <code>DataArrays.jl</code> package is recommended.</p></div>
</div>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/statistics.jl#L188-L203">source</a><br><h3 id="Base.varm">
<code>Base.varm</code><span class="docstring-category">Function</span>
</h3>
<pre>varm(v, m[, region]; corrected::Bool=true)</pre>
<p>Compute the sample variance of a collection <code>v</code> with known mean(s) <code>m</code>, optionally over <code>region</code>. <code>m</code> may contain means for each dimension of <code>v</code>. If <code>corrected</code> is <code>true</code>, then the sum is scaled with <code>n-1</code>, whereas the sum is scaled with <code>n</code> if <code>corrected</code> is <code>false</code> where <code>n = length(x)</code>.</p>
<div class="admonition note">
<div class="admonition-title">Note</div>
<div class="admonition-text"><p>Julia does not ignore <code>NaN</code> values in the computation. For applications requiring the handling of missing data, the <code>DataArrays.jl</code> package is recommended.</p></div>
</div>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/statistics.jl#L167-L179">source</a><br><h3 id="Base.middle">
<code>Base.middle</code><span class="docstring-category">Function</span>
</h3>
<pre>middle(x)</pre>
<p>Compute the middle of a scalar value, which is equivalent to <code>x</code> itself, but of the type of <code>middle(x, x)</code> for consistency.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/statistics.jl#L533-L537">source</a><br><pre>middle(x, y)</pre>
<p>Compute the middle of two reals <code>x</code> and <code>y</code>, which is equivalent in both value and type to computing their mean (<code>(x + y) / 2</code>).</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/statistics.jl#L543-L548">source</a><br><pre>middle(range)</pre>
<p>Compute the middle of a range, which consists of computing the mean of its extrema. Since a range is sorted, the mean is performed with the first and last element.</p>
<pre>julia&gt; middle(1:10)
5.5</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/statistics.jl#L551-L561">source</a><br><pre>middle(a)</pre>
<p>Compute the middle of an array <code>a</code>, which consists of finding its extrema and then computing their mean.</p>
<pre>julia&gt; a = [1,2,3.6,10.9]
4-element Array{Float64,1}:
  1.0
  2.0
  3.6
 10.9

julia&gt; middle(a)
5.95</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/statistics.jl#L564-L581">source</a><br><h3 id="Base.median">
<code>Base.median</code><span class="docstring-category">Function</span>
</h3>
<pre>median(v[, region])</pre>
<p>Compute the median of an entire array <code>v</code>, or, optionally, along the dimensions in <code>region</code>. For an even number of elements no exact median element exists, so the result is equivalent to calculating mean of two median elements.</p>
<div class="admonition note">
<div class="admonition-title">Note</div>
<div class="admonition-text"><p>Julia does not ignore <code>NaN</code> values in the computation. For applications requiring the handling of missing data, the <code>DataArrays.jl</code> package is recommended.</p></div>
</div>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/statistics.jl#L609-L620">source</a><br><h3 id="Base.median!">
<code>Base.median!</code><span class="docstring-category">Function</span>
</h3>
<pre>median!(v)</pre>
<p>Like <a href="#Base.median"><code>median</code></a>, but may overwrite the input vector.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/statistics.jl#L584-L588">source</a><br><h3 id="Base.quantile">
<code>Base.quantile</code><span class="docstring-category">Function</span>
</h3>
<pre>quantile(v, p; sorted=false)</pre>
<p>Compute the quantile(s) of a vector <code>v</code> at a specified probability or vector <code>p</code>. The keyword argument <code>sorted</code> indicates whether <code>v</code> can be assumed to be sorted.</p>
<p>The <code>p</code> should be on the interval [0,1], and <code>v</code> should not have any <code>NaN</code> values.</p>
<p>Quantiles are computed via linear interpolation between the points <code>((k-1)/(n-1), v[k])</code>, for <code>k = 1:n</code> where <code>n = length(v)</code>. This corresponds to Definition 7 of Hyndman and Fan (1996), and is the same as the R default.</p>
<div class="admonition note">
<div class="admonition-title">Note</div>
<div class="admonition-text"><p>Julia does not ignore <code>NaN</code> values in the computation. For applications requiring the handling of missing data, the <code>DataArrays.jl</code> package is recommended. <code>quantile</code> will throw an <code>ArgumentError</code> in the presence of <code>NaN</code> values in the data array.</p></div>
</div>
<ul><li><p>Hyndman, R.J and Fan, Y. (1996) "Sample Quantiles in Statistical Packages", <em>The American Statistician</em>, Vol. 50, No. 4, pp. 361-365</p></li></ul>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/statistics.jl#L719-L738">source</a><br><h3 id="Base.quantile!">
<code>Base.quantile!</code><span class="docstring-category">Function</span>
</h3>
<pre>quantile!([q, ] v, p; sorted=false)</pre>
<p>Compute the quantile(s) of a vector <code>v</code> at the probabilities <code>p</code>, with optional output into array <code>q</code> (if not provided, a new output array is created). The keyword argument <code>sorted</code> indicates whether <code>v</code> can be assumed to be sorted; if <code>false</code> (the default), then the elements of <code>v</code> may be partially sorted.</p>
<p>The elements of <code>p</code> should be on the interval [0,1], and <code>v</code> should not have any <code>NaN</code> values.</p>
<p>Quantiles are computed via linear interpolation between the points <code>((k-1)/(n-1), v[k])</code>, for <code>k = 1:n</code> where <code>n = length(v)</code>. This corresponds to Definition 7 of Hyndman and Fan (1996), and is the same as the R default.</p>
<div class="admonition note">
<div class="admonition-title">Note</div>
<div class="admonition-text"><p>Julia does not ignore <code>NaN</code> values in the computation. For applications requiring the handling of missing data, the <code>DataArrays.jl</code> package is recommended. <code>quantile!</code> will throw an <code>ArgumentError</code> in the presence of <code>NaN</code> values in the data array.</p></div>
</div>
<ul><li><p>Hyndman, R.J and Fan, Y. (1996) "Sample Quantiles in Statistical Packages", <em>The American Statistician</em>, Vol. 50, No. 4, pp. 361-365</p></li></ul>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/statistics.jl#L625-L647">source</a><br><h3 id="Base.cov">
<code>Base.cov</code><span class="docstring-category">Function</span>
</h3>
<pre>cov(x[, corrected=true])</pre>
<p>Compute the variance of the vector <code>x</code>. If <code>corrected</code> is <code>true</code> (the default) then the sum is scaled with <code>n-1</code>, whereas the sum is scaled with <code>n</code> if <code>corrected</code> is <code>false</code> where <code>n = length(x)</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/statistics.jl#L342-L347">source</a><br><pre>cov(X[, vardim=1, corrected=true])</pre>
<p>Compute the covariance matrix of the matrix <code>X</code> along the dimension <code>vardim</code>. If <code>corrected</code> is <code>true</code> (the default) then the sum is scaled with <code>n-1</code>, whereas the sum is scaled with <code>n</code> if <code>corrected</code> is <code>false</code> where <code>n = size(X, vardim)</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/statistics.jl#L352-L358">source</a><br><pre>cov(x, y[, corrected=true])</pre>
<p>Compute the covariance between the vectors <code>x</code> and <code>y</code>. If <code>corrected</code> is <code>true</code> (the default), computes <span>$\frac{1}{n-1}\sum_{i=1}^n (x_i-\bar x) (y_i-\bar y)^*$</span> where <span>$*$</span> denotes the complex conjugate and <code>n = length(x) = length(y)</code>. If <code>corrected</code> is <code>false</code>, computes <span>$rac{1}{n}sum_{i=1}^n (x_i-\bar x) (y_i-\bar y)^*$</span>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/statistics.jl#L364-L371">source</a><br><pre>cov(X, Y[, vardim=1, corrected=true])</pre>
<p>Compute the covariance between the vectors or matrices <code>X</code> and <code>Y</code> along the dimension <code>vardim</code>. If <code>corrected</code> is <code>true</code> (the default) then the sum is scaled with <code>n-1</code>, whereas the sum is scaled with <code>n</code> if <code>corrected</code> is <code>false</code> where <code>n = size(X, vardim) = size(Y, vardim)</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/statistics.jl#L378-L384">source</a><br><h3 id="Base.cor">
<code>Base.cor</code><span class="docstring-category">Function</span>
</h3>
<pre>cor(x)</pre>
<p>Return the number one.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/statistics.jl#L494-L498">source</a><br><pre>cor(X[, vardim=1])</pre>
<p>Compute the Pearson correlation matrix of the matrix <code>X</code> along the dimension <code>vardim</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/statistics.jl#L502-L506">source</a><br><pre>cor(x, y)</pre>
<p>Compute the Pearson correlation between the vectors <code>x</code> and <code>y</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/statistics.jl#L511-L515">source</a><br><pre>cor(X, Y[, vardim=1])</pre>
<p>Compute the Pearson correlation between the vectors or matrices <code>X</code> and <code>Y</code> along the dimension <code>vardim</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/statistics.jl#L519-L523">source</a><br><h2 id="Signal-Processing-1">Signal Processing</h2>
<p>Fast Fourier transform (FFT) functions in Julia are implemented by calling functions from <a href="http://www.fftw.org" target="_blank">FFTW</a>.</p>
<h3 id="Base.DFT.fft">
<code>Base.DFT.fft</code><span class="docstring-category">Function</span>
</h3>
<pre>fft(A [, dims])</pre>
<p>Performs a multidimensional FFT of the array <code>A</code>. The optional <code>dims</code> argument specifies an iterable subset of dimensions (e.g. an integer, range, tuple, or array) to transform along. Most efficient if the size of <code>A</code> along the transformed dimensions is a product of small primes; see <code>nextprod()</code>. See also <code>plan_fft()</code> for even greater efficiency.</p>
<p>A one-dimensional FFT computes the one-dimensional discrete Fourier transform (DFT) as defined by</p>\[\operatorname{DFT}(A)[k] = \sum_{n=1}^{\operatorname{length}(A)} \exp\left(-i\frac{2\pi (n-1)(k-1)}{\operatorname{length}(A)} \right) A[n].\]<p>A multidimensional FFT simply performs this operation along each transformed dimension of <code>A</code>.</p>
<div class="admonition note">
<div class="admonition-title">Note</div>
<div class="admonition-text"><ul>
<li><p>Julia starts FFTW up with 1 thread by default. Higher performance is usually possible by increasing number of threads. Use <code>FFTW.set_num_threads(Sys.CPU_CORES)</code> to use as many threads as cores on your system.</p></li>
<li><p>This performs a multidimensional FFT by default. FFT libraries in other languages such as Python and Octave perform a one-dimensional FFT along the first non-singleton dimension of the array. This is worth noting while performing comparisons. For more details, refer to the <a href="../../manual/noteworthy-differences/#Noteworthy-Differences-from-other-Languages-1">Noteworthy Differences from other Languages</a> section of the manual.</p></li>
</ul></div>
</div>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L401-L431">source</a><br><h3 id="Base.DFT.fft!">
<code>Base.DFT.fft!</code><span class="docstring-category">Function</span>
</h3>
<pre>fft!(A [, dims])</pre>
<p>Same as <a href="#Base.DFT.fft"><code>fft</code></a>, but operates in-place on <code>A</code>, which must be an array of complex floating-point numbers.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L169-L174">source</a><br><h3 id="Base.DFT.ifft">
<code>Base.DFT.ifft</code><span class="docstring-category">Function</span>
</h3>
<pre>ifft(A [, dims])</pre>
<p>Multidimensional inverse FFT.</p>
<p>A one-dimensional inverse FFT computes</p>\[\operatorname{IDFT}(A)[k] = \frac{1}{\operatorname{length}(A)} \sum_{n=1}^{\operatorname{length}(A)} \exp\left(+i\frac{2\pi (n-1)(k-1)} {\operatorname{length}(A)} \right) A[n].\]<p>A multidimensional inverse FFT simply performs this operation along each transformed dimension of <code>A</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L152-L166">source</a><br><h3 id="Base.DFT.ifft!">
<code>Base.DFT.ifft!</code><span class="docstring-category">Function</span>
</h3>
<pre>ifft!(A [, dims])</pre>
<p>Same as <a href="#Base.DFT.ifft"><code>ifft</code></a>, but operates in-place on <code>A</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L145-L149">source</a><br><h3 id="Base.DFT.bfft">
<code>Base.DFT.bfft</code><span class="docstring-category">Function</span>
</h3>
<pre>bfft(A [, dims])</pre>
<p>Similar to <a href="#Base.DFT.ifft"><code>ifft</code></a>, but computes an unnormalized inverse (backward) transform, which must be divided by the product of the sizes of the transformed dimensions in order to obtain the inverse. (This is slightly more efficient than <a href="#Base.DFT.ifft"><code>ifft</code></a> because it omits a scaling step, which in some applications can be combined with other computational steps elsewhere.)</p>\[\operatorname{BDFT}(A)[k] = \operatorname{length}(A) \operatorname{IDFT}(A)[k]\]<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L177-L189">source</a><br><h3 id="Base.DFT.bfft!">
<code>Base.DFT.bfft!</code><span class="docstring-category">Function</span>
</h3>
<pre>bfft!(A [, dims])</pre>
<p>Same as <a href="#Base.DFT.bfft"><code>bfft</code></a>, but operates in-place on <code>A</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L192-L196">source</a><br><h3 id="Base.DFT.plan_fft">
<code>Base.DFT.plan_fft</code><span class="docstring-category">Function</span>
</h3>
<pre>plan_fft(A [, dims]; flags=FFTW.ESTIMATE;  timelimit=Inf)</pre>
<p>Pre-plan an optimized FFT along given dimensions (<code>dims</code>) of arrays matching the shape and type of <code>A</code>. (The first two arguments have the same meaning as for <a href="#Base.DFT.fft"><code>fft</code></a>.) Returns an object <code>P</code> which represents the linear operator computed by the FFT, and which contains all of the information needed to compute <code>fft(A, dims)</code> quickly.</p>
<p>To apply <code>P</code> to an array <code>A</code>, use <code>P * A</code>; in general, the syntax for applying plans is much like that of matrices. (A plan can only be applied to arrays of the same size as the <code>A</code> for which the plan was created.) You can also apply a plan with a preallocated output array <code>Â</code> by calling <code>A_mul_B!(Â, plan, A)</code>. (For <code>A_mul_B!</code>, however, the input array <code>A</code> must be a complex floating-point array like the output <code>Â</code>.) You can compute the inverse-transform plan by <code>inv(P)</code> and apply the inverse plan with <code>P \ Â</code> (the inverse plan is cached and reused for subsequent calls to <code>inv</code> or <code>\</code>), and apply the inverse plan to a pre-allocated output array <code>A</code> with <code>A_ldiv_B!(A, P, Â)</code>.</p>
<p>The <code>flags</code> argument is a bitwise-or of FFTW planner flags, defaulting to <code>FFTW.ESTIMATE</code>. e.g. passing <code>FFTW.MEASURE</code> or <code>FFTW.PATIENT</code> will instead spend several seconds (or more) benchmarking different possible FFT algorithms and picking the fastest one; see the FFTW manual for more information on planner flags. The optional <code>timelimit</code> argument specifies a rough upper bound on the allowed planning time, in seconds. Passing <code>FFTW.MEASURE</code> or <code>FFTW.PATIENT</code> may cause the input array <code>A</code> to be overwritten with zeros during plan creation.</p>
<p><a href="#Base.DFT.plan_fft!"><code>plan_fft!</code></a> is the same as <a href="#Base.DFT.plan_fft"><code>plan_fft</code></a> but creates a plan that operates in-place on its argument (which must be an array of complex floating-point numbers). <a href="#Base.DFT.plan_ifft"><code>plan_ifft</code></a> and so on are similar but produce plans that perform the equivalent of the inverse transforms <a href="#Base.DFT.ifft"><code>ifft</code></a> and so on.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L92-L121">source</a><br><h3 id="Base.DFT.plan_ifft">
<code>Base.DFT.plan_ifft</code><span class="docstring-category">Function</span>
</h3>
<pre>plan_ifft(A [, dims]; flags=FFTW.ESTIMATE;  timelimit=Inf)</pre>
<p>Same as <a href="#Base.DFT.plan_fft"><code>plan_fft</code></a>, but produces a plan that performs inverse transforms <a href="#Base.DFT.ifft"><code>ifft</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L62-L67">source</a><br><h3 id="Base.DFT.plan_bfft">
<code>Base.DFT.plan_bfft</code><span class="docstring-category">Function</span>
</h3>
<pre>plan_bfft(A [, dims]; flags=FFTW.ESTIMATE;  timelimit=Inf)</pre>
<p>Same as <a href="#Base.DFT.plan_fft"><code>plan_fft</code></a>, but produces a plan that performs an unnormalized backwards transform <a href="#Base.DFT.bfft"><code>bfft</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L84-L89">source</a><br><h3 id="Base.DFT.plan_fft!">
<code>Base.DFT.plan_fft!</code><span class="docstring-category">Function</span>
</h3>
<pre>plan_fft!(A [, dims]; flags=FFTW.ESTIMATE;  timelimit=Inf)</pre>
<p>Same as <a href="#Base.DFT.plan_fft"><code>plan_fft</code></a>, but operates in-place on <code>A</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L124-L128">source</a><br><h3 id="Base.DFT.plan_ifft!">
<code>Base.DFT.plan_ifft!</code><span class="docstring-category">Function</span>
</h3>
<pre>plan_ifft!(A [, dims]; flags=FFTW.ESTIMATE;  timelimit=Inf)</pre>
<p>Same as <a href="#Base.DFT.plan_ifft"><code>plan_ifft</code></a>, but operates in-place on <code>A</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L70-L74">source</a><br><h3 id="Base.DFT.plan_bfft!">
<code>Base.DFT.plan_bfft!</code><span class="docstring-category">Function</span>
</h3>
<pre>plan_bfft!(A [, dims]; flags=FFTW.ESTIMATE;  timelimit=Inf)</pre>
<p>Same as <a href="#Base.DFT.plan_bfft"><code>plan_bfft</code></a>, but operates in-place on <code>A</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L77-L81">source</a><br><h3 id="Base.DFT.rfft">
<code>Base.DFT.rfft</code><span class="docstring-category">Function</span>
</h3>
<pre>rfft(A [, dims])</pre>
<p>Multidimensional FFT of a real array <code>A</code>, exploiting the fact that the transform has conjugate symmetry in order to save roughly half the computational time and storage costs compared with <a href="#Base.DFT.fft"><code>fft</code></a>. If <code>A</code> has size <code>(n_1, ..., n_d)</code>, the result has size <code>(div(n_1,2)+1, ..., n_d)</code>.</p>
<p>The optional <code>dims</code> argument specifies an iterable subset of one or more dimensions of <code>A</code> to transform, similar to <a href="#Base.DFT.fft"><code>fft</code></a>. Instead of (roughly) halving the first dimension of <code>A</code> in the result, the <code>dims[1]</code> dimension is (roughly) halved in the same way.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L131-L142">source</a><br><h3 id="Base.DFT.irfft">
<code>Base.DFT.irfft</code><span class="docstring-category">Function</span>
</h3>
<pre>irfft(A, d [, dims])</pre>
<p>Inverse of <a href="#Base.DFT.rfft"><code>rfft</code></a>: for a complex array <code>A</code>, gives the corresponding real array whose FFT yields <code>A</code> in the first half. As for <a href="#Base.DFT.rfft"><code>rfft</code></a>, <code>dims</code> is an optional subset of dimensions to transform, defaulting to <code>1:ndims(A)</code>.</p>
<p><code>d</code> is the length of the transformed real array along the <code>dims[1]</code> dimension, which must satisfy <code>div(d,2)+1 == size(A,dims[1])</code>. (This parameter cannot be inferred from <code>size(A)</code> since both <code>2*size(A,dims[1])-2</code> as well as <code>2*size(A,dims[1])-1</code> are valid sizes for the transformed real array.)</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L302-L313">source</a><br><h3 id="Base.DFT.brfft">
<code>Base.DFT.brfft</code><span class="docstring-category">Function</span>
</h3>
<pre>brfft(A, d [, dims])</pre>
<p>Similar to <a href="#Base.DFT.irfft"><code>irfft</code></a> but computes an unnormalized inverse transform (similar to <a href="#Base.DFT.bfft"><code>bfft</code></a>), which must be divided by the product of the sizes of the transformed dimensions (of the real output array) in order to obtain the inverse transform.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L316-L322">source</a><br><h3 id="Base.DFT.plan_rfft">
<code>Base.DFT.plan_rfft</code><span class="docstring-category">Function</span>
</h3>
<pre>plan_rfft(A [, dims]; flags=FFTW.ESTIMATE;  timelimit=Inf)</pre>
<p>Pre-plan an optimized real-input FFT, similar to <a href="#Base.DFT.plan_fft"><code>plan_fft</code></a> except for <a href="#Base.DFT.rfft"><code>rfft</code></a> instead of <a href="#Base.DFT.fft"><code>fft</code></a>. The first two arguments, and the size of the transformed result, are the same as for <a href="#Base.DFT.rfft"><code>rfft</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L434-L440">source</a><br><h3 id="Base.DFT.plan_brfft">
<code>Base.DFT.plan_brfft</code><span class="docstring-category">Function</span>
</h3>
<pre>plan_brfft(A, d [, dims]; flags=FFTW.ESTIMATE;  timelimit=Inf)</pre>
<p>Pre-plan an optimized real-input unnormalized transform, similar to <a href="#Base.DFT.plan_rfft"><code>plan_rfft</code></a> except for <a href="#Base.DFT.brfft"><code>brfft</code></a> instead of <a href="#Base.DFT.rfft"><code>rfft</code></a>. The first two arguments and the size of the transformed result, are the same as for <a href="#Base.DFT.brfft"><code>brfft</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L443-L450">source</a><br><h3 id="Base.DFT.plan_irfft">
<code>Base.DFT.plan_irfft</code><span class="docstring-category">Function</span>
</h3>
<pre>plan_irfft(A, d [, dims]; flags=FFTW.ESTIMATE;  timelimit=Inf)</pre>
<p>Pre-plan an optimized inverse real-input FFT, similar to <a href="#Base.DFT.plan_rfft"><code>plan_rfft</code></a> except for <a href="#Base.DFT.irfft"><code>irfft</code></a> and <a href="#Base.DFT.brfft"><code>brfft</code></a>, respectively. The first three arguments have the same meaning as for <a href="#Base.DFT.irfft"><code>irfft</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L344-L350">source</a><br><h3 id="Base.DFT.FFTW.dct">
<code>Base.DFT.FFTW.dct</code><span class="docstring-category">Function</span>
</h3>
<pre>dct(A [, dims])</pre>
<p>Performs a multidimensional type-II discrete cosine transform (DCT) of the array <code>A</code>, using the unitary normalization of the DCT. The optional <code>dims</code> argument specifies an iterable subset of dimensions (e.g. an integer, range, tuple, or array) to transform along. Most efficient if the size of <code>A</code> along the transformed dimensions is a product of small primes; see <a href="#Base.nextprod"><code>nextprod</code></a>. See also <a href="#Base.DFT.FFTW.plan_dct"><code>plan_dct</code></a> for even greater efficiency.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L494-L503">source</a><br><h3 id="Base.DFT.FFTW.dct!">
<code>Base.DFT.FFTW.dct!</code><span class="docstring-category">Function</span>
</h3>
<pre>dct!(A [, dims])</pre>
<p>Same as <a href="#Base.DFT.FFTW.dct!"><code>dct!</code></a>, except that it operates in-place on <code>A</code>, which must be an array of real or complex floating-point values.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L518-L523">source</a><br><h3 id="Base.DFT.FFTW.idct">
<code>Base.DFT.FFTW.idct</code><span class="docstring-category">Function</span>
</h3>
<pre>idct(A [, dims])</pre>
<p>Computes the multidimensional inverse discrete cosine transform (DCT) of the array <code>A</code> (technically, a type-III DCT with the unitary normalization). The optional <code>dims</code> argument specifies an iterable subset of dimensions (e.g. an integer, range, tuple, or array) to transform along. Most efficient if the size of <code>A</code> along the transformed dimensions is a product of small primes; see <a href="#Base.nextprod"><code>nextprod</code></a>. See also <a href="#Base.DFT.FFTW.plan_idct"><code>plan_idct</code></a> for even greater efficiency.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L506-L515">source</a><br><h3 id="Base.DFT.FFTW.idct!">
<code>Base.DFT.FFTW.idct!</code><span class="docstring-category">Function</span>
</h3>
<pre>idct!(A [, dims])</pre>
<p>Same as <a href="#Base.DFT.FFTW.idct!"><code>idct!</code></a>, but operates in-place on <code>A</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L526-L530">source</a><br><h3 id="Base.DFT.FFTW.plan_dct">
<code>Base.DFT.FFTW.plan_dct</code><span class="docstring-category">Function</span>
</h3>
<pre>plan_dct(A [, dims [, flags [, timelimit]]])</pre>
<p>Pre-plan an optimized discrete cosine transform (DCT), similar to <a href="#Base.DFT.plan_fft"><code>plan_fft</code></a> except producing a function that computes <a href="#Base.DFT.FFTW.dct"><code>dct</code></a>. The first two arguments have the same meaning as for <a href="#Base.DFT.FFTW.dct"><code>dct</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L477-L484">source</a><br><h3 id="Base.DFT.FFTW.plan_dct!">
<code>Base.DFT.FFTW.plan_dct!</code><span class="docstring-category">Function</span>
</h3>
<pre>plan_dct!(A [, dims [, flags [, timelimit]]])</pre>
<p>Same as <a href="#Base.DFT.FFTW.plan_dct"><code>plan_dct</code></a>, but operates in-place on <code>A</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L460-L464">source</a><br><h3 id="Base.DFT.FFTW.plan_idct">
<code>Base.DFT.FFTW.plan_idct</code><span class="docstring-category">Function</span>
</h3>
<pre>plan_idct(A [, dims [, flags [, timelimit]]])</pre>
<p>Pre-plan an optimized inverse discrete cosine transform (DCT), similar to <a href="#Base.DFT.plan_fft"><code>plan_fft</code></a> except producing a function that computes <a href="#Base.DFT.FFTW.idct"><code>idct</code></a>. The first two arguments have the same meaning as for <a href="#Base.DFT.FFTW.idct"><code>idct</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L467-L474">source</a><br><h3 id="Base.DFT.FFTW.plan_idct!">
<code>Base.DFT.FFTW.plan_idct!</code><span class="docstring-category">Function</span>
</h3>
<pre>plan_idct!(A [, dims [, flags [, timelimit]]])</pre>
<p>Same as <a href="#Base.DFT.FFTW.plan_idct"><code>plan_idct</code></a>, but operates in-place on <code>A</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L487-L491">source</a><br><h3 id="Base.DFT.fftshift-Tuple{Any}">
<code>Base.DFT.fftshift</code><span class="docstring-category">Method</span>
</h3>
<pre>fftshift(x)</pre>
<p>Swap the first and second halves of each dimension of <code>x</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L359-L363">source</a><br><h3 id="Base.DFT.fftshift-Tuple{Any,Any}">
<code>Base.DFT.fftshift</code><span class="docstring-category">Method</span>
</h3>
<pre>fftshift(x,dim)</pre>
<p>Swap the first and second halves of the given dimension or iterable of dimensions of array <code>x</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L374-L378">source</a><br><h3 id="Base.DFT.ifftshift">
<code>Base.DFT.ifftshift</code><span class="docstring-category">Function</span>
</h3>
<pre>ifftshift(x, [dim])</pre>
<p>Undoes the effect of <code>fftshift</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L383-L387">source</a><br><h3 id="Base.DSP.filt">
<code>Base.DSP.filt</code><span class="docstring-category">Function</span>
</h3>
<pre>filt(b, a, x, [si])</pre>
<p>Apply filter described by vectors <code>a</code> and <code>b</code> to vector <code>x</code>, with an optional initial filter state vector <code>si</code> (defaults to zeros).</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dsp.jl#L11-L16">source</a><br><h3 id="Base.DSP.filt!">
<code>Base.DSP.filt!</code><span class="docstring-category">Function</span>
</h3>
<pre>filt!(out, b, a, x, [si])</pre>
<p>Same as <a href="#Base.DSP.filt"><code>filt</code></a> but writes the result into the <code>out</code> argument, which may alias the input <code>x</code> to modify it in-place.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dsp.jl#L25-L30">source</a><br><h3 id="Base.DSP.deconv">
<code>Base.DSP.deconv</code><span class="docstring-category">Function</span>
</h3>
<pre>deconv(b,a) -&gt; c</pre>
<p>Construct vector <code>c</code> such that <code>b = conv(a,c) + r</code>. Equivalent to polynomial division.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dsp.jl#L105-L110">source</a><br><h3 id="Base.DSP.conv">
<code>Base.DSP.conv</code><span class="docstring-category">Function</span>
</h3>
<pre>conv(u,v)</pre>
<p>Convolution of two vectors. Uses FFT algorithm.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dsp.jl#L123-L127">source</a><br><h3 id="Base.DSP.conv2">
<code>Base.DSP.conv2</code><span class="docstring-category">Function</span>
</h3>
<pre>conv2(u,v,A)</pre>
<p>2-D convolution of the matrix <code>A</code> with the 2-D separable kernel generated by the vectors <code>u</code> and <code>v</code>. Uses 2-D FFT algorithm.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dsp.jl#L148-L154">source</a><br><pre>conv2(B,A)</pre>
<p>2-D convolution of the matrix <code>B</code> with the matrix <code>A</code>. Uses 2-D FFT algorithm.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dsp.jl#L169-L173">source</a><br><h3 id="Base.DSP.xcorr">
<code>Base.DSP.xcorr</code><span class="docstring-category">Function</span>
</h3>
<pre>xcorr(u,v)</pre>
<p>Compute the cross-correlation of two vectors.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dsp.jl#L192-L196">source</a><br><p>The following functions are defined within the <code>Base.FFTW</code> module.</p>
<h3 id="Base.DFT.FFTW.r2r">
<code>Base.DFT.FFTW.r2r</code><span class="docstring-category">Function</span>
</h3>
<pre>r2r(A, kind [, dims])</pre>
<p>Performs a multidimensional real-input/real-output (r2r) transform of type <code>kind</code> of the array <code>A</code>, as defined in the FFTW manual. <code>kind</code> specifies either a discrete cosine transform of various types (<code>FFTW.REDFT00</code>, <code>FFTW.REDFT01</code>, <code>FFTW.REDFT10</code>, or <code>FFTW.REDFT11</code>), a discrete sine transform of various types (<code>FFTW.RODFT00</code>, <code>FFTW.RODFT01</code>, <code>FFTW.RODFT10</code>, or <code>FFTW.RODFT11</code>), a real-input DFT with halfcomplex-format output (<code>FFTW.R2HC</code> and its inverse <code>FFTW.HC2R</code>), or a discrete Hartley transform (<code>FFTW.DHT</code>). The <code>kind</code> argument may be an array or tuple in order to specify different transform types along the different dimensions of <code>A</code>; <code>kind[end]</code> is used for any unspecified dimensions. See the FFTW manual for precise definitions of these transform types, at http://www.fftw.org/doc.</p>
<p>The optional <code>dims</code> argument specifies an iterable subset of dimensions (e.g. an integer, range, tuple, or array) to transform along. <code>kind[i]</code> is then the transform type for <code>dims[i]</code>, with <code>kind[end]</code> being used for <code>i &gt; length(kind)</code>.</p>
<p>See also <a href="#Base.DFT.FFTW.plan_r2r"><code>plan_r2r</code></a> to pre-plan optimized r2r transforms.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L533-L556">source</a><br><h3 id="Base.DFT.FFTW.r2r!">
<code>Base.DFT.FFTW.r2r!</code><span class="docstring-category">Function</span>
</h3>
<pre>r2r!(A, kind [, dims])</pre>
<p>Same as <a href="#Base.DFT.FFTW.r2r"><code>r2r</code></a>, but operates in-place on <code>A</code>, which must be an array of real or complex floating-point numbers.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L559-L564">source</a><br><h3 id="Base.DFT.FFTW.plan_r2r">
<code>Base.DFT.FFTW.plan_r2r</code><span class="docstring-category">Function</span>
</h3>
<pre>plan_r2r(A, kind [, dims [, flags [, timelimit]]])</pre>
<p>Pre-plan an optimized r2r transform, similar to <a href="#Base.DFT.plan_fft"><code>plan_fft</code></a> except that the transforms (and the first three arguments) correspond to <a href="#Base.DFT.FFTW.r2r"><code>r2r</code></a> and <a href="#Base.DFT.FFTW.r2r!"><code>r2r!</code></a>, respectively.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L574-L580">source</a><br><h3 id="Base.DFT.FFTW.plan_r2r!">
<code>Base.DFT.FFTW.plan_r2r!</code><span class="docstring-category">Function</span>
</h3>
<pre>plan_r2r!(A, kind [, dims [, flags [, timelimit]]])</pre>
<p>Similar to <a href="#Base.DFT.plan_fft"><code>plan_fft</code></a>, but corresponds to <a href="#Base.DFT.FFTW.r2r!"><code>r2r!</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dft.jl#L567-L571">source</a><br><div class="_attribution">
  <p class="_attribution-p">
    © 2009–2016 Jeff Bezanson, Stefan Karpinski, Viral B. Shah, and other contributors<br>Licensed under the MIT License.<br>
    <a href="https://docs.julialang.org/en/release-0.6/stdlib/math/" class="_attribution-link" target="_blank">https://docs.julialang.org/en/release-0.6/stdlib/math/</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
