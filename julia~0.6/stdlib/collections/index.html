
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Collections and Data Structures - Julia 0.6 - W3cubDocs</title>
  
  <meta name="description" content=" Sequential iteration is implemented by the methods start(), done(), and next(). The general for loop&#58; ">
  <meta name="keywords" content="collections, and, data, structures, -, julia, julia~0.6">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/julia~0.6/stdlib/collections/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-e0f881b0fce8cbe96f33dadc355b7159d5d2912911231446d60eb8f9caffa802.css">
  <script type="text/javascript" src="/assets/application-8fc46316434047265cd383f02b8e7f434ed7dec4a59f920dd633deef8d488d1b.js"></script>
  <script src="/json/julia~0.6.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/julia~0.6/" class="_nav-link" title="" style="margin-left:0;">Julia 0.6</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _julia">
				
<h1 id="Collections-and-Data-Structures-1">Collections and Data Structures</h1>
<h2 id="lib-collections-iteration-1">Iteration</h2>
<p>Sequential iteration is implemented by the methods <a href="#Base.start"><code>start()</code></a>, <a href="#Base.done"><code>done()</code></a>, and <a href="#Base.next"><code>next()</code></a>. The general <code>for</code> loop:</p>
<pre>for i = I   # or  "for i in I"
    # body
end</pre>
<p>is translated into:</p>
<pre>state = start(I)
while !done(I, state)
    (i, state) = next(I, state)
    # body
end</pre>
<p>The <code>state</code> object may be anything, and should be chosen appropriately for each iterable type. See the <a href="../../manual/interfaces/#man-interface-iteration-1">manual section on the iteration interface</a> for more details about defining a custom iterable type.</p>
<h3 id="Base.start">
<code>Base.start</code><span class="docstring-category">Function</span>
</h3>
<pre>start(iter) -&gt; state</pre>
<p>Get initial iteration state for an iterable object.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; start(1:5)
1

julia&gt; start([1;2;3])
1

julia&gt; start([4;2;3])
1</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2119-L2135">source</a><br><h3 id="Base.done">
<code>Base.done</code><span class="docstring-category">Function</span>
</h3>
<pre>done(iter, state) -&gt; Bool</pre>
<p>Test whether we are done iterating.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; done(1:5, 3)
false

julia&gt; done(1:5, 5)
false

julia&gt; done(1:5, 6)
true</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2154-L2170">source</a><br><h3 id="Base.next">
<code>Base.next</code><span class="docstring-category">Function</span>
</h3>
<pre>next(iter, state) -&gt; item, state</pre>
<p>For a given iterable object and iteration state, return the current item and the next iteration state.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; next(1:5, 3)
(3, 4)

julia&gt; next(1:5, 5)
(5, 6)</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1098-L1111">source</a><br><h3 id="Base.iteratorsize">
<code>Base.iteratorsize</code><span class="docstring-category">Function</span>
</h3>
<pre>iteratorsize(itertype::Type) -&gt; IteratorSize</pre>
<p>Given the type of an iterator, returns one of the following values:</p>
<ul>
<li><p><code>SizeUnknown()</code> if the length (number of elements) cannot be determined in advance.</p></li>
<li><p><code>HasLength()</code> if there is a fixed, finite length.</p></li>
<li><p><code>HasShape()</code> if there is a known length plus a notion of multidimensional shape (as for an array). In this case the <a href="../arrays/#Base.size"><code>size</code></a> function is valid for the iterator.</p></li>
<li><p><code>IsInfinite()</code> if the iterator yields values forever.</p></li>
</ul>
<p>The default value (for iterators that do not define this function) is <code>HasLength()</code>. This means that most iterators are assumed to implement <a href="#"><code>length</code></a>.</p>
<p>This trait is generally used to select between algorithms that pre-allocate space for their result, and algorithms that resize their result incrementally.</p>
<pre>julia&gt; Base.iteratorsize(1:5)
Base.HasShape()

julia&gt; Base.iteratorsize((2,3))
Base.HasLength()</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/generator.jl#L57-L81">source</a><br><h3 id="Base.iteratoreltype">
<code>Base.iteratoreltype</code><span class="docstring-category">Function</span>
</h3>
<pre>iteratoreltype(itertype::Type) -&gt; IteratorEltype</pre>
<p>Given the type of an iterator, returns one of the following values:</p>
<ul>
<li><p><code>EltypeUnknown()</code> if the type of elements yielded by the iterator is not known in advance.</p></li>
<li><p><code>HasEltype()</code> if the element type is known, and <a href="#Base.eltype"><code>eltype</code></a> would return a meaningful value.</p></li>
</ul>
<p><code>HasEltype()</code> is the default, since iterators are assumed to implement <a href="#Base.eltype"><code>eltype</code></a>.</p>
<p>This trait is generally used to select between algorithms that pre-allocate a specific type of result, and algorithms that pick a result type based on the types of yielded values.</p>
<pre>julia&gt; Base.iteratoreltype(1:5)
Base.HasEltype()</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/generator.jl#L89-L107">source</a><br><p>Fully implemented by:</p>
<ul>
<li><p><code>Range</code></p></li>
<li><p><code>UnitRange</code></p></li>
<li><p><code>Tuple</code></p></li>
<li><p><code>Number</code></p></li>
<li><p><a href="../arrays/#Core.AbstractArray"><code>AbstractArray</code></a></p></li>
<li><p><a href="#Base.IntSet"><code>IntSet</code></a></p></li>
<li><p><a href="#Base.ObjectIdDict"><code>ObjectIdDict</code></a></p></li>
<li><p><a href="#Base.Dict"><code>Dict</code></a></p></li>
<li><p><a href="#Base.WeakKeyDict"><code>WeakKeyDict</code></a></p></li>
<li><p><code>EachLine</code></p></li>
<li><p><code>AbstractString</code></p></li>
<li><p><a href="#Base.Set"><code>Set</code></a></p></li>
</ul>
<h2 id="General-Collections-1">General Collections</h2>
<h3 id="Base.isempty">
<code>Base.isempty</code><span class="docstring-category">Function</span>
</h3>
<pre>isempty(collection) -&gt; Bool</pre>
<p>Determine whether a collection is empty (has no elements).</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; isempty([])
true

julia&gt; isempty([1 2 3])
false</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1586-L1599">source</a><br><h3 id="Base.empty!">
<code>Base.empty!</code><span class="docstring-category">Function</span>
</h3>
<pre>empty!(collection) -&gt; collection</pre>
<p>Remove all elements from a <code>collection</code>.</p>
<pre>julia&gt; A = Dict("a" =&gt; 1, "b" =&gt; 2)
Dict{String,Int64} with 2 entries:
  "b" =&gt; 2
  "a" =&gt; 1

julia&gt; empty!(A);

julia&gt; A
Dict{String,Int64} with 0 entries</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dict.jl#L286-L302">source</a><br><h3 id="Base.length-Tuple{Any}">
<code>Base.length</code><span class="docstring-category">Method</span>
</h3>
<pre>length(collection) -&gt; Integer</pre>
<p>For ordered, indexable collections, returns the maximum index <code>i</code> for which <code>getindex(collection, i)</code> is valid. For unordered collections, returns the number of elements.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; length(1:5)
5

julia&gt; length([1; 2; 3; 4])
4</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2008-L2023">source</a><br><h3 id="Base.endof">
<code>Base.endof</code><span class="docstring-category">Function</span>
</h3>
<pre>endof(collection) -&gt; Integer</pre>
<p>Returns the last index of the collection.</p>
<p><strong>Example</strong></p>
<pre>julia&gt; endof([1,2,4])
3</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1085-L1095">source</a><br><p>Fully implemented by:</p>
<ul>
<li><p><code>Range</code></p></li>
<li><p><code>UnitRange</code></p></li>
<li><p><code>Tuple</code></p></li>
<li><p><code>Number</code></p></li>
<li><p><a href="../arrays/#Core.AbstractArray"><code>AbstractArray</code></a></p></li>
<li><p><a href="#Base.IntSet"><code>IntSet</code></a></p></li>
<li><p><a href="#Base.ObjectIdDict"><code>ObjectIdDict</code></a></p></li>
<li><p><a href="#Base.Dict"><code>Dict</code></a></p></li>
<li><p><a href="#Base.WeakKeyDict"><code>WeakKeyDict</code></a></p></li>
<li><p><code>AbstractString</code></p></li>
<li><p><a href="#Base.Set"><code>Set</code></a></p></li>
</ul>
<h2 id="Iterable-Collections-1">Iterable Collections</h2>
<h3 id="Base.in">
<code>Base.in</code><span class="docstring-category">Function</span>
</h3>
<pre>in(item, collection) -&gt; Bool
∈(item,collection) -&gt; Bool
∋(collection,item) -&gt; Bool
∉(item,collection) -&gt; Bool
∌(collection,item) -&gt; Bool</pre>
<p>Determine whether an item is in the given collection, in the sense that it is <code>==</code> to one of the values generated by iterating over the collection. Some collections need a slightly different definition; for example <a href="#Base.Set"><code>Set</code></a>s check whether the item <a href="#"><code>isequal</code></a> to one of the elements. <a href="#Base.Dict"><code>Dict</code></a>s look for <code>(key,value)</code> pairs, and the key is compared using <a href="#"><code>isequal</code></a>. To test for the presence of a key in a dictionary, use <a href="#Base.haskey"><code>haskey</code></a> or <code>k in keys(dict)</code>.</p>
<pre>julia&gt; a = 1:3:20
1:3:19

julia&gt; 4 in a
true

julia&gt; 5 in a
false</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L606-L630">source</a><br><h3 id="Base.eltype">
<code>Base.eltype</code><span class="docstring-category">Function</span>
</h3>
<pre>eltype(type)</pre>
<p>Determine the type of the elements generated by iterating a collection of the given <code>type</code>. For associative collection types, this will be a <code>Pair{KeyType,ValType}</code>. The definition <code>eltype(x) = eltype(typeof(x))</code> is provided for convenience so that instances can be passed instead of types. However the form that accepts a type argument should be defined for new types.</p>
<pre>julia&gt; eltype(ones(Float32,2,2))
Float32

julia&gt; eltype(ones(Int8,2,2))
Int8</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L26-L42">source</a><br><h3 id="Base.indexin">
<code>Base.indexin</code><span class="docstring-category">Function</span>
</h3>
<pre>indexin(a, b)</pre>
<p>Returns a vector containing the highest index in <code>b</code> for each value in <code>a</code> that is a member of <code>b</code> . The output vector contains 0 wherever <code>a</code> is not a member of <code>b</code>.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; a = ['a', 'b', 'c', 'b', 'd', 'a'];

julia&gt; b = ['a','b','c'];

julia&gt; indexin(a,b)
6-element Array{Int64,1}:
 1
 2
 3
 2
 0
 1

julia&gt; indexin(b,a)
3-element Array{Int64,1}:
 6
 4
 3</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L1779-L1807">source</a><br><h3 id="Base.findin">
<code>Base.findin</code><span class="docstring-category">Function</span>
</h3>
<pre>findin(a, b)</pre>
<p>Returns the indices of elements in collection <code>a</code> that appear in collection <code>b</code>.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; a = collect(1:3:15)
5-element Array{Int64,1}:
  1
  4
  7
 10
 13

julia&gt; b = collect(2:4:10)
3-element Array{Int64,1}:
  2
  6
 10

julia&gt; findin(a,b) # 10 is the only common element
1-element Array{Int64,1}:
 4</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L1813-L1838">source</a><br><h3 id="Base.unique">
<code>Base.unique</code><span class="docstring-category">Function</span>
</h3>
<pre>unique(itr)</pre>
<p>Returns an array containing one value from <code>itr</code> for each unique value, as determined by <a href="#"><code>isequal</code></a>.</p>
<pre>julia&gt; unique([1; 2; 2; 6])
3-element Array{Int64,1}:
 1
 2
 6</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/set.jl#L115-L128">source</a><br><pre>unique(f, itr)</pre>
<p>Returns an array containing one value from <code>itr</code> for each unique value produced by <code>f</code> applied to elements of <code>itr</code>.</p>
<pre>julia&gt; unique(isodd, [1; 2; 2; 6])
2-element Array{Int64,1}:
 1
 2</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/set.jl#L170-L182">source</a><br><pre>unique(itr[, dim])</pre>
<p>Returns an array containing only the unique elements of the iterable <code>itr</code>, in the order that the first of each set of equivalent elements originally appears. If <code>dim</code> is specified, returns unique regions of the array <code>itr</code> along <code>dim</code>.</p>
<pre>julia&gt; A = map(isodd, reshape(collect(1:8), (2,2,2)))
2×2×2 Array{Bool,3}:
[:, :, 1] =
  true   true
 false  false

[:, :, 2] =
  true   true
 false  false

julia&gt; unique(A)
2-element Array{Bool,1}:
  true
 false

julia&gt; unique(A, 2)
2×1×2 Array{Bool,3}:
[:, :, 1] =
  true
 false

[:, :, 2] =
  true
 false

julia&gt; unique(A, 3)
2×2×1 Array{Bool,3}:
[:, :, 1] =
  true   true
 false  false</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/multidimensional.jl#L1353-L1392">source</a><br><h3 id="Base.allunique">
<code>Base.allunique</code><span class="docstring-category">Function</span>
</h3>
<pre>allunique(itr) -&gt; Bool</pre>
<p>Return <code>true</code> if all values from <code>itr</code> are distinct when compared with <a href="#"><code>isequal</code></a>.</p>
<pre>julia&gt; a = [1; 2; 3]
3-element Array{Int64,1}:
 1
 2
 3

julia&gt; allunique([a, a])
false</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/set.jl#L196-L211">source</a><br><h3 id="Base.reduce-Tuple{Any,Any,Any}">
<code>Base.reduce</code><span class="docstring-category">Method</span>
</h3>
<pre>reduce(op, v0, itr)</pre>
<p>Reduce the given collection <code>ìtr</code> with the given binary operator <code>op</code>. <code>v0</code> must be a neutral element for <code>op</code> that will be returned for empty collections. It is unspecified whether <code>v0</code> is used for non-empty collections.</p>
<p>Reductions for certain commonly-used operators have special implementations which should be used instead: <code>maximum(itr)</code>, <code>minimum(itr)</code>, <code>sum(itr)</code>, <code>prod(itr)</code>, <code>any(itr)</code>, <code>all(itr)</code>.</p>
<p>The associativity of the reduction is implementation dependent. This means that you can't use non-associative operations like <code>-</code> because it is undefined whether <code>reduce(-,[1,2,3])</code> should be evaluated as <code>(1-2)-3</code> or <code>1-(2-3)</code>. Use <a href="#Base.foldl-Tuple%7BAny,Any,Any%7D"><code>foldl</code></a> or <a href="#Base.foldr-Tuple%7BAny,Any,Any%7D"><code>foldr</code></a> instead for guaranteed left or right associativity.</p>
<p>Some operations accumulate error, and parallelism will also be easier if the reduction can be executed in groups. Future versions of Julia might change the algorithm. Note that the elements are not reordered if you use an ordered collection.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; reduce(*, 1, [2; 3; 4])
24</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L289-L315">source</a><br><h3 id="Base.reduce-Tuple{Any,Any}">
<code>Base.reduce</code><span class="docstring-category">Method</span>
</h3>
<pre>reduce(op, itr)</pre>
<p>Like <code>reduce(op, v0, itr)</code>. This cannot be used with empty collections, except for some special cases (e.g. when <code>op</code> is one of <code>+</code>, <code>*</code>, <code>max</code>, <code>min</code>, <code>&amp;</code>, <code>|</code>) when Julia can determine the neutral element of <code>op</code>.</p>
<pre>julia&gt; reduce(*, [2; 3; 4])
24</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L318-L329">source</a><br><h3 id="Base.foldl-Tuple{Any,Any,Any}">
<code>Base.foldl</code><span class="docstring-category">Method</span>
</h3>
<pre>foldl(op, v0, itr)</pre>
<p>Like <a href="#Base.reduce-Tuple%7BAny,Any,Any%7D"><code>reduce</code></a>, but with guaranteed left associativity. <code>v0</code> will be used exactly once.</p>
<pre>julia&gt; foldl(-, 1, 2:5)
-13</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L76-L86">source</a><br><h3 id="Base.foldl-Tuple{Any,Any}">
<code>Base.foldl</code><span class="docstring-category">Method</span>
</h3>
<pre>foldl(op, itr)</pre>
<p>Like <code>foldl(op, v0, itr)</code>, but using the first element of <code>itr</code> as <code>v0</code>. In general, this cannot be used with empty collections (see <code>reduce(op, itr)</code>).</p>
<pre>julia&gt; foldl(-, 2:5)
-10</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L89-L99">source</a><br><h3 id="Base.foldr-Tuple{Any,Any,Any}">
<code>Base.foldr</code><span class="docstring-category">Method</span>
</h3>
<pre>foldr(op, v0, itr)</pre>
<p>Like <a href="#Base.reduce-Tuple%7BAny,Any,Any%7D"><code>reduce</code></a>, but with guaranteed right associativity. <code>v0</code> will be used exactly once.</p>
<pre>julia&gt; foldr(-, 1, 2:5)
-1</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L142-L152">source</a><br><h3 id="Base.foldr-Tuple{Any,Any}">
<code>Base.foldr</code><span class="docstring-category">Method</span>
</h3>
<pre>foldr(op, itr)</pre>
<p>Like <code>foldr(op, v0, itr)</code>, but using the last element of <code>itr</code> as <code>v0</code>. In general, this cannot be used with empty collections (see <code>reduce(op, itr)</code>).</p>
<pre>julia&gt; foldr(-, 2:5)
-2</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L155-L165">source</a><br><h3 id="Base.maximum-Tuple{Any}">
<code>Base.maximum</code><span class="docstring-category">Method</span>
</h3>
<pre>maximum(itr)</pre>
<p>Returns the largest element in a collection.</p>
<pre>julia&gt; maximum(-20.5:10)
9.5

julia&gt; maximum([1,2,3])
3</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L441-L453">source</a><br><h3 id="Base.maximum-Tuple{Any,Any}">
<code>Base.maximum</code><span class="docstring-category">Method</span>
</h3>
<pre>maximum(A, dims)</pre>
<p>Compute the maximum value of an array over the given dimensions. See also the <a href="../math/#Base.max"><code>max(a,b)</code></a> function to take the maximum of two or more arguments, which can be applied elementwise to arrays via <code>max.(a,b)</code>.</p>
<pre>julia&gt; A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; maximum(A, 1)
1×2 Array{Int64,2}:
 3  4

julia&gt; maximum(A, 2)
2×1 Array{Int64,2}:
 2
 4</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reducedim.jl#L378-L400">source</a><br><h3 id="Base.maximum!">
<code>Base.maximum!</code><span class="docstring-category">Function</span>
</h3>
<pre>maximum!(r, A)</pre>
<p>Compute the maximum value of <code>A</code> over the singleton dimensions of <code>r</code>, and write results to <code>r</code>.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; maximum!([1; 1], A)
2-element Array{Int64,1}:
 2
 4

julia&gt; maximum!([1 1], A)
1×2 Array{Int64,2}:
 3  4</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reducedim.jl#L403-L424">source</a><br><h3 id="Base.minimum-Tuple{Any}">
<code>Base.minimum</code><span class="docstring-category">Method</span>
</h3>
<pre>minimum(itr)</pre>
<p>Returns the smallest element in a collection.</p>
<pre>julia&gt; minimum(-20.5:10)
-20.5

julia&gt; minimum([1,2,3])
1</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L456-L468">source</a><br><h3 id="Base.minimum-Tuple{Any,Any}">
<code>Base.minimum</code><span class="docstring-category">Method</span>
</h3>
<pre>minimum(A, dims)</pre>
<p>Compute the minimum value of an array over the given dimensions. See also the <a href="../math/#Base.min"><code>min(a,b)</code></a> function to take the minimum of two or more arguments, which can be applied elementwise to arrays via <code>min.(a,b)</code>.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; minimum(A, 1)
1×2 Array{Int64,2}:
 1  2

julia&gt; minimum(A, 2)
2×1 Array{Int64,2}:
 1
 3</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reducedim.jl#L427-L450">source</a><br><h3 id="Base.minimum!">
<code>Base.minimum!</code><span class="docstring-category">Function</span>
</h3>
<pre>minimum!(r, A)</pre>
<p>Compute the minimum value of <code>A</code> over the singleton dimensions of <code>r</code>, and write results to <code>r</code>.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; minimum!([1; 1], A)
2-element Array{Int64,1}:
 1
 3

julia&gt; minimum!([1 1], A)
1×2 Array{Int64,2}:
 1  2</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reducedim.jl#L453-L474">source</a><br><h3 id="Base.extrema-Tuple{Any}">
<code>Base.extrema</code><span class="docstring-category">Method</span>
</h3>
<pre>extrema(itr) -&gt; Tuple</pre>
<p>Compute both the minimum and maximum element in a single pass, and return them as a 2-tuple.</p>
<pre>julia&gt; extrema(2:10)
(2, 10)

julia&gt; extrema([9,pi,4.5])
(3.141592653589793, 9.0)</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L476-L488">source</a><br><h3 id="Base.extrema-Tuple{AbstractArray,Any}">
<code>Base.extrema</code><span class="docstring-category">Method</span>
</h3>
<pre>extrema(A, dims) -&gt; Array{Tuple}</pre>
<p>Compute the minimum and maximum elements of an array over the given dimensions.</p>
<p><strong>Example</strong></p>
<pre>julia&gt; A = reshape(collect(1:2:16), (2,2,2))
2×2×2 Array{Int64,3}:
[:, :, 1] =
 1  5
 3  7

[:, :, 2] =
  9  13
 11  15

julia&gt; extrema(A, (1,2))
1×1×2 Array{Tuple{Int64,Int64},3}:
[:, :, 1] =
 (1, 7)

[:, :, 2] =
 (9, 15)</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/multidimensional.jl#L1464-L1489">source</a><br><h3 id="Base.indmax">
<code>Base.indmax</code><span class="docstring-category">Function</span>
</h3>
<pre>indmax(itr) -&gt; Integer</pre>
<p>Returns the index of the maximum element in a collection. If there are multiple maximal elements, then the first one will be returned. <code>NaN</code> values are ignored, unless all elements are <code>NaN</code>.</p>
<p>The collection must not be empty.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; indmax([8,0.1,-9,pi])
1

julia&gt; indmax([1,7,7,6])
2

julia&gt; indmax([1,7,7,NaN])
2</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L1732-L1752">source</a><br><h3 id="Base.indmin">
<code>Base.indmin</code><span class="docstring-category">Function</span>
</h3>
<pre>indmin(itr) -&gt; Integer</pre>
<p>Returns the index of the minimum element in a collection. If there are multiple minimal elements, then the first one will be returned. <code>NaN</code> values are ignored, unless all elements are <code>NaN</code>.</p>
<p>The collection must not be empty.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; indmin([8,0.1,-9,pi])
3

julia&gt; indmin([7,1,1,6])
2

julia&gt; indmin([7,1,1,NaN])
2</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L1755-L1775">source</a><br><h3 id="Base.findmax-Tuple{Any}">
<code>Base.findmax</code><span class="docstring-category">Method</span>
</h3>
<pre>findmax(itr) -&gt; (x, index)</pre>
<p>Returns the maximum element of the collection <code>itr</code> and its index. If there are multiple maximal elements, then the first one will be returned. <code>NaN</code> values are ignored, unless all elements are <code>NaN</code>.</p>
<p>The collection must not be empty.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; findmax([8,0.1,-9,pi])
(8.0, 1)

julia&gt; findmax([1,7,7,6])
(7, 2)

julia&gt; findmax([1,7,7,NaN])
(7.0, 2)</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L1654-L1674">source</a><br><h3 id="Base.findmax-Tuple{AbstractArray,Any}">
<code>Base.findmax</code><span class="docstring-category">Method</span>
</h3>
<pre>findmax(A, region) -&gt; (maxval, index)</pre>
<p>For an array input, returns the value and index of the maximum over the given region.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; findmax(A,1)
([3 4], [2 4])

julia&gt; findmax(A,2)
([2; 4], [3; 4])</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reducedim.jl#L687-L705">source</a><br><h3 id="Base.findmin-Tuple{Any}">
<code>Base.findmin</code><span class="docstring-category">Method</span>
</h3>
<pre>findmin(itr) -&gt; (x, index)</pre>
<p>Returns the minimum element of the collection <code>itr</code> and its index. If there are multiple minimal elements, then the first one will be returned. <code>NaN</code> values are ignored, unless all elements are <code>NaN</code>.</p>
<p>The collection must not be empty.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; findmin([8,0.1,-9,pi])
(-9.0, 3)

julia&gt; findmin([7,1,1,6])
(1, 2)

julia&gt; findmin([7,1,1,NaN])
(1.0, 2)</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L1693-L1713">source</a><br><h3 id="Base.findmin-Tuple{AbstractArray,Any}">
<code>Base.findmin</code><span class="docstring-category">Method</span>
</h3>
<pre>findmin(A, region) -&gt; (minval, index)</pre>
<p>For an array input, returns the value and index of the minimum over the given region.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; findmin(A, 1)
([1 2], [1 3])

julia&gt; findmin(A, 2)
([1; 3], [1; 2])</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reducedim.jl#L648-L666">source</a><br><h3 id="Base.findmax!">
<code>Base.findmax!</code><span class="docstring-category">Function</span>
</h3>
<pre>findmax!(rval, rind, A, [init=true]) -&gt; (maxval, index)</pre>
<p>Find the maximum of <code>A</code> and the corresponding linear index along singleton dimensions of <code>rval</code> and <code>rind</code>, and store the results in <code>rval</code> and <code>rind</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reducedim.jl#L676-L681">source</a><br><h3 id="Base.findmin!">
<code>Base.findmin!</code><span class="docstring-category">Function</span>
</h3>
<pre>findmin!(rval, rind, A, [init=true]) -&gt; (minval, index)</pre>
<p>Find the minimum of <code>A</code> and the corresponding linear index along singleton dimensions of <code>rval</code> and <code>rind</code>, and store the results in <code>rval</code> and <code>rind</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reducedim.jl#L637-L642">source</a><br><h3 id="Base.sum">
<code>Base.sum</code><span class="docstring-category">Function</span>
</h3>
<pre>sum(f, itr)</pre>
<p>Sum the results of calling function <code>f</code> on each element of <code>itr</code>.</p>
<pre>julia&gt; sum(abs2, [2; 3; 4])
29</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L337-L346">source</a><br><pre>sum(itr)</pre>
<p>Returns the sum of all elements in a collection.</p>
<pre>julia&gt; sum(1:20)
210</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L349-L358">source</a><br><pre>sum(A, dims)</pre>
<p>Sum elements of an array over the given dimensions.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; sum(A, 1)
1×2 Array{Int64,2}:
 4  6

julia&gt; sum(A, 2)
2×1 Array{Int64,2}:
 3
 7</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reducedim.jl#L282-L303">source</a><br><h3 id="Base.sum!">
<code>Base.sum!</code><span class="docstring-category">Function</span>
</h3>
<pre>sum!(r, A)</pre>
<p>Sum elements of <code>A</code> over the singleton dimensions of <code>r</code>, and write results to <code>r</code>.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; sum!([1; 1], A)
2-element Array{Int64,1}:
 3
 7

julia&gt; sum!([1 1], A)
1×2 Array{Int64,2}:
 4  6</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reducedim.jl#L306-L327">source</a><br><h3 id="Base.prod">
<code>Base.prod</code><span class="docstring-category">Function</span>
</h3>
<pre>prod(f, itr)</pre>
<p>Returns the product of <code>f</code> applied to each element of <code>itr</code>.</p>
<pre>julia&gt; prod(abs2, [2; 3; 4])
576</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L395-L404">source</a><br><pre>prod(itr)</pre>
<p>Returns the product of all elements of a collection.</p>
<pre>julia&gt; prod(1:20)
2432902008176640000</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L407-L416">source</a><br><pre>prod(A, dims)</pre>
<p>Multiply elements of an array over the given dimensions.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; prod(A, 1)
1×2 Array{Int64,2}:
 3  8

julia&gt; prod(A, 2)
2×1 Array{Int64,2}:
  2
 12</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reducedim.jl#L330-L351">source</a><br><h3 id="Base.prod!">
<code>Base.prod!</code><span class="docstring-category">Function</span>
</h3>
<pre>prod!(r, A)</pre>
<p>Multiply elements of <code>A</code> over the singleton dimensions of <code>r</code>, and write results to <code>r</code>.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; prod!([1; 1], A)
2-element Array{Int64,1}:
  2
 12

julia&gt; prod!([1 1], A)
1×2 Array{Int64,2}:
 3  8</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reducedim.jl#L354-L375">source</a><br><h3 id="Base.any-Tuple{Any}">
<code>Base.any</code><span class="docstring-category">Method</span>
</h3>
<pre>any(itr) -&gt; Bool</pre>
<p>Test whether any elements of a boolean collection are <code>true</code>, returning <code>true</code> as soon as the first <code>true</code> value in <code>itr</code> is encountered (short-circuiting).</p>
<pre>julia&gt; a = [true,false,false,true]
4-element Array{Bool,1}:
  true
 false
 false
  true

julia&gt; any(a)
true

julia&gt; any((println(i); v) for (i, v) in enumerate(a))
1
true</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L504-L525">source</a><br><h3 id="Base.any-Tuple{AbstractArray,Any}">
<code>Base.any</code><span class="docstring-category">Method</span>
</h3>
<pre>any(A, dims)</pre>
<p>Test whether any values along the given dimensions of an array are <code>true</code>.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; A = [true false; true false]
2×2 Array{Bool,2}:
 true  false
 true  false

julia&gt; any(A, 1)
1×2 Array{Bool,2}:
 true  false

julia&gt; any(A, 2)
2×1 Array{Bool,2}:
 true
 true</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reducedim.jl#L525-L546">source</a><br><h3 id="Base.any!">
<code>Base.any!</code><span class="docstring-category">Function</span>
</h3>
<pre>any!(r, A)</pre>
<p>Test whether any values in <code>A</code> along the singleton dimensions of <code>r</code> are <code>true</code>, and write results to <code>r</code>.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; A = [true false; true false]
2×2 Array{Bool,2}:
 true  false
 true  false

julia&gt; any!([1; 1], A)
2-element Array{Int64,1}:
 1
 1

julia&gt; any!([1 1], A)
1×2 Array{Int64,2}:
 1  0</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reducedim.jl#L549-L571">source</a><br><h3 id="Base.all-Tuple{Any}">
<code>Base.all</code><span class="docstring-category">Method</span>
</h3>
<pre>all(itr) -&gt; Bool</pre>
<p>Test whether all elements of a boolean collection are <code>true</code>, returning <code>false</code> as soon as the first <code>false</code> value in <code>itr</code> is encountered (short-circuiting).</p>
<pre>julia&gt; a = [true,false,false,true]
4-element Array{Bool,1}:
  true
 false
 false
  true

julia&gt; all(a)
false

julia&gt; all((println(i); v) for (i, v) in enumerate(a))
1
2
false</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L528-L550">source</a><br><h3 id="Base.all-Tuple{AbstractArray,Any}">
<code>Base.all</code><span class="docstring-category">Method</span>
</h3>
<pre>all(A, dims)</pre>
<p>Test whether all values along the given dimensions of an array are <code>true</code>.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; A = [true false; true true]
2×2 Array{Bool,2}:
 true  false
 true   true

julia&gt; all(A, 1)
1×2 Array{Bool,2}:
 true  false

julia&gt; all(A, 2)
2×1 Array{Bool,2}:
 false
  true</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reducedim.jl#L477-L498">source</a><br><h3 id="Base.all!">
<code>Base.all!</code><span class="docstring-category">Function</span>
</h3>
<pre>all!(r, A)</pre>
<p>Test whether all values in <code>A</code> along the singleton dimensions of <code>r</code> are <code>true</code>, and write results to <code>r</code>.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; A = [true false; true false]
2×2 Array{Bool,2}:
 true  false
 true  false

julia&gt; all!([1; 1], A)
2-element Array{Int64,1}:
 0
 0

julia&gt; all!([1 1], A)
1×2 Array{Int64,2}:
 1  0</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reducedim.jl#L501-L522">source</a><br><h3 id="Base.count">
<code>Base.count</code><span class="docstring-category">Function</span>
</h3>
<pre>count(p, itr) -&gt; Integer
count(itr) -&gt; Integer</pre>
<p>Count the number of elements in <code>itr</code> for which predicate <code>p</code> returns <code>true</code>. If <code>p</code> is omitted, counts the number of <code>true</code> elements in <code>itr</code> (which should be a collection of boolean values).</p>
<pre>julia&gt; count(i-&gt;(4&lt;=i&lt;=6), [2,3,4,5,6])
3

julia&gt; count([true, false, true, true])
3</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L673-L688">source</a><br><h3 id="Base.any-Tuple{Any,Any}">
<code>Base.any</code><span class="docstring-category">Method</span>
</h3>
<pre>any(p, itr) -&gt; Bool</pre>
<p>Determine whether predicate <code>p</code> returns <code>true</code> for any elements of <code>itr</code>, returning <code>true</code> as soon as the first item in <code>itr</code> for which <code>p</code> returns <code>true</code> is encountered (short-circuiting).</p>
<pre>julia&gt; any(i-&gt;(4&lt;=i&lt;=6), [3,5,7])
true

julia&gt; any(i -&gt; (println(i); i &gt; 3), 1:10)
1
2
3
4
true</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L553-L571">source</a><br><h3 id="Base.all-Tuple{Any,Any}">
<code>Base.all</code><span class="docstring-category">Method</span>
</h3>
<pre>all(p, itr) -&gt; Bool</pre>
<p>Determine whether predicate <code>p</code> returns <code>true</code> for all elements of <code>itr</code>, returning <code>false</code> as soon as the first item in <code>itr</code> for which <code>p</code> returns <code>false</code> is encountered (short-circuiting).</p>
<pre>julia&gt; all(i-&gt;(4&lt;=i&lt;=6), [4,5,6])
true

julia&gt; all(i -&gt; (println(i); i &lt; 3), 1:10)
1
2
3
false</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L579-L596">source</a><br><h3 id="Base.foreach">
<code>Base.foreach</code><span class="docstring-category">Function</span>
</h3>
<pre>foreach(f, c...) -&gt; Void</pre>
<p>Call function <code>f</code> on each element of iterable <code>c</code>. For multiple iterable arguments, <code>f</code> is called elementwise. <code>foreach</code> should be used instead of <code>map</code> when the results of <code>f</code> are not needed, for example in <code>foreach(println, array)</code>.</p>
<p><strong>Example</strong></p>
<pre>julia&gt; a = 1:3:7;

julia&gt; foreach(x -&gt; println(x^2), a)
1
16
49</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarray.jl#L1714-L1731">source</a><br><h3 id="Base.map">
<code>Base.map</code><span class="docstring-category">Function</span>
</h3>
<pre>map(f, c...) -&gt; collection</pre>
<p>Transform collection <code>c</code> by applying <code>f</code> to each element. For multiple collection arguments, apply <code>f</code> elementwise.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; map(x -&gt; x * 2, [1, 2, 3])
3-element Array{Int64,1}:
 2
 4
 6

julia&gt; map(+, [1, 2, 3], [10, 20, 30])
3-element Array{Int64,1}:
 11
 22
 33</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarray.jl#L1871-L1891">source</a><br><pre>map(f, x::Nullable)</pre>
<p>Return <code>f</code> applied to the value of <code>x</code> if it has one, as a <code>Nullable</code>. If <code>x</code> is null, then return a null value of type <code>Nullable{S}</code>. <code>S</code> is guaranteed to be either <code>Union{}</code> or a concrete type. Whichever of these is chosen is an implementation detail, but typically the choice that maximizes performance would be used. If <code>x</code> has a value, then the return type is guaranteed to be of type <code>Nullable{typeof(f(x))}</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/nullable.jl#L270-L279">source</a><br><h3 id="Base.map!">
<code>Base.map!</code><span class="docstring-category">Function</span>
</h3>
<pre>map!(function, destination, collection...)</pre>
<p>Like <a href="#Base.map"><code>map</code></a>, but stores the result in <code>destination</code> rather than a new collection. <code>destination</code> must be at least as large as the first collection.</p>
<p><strong>Example</strong></p>
<pre>julia&gt; x = zeros(3);

julia&gt; map!(x -&gt; x * 2, x, [1, 2, 3]);

julia&gt; x
3-element Array{Float64,1}:
 2.0
 4.0
 6.0</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarray.jl#L1914-L1932">source</a><br><h3 id="Base.mapreduce-NTuple{4,Any}">
<code>Base.mapreduce</code><span class="docstring-category">Method</span>
</h3>
<pre>mapreduce(f, op, v0, itr)</pre>
<p>Apply function <code>f</code> to each element in <code>itr</code>, and then reduce the result using the binary function <code>op</code>. <code>v0</code> must be a neutral element for <code>op</code> that will be returned for empty collections. It is unspecified whether <code>v0</code> is used for non-empty collections.</p>
<p><a href="#Base.mapreduce-NTuple%7B4,Any%7D"><code>mapreduce</code></a> is functionally equivalent to calling <code>reduce(op, v0, map(f, itr))</code>, but will in general execute faster since no intermediate collection needs to be created. See documentation for <a href="#Base.reduce-Tuple%7BAny,Any,Any%7D"><code>reduce</code></a> and <a href="#Base.map"><code>map</code></a>.</p>
<pre>julia&gt; mapreduce(x-&gt;x^2, +, [1:3;]) # == 1 + 4 + 9
14</pre>
<p>The associativity of the reduction is implementation-dependent. Additionally, some implementations may reuse the return value of <code>f</code> for elements that appear multiple times in <code>itr</code>. Use <a href="#Base.mapfoldl-NTuple%7B4,Any%7D"><code>mapfoldl</code></a> or <a href="#Base.mapfoldr-NTuple%7B4,Any%7D"><code>mapfoldr</code></a> instead for guaranteed left or right associativity and invocation of <code>f</code> for every value.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L208-L228">source</a><br><h3 id="Base.mapreduce-Tuple{Any,Any,Any}">
<code>Base.mapreduce</code><span class="docstring-category">Method</span>
</h3>
<pre>mapreduce(f, op, itr)</pre>
<p>Like <code>mapreduce(f, op, v0, itr)</code>. In general, this cannot be used with empty collections (see <code>reduce(op, itr)</code>).</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L200-L205">source</a><br><h3 id="Base.mapfoldl-NTuple{4,Any}">
<code>Base.mapfoldl</code><span class="docstring-category">Method</span>
</h3>
<pre>mapfoldl(f, op, v0, itr)</pre>
<p>Like <a href="#Base.mapreduce-NTuple%7B4,Any%7D"><code>mapreduce</code></a>, but with guaranteed left associativity, as in <a href="#Base.foldl-Tuple%7BAny,Any,Any%7D"><code>foldl</code></a>. <code>v0</code> will be used exactly once.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L52-L57">source</a><br><h3 id="Base.mapfoldl-Tuple{Any,Any,Any}">
<code>Base.mapfoldl</code><span class="docstring-category">Method</span>
</h3>
<pre>mapfoldl(f, op, itr)</pre>
<p>Like <code>mapfoldl(f, op, v0, itr)</code>, but using the first element of <code>itr</code> as <code>v0</code>. In general, this cannot be used with empty collections (see <code>reduce(op, itr)</code>).</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L60-L65">source</a><br><h3 id="Base.mapfoldr-NTuple{4,Any}">
<code>Base.mapfoldr</code><span class="docstring-category">Method</span>
</h3>
<pre>mapfoldr(f, op, v0, itr)</pre>
<p>Like <a href="#Base.mapreduce-NTuple%7B4,Any%7D"><code>mapreduce</code></a>, but with guaranteed right associativity, as in <a href="#Base.foldr-Tuple%7BAny,Any,Any%7D"><code>foldr</code></a>. <code>v0</code> will be used exactly once.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L120-L125">source</a><br><h3 id="Base.mapfoldr-Tuple{Any,Any,Any}">
<code>Base.mapfoldr</code><span class="docstring-category">Method</span>
</h3>
<pre>mapfoldr(f, op, itr)</pre>
<p>Like <code>mapfoldr(f, op, v0, itr)</code>, but using the first element of <code>itr</code> as <code>v0</code>. In general, this cannot be used with empty collections (see <code>reduce(op, itr)</code>).</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/reduce.jl#L128-L133">source</a><br><h3 id="Base.first">
<code>Base.first</code><span class="docstring-category">Function</span>
</h3>
<pre>first(coll)</pre>
<p>Get the first element of an iterable collection. Returns the start point of a <code>Range</code> even if it is empty.</p>
<pre>julia&gt; first(2:2:10)
2

julia&gt; first([1; 2; 3; 4])
1</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarray.jl#L137-L150">source</a><br><h3 id="Base.last">
<code>Base.last</code><span class="docstring-category">Function</span>
</h3>
<pre>last(coll)</pre>
<p>Get the last element of an ordered collection, if it can be computed in O(1) time. This is accomplished by calling <a href="#Base.endof"><code>endof</code></a> to get the last index. Returns the end point of a <code>Range</code> even if it is empty.</p>
<pre>julia&gt; last(1:2:10)
9

julia&gt; last([1; 2; 3; 4])
4</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/abstractarray.jl#L157-L171">source</a><br><h3 id="Base.step">
<code>Base.step</code><span class="docstring-category">Function</span>
</h3>
<pre>step(r)</pre>
<p>Get the step size of a <code>Range</code> object.</p>
<pre>julia&gt; step(1:10)
1

julia&gt; step(1:2:10)
2

julia&gt; step(2.5:0.3:10.9)
0.3

julia&gt; step(linspace(2.5,10.9,85))
0.1</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/range.jl#L343-L360">source</a><br><h3 id="Base.collect-Tuple{Any}">
<code>Base.collect</code><span class="docstring-category">Method</span>
</h3>
<pre>collect(collection)</pre>
<p>Return an <code>Array</code> of all items in a collection or iterator. For associative collections, returns <code>Pair{KeyType, ValType}</code>. If the argument is array-like or is an iterator with the <code>HasShape()</code> trait, the result will have the same shape and number of dimensions as the argument.</p>
<p><strong>Example</strong></p>
<pre>julia&gt; collect(1:2:13)
7-element Array{Int64,1}:
  1
  3
  5
  7
  9
 11
 13</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L411-L430">source</a><br><h3 id="Base.collect-Tuple{Type,Any}">
<code>Base.collect</code><span class="docstring-category">Method</span>
</h3>
<pre>collect(element_type, collection)</pre>
<p>Return an <code>Array</code> with the given element type of all items in a collection or iterable. The result has the same shape and number of dimensions as <code>collection</code>.</p>
<pre>julia&gt; collect(Float64, 1:2:5)
3-element Array{Float64,1}:
 1.0
 3.0
 5.0</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L379-L392">source</a><br><h3 id="Base.issubset-Tuple{Any,Any}">
<code>Base.issubset</code><span class="docstring-category">Method</span>
</h3>
<pre>issubset(a, b)
⊆(a,b) -&gt; Bool
⊈(a,b) -&gt; Bool
⊊(a,b) -&gt; Bool</pre>
<p>Determine whether every element of <code>a</code> is also in <code>b</code>, using <a href="#Base.in"><code>in</code></a>.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; issubset([1, 2], [1, 2, 3])
true

julia&gt; issubset([1, 2, 3], [1, 2])
false</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2326-L2342">source</a><br><h3 id="Base.filter">
<code>Base.filter</code><span class="docstring-category">Function</span>
</h3>
<pre>filter(function, collection)</pre>
<p>Return a copy of <code>collection</code>, removing elements for which <code>function</code> is <code>false</code>. For associative collections, the function is passed two arguments (key and value).</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; a = 1:10
1:10

julia&gt; filter(isodd, a)
5-element Array{Int64,1}:
 1
 3
 5
 7
 9

julia&gt; d = Dict(1=&gt;"a", 2=&gt;"b")
Dict{Int64,String} with 2 entries:
  2 =&gt; "b"
  1 =&gt; "a"

julia&gt; filter((x,y)-&gt;isodd(x), d)
Dict{Int64,String} with 1 entry:
  1 =&gt; "a"</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L1874-L1902">source</a><br><pre>filter(p, x::Nullable)</pre>
<p>Return null if either <code>x</code> is null or <code>p(get(x))</code> is false, and <code>x</code> otherwise.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/nullable.jl#L251-L255">source</a><br><h3 id="Base.filter!">
<code>Base.filter!</code><span class="docstring-category">Function</span>
</h3>
<pre>filter!(function, collection)</pre>
<p>Update <code>collection</code>, removing elements for which <code>function</code> is <code>false</code>. For associative collections, the function is passed two arguments (key and value).</p>
<p><strong>Example</strong></p>
<pre>julia&gt; filter!(isodd, collect(1:10))
5-element Array{Int64,1}:
 1
 3
 5
 7
 9</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L313-L329">source</a><br><h2 id="Indexable-Collections-1">Indexable Collections</h2>
<h3 id="Base.getindex-Tuple{Any,Vararg{Any,N} where N}">
<code>Base.getindex</code><span class="docstring-category">Method</span>
</h3>
<pre>getindex(collection, key...)</pre>
<p>Retrieve the value(s) stored at the given key or index within a collection. The syntax <code>a[i,j,...]</code> is converted by the compiler to <code>getindex(a, i, j, ...)</code>.</p>
<p><strong>Example</strong></p>
<pre>julia&gt; A = Dict("a" =&gt; 1, "b" =&gt; 2)
Dict{String,Int64} with 2 entries:
  "b" =&gt; 2
  "a" =&gt; 1

julia&gt; getindex(A, "a")
1</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L150-L166">source</a><br><h3 id="Base.setindex!-Tuple{Any,Any,Vararg{Any,N} where N}">
<code>Base.setindex!</code><span class="docstring-category">Method</span>
</h3>
<pre>setindex!(collection, value, key...)</pre>
<p>Store the given value at the given key or index within a collection. The syntax <code>a[i,j,...] = x</code> is converted by the compiler to <code>(setindex!(a, x, i, j, ...); x)</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2295-L2300">source</a><br><p>Fully implemented by:</p>
<ul>
<li><p><a href="../arrays/#Core.Array"><code>Array</code></a></p></li>
<li><p><a href="../arrays/#Base.BitArray"><code>BitArray</code></a></p></li>
<li><p><a href="../arrays/#Core.AbstractArray"><code>AbstractArray</code></a></p></li>
<li><p><code>SubArray</code></p></li>
<li><p><a href="#Base.ObjectIdDict"><code>ObjectIdDict</code></a></p></li>
<li><p><a href="#Base.Dict"><code>Dict</code></a></p></li>
<li><p><a href="#Base.WeakKeyDict"><code>WeakKeyDict</code></a></p></li>
<li><p><code>AbstractString</code></p></li>
</ul>
<p>Partially implemented by:</p>
<ul>
<li><p><code>Range</code></p></li>
<li><p><code>UnitRange</code></p></li>
<li><p><code>Tuple</code></p></li>
</ul>
<h2 id="Associative-Collections-1">Associative Collections</h2>
<p><a href="#Base.Dict"><code>Dict</code></a> is the standard associative collection. Its implementation uses <a href="../base/#Base.hash"><code>hash()</code></a> as the hashing function for the key, and <a href="#"><code>isequal()</code></a> to determine equality. Define these two functions for custom types to override how they are stored in a hash table.</p>
<p><a href="#Base.ObjectIdDict"><code>ObjectIdDict</code></a> is a special hash table where the keys are always object identities.</p>
<p><a href="#Base.WeakKeyDict"><code>WeakKeyDict</code></a> is a hash table implementation where the keys are weak references to objects, and thus may be garbage collected even when referenced in a hash table.</p>
<p><a href="#Base.Dict"><code>Dict</code></a>s can be created by passing pair objects constructed with <code>=&gt;()</code> to a <a href="#Base.Dict"><code>Dict</code></a> constructor: <code>Dict("A"=&gt;1, "B"=&gt;2)</code>. This call will attempt to infer type information from the keys and values (i.e. this example creates a <code>Dict{String, Int64}</code>). To explicitly specify types use the syntax <code>Dict{KeyType,ValueType}(...)</code>. For example, <code>Dict{String,Int32}("A"=&gt;1, "B"=&gt;2)</code>.</p>
<p>Associative collections may also be created with generators. For example, <code>Dict(i =&gt; f(i) for i = 1:10)</code>.</p>
<p>Given a dictionary <code>D</code>, the syntax <code>D[x]</code> returns the value of key <code>x</code> (if it exists) or throws an error, and <code>D[x] = y</code> stores the key-value pair <code>x =&gt; y</code> in <code>D</code> (replacing any existing value for the key <code>x</code>). Multiple arguments to <code>D[...]</code> are converted to tuples; for example, the syntax <code>D[x,y]</code> is equivalent to <code>D[(x,y)]</code>, i.e. it refers to the value keyed by the tuple <code>(x,y)</code>.</p>
<h3 id="Base.Dict">
<code>Base.Dict</code><span class="docstring-category">Type</span>
</h3>
<pre>Dict([itr])</pre>
<p><code>Dict{K,V}()</code> constructs a hash table with keys of type <code>K</code> and values of type <code>V</code>.</p>
<p>Given a single iterable argument, constructs a <a href="#Base.Dict"><code>Dict</code></a> whose key-value pairs are taken from 2-tuples <code>(key,value)</code> generated by the argument.</p>
<pre>julia&gt; Dict([("A", 1), ("B", 2)])
Dict{String,Int64} with 2 entries:
  "B" =&gt; 2
  "A" =&gt; 1</pre>
<p>Alternatively, a sequence of pair arguments may be passed.</p>
<pre>julia&gt; Dict("A"=&gt;1, "B"=&gt;2)
Dict{String,Int64} with 2 entries:
  "B" =&gt; 2
  "A" =&gt; 1</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dict.jl#L68-L91">source</a><br><h3 id="Base.ObjectIdDict">
<code>Base.ObjectIdDict</code><span class="docstring-category">Type</span>
</h3>
<pre>ObjectIdDict([itr])</pre>
<p><code>ObjectIdDict()</code> constructs a hash table where the keys are (always) object identities. Unlike <code>Dict</code> it is not parameterized on its key and value type and thus its <code>eltype</code> is always <code>Pair{Any,Any}</code>.</p>
<p>See <a href="#Base.Dict"><code>Dict</code></a> for further help.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/associative.jl#L379-L387">source</a><br><h3 id="Base.WeakKeyDict">
<code>Base.WeakKeyDict</code><span class="docstring-category">Type</span>
</h3>
<pre>WeakKeyDict([itr])</pre>
<p><code>WeakKeyDict()</code> constructs a hash table where the keys are weak references to objects, and thus may be garbage collected even when referenced in a hash table.</p>
<p>See <a href="#Base.Dict"><code>Dict</code></a> for further help.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/weakkeydict.jl#L5-L13">source</a><br><h3 id="Base.haskey">
<code>Base.haskey</code><span class="docstring-category">Function</span>
</h3>
<pre>haskey(collection, key) -&gt; Bool</pre>
<p>Determine whether a collection has a mapping for a given key.</p>
<pre>julia&gt; a = Dict('a'=&gt;2, 'b'=&gt;3)
Dict{Char,Int64} with 2 entries:
  'b' =&gt; 3
  'a' =&gt; 2

julia&gt; haskey(a,'a')
true

julia&gt; haskey(a,'c')
false</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dict.jl#L487-L504">source</a><br><h3 id="Base.get-Tuple{Any,Any,Any}">
<code>Base.get</code><span class="docstring-category">Method</span>
</h3>
<pre>get(collection, key, default)</pre>
<p>Return the value stored for the given key, or the given default value if no mapping for the key is present.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; d = Dict("a"=&gt;1, "b"=&gt;2);

julia&gt; get(d, "a", 3)
1

julia&gt; get(d, "c", 3)
3</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1418-L1434">source</a><br><h3 id="Base.get">
<code>Base.get</code><span class="docstring-category">Function</span>
</h3>
<pre>get(f::Function, collection, key)</pre>
<p>Return the value stored for the given key, or if no mapping for the key is present, return <code>f()</code>. Use <a href="#Base.get!-Tuple%7BAny,Any,Any%7D"><code>get!</code></a> to also store the default value in the dictionary.</p>
<p>This is intended to be called using <code>do</code> block syntax</p>
<pre>get(dict, key) do
    # default value calculated here
    time()
end</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1437-L1451">source</a><br><h3 id="Base.get!-Tuple{Any,Any,Any}">
<code>Base.get!</code><span class="docstring-category">Method</span>
</h3>
<pre>get!(collection, key, default)</pre>
<p>Return the value stored for the given key, or if no mapping for the key is present, store <code>key =&gt; default</code>, and return <code>default</code>.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; d = Dict("a"=&gt;1, "b"=&gt;2, "c"=&gt;3);

julia&gt; get!(d, "a", 5)
1

julia&gt; get!(d, "d", 4)
4

julia&gt; d
Dict{String,Int64} with 4 entries:
  "c" =&gt; 3
  "b" =&gt; 2
  "a" =&gt; 1
  "d" =&gt; 4</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1947-L1970">source</a><br><h3 id="Base.get!-Tuple{Function,Any,Any}">
<code>Base.get!</code><span class="docstring-category">Method</span>
</h3>
<pre>get!(f::Function, collection, key)</pre>
<p>Return the value stored for the given key, or if no mapping for the key is present, store <code>key =&gt; f()</code>, and return <code>f()</code>.</p>
<p>This is intended to be called using <code>do</code> block syntax:</p>
<pre>get!(dict, key) do
    # default value calculated here
    time()
end</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1973-L1986">source</a><br><h3 id="Base.getkey">
<code>Base.getkey</code><span class="docstring-category">Function</span>
</h3>
<pre>getkey(collection, key, default)</pre>
<p>Return the key matching argument <code>key</code> if one exists in <code>collection</code>, otherwise return <code>default</code>.</p>
<pre>julia&gt; a = Dict('a'=&gt;2, 'b'=&gt;3)
Dict{Char,Int64} with 2 entries:
  'b' =&gt; 3
  'a' =&gt; 2

julia&gt; getkey(a,'a',1)
'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)

julia&gt; getkey(a,'d','a')
'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/dict.jl#L508-L525">source</a><br><h3 id="Base.delete!">
<code>Base.delete!</code><span class="docstring-category">Function</span>
</h3>
<pre>delete!(collection, key)</pre>
<p>Delete the mapping for the given key in a collection, and return the collection.</p>
<p><strong>Example</strong></p>
<pre>julia&gt; d = Dict("a"=&gt;1, "b"=&gt;2)
Dict{String,Int64} with 2 entries:
  "b" =&gt; 2
  "a" =&gt; 1

julia&gt; delete!(d, "b")
Dict{String,Int64} with 1 entry:
  "a" =&gt; 1</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1331-L1347">source</a><br><h3 id="Base.pop!-Tuple{Any,Any,Any}">
<code>Base.pop!</code><span class="docstring-category">Method</span>
</h3>
<pre>pop!(collection, key[, default])</pre>
<p>Delete and return the mapping for <code>key</code> if it exists in <code>collection</code>, otherwise return <code>default</code>, or throw an error if <code>default</code> is not specified.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; d = Dict("a"=&gt;1, "b"=&gt;2, "c"=&gt;3);

julia&gt; pop!(d, "a")
1

julia&gt; pop!(d, "d")
ERROR: KeyError: key "d" not found
Stacktrace:
 [1] pop!(::Dict{String,Int64}, ::String) at ./dict.jl:539

julia&gt; pop!(d, "e", 4)
4</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2600-L2621">source</a><br><h3 id="Base.keys">
<code>Base.keys</code><span class="docstring-category">Function</span>
</h3>
<pre>keys(a::Associative)</pre>
<p>Return an iterator over all keys in a collection. <code>collect(keys(a))</code> returns an array of keys. Since the keys are stored internally in a hash table, the order in which they are returned may vary. But <code>keys(a)</code> and <code>values(a)</code> both iterate <code>a</code> and return the elements in the same order.</p>
<pre>julia&gt; a = Dict('a'=&gt;2, 'b'=&gt;3)
Dict{Char,Int64} with 2 entries:
  'b' =&gt; 3
  'a' =&gt; 2

julia&gt; collect(keys(a))
2-element Array{Char,1}:
 'b'
 'a'</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/associative.jl#L63-L84">source</a><br><h3 id="Base.values">
<code>Base.values</code><span class="docstring-category">Function</span>
</h3>
<pre>values(a::Associative)</pre>
<p>Return an iterator over all values in a collection. <code>collect(values(a))</code> returns an array of values. Since the values are stored internally in a hash table, the order in which they are returned may vary. But <code>keys(a)</code> and <code>values(a)</code> both iterate <code>a</code> and return the elements in the same order.</p>
<pre>julia&gt; a = Dict('a'=&gt;2, 'b'=&gt;3)
Dict{Char,Int64} with 2 entries:
  'b' =&gt; 3
  'a' =&gt; 2

julia&gt; collect(values(a))
2-element Array{Int64,1}:
 3
 2</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/associative.jl#L88-L109">source</a><br><h3 id="Base.merge">
<code>Base.merge</code><span class="docstring-category">Function</span>
</h3>
<pre>merge(d::Associative, others::Associative...)</pre>
<p>Construct a merged collection from the given collections. If necessary, the types of the resulting collection will be promoted to accommodate the types of the merged collections. If the same key is present in another collection, the value for that key will be the value it has in the last collection listed.</p>
<pre>julia&gt; a = Dict("foo" =&gt; 0.0, "bar" =&gt; 42.0)
Dict{String,Float64} with 2 entries:
  "bar" =&gt; 42.0
  "foo" =&gt; 0.0

julia&gt; b = Dict("baz" =&gt; 17, "bar" =&gt; 4711)
Dict{String,Int64} with 2 entries:
  "bar" =&gt; 4711
  "baz" =&gt; 17

julia&gt; merge(a, b)
Dict{String,Float64} with 3 entries:
  "bar" =&gt; 4711.0
  "baz" =&gt; 17.0
  "foo" =&gt; 0.0

julia&gt; merge(b, a)
Dict{String,Float64} with 3 entries:
  "bar" =&gt; 42.0
  "baz" =&gt; 17.0
  "foo" =&gt; 0.0</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/associative.jl#L224-L255">source</a><br><pre>merge(combine, d::Associative, others::Associative...)</pre>
<p>Construct a merged collection from the given collections. If necessary, the types of the resulting collection will be promoted to accommodate the types of the merged collections. Values with the same key will be combined using the combiner function.</p>
<pre>julia&gt; a = Dict("foo" =&gt; 0.0, "bar" =&gt; 42.0)
Dict{String,Float64} with 2 entries:
  "bar" =&gt; 42.0
  "foo" =&gt; 0.0

julia&gt; b = Dict("baz" =&gt; 17, "bar" =&gt; 4711)
Dict{String,Int64} with 2 entries:
  "bar" =&gt; 4711
  "baz" =&gt; 17

julia&gt; merge(+, a, b)
Dict{String,Float64} with 3 entries:
  "bar" =&gt; 4753.0
  "baz" =&gt; 17.0
  "foo" =&gt; 0.0</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/associative.jl#L259-L284">source</a><br><h3 id="Base.merge!">
<code>Base.merge!</code><span class="docstring-category">Function</span>
</h3>
<pre>merge!(d::Associative, others::Associative...)</pre>
<p>Update collection with pairs from the other collections. See also <a href="#Base.merge"><code>merge</code></a>.</p>
<pre>julia&gt; d1 = Dict(1 =&gt; 2, 3 =&gt; 4);

julia&gt; d2 = Dict(1 =&gt; 4, 4 =&gt; 5);

julia&gt; merge!(d1, d2);

julia&gt; d1
Dict{Int64,Int64} with 3 entries:
  4 =&gt; 5
  3 =&gt; 4
  1 =&gt; 4</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/associative.jl#L120-L139">source</a><br><pre>merge!(combine, d::Associative, others::Associative...)</pre>
<p>Update collection with pairs from the other collections. Values with the same key will be combined using the combiner function.</p>
<pre>julia&gt; d1 = Dict(1 =&gt; 2, 3 =&gt; 4);

julia&gt; d2 = Dict(1 =&gt; 4, 4 =&gt; 5);

julia&gt; merge!(+, d1, d2);

julia&gt; d1
Dict{Int64,Int64} with 3 entries:
  4 =&gt; 5
  3 =&gt; 4
  1 =&gt; 6

julia&gt; merge!(-, d1, d1);

julia&gt; d1
Dict{Int64,Int64} with 3 entries:
  4 =&gt; 0
  3 =&gt; 0
  1 =&gt; 0</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/associative.jl#L149-L177">source</a><br><p>Merge changes into current head </p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/merge.jl#L66">source</a><br><p>Internal implementation of merge. Returns <code>true</code> if merge was successful, otherwise <code>false</code></p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/merge.jl#L80-L83">source</a><br><pre>merge!(repo::GitRepo; kwargs...) -&gt; Bool</pre>
<p>Perform a git merge on the repository <code>repo</code>, merging commits with diverging history into the current branch. Returns <code>true</code> if the merge succeeded, <code>false</code> if not.</p>
<p>The keyword arguments are:</p>
<ul>
<li><p><code>committish::AbstractString=""</code>: Merge the named commit(s) in <code>committish</code>.</p></li>
<li><p><code>branch::AbstractString=""</code>: Merge the branch <code>branch</code> and all its commits since it diverged from the current branch.</p></li>
<li><p><code>fastforward::Bool=false</code>: If <code>fastforward</code> is <code>true</code>, only merge if the merge is a fast-forward (the current branch head is an ancestor of the commits to be merged), otherwise refuse to merge and return <code>false</code>. This is equivalent to the git CLI option <code>--ff-only</code>.</p></li>
<li><p><code>merge_opts::MergeOptions=MergeOptions()</code>: <code>merge_opts</code> specifies options for the merge, such as merge strategy in case of conflicts.</p></li>
<li><p><code>checkout_opts::CheckoutOptions=CheckoutOptions()</code>: <code>checkout_opts</code> specifies options for the checkout step.</p></li>
</ul>
<p>Equivalent to <code>git merge [--ff-only] [&lt;committish&gt; | &lt;branch&gt;]</code>.</p>
<div class="admonition note">
<div class="admonition-title">Note</div>
<div class="admonition-text"><p>If you specify a <code>branch</code>, this must be done in reference format, since the string will be turned into a <code>GitReference</code>. For example, if you wanted to merge branch <code>branch_a</code>, you would call <code>merge!(repo, branch="refs/heads/branch_a")</code>.</p></div>
</div>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/libgit2/libgit2.jl#L625-L652">source</a><br><h3 id="Base.sizehint!">
<code>Base.sizehint!</code><span class="docstring-category">Function</span>
</h3>
<pre>sizehint!(s, n)</pre>
<p>Suggest that collection <code>s</code> reserve capacity for at least <code>n</code> elements. This can improve performance.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1114-L1118">source</a><br><h3 id="Base.keytype">
<code>Base.keytype</code><span class="docstring-category">Function</span>
</h3>
<pre>keytype(type)</pre>
<p>Get the key type of an associative collection type. Behaves similarly to <a href="#Base.eltype"><code>eltype</code></a>.</p>
<pre>julia&gt; keytype(Dict(Int32(1) =&gt; "foo"))
Int32</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/associative.jl#L196-L205">source</a><br><h3 id="Base.valtype">
<code>Base.valtype</code><span class="docstring-category">Function</span>
</h3>
<pre>valtype(type)</pre>
<p>Get the value type of an associative collection type. Behaves similarly to <a href="#Base.eltype"><code>eltype</code></a>.</p>
<pre>julia&gt; valtype(Dict(Int32(1) =&gt; "foo"))
String</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/associative.jl#L210-L219">source</a><br><p>Fully implemented by:</p>
<ul>
<li><p><a href="#Base.ObjectIdDict"><code>ObjectIdDict</code></a></p></li>
<li><p><a href="#Base.Dict"><code>Dict</code></a></p></li>
<li><p><a href="#Base.WeakKeyDict"><code>WeakKeyDict</code></a></p></li>
</ul>
<p>Partially implemented by:</p>
<ul>
<li><p><a href="#Base.IntSet"><code>IntSet</code></a></p></li>
<li><p><a href="#Base.Set"><code>Set</code></a></p></li>
<li><p><a href="../base/#Base.EnvHash"><code>EnvHash</code></a></p></li>
<li><p><a href="../arrays/#Core.Array"><code>Array</code></a></p></li>
<li><p><a href="../arrays/#Base.BitArray"><code>BitArray</code></a></p></li>
</ul>
<h2 id="Set-Like-Collections-1">Set-Like Collections</h2>
<h3 id="Base.Set">
<code>Base.Set</code><span class="docstring-category">Type</span>
</h3>
<pre>Set([itr])</pre>
<p>Construct a <a href="#Base.Set"><code>Set</code></a> of the values generated by the given iterable object, or an empty set. Should be used instead of <a href="#Base.IntSet"><code>IntSet</code></a> for sparse integer sets, or for sets of arbitrary objects.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2557-L2563">source</a><br><h3 id="Base.IntSet">
<code>Base.IntSet</code><span class="docstring-category">Type</span>
</h3>
<pre>IntSet([itr])</pre>
<p>Construct a sorted set of positive <code>Int</code>s generated by the given iterable object, or an empty set. Implemented as a bit string, and therefore designed for dense integer sets. Only <code>Int</code>s greater than 0 can be stored. If the set will be sparse (for example holding a few very large integers), use <a href="#Base.Set"><code>Set</code></a> instead.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1630-L1637">source</a><br><h3 id="Base.union">
<code>Base.union</code><span class="docstring-category">Function</span>
</h3>
<pre>union(s1,s2...)
∪(s1,s2...)</pre>
<p>Construct the union of two or more sets. Maintains order with arrays.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; union([1, 2], [3, 4])
4-element Array{Int64,1}:
 1
 2
 3
 4

julia&gt; union([1, 2], [2, 4])
3-element Array{Int64,1}:
 1
 2
 4

julia&gt; union([4, 2], [1, 2])
3-element Array{Int64,1}:
 4
 2
 1</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L944-L971">source</a><br><h3 id="Base.union!">
<code>Base.union!</code><span class="docstring-category">Function</span>
</h3>
<pre>union!(s, iterable)</pre>
<p>Union each element of <code>iterable</code> into set <code>s</code> in-place.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2511-L2515">source</a><br><h3 id="Base.intersect">
<code>Base.intersect</code><span class="docstring-category">Function</span>
</h3>
<pre>intersect(s1,s2...)
∩(s1,s2)</pre>
<p>Construct the intersection of two or more sets. Maintains order and multiplicity of the first argument for arrays and ranges.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2069-L2075">source</a><br><h3 id="Base.setdiff">
<code>Base.setdiff</code><span class="docstring-category">Function</span>
</h3>
<pre>setdiff(a, b)</pre>
<p>Construct the set of elements in <code>a</code> but not <code>b</code>. Maintains order with arrays. Note that both arguments must be collections, and both will be iterated over. In particular, <code>setdiff(set,element)</code> where <code>element</code> is a potential member of <code>set</code>, will not work in general.</p>
<p><strong>Example</strong></p>
<pre>julia&gt; setdiff([1,2,3],[3,4,5])
2-element Array{Int64,1}:
 1
 2</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L1968-L1983">source</a><br><h3 id="Base.setdiff!">
<code>Base.setdiff!</code><span class="docstring-category">Function</span>
</h3>
<pre>setdiff!(s, iterable)</pre>
<p>Remove each element of <code>iterable</code> from set <code>s</code> in-place.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L792-L796">source</a><br><h3 id="Base.symdiff">
<code>Base.symdiff</code><span class="docstring-category">Function</span>
</h3>
<pre>symdiff(a, b, rest...)</pre>
<p>Construct the symmetric difference of elements in the passed in sets or arrays. Maintains order with arrays.</p>
<p><strong>Example</strong></p>
<pre>julia&gt; symdiff([1,2,3],[3,4,5],[4,5,6])
3-element Array{Int64,1}:
 1
 2
 6</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L2004-L2018">source</a><br><h3 id="Base.symdiff!-Tuple{IntSet,Integer}">
<code>Base.symdiff!</code><span class="docstring-category">Method</span>
</h3>
<pre>symdiff!(s, n)</pre>
<p>The set <code>s</code> is destructively modified to toggle the inclusion of integer <code>n</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/intset.jl#L137-L141">source</a><br><h3 id="Base.symdiff!-Tuple{IntSet,Any}">
<code>Base.symdiff!</code><span class="docstring-category">Method</span>
</h3>
<pre>symdiff!(s, itr)</pre>
<p>For each element in <code>itr</code>, destructively toggle its inclusion in set <code>s</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/intset.jl#L131-L135">source</a><br><h3 id="Base.symdiff!-Tuple{IntSet,IntSet}">
<code>Base.symdiff!</code><span class="docstring-category">Method</span>
</h3>
<pre>symdiff!(s, itr)</pre>
<p>For each element in <code>itr</code>, destructively toggle its inclusion in set <code>s</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/intset.jl#L131-L135">source</a><br><h3 id="Base.intersect!">
<code>Base.intersect!</code><span class="docstring-category">Function</span>
</h3>
<pre>intersect!(s1::IntSet, s2::IntSet)</pre>
<p>Intersects sets <code>s1</code> and <code>s2</code> and overwrites the set <code>s1</code> with the result. If needed, <code>s1</code> will be expanded to the size of <code>s2</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/intset.jl#L112-L117">source</a><br><h3 id="Base.issubset">
<code>Base.issubset</code><span class="docstring-category">Function</span>
</h3>
<pre>issubset(A, S) -&gt; Bool
⊆(A,S) -&gt; Bool</pre>
<p>Return <code>true</code> if <code>A</code> is a subset of or equal to <code>S</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2345-L2350">source</a><br><p>Fully implemented by:</p>
<ul>
<li><p><a href="#Base.IntSet"><code>IntSet</code></a></p></li>
<li><p><a href="#Base.Set"><code>Set</code></a></p></li>
</ul>
<p>Partially implemented by:</p>
<ul><li><p><a href="../arrays/#Core.Array"><code>Array</code></a></p></li></ul>
<h2 id="Dequeues-1">Dequeues</h2>
<h3 id="Base.push!">
<code>Base.push!</code><span class="docstring-category">Function</span>
</h3>
<pre>push!(collection, items...) -&gt; collection</pre>
<p>Insert one or more <code>items</code> at the end of <code>collection</code>.</p>
<p><strong>Example</strong></p>
<pre>julia&gt; push!([1, 2, 3], 4, 5, 6)
6-element Array{Int64,1}:
 1
 2
 3
 4
 5
 6</pre>
<p>Use <a href="#Base.append!"><code>append!</code></a> to add all the elements of another collection to <code>collection</code>. The result of the preceding example is equivalent to <code>append!([1, 2, 3], [4, 5, 6])</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L384-L404">source</a><br><h3 id="Base.pop!-Tuple{Any}">
<code>Base.pop!</code><span class="docstring-category">Method</span>
</h3>
<pre>pop!(collection) -&gt; item</pre>
<p>Remove the last item in <code>collection</code> and return it.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; A=[1, 2, 3, 4, 5, 6]
6-element Array{Int64,1}:
 1
 2
 3
 4
 5
 6

julia&gt; pop!(A)
6

julia&gt; A
5-element Array{Int64,1}:
 1
 2
 3
 4
 5</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2624-L2651">source</a><br><h3 id="Base.unshift!">
<code>Base.unshift!</code><span class="docstring-category">Function</span>
</h3>
<pre>unshift!(collection, items...) -&gt; collection</pre>
<p>Insert one or more <code>items</code> at the beginning of <code>collection</code>.</p>
<p><strong>Example</strong></p>
<pre>julia&gt; unshift!([1, 2, 3, 4], 5, 6)
6-element Array{Int64,1}:
 5
 6
 1
 2
 3
 4</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L798-L814">source</a><br><h3 id="Base.shift!">
<code>Base.shift!</code><span class="docstring-category">Function</span>
</h3>
<pre>shift!(collection) -&gt; item</pre>
<p>Remove the first <code>item</code> from <code>collection</code>.</p>
<p><strong>Example</strong></p>
<pre>julia&gt; A = [1, 2, 3, 4, 5, 6]
6-element Array{Int64,1}:
 1
 2
 3
 4
 5
 6

julia&gt; shift!(A)
1

julia&gt; A
5-element Array{Int64,1}:
 2
 3
 4
 5
 6</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1489-L1516">source</a><br><h3 id="Base.insert!">
<code>Base.insert!</code><span class="docstring-category">Function</span>
</h3>
<pre>insert!(a::Vector, index::Integer, item)</pre>
<p>Insert an <code>item</code> into <code>a</code> at the given <code>index</code>. <code>index</code> is the index of <code>item</code> in the resulting <code>a</code>.</p>
<p><strong>Example</strong></p>
<pre>julia&gt; insert!([6, 5, 4, 2, 1], 4, 3)
6-element Array{Int64,1}:
 6
 5
 4
 3
 2
 1</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L831-L848">source</a><br><h3 id="Base.deleteat!">
<code>Base.deleteat!</code><span class="docstring-category">Function</span>
</h3>
<pre>deleteat!(a::Vector, i::Integer)</pre>
<p>Remove the item at the given <code>i</code> and return the modified <code>a</code>. Subsequent items are shifted to fill the resulting gap.</p>
<p><strong>Example</strong></p>
<pre>julia&gt; deleteat!([6, 5, 4, 3, 2, 1], 2)
5-element Array{Int64,1}:
 6
 4
 3
 2
 1</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L858-L874">source</a><br><pre>deleteat!(a::Vector, inds)</pre>
<p>Remove the items at the indices given by <code>inds</code>, and return the modified <code>a</code>. Subsequent items are shifted to fill the resulting gap.</p>
<p><code>inds</code> can be either an iterator or a collection of sorted and unique integer indices, or a boolean vector of the same length as <code>a</code> with <code>true</code> indicating entries to delete.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; deleteat!([6, 5, 4, 3, 2, 1], 1:2:5)
3-element Array{Int64,1}:
 5
 3
 1

julia&gt; deleteat!([6, 5, 4, 3, 2, 1], [true, false, true, false, true, false])
3-element Array{Int64,1}:
 5
 3
 1

julia&gt; deleteat!([6, 5, 4, 3, 2, 1], (2, 2))
ERROR: ArgumentError: indices must be unique and sorted
Stacktrace:
 [1] _deleteat!(::Array{Int64,1}, ::Tuple{Int64,Int64}) at ./array.jl:926
 [2] deleteat!(::Array{Int64,1}, ::Tuple{Int64,Int64}) at ./array.jl:913</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L883-L912">source</a><br><h3 id="Base.splice!">
<code>Base.splice!</code><span class="docstring-category">Function</span>
</h3>
<pre>splice!(a::Vector, index::Integer, [replacement]) -&gt; item</pre>
<p>Remove the item at the given index, and return the removed item. Subsequent items are shifted left to fill the resulting gap. If specified, replacement values from an ordered collection will be spliced in place of the removed item.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; A = [6, 5, 4, 3, 2, 1]; splice!(A, 5)
2

julia&gt; A
5-element Array{Int64,1}:
 6
 5
 4
 3
 1

julia&gt; splice!(A, 5, -1)
1

julia&gt; A
5-element Array{Int64,1}:
  6
  5
  4
  3
 -1

julia&gt; splice!(A, 1, [-1, -2, -3])
6

julia&gt; A
7-element Array{Int64,1}:
 -1
 -2
 -3
  5
  4
  3
 -1</pre>
<p>To insert <code>replacement</code> before an index <code>n</code> without removing any items, use <code>splice!(collection, n:n-1, replacement)</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L960-L1008">source</a><br><pre>splice!(a::Vector, range, [replacement]) -&gt; items</pre>
<p>Remove items in the specified index range, and return a collection containing the removed items. Subsequent items are shifted left to fill the resulting gap. If specified, replacement values from an ordered collection will be spliced in place of the removed items.</p>
<p>To insert <code>replacement</code> before an index <code>n</code> without removing any items, use <code>splice!(collection, n:n-1, replacement)</code>.</p>
<p><strong>Example</strong></p>
<pre>julia&gt; splice!(A, 4:3, 2)
0-element Array{Int64,1}

julia&gt; A
8-element Array{Int64,1}:
 -1
 -2
 -3
  2
  5
  4
  3
 -1</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L1027-L1055">source</a><br><h3 id="Base.resize!">
<code>Base.resize!</code><span class="docstring-category">Function</span>
</h3>
<pre>resize!(a::Vector, n::Integer) -&gt; Vector</pre>
<p>Resize <code>a</code> to contain <code>n</code> elements. If <code>n</code> is smaller than the current collection length, the first <code>n</code> elements will be retained. If <code>n</code> is larger, the new elements are not guaranteed to be initialized.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; resize!([6, 5, 4, 3, 2, 1], 3)
3-element Array{Int64,1}:
 6
 5
 4

julia&gt; a = resize!([6, 5, 4, 3, 2, 1], 8);

julia&gt; length(a)
8

julia&gt; a[1:6]
6-element Array{Int64,1}:
 6
 5
 4
 3
 2
 1</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L741-L770">source</a><br><h3 id="Base.append!">
<code>Base.append!</code><span class="docstring-category">Function</span>
</h3>
<pre>append!(collection, collection2) -&gt; collection.</pre>
<p>Add the elements of <code>collection2</code> to the end of <code>collection</code>.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; append!([1],[2,3])
3-element Array{Int64,1}:
 1
 2
 3

julia&gt; append!([1, 2, 3], [4, 5, 6])
6-element Array{Int64,1}:
 1
 2
 3
 4
 5
 6</pre>
<p>Use <a href="#Base.push!"><code>push!</code></a> to add individual items to <code>collection</code> which are not already themselves in another collection. The result is of the preceding example is equivalent to <code>push!([1, 2, 3], 4, 5, 6)</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L756-L782">source</a><br><h3 id="Base.prepend!">
<code>Base.prepend!</code><span class="docstring-category">Function</span>
</h3>
<pre>prepend!(a::Vector, items) -&gt; collection</pre>
<p>Insert the elements of <code>items</code> to the beginning of <code>a</code>.</p>
<p><strong>Example</strong></p>
<pre>julia&gt; prepend!([3],[1,2])
3-element Array{Int64,1}:
 1
 2
 3</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/array.jl#L690-L703">source</a><br><p>Fully implemented by:</p>
<ul>
<li><p><code>Vector</code> (a.k.a. 1-dimensional <a href="../arrays/#Core.Array"><code>Array</code></a>)</p></li>
<li><p><code>BitVector</code> (a.k.a. 1-dimensional <a href="../arrays/#Base.BitArray"><code>BitArray</code></a>)</p></li>
</ul>
<div class="_attribution">
  <p class="_attribution-p">
    © 2009–2016 Jeff Bezanson, Stefan Karpinski, Viral B. Shah, and other contributors<br>Licensed under the MIT License.<br>
    <a href="https://docs.julialang.org/en/release-0.6/stdlib/collections/" class="_attribution-link" target="_blank">https://docs.julialang.org/en/release-0.6/stdlib/collections/</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
