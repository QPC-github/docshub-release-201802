
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Numbers - Julia 0.6 - W3cubDocs</title>
  
  <meta name="description" content=" Abstract supertype for all number types. ">
  <meta name="keywords" content="numbers, -, julia, julia~0.6">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/julia~0.6/stdlib/numbers/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-e0f881b0fce8cbe96f33dadc355b7159d5d2912911231446d60eb8f9caffa802.css">
  <script type="text/javascript" src="/assets/application-8fc46316434047265cd383f02b8e7f434ed7dec4a59f920dd633deef8d488d1b.js"></script>
  <script src="/json/julia~0.6.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/julia~0.6/" class="_nav-link" title="" style="margin-left:0;">Julia 0.6</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _julia">
				
<h1 id="lib-numbers-1">Numbers</h1>
<h2 id="Standard-Numeric-Types-1">Standard Numeric Types</h2>
<h3 id="Abstract-number-types-1">Abstract number types</h3>
<h3 id="Core.Number">
<code>Core.Number</code><span class="docstring-category">Type</span>
</h3>
<pre>Number</pre>
<p>Abstract supertype for all number types.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2668-L2672">source</a><br><h3 id="Core.Real">
<code>Core.Real</code><span class="docstring-category">Type</span>
</h3>
<pre>Real &lt;: Number</pre>
<p>Abstract supertype for all real numbers.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2675-L2679">source</a><br><h3 id="Core.AbstractFloat">
<code>Core.AbstractFloat</code><span class="docstring-category">Type</span>
</h3>
<pre>AbstractFloat &lt;: Real</pre>
<p>Abstract supertype for all floating point numbers.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2682-L2686">source</a><br><h3 id="Core.Integer">
<code>Core.Integer</code><span class="docstring-category">Type</span>
</h3>
<pre>Integer &lt;: Real</pre>
<p>Abstract supertype for all integers.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2689-L2693">source</a><br><h3 id="Core.Signed">
<code>Core.Signed</code><span class="docstring-category">Type</span>
</h3>
<pre>Signed &lt;: Integer</pre>
<p>Abstract supertype for all signed integers.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2696-L2700">source</a><br><h3 id="Core.Unsigned">
<code>Core.Unsigned</code><span class="docstring-category">Type</span>
</h3>
<pre>Unsigned &lt;: Integer</pre>
<p>Abstract supertype for all unsigned integers.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2703-L2707">source</a><br><h3 id="Concrete-number-types-1">Concrete number types</h3>
<h3 id="Core.Float16">
<code>Core.Float16</code><span class="docstring-category">Type</span>
</h3>
<pre>Float16 &lt;: AbstractFloat</pre>
<p>16-bit floating point number type.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2719-L2723">source</a><br><h3 id="Core.Float32">
<code>Core.Float32</code><span class="docstring-category">Type</span>
</h3>
<pre>Float32 &lt;: AbstractFloat</pre>
<p>32-bit floating point number type.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2719-L2723">source</a><br><h3 id="Core.Float64">
<code>Core.Float64</code><span class="docstring-category">Type</span>
</h3>
<pre>Float64 &lt;: AbstractFloat</pre>
<p>64-bit floating point number type.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2719-L2723">source</a><br><h3 id="Base.MPFR.BigFloat">
<code>Base.MPFR.BigFloat</code><span class="docstring-category">Type</span>
</h3>
<pre>BigFloat &lt;: AbstractFloat</pre>
<p>Arbitrary precision floating point number type.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/mpfr.jl#L43-L47">source</a><br><h3 id="Core.Bool">
<code>Core.Bool</code><span class="docstring-category">Type</span>
</h3>
<pre>Bool &lt;: Integer</pre>
<p>Boolean type.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2710-L2714">source</a><br><h3 id="Core.Int8">
<code>Core.Int8</code><span class="docstring-category">Type</span>
</h3>
<pre>Int8 &lt;: Signed</pre>
<p>8-bit signed integer type.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2730-L2734">source</a><br><h3 id="Core.UInt8">
<code>Core.UInt8</code><span class="docstring-category">Type</span>
</h3>
<pre>UInt8 &lt;: Unsigned</pre>
<p>8-bit unsigned integer type.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2737-L2741">source</a><br><h3 id="Core.Int16">
<code>Core.Int16</code><span class="docstring-category">Type</span>
</h3>
<pre>Int16 &lt;: Signed</pre>
<p>16-bit signed integer type.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2730-L2734">source</a><br><h3 id="Core.UInt16">
<code>Core.UInt16</code><span class="docstring-category">Type</span>
</h3>
<pre>UInt16 &lt;: Unsigned</pre>
<p>16-bit unsigned integer type.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2737-L2741">source</a><br><h3 id="Core.Int32">
<code>Core.Int32</code><span class="docstring-category">Type</span>
</h3>
<pre>Int32 &lt;: Signed</pre>
<p>32-bit signed integer type.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2730-L2734">source</a><br><h3 id="Core.UInt32">
<code>Core.UInt32</code><span class="docstring-category">Type</span>
</h3>
<pre>UInt32 &lt;: Unsigned</pre>
<p>32-bit unsigned integer type.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2737-L2741">source</a><br><h3 id="Core.Int64">
<code>Core.Int64</code><span class="docstring-category">Type</span>
</h3>
<pre>Int64 &lt;: Signed</pre>
<p>64-bit signed integer type.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2730-L2734">source</a><br><h3 id="Core.UInt64">
<code>Core.UInt64</code><span class="docstring-category">Type</span>
</h3>
<pre>UInt64 &lt;: Unsigned</pre>
<p>64-bit unsigned integer type.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2737-L2741">source</a><br><h3 id="Core.Int128">
<code>Core.Int128</code><span class="docstring-category">Type</span>
</h3>
<pre>Int128 &lt;: Signed</pre>
<p>128-bit signed integer type.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2730-L2734">source</a><br><h3 id="Core.UInt128">
<code>Core.UInt128</code><span class="docstring-category">Type</span>
</h3>
<pre>UInt128 &lt;: Unsigned</pre>
<p>128-bit unsigned integer type.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2737-L2741">source</a><br><h3 id="Base.GMP.BigInt">
<code>Base.GMP.BigInt</code><span class="docstring-category">Type</span>
</h3>
<pre>BigInt &lt;: Integer</pre>
<p>Arbitrary precision integer type.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/gmp.jl#L40-L44">source</a><br><h3 id="Base.Complex">
<code>Base.Complex</code><span class="docstring-category">Type</span>
</h3>
<pre>Complex{T&lt;:Real} &lt;: Number</pre>
<p>Complex number type with real and imaginary part of type <code>T</code>.</p>
<p><code>Complex32</code>, <code>Complex64</code> and <code>Complex128</code> are aliases for <code>Complex{Float16}</code>, <code>Complex{Float32}</code> and <code>Complex{Float64}</code> respectively.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/complex.jl#L3-L10">source</a><br><h3 id="Base.Rational">
<code>Base.Rational</code><span class="docstring-category">Type</span>
</h3>
<pre>Rational{T&lt;:Integer} &lt;: Real</pre>
<p>Rational number type, with numerator and denominator of type <code>T</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/rational.jl#L3-L7">source</a><br><h3 id="Base.Irrational">
<code>Base.Irrational</code><span class="docstring-category">Type</span>
</h3>
<pre>Irrational &lt;: Real</pre>
<p>Irrational number type.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/irrationals.jl#L5-L9">source</a><br><h2 id="Data-Formats-1">Data Formats</h2>
<h3 id="Base.bin">
<code>Base.bin</code><span class="docstring-category">Function</span>
</h3>
<pre>bin(n, pad::Int=1)</pre>
<p>Convert an integer to a binary string, optionally specifying a number of digits to pad to.</p>
<pre>julia&gt; bin(10,2)
"1010"

julia&gt; bin(10,8)
"00001010"</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/intfuncs.jl#L601-L613">source</a><br><h3 id="Base.hex">
<code>Base.hex</code><span class="docstring-category">Function</span>
</h3>
<pre>hex(n, pad::Int=1)</pre>
<p>Convert an integer to a hexadecimal string, optionally specifying a number of digits to pad to.</p>
<pre>julia&gt; hex(20)
"14"

julia&gt; hex(20, 3)
"014"</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/intfuncs.jl#L616-L629">source</a><br><h3 id="Base.dec">
<code>Base.dec</code><span class="docstring-category">Function</span>
</h3>
<pre>dec(n, pad::Int=1)</pre>
<p>Convert an integer to a decimal string, optionally specifying a number of digits to pad to.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; dec(20)
"20"

julia&gt; dec(20, 3)
"020"</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/intfuncs.jl#L648-L662">source</a><br><h3 id="Base.oct">
<code>Base.oct</code><span class="docstring-category">Function</span>
</h3>
<pre>oct(n, pad::Int=1)</pre>
<p>Convert an integer to an octal string, optionally specifying a number of digits to pad to.</p>
<pre>julia&gt; oct(20)
"24"

julia&gt; oct(20, 3)
"024"</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/intfuncs.jl#L632-L645">source</a><br><h3 id="Base.base">
<code>Base.base</code><span class="docstring-category">Function</span>
</h3>
<pre>base(base::Integer, n::Integer, pad::Integer=1)</pre>
<p>Convert an integer <code>n</code> to a string in the given <code>base</code>, optionally specifying a number of digits to pad to.</p>
<pre>julia&gt; base(13,5,4)
"0005"

julia&gt; base(5,13,4)
"0023"</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/intfuncs.jl#L574-L587">source</a><br><h3 id="Base.digits">
<code>Base.digits</code><span class="docstring-category">Function</span>
</h3>
<pre>digits([T&lt;:Integer], n::Integer, base::T=10, pad::Integer=1)</pre>
<p>Returns an array with element type <code>T</code> (default <code>Int</code>) of the digits of <code>n</code> in the given base, optionally padded with zeros to a specified size. More significant digits are at higher indexes, such that <code>n == sum([digits[k]*base^(k-1) for k=1:length(digits)])</code>.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; digits(10, 10)
2-element Array{Int64,1}:
 0
 1

julia&gt; digits(10, 2)
4-element Array{Int64,1}:
 0
 1
 0
 1

julia&gt; digits(10, 2, 6)
6-element Array{Int64,1}:
 0
 1
 0
 1
 0
 0</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/intfuncs.jl#L671-L701">source</a><br><h3 id="Base.digits!">
<code>Base.digits!</code><span class="docstring-category">Function</span>
</h3>
<pre>digits!(array, n::Integer, base::Integer=10)</pre>
<p>Fills an array of the digits of <code>n</code> in the given base. More significant digits are at higher indexes. If the array length is insufficient, the least significant digits are filled up to the array length. If the array length is excessive, the excess portion is filled with zeros.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; digits!([2,2,2,2], 10, 2)
4-element Array{Int64,1}:
 0
 1
 0
 1

julia&gt; digits!([2,2,2,2,2,2], 10, 2)
6-element Array{Int64,1}:
 0
 1
 0
 1
 0
 0</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/intfuncs.jl#L709-L734">source</a><br><h3 id="Base.bits">
<code>Base.bits</code><span class="docstring-category">Function</span>
</h3>
<pre>bits(n)</pre>
<p>A string giving the literal bit representation of a number.</p>
<p><strong>Example</strong></p>
<pre>julia&gt; bits(4)
"0000000000000000000000000000000000000000000000000000000000000100"

julia&gt; bits(2.2)
"0100000000000001100110011001100110011001100110011001100110011010"</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L80-L93">source</a><br><h3 id="Base.parse-Tuple{Type,Any,Any}">
<code>Base.parse</code><span class="docstring-category">Method</span>
</h3>
<pre>parse(type, str, [base])</pre>
<p>Parse a string as a number. If the type is an integer type, then a base can be specified (the default is 10). If the type is a floating point type, the string is parsed as a decimal floating point number. If the string does not contain a valid number, an error is raised.</p>
<pre>julia&gt; parse(Int, "1234")
1234

julia&gt; parse(Int, "1234", 5)
194

julia&gt; parse(Int, "afc", 16)
2812

julia&gt; parse(Float64, "1.2e-3")
0.0012</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1201-L1221">source</a><br><h3 id="Base.tryparse">
<code>Base.tryparse</code><span class="docstring-category">Function</span>
</h3>
<pre>tryparse(type, str, [base])</pre>
<p>Like <a href="#Base.parse-Tuple%7BType,Any,Any%7D"><code>parse</code></a>, but returns a <a href="../base/#Base.Nullable"><code>Nullable</code></a> of the requested type. The result will be null if the string does not contain a valid number.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2478-L2483">source</a><br><h3 id="Base.big">
<code>Base.big</code><span class="docstring-category">Function</span>
</h3>
<pre>big(x)</pre>
<p>Convert a number to a maximum precision representation (typically <a href="#Base.GMP.BigInt"><code>BigInt</code></a> or <code>BigFloat</code>). See <a href="#Base.MPFR.BigFloat"><code>BigFloat</code></a> for information about some pitfalls with floating-point numbers.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1373-L1378">source</a><br><h3 id="Base.signed">
<code>Base.signed</code><span class="docstring-category">Function</span>
</h3>
<pre>signed(x)</pre>
<p>Convert a number to a signed integer. If the argument is unsigned, it is reinterpreted as signed without checking for overflow.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2566-L2571">source</a><br><h3 id="Base.unsigned">
<code>Base.unsigned</code><span class="docstring-category">Function</span>
</h3>
<pre>unsigned(x) -&gt; Unsigned</pre>
<p>Convert a number to an unsigned integer. If the argument is signed, it is reinterpreted as unsigned without checking for negative values.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; unsigned(-2)
0xfffffffffffffffe

julia&gt; unsigned(2)
0x0000000000000002

julia&gt; signed(unsigned(-2))
-2</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2420-L2437">source</a><br><h3 id="Base.float-Tuple{Any}">
<code>Base.float</code><span class="docstring-category">Method</span>
</h3>
<pre>float(x)</pre>
<p>Convert a number or array to a floating point data type. When passed a string, this function is equivalent to <code>parse(Float64, x)</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/float.jl#L252-L257">source</a><br><h3 id="Base.Math.significand">
<code>Base.Math.significand</code><span class="docstring-category">Function</span>
</h3>
<pre>significand(x)</pre>
<p>Extract the <code>significand(s)</code> (a.k.a. mantissa), in binary representation, of a floating-point number. If <code>x</code> is a non-zero finite number, then the result will be a number of the same type on the interval <span>$[1,2)$</span>. Otherwise <code>x</code> is returned.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; significand(15.2)/15.2
0.125

julia&gt; significand(15.2)*8
15.2</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L584-L599">source</a><br><h3 id="Base.Math.exponent">
<code>Base.Math.exponent</code><span class="docstring-category">Function</span>
</h3>
<pre>exponent(x) -&gt; Int</pre>
<p>Get the exponent of a normalized floating-point number.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/math.jl#L567-L571">source</a><br><h3 id="Base.complex-Tuple{Complex}">
<code>Base.complex</code><span class="docstring-category">Method</span>
</h3>
<pre>complex(r, [i])</pre>
<p>Convert real numbers or arrays to complex. <code>i</code> defaults to zero.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/complex.jl#L122-L126">source</a><br><h3 id="Base.bswap">
<code>Base.bswap</code><span class="docstring-category">Function</span>
</h3>
<pre>bswap(n)</pre>
<p>Byte-swap an integer. Flip the bits of its binary representation.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; a = bswap(4)
288230376151711744

julia&gt; bswap(a)
4

julia&gt; bin(1)
"1"

julia&gt; bin(bswap(1))
"100000000000000000000000000000000000000000000000000000000"</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1294-L1313">source</a><br><h3 id="Base.num2hex">
<code>Base.num2hex</code><span class="docstring-category">Function</span>
</h3>
<pre>num2hex(f)</pre>
<p>Get a hexadecimal string of the binary representation of a floating point number.</p>
<p><strong>Example</strong></p>
<pre>julia&gt; num2hex(2.2)
"400199999999999a"</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L602-L612">source</a><br><h3 id="Base.hex2num">
<code>Base.hex2num</code><span class="docstring-category">Function</span>
</h3>
<pre>hex2num(str)</pre>
<p>Convert a hexadecimal string to the floating point number it represents.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L1602-L1606">source</a><br><h3 id="Base.hex2bytes">
<code>Base.hex2bytes</code><span class="docstring-category">Function</span>
</h3>
<pre>hex2bytes(s::AbstractString)</pre>
<p>Convert an arbitrarily long hexadecimal string to its binary representation. Returns an <code>Array{UInt8,1}</code>, i.e. an array of bytes.</p>
<pre>julia&gt; a = hex(12345)
"3039"

julia&gt; hex2bytes(a)
2-element Array{UInt8,1}:
 0x30
 0x39</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/util.jl#L408-L423">source</a><br><h3 id="Base.bytes2hex">
<code>Base.bytes2hex</code><span class="docstring-category">Function</span>
</h3>
<pre>bytes2hex(bin_arr::Array{UInt8, 1}) -&gt; String</pre>
<p>Convert an array of bytes to its hexadecimal representation. All characters are in lower-case.</p>
<pre>julia&gt; a = hex(12345)
"3039"

julia&gt; b = hex2bytes(a)
2-element Array{UInt8,1}:
 0x30
 0x39

julia&gt; bytes2hex(b)
"3039"</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/strings/util.jl#L446-L464">source</a><br><h2 id="General-Number-Functions-and-Constants-1">General Number Functions and Constants</h2>
<h3 id="Base.one">
<code>Base.one</code><span class="docstring-category">Function</span>
</h3>
<pre>one(x)
one(T::type)</pre>
<p>Return a multiplicative identity for <code>x</code>: a value such that <code>one(x)*x == x*one(x) == x</code>. Alternatively <code>one(T)</code> can take a type <code>T</code>, in which case <code>one</code> returns a multiplicative identity for any <code>x</code> of type <code>T</code>.</p>
<p>If possible, <code>one(x)</code> returns a value of the same type as <code>x</code>, and <code>one(T)</code> returns a value of type <code>T</code>. However, this may not be the case for types representing dimensionful quantities (e.g. time in days), since the multiplicative identity must be dimensionless. In that case, <code>one(x)</code> should return an identity value of the same precision (and shape, for matrices) as <code>x</code>.</p>
<p>If you want a quantity that is of the same type as <code>x</code>, or of type <code>T</code>, even if <code>x</code> is dimensionful, use <a href="#Base.oneunit"><code>oneunit</code></a> instead.</p>
<pre>julia&gt; one(3.7)
1.0

julia&gt; one(Int)
1

julia&gt; one(Dates.Day(1))
1</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/number.jl#L159-L188">source</a><br><h3 id="Base.oneunit">
<code>Base.oneunit</code><span class="docstring-category">Function</span>
</h3>
<pre>oneunit(x::T)
oneunit(T::Type)</pre>
<p>Returns <code>T(one(x))</code>, where <code>T</code> is either the type of the argument or (if a type is passed) the argument. This differs from <a href="#Base.one"><code>one</code></a> for dimensionful quantities: <code>one</code> is dimensionless (a multiplicative identity) while <code>oneunit</code> is dimensionful (of the same type as <code>x</code>, or of type <code>T</code>).</p>
<pre>julia&gt; oneunit(3.7)
1.0

julia&gt; oneunit(Dates.Day)
1 day</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/number.jl#L194-L210">source</a><br><h3 id="Base.zero">
<code>Base.zero</code><span class="docstring-category">Function</span>
</h3>
<pre>zero(x)</pre>
<p>Get the additive identity element for the type of <code>x</code> (<code>x</code> can also specify the type itself).</p>
<pre>julia&gt; zero(1)
0

julia&gt; zero(big"2.0")
0.000000000000000000000000000000000000000000000000000000000000000000000000000000

julia&gt; zero(rand(2,2))
2×2 Array{Float64,2}:
 0.0  0.0
 0.0  0.0</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/number.jl#L138-L155">source</a><br><h3 id="Base.pi">
<code>Base.pi</code><span class="docstring-category">Constant</span>
</h3>
<pre>pi
π</pre>
<p>The constant pi.</p>
<pre>julia&gt; pi
π = 3.1415926535897...</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/irrationals.jl#L149-L159">source</a><br><h3 id="Base.im">
<code>Base.im</code><span class="docstring-category">Constant</span>
</h3>
<pre>im</pre>
<p>The imaginary unit.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/complex.jl#L18-L22">source</a><br><h3 id="Base.eu">
<code>Base.eu</code><span class="docstring-category">Constant</span>
</h3>
<pre>e
eu</pre>
<p>The constant e.</p>
<pre>julia&gt; e
e = 2.7182818284590...</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/irrationals.jl#L162-L172">source</a><br><h3 id="Base.catalan">
<code>Base.catalan</code><span class="docstring-category">Constant</span>
</h3>
<pre>catalan</pre>
<p>Catalan's constant.</p>
<pre>julia&gt; catalan
catalan = 0.9159655941772...</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/irrationals.jl#L201-L210">source</a><br><h3 id="Base.eulergamma">
<code>Base.eulergamma</code><span class="docstring-category">Constant</span>
</h3>
<pre>γ
eulergamma</pre>
<p>Euler's constant.</p>
<pre>julia&gt; eulergamma
γ = 0.5772156649015...</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/irrationals.jl#L175-L185">source</a><br><h3 id="Base.golden">
<code>Base.golden</code><span class="docstring-category">Constant</span>
</h3>
<pre>φ
golden</pre>
<p>The golden ratio.</p>
<pre>julia&gt; golden
φ = 1.6180339887498...</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/irrationals.jl#L188-L198">source</a><br><h3 id="Base.Inf">
<code>Base.Inf</code><span class="docstring-category">Constant</span>
</h3>
<pre>Inf</pre>
<p>Positive infinity of type <a href="#Core.Float64"><code>Float64</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/float.jl#L32-L36">source</a><br><h3 id="Base.Inf32">
<code>Base.Inf32</code><span class="docstring-category">Constant</span>
</h3>
<pre>Inf32</pre>
<p>Positive infinity of type <a href="#Core.Float32"><code>Float32</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/float.jl#L17-L21">source</a><br><h3 id="Base.Inf16">
<code>Base.Inf16</code><span class="docstring-category">Constant</span>
</h3>
<pre>Inf16</pre>
<p>Positive infinity of type <a href="#Core.Float16"><code>Float16</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/float.jl#L5-L9">source</a><br><h3 id="Base.NaN">
<code>Base.NaN</code><span class="docstring-category">Constant</span>
</h3>
<pre>NaN</pre>
<p>A not-a-number value of type <a href="#Core.Float64"><code>Float64</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/float.jl#L38-L42">source</a><br><h3 id="Base.NaN32">
<code>Base.NaN32</code><span class="docstring-category">Constant</span>
</h3>
<pre>NaN32</pre>
<p>A not-a-number value of type <a href="#Core.Float32"><code>Float32</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/float.jl#L23-L27">source</a><br><h3 id="Base.NaN16">
<code>Base.NaN16</code><span class="docstring-category">Constant</span>
</h3>
<pre>NaN16</pre>
<p>A not-a-number value of type <a href="#Core.Float16"><code>Float16</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/float.jl#L11-L15">source</a><br><h3 id="Base.issubnormal">
<code>Base.issubnormal</code><span class="docstring-category">Function</span>
</h3>
<pre>issubnormal(f) -&gt; Bool</pre>
<p>Test whether a floating point number is subnormal.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L2055-L2059">source</a><br><h3 id="Base.isfinite">
<code>Base.isfinite</code><span class="docstring-category">Function</span>
</h3>
<pre>isfinite(f) -&gt; Bool</pre>
<p>Test whether a number is finite.</p>
<pre>julia&gt; isfinite(5)
true

julia&gt; isfinite(NaN32)
false</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/float.jl#L525-L537">source</a><br><h3 id="Base.isinf">
<code>Base.isinf</code><span class="docstring-category">Function</span>
</h3>
<pre>isinf(f) -&gt; Bool</pre>
<p>Test whether a number is infinite.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/float.jl#L543-L547">source</a><br><h3 id="Base.isnan">
<code>Base.isnan</code><span class="docstring-category">Function</span>
</h3>
<pre>isnan(f) -&gt; Bool</pre>
<p>Test whether a floating point number is not a number (NaN).</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/float.jl#L516-L520">source</a><br><h3 id="Base.iszero">
<code>Base.iszero</code><span class="docstring-category">Function</span>
</h3>
<pre>iszero(x)</pre>
<p>Return <code>true</code> if <code>x == zero(x)</code>; if <code>x</code> is an array, this checks whether all of the elements of <code>x</code> are zero.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/number.jl#L16-L21">source</a><br><h3 id="Base.nextfloat">
<code>Base.nextfloat</code><span class="docstring-category">Function</span>
</h3>
<pre>nextfloat(x::AbstractFloat, n::Integer)</pre>
<p>The result of <code>n</code> iterative applications of <code>nextfloat</code> to <code>x</code> if <code>n &gt;= 0</code>, or <code>-n</code> applications of <code>prevfloat</code> if <code>n &lt; 0</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/float.jl#L580-L585">source</a><br><pre>nextfloat(x::AbstractFloat)</pre>
<p>Returns the smallest floating point number <code>y</code> of the same type as <code>x</code> such <code>x &lt; y</code>. If no such <code>y</code> exists (e.g. if <code>x</code> is <code>Inf</code> or <code>NaN</code>), then returns <code>x</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/float.jl#L624-L629">source</a><br><h3 id="Base.prevfloat">
<code>Base.prevfloat</code><span class="docstring-category">Function</span>
</h3>
<pre>prevfloat(x::AbstractFloat)</pre>
<p>Returns the largest floating point number <code>y</code> of the same type as <code>x</code> such <code>y &lt; x</code>. If no such <code>y</code> exists (e.g. if <code>x</code> is <code>-Inf</code> or <code>NaN</code>), then returns <code>x</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/float.jl#L632-L637">source</a><br><h3 id="Base.isinteger">
<code>Base.isinteger</code><span class="docstring-category">Function</span>
</h3>
<pre>isinteger(x) -&gt; Bool</pre>
<p>Test whether <code>x</code> is numerically equal to some integer.</p>
<pre>julia&gt; isinteger(4.0)
true</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/number.jl#L4-L13">source</a><br><h3 id="Base.isreal">
<code>Base.isreal</code><span class="docstring-category">Function</span>
</h3>
<pre>isreal(x) -&gt; Bool</pre>
<p>Test whether <code>x</code> or all its elements are numerically equal to some real number.</p>
<pre>julia&gt; isreal(5.)
true

julia&gt; isreal([4.; complex(0,1)])
false</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/complex.jl#L101-L113">source</a><br><h3 id="Core.Float32-Tuple{Any}">
<code>Core.Float32</code><span class="docstring-category">Method</span>
</h3>
<pre>Float32(x [, mode::RoundingMode])</pre>
<p>Create a Float32 from <code>x</code>. If <code>x</code> is not exactly representable then <code>mode</code> determines how <code>x</code> is rounded.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; Float32(1/3, RoundDown)
0.3333333f0

julia&gt; Float32(1/3, RoundUp)
0.33333334f0</pre>
<p>See <a href="../math/#Base.Rounding.RoundingMode"><code>RoundingMode</code></a> for available rounding modes.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L221-L237">source</a><br><h3 id="Core.Float64-Tuple{Any}">
<code>Core.Float64</code><span class="docstring-category">Method</span>
</h3>
<pre>Float64(x [, mode::RoundingMode])</pre>
<p>Create a Float64 from <code>x</code>. If <code>x</code> is not exactly representable then <code>mode</code> determines how <code>x</code> is rounded.</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; Float64(pi, RoundDown)
3.141592653589793

julia&gt; Float64(pi, RoundUp)
3.1415926535897936</pre>
<p>See <a href="../math/#Base.Rounding.RoundingMode"><code>RoundingMode</code></a> for available rounding modes.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L925-L941">source</a><br><h3 id="Base.GMP.BigInt-Tuple{Any}">
<code>Base.GMP.BigInt</code><span class="docstring-category">Method</span>
</h3>
<pre>BigInt(x)</pre>
<p>Create an arbitrary precision integer. <code>x</code> may be an <code>Int</code> (or anything that can be converted to an <code>Int</code>). The usual mathematical operators are defined for this type, and results are promoted to a <a href="#Base.GMP.BigInt"><code>BigInt</code></a>.</p>
<p>Instances can be constructed from strings via <a href="#Base.parse-Tuple%7BType,Any,Any%7D"><code>parse</code></a>, or using the <code>big</code> string literal.</p>
<pre>julia&gt; parse(BigInt, "42")
42

julia&gt; big"313"
313</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/gmp.jl#L61-L78">source</a><br><h3 id="Base.MPFR.BigFloat-Tuple{Any}">
<code>Base.MPFR.BigFloat</code><span class="docstring-category">Method</span>
</h3>
<pre>BigFloat(x)</pre>
<p>Create an arbitrary precision floating point number. <code>x</code> may be an <a href="#Core.Integer"><code>Integer</code></a>, a <a href="#Core.Float64"><code>Float64</code></a> or a <a href="#Base.GMP.BigInt"><code>BigInt</code></a>. The usual mathematical operators are defined for this type, and results are promoted to a <a href="#Base.MPFR.BigFloat"><code>BigFloat</code></a>.</p>
<p>Note that because decimal literals are converted to floating point numbers when parsed, <code>BigFloat(2.1)</code> may not yield what you expect. You may instead prefer to initialize constants from strings via <a href="#Base.parse-Tuple%7BType,Any,Any%7D"><code>parse</code></a>, or using the <code>big</code> string literal.</p>
<pre>julia&gt; BigFloat(2.1)
2.100000000000000088817841970012523233890533447265625000000000000000000000000000

julia&gt; big"2.1"
2.099999999999999999999999999999999999999999999999999999999999999999999999999986</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/mpfr.jl#L68-L86">source</a><br><h3 id="Base.Rounding.rounding">
<code>Base.Rounding.rounding</code><span class="docstring-category">Function</span>
</h3>
<pre>rounding(T)</pre>
<p>Get the current floating point rounding mode for type <code>T</code>, controlling the rounding of basic arithmetic functions (<a href="../math/#Base.:+"><code>+</code></a>, <a href="#"><code>-</code></a>, <a href="#"><code>*</code></a>, <a href="../math/#Base.:/"><code>/</code></a> and <a href="../math/#Base.sqrt"><code>sqrt</code></a>) and type conversion.</p>
<p>See <a href="../math/#Base.Rounding.RoundingMode"><code>RoundingMode</code></a> for available modes.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/rounding.jl#L131-L139">source</a><br><h3 id="Base.Rounding.setrounding-Tuple{Type,Any}">
<code>Base.Rounding.setrounding</code><span class="docstring-category">Method</span>
</h3>
<pre>setrounding(T, mode)</pre>
<p>Set the rounding mode of floating point type <code>T</code>, controlling the rounding of basic arithmetic functions (<a href="../math/#Base.:+"><code>+</code></a>, <a href="#"><code>-</code></a>, <a href="#"><code>*</code></a>, <a href="../math/#Base.:/"><code>/</code></a> and <a href="../math/#Base.sqrt"><code>sqrt</code></a>) and type conversion. Other numerical functions may give incorrect or invalid values when using rounding modes other than the default <code>RoundNearest</code>.</p>
<p>Note that this may affect other types, for instance changing the rounding mode of <a href="#Core.Float64"><code>Float64</code></a> will change the rounding mode of <a href="#Core.Float32"><code>Float32</code></a>. See <a href="../math/#Base.Rounding.RoundingMode"><code>RoundingMode</code></a> for available modes.</p>
<div class="admonition warning">
<div class="admonition-title">Warning</div>
<div class="admonition-text"><p>This feature is still experimental, and may give unexpected or incorrect values.</p></div>
</div>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/rounding.jl#L112-L128">source</a><br><h3 id="Base.Rounding.setrounding-Tuple{Function,Type,RoundingMode}">
<code>Base.Rounding.setrounding</code><span class="docstring-category">Method</span>
</h3>
<pre>setrounding(f::Function, T, mode)</pre>
<p>Change the rounding mode of floating point type <code>T</code> for the duration of <code>f</code>. It is logically equivalent to:</p>
<pre>old = rounding(T)
setrounding(T, mode)
f()
setrounding(T, old)</pre>
<p>See <a href="../math/#Base.Rounding.RoundingMode"><code>RoundingMode</code></a> for available rounding modes.</p>
<div class="admonition warning">
<div class="admonition-title">Warning</div>
<div class="admonition-text">
<p>This feature is still experimental, and may give unexpected or incorrect values. A known problem is the interaction with compiler optimisations, e.g.</p>
<pre>julia&gt; setrounding(Float64,RoundDown) do
           1.1 + 0.1
       end
1.2000000000000002</pre>
<p>Here the compiler is <em>constant folding</em>, that is evaluating a known constant expression at compile time, however the rounding mode is only changed at runtime, so this is not reflected in the function result. This can be avoided by moving constants outside the expression, e.g.</p>
<pre>julia&gt; x = 1.1; y = 0.1;

julia&gt; setrounding(Float64,RoundDown) do
           x + y
       end
1.2</pre>
</div>
</div>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/rounding.jl#L148-L182">source</a><br><h3 id="Base.Rounding.get_zero_subnormals">
<code>Base.Rounding.get_zero_subnormals</code><span class="docstring-category">Function</span>
</h3>
<pre>get_zero_subnormals() -&gt; Bool</pre>
<p>Returns <code>false</code> if operations on subnormal floating-point values ("denormals") obey rules for IEEE arithmetic, and <code>true</code> if they might be converted to zeros.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/rounding.jl#L235-L240">source</a><br><h3 id="Base.Rounding.set_zero_subnormals">
<code>Base.Rounding.set_zero_subnormals</code><span class="docstring-category">Function</span>
</h3>
<pre>set_zero_subnormals(yes::Bool) -&gt; Bool</pre>
<p>If <code>yes</code> is <code>false</code>, subsequent floating-point operations follow rules for IEEE arithmetic on subnormal values ("denormals"). Otherwise, floating-point operations are permitted (but not required) to convert subnormal inputs or outputs to zero. Returns <code>true</code> unless <code>yes==true</code> but the hardware does not support zeroing of subnormal numbers.</p>
<p><code>set_zero_subnormals(true)</code> can speed up some computations on some hardware. However, it can break identities such as <code>(x-y==0) == (x==y)</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/rounding.jl#L222-L232">source</a><br><h3 id="Integers-1">Integers</h3>
<h3 id="Base.count_ones">
<code>Base.count_ones</code><span class="docstring-category">Function</span>
</h3>
<pre>count_ones(x::Integer) -&gt; Integer</pre>
<p>Number of ones in the binary representation of <code>x</code>.</p>
<pre>julia&gt; count_ones(7)
3</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/int.jl#L216-L225">source</a><br><h3 id="Base.count_zeros">
<code>Base.count_zeros</code><span class="docstring-category">Function</span>
</h3>
<pre>count_zeros(x::Integer) -&gt; Integer</pre>
<p>Number of zeros in the binary representation of <code>x</code>.</p>
<pre>julia&gt; count_zeros(Int32(2 ^ 16 - 1))
16</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/int.jl#L252-L261">source</a><br><h3 id="Base.leading_zeros">
<code>Base.leading_zeros</code><span class="docstring-category">Function</span>
</h3>
<pre>leading_zeros(x::Integer) -&gt; Integer</pre>
<p>Number of zeros leading the binary representation of <code>x</code>.</p>
<pre>julia&gt; leading_zeros(Int32(1))
31</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/int.jl#L228-L237">source</a><br><h3 id="Base.leading_ones">
<code>Base.leading_ones</code><span class="docstring-category">Function</span>
</h3>
<pre>leading_ones(x::Integer) -&gt; Integer</pre>
<p>Number of ones leading the binary representation of <code>x</code>.</p>
<pre>julia&gt; leading_ones(UInt32(2 ^ 32 - 2))
31</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/int.jl#L264-L273">source</a><br><h3 id="Base.trailing_zeros">
<code>Base.trailing_zeros</code><span class="docstring-category">Function</span>
</h3>
<pre>trailing_zeros(x::Integer) -&gt; Integer</pre>
<p>Number of zeros trailing the binary representation of <code>x</code>.</p>
<pre>julia&gt; trailing_zeros(2)
1</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/int.jl#L240-L249">source</a><br><h3 id="Base.trailing_ones">
<code>Base.trailing_ones</code><span class="docstring-category">Function</span>
</h3>
<pre>trailing_ones(x::Integer) -&gt; Integer</pre>
<p>Number of ones trailing the binary representation of <code>x</code>.</p>
<pre>julia&gt; trailing_ones(3)
2</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/int.jl#L276-L285">source</a><br><h3 id="Base.isodd">
<code>Base.isodd</code><span class="docstring-category">Function</span>
</h3>
<pre>isodd(x::Integer) -&gt; Bool</pre>
<p>Returns <code>true</code> if <code>x</code> is odd (that is, not divisible by 2), and <code>false</code> otherwise.</p>
<pre>julia&gt; isodd(9)
true

julia&gt; isodd(10)
false</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/int.jl#L40-L52">source</a><br><h3 id="Base.iseven">
<code>Base.iseven</code><span class="docstring-category">Function</span>
</h3>
<pre>iseven(x::Integer) -&gt; Bool</pre>
<p>Returns <code>true</code> is <code>x</code> is even (that is, divisible by 2), and <code>false</code> otherwise.</p>
<pre>julia&gt; iseven(9)
false

julia&gt; iseven(10)
true</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/int.jl#L55-L67">source</a><br><h2 id="BigFloats-1">BigFloats</h2>
<p>The <a href="#Base.MPFR.BigFloat"><code>BigFloat</code></a> type implements arbitrary-precision floating-point arithmetic using the <a href="http://www.mpfr.org/" target="_blank">GNU MPFR library</a>.</p>
<h3 id="Base.precision">
<code>Base.precision</code><span class="docstring-category">Function</span>
</h3>
<pre>precision(num::AbstractFloat)</pre>
<p>Get the precision of a floating point number, as defined by the effective number of bits in the mantissa.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/docs/helpdb/Base.jl#L58-L63">source</a><br><h3 id="Base.precision-Tuple{Type{BigFloat}}">
<code>Base.precision</code><span class="docstring-category">Method</span>
</h3>
<pre>precision(BigFloat)</pre>
<p>Get the precision (in bits) currently used for <a href="#Base.MPFR.BigFloat"><code>BigFloat</code></a> arithmetic.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/mpfr.jl#L715-L719">source</a><br><h3 id="Base.MPFR.setprecision">
<code>Base.MPFR.setprecision</code><span class="docstring-category">Function</span>
</h3>
<pre>setprecision([T=BigFloat,] precision::Int)</pre>
<p>Set the precision (in bits) to be used for <code>T</code> arithmetic.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/mpfr.jl#L722-L726">source</a><br><pre>setprecision(f::Function, [T=BigFloat,] precision::Integer)</pre>
<p>Change the <code>T</code> arithmetic precision (in bits) for the duration of <code>f</code>. It is logically equivalent to:</p>
<pre>old = precision(BigFloat)
setprecision(BigFloat, precision)
f()
setprecision(BigFloat, old)</pre>
<p>Often used as <code>setprecision(T, precision) do ... end</code></p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/mpfr.jl#L859-L871">source</a><br><h3 id="Base.MPFR.BigFloat-Tuple{Any,Int64}">
<code>Base.MPFR.BigFloat</code><span class="docstring-category">Method</span>
</h3>
<pre>BigFloat(x, prec::Int)</pre>
<p>Create a representation of <code>x</code> as a <a href="#Base.MPFR.BigFloat"><code>BigFloat</code></a> with precision <code>prec</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/mpfr.jl#L129-L133">source</a><br><h3 id="Base.MPFR.BigFloat-Tuple{Union{AbstractFloat, Integer, String},RoundingMode}">
<code>Base.MPFR.BigFloat</code><span class="docstring-category">Method</span>
</h3>
<pre>BigFloat(x, rounding::RoundingMode)</pre>
<p>Create a representation of <code>x</code> as a <a href="#Base.MPFR.BigFloat"><code>BigFloat</code></a> with the current global precision and rounding mode <code>rounding</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/mpfr.jl#L152-L157">source</a><br><h3 id="Base.MPFR.BigFloat-Tuple{Any,Int64,RoundingMode}">
<code>Base.MPFR.BigFloat</code><span class="docstring-category">Method</span>
</h3>
<pre>BigFloat(x, prec::Int, rounding::RoundingMode)</pre>
<p>Create a representation of <code>x</code> as a <a href="#Base.MPFR.BigFloat"><code>BigFloat</code></a> with precision <code>prec</code> and rounding mode <code>rounding</code>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/mpfr.jl#L140-L145">source</a><br><h3 id="Base.MPFR.BigFloat-Tuple{String}">
<code>Base.MPFR.BigFloat</code><span class="docstring-category">Method</span>
</h3>
<pre>BigFloat(x::String)</pre>
<p>Create a representation of the string <code>x</code> as a <a href="#Base.MPFR.BigFloat"><code>BigFloat</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/mpfr.jl#L162-L166">source</a><br><h2 id="Random-Numbers-1">Random Numbers</h2>
<p>Random number generation in Julia uses the <a href="http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/SFMT/#dSFMT" target="_blank">Mersenne Twister library</a> via <code>MersenneTwister</code> objects. Julia has a global RNG, which is used by default. Other RNG types can be plugged in by inheriting the <code>AbstractRNG</code> type; they can then be used to have multiple streams of random numbers. Besides <code>MersenneTwister</code>, Julia also provides the <code>RandomDevice</code> RNG type, which is a wrapper over the OS provided entropy.</p>
<p>Most functions related to random generation accept an optional <code>AbstractRNG</code> as the first argument, <code>rng</code> , which defaults to the global one if not provided. Morever, some of them accept optionally dimension specifications <code>dims...</code> (which can be given as a tuple) to generate arrays of random values.</p>
<p>A <code>MersenneTwister</code> or <code>RandomDevice</code> RNG can generate random numbers of the following types: <a href="#Core.Float16"><code>Float16</code></a>, <a href="#Core.Float32"><code>Float32</code></a>, <a href="#Core.Float64"><code>Float64</code></a>, <a href="#Core.Bool"><code>Bool</code></a>, <a href="#Core.Int8"><code>Int8</code></a>, <a href="#Core.UInt8"><code>UInt8</code></a>, <a href="#Core.Int16"><code>Int16</code></a>, <a href="#Core.UInt16"><code>UInt16</code></a>, <a href="#Core.Int32"><code>Int32</code></a>, <a href="#Core.UInt32"><code>UInt32</code></a>, <a href="#Core.Int64"><code>Int64</code></a>, <a href="#Core.UInt64"><code>UInt64</code></a>, <a href="#Core.Int128"><code>Int128</code></a>, <a href="#Core.UInt128"><code>UInt128</code></a>, <a href="#Base.GMP.BigInt"><code>BigInt</code></a> (or complex numbers of those types). Random floating point numbers are generated uniformly in <span>$[0, 1)$</span>. As <code>BigInt</code> represents unbounded integers, the interval must be specified (e.g. <code>rand(big(1:6))</code>).</p>
<h3 id="Base.Random.srand">
<code>Base.Random.srand</code><span class="docstring-category">Function</span>
</h3>
<pre>srand([rng=GLOBAL_RNG], [seed]) -&gt; rng
srand([rng=GLOBAL_RNG], filename, n=4) -&gt; rng</pre>
<p>Reseed the random number generator. If a <code>seed</code> is provided, the RNG will give a reproducible sequence of numbers, otherwise Julia will get entropy from the system. For <code>MersenneTwister</code>, the <code>seed</code> may be a non-negative integer, a vector of <a href="#Core.UInt32"><code>UInt32</code></a> integers or a filename, in which case the seed is read from a file (<code>4n</code> bytes are read from the file, where <code>n</code> is an optional argument). <code>RandomDevice</code> does not support seeding.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/random.jl#L227-L236">source</a><br><h3 id="Base.Random.MersenneTwister">
<code>Base.Random.MersenneTwister</code><span class="docstring-category">Type</span>
</h3>
<pre>MersenneTwister(seed)</pre>
<p>Create a <code>MersenneTwister</code> RNG object. Different RNG objects can have their own seeds, which may be useful for generating different streams of random numbers.</p>
<p><strong>Example</strong></p>
<pre>julia&gt; rng = MersenneTwister(1234);</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/random.jl#L91-L101">source</a><br><h3 id="Base.Random.RandomDevice">
<code>Base.Random.RandomDevice</code><span class="docstring-category">Type</span>
</h3>
<pre>RandomDevice()</pre>
<p>Create a <code>RandomDevice</code> RNG object. Two such objects will always generate different streams of random numbers.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/random.jl#L58-L62">source</a><br><h3 id="Base.Random.rand">
<code>Base.Random.rand</code><span class="docstring-category">Function</span>
</h3>
<pre>rand([rng=GLOBAL_RNG], [S], [dims...])</pre>
<p>Pick a random element or array of random elements from the set of values specified by <code>S</code>; <code>S</code> can be</p>
<ul>
<li><p>an indexable collection (for example <code>1:n</code> or <code>['x','y','z']</code>), or</p></li>
<li><p>a type: the set of values to pick from is then equivalent to <code>typemin(S):typemax(S)</code> for integers (this is not applicable to <a href="#Base.GMP.BigInt"><code>BigInt</code></a>), and to <span>$[0, 1)$</span> for floating point numbers;</p></li>
</ul>
<p><code>S</code> defaults to <a href="#Core.Float64"><code>Float64</code></a>.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/random.jl#L270-L281">source</a><br><h3 id="Base.Random.rand!">
<code>Base.Random.rand!</code><span class="docstring-category">Function</span>
</h3>
<pre>rand!([rng=GLOBAL_RNG], A, [coll])</pre>
<p>Populate the array <code>A</code> with random values. If the indexable collection <code>coll</code> is specified, the values are picked randomly from <code>coll</code>. This is equivalent to <code>copy!(A, rand(rng, coll, size(A)))</code> or <code>copy!(A, rand(rng, eltype(A), size(A)))</code> but without allocating a new array.</p>
<p><strong>Example</strong></p>
<pre>julia&gt; rng = MersenneTwister(1234);

julia&gt; rand!(rng, zeros(5))
5-element Array{Float64,1}:
 0.590845
 0.766797
 0.566237
 0.460085
 0.794026</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/random.jl#L292-L312">source</a><br><h3 id="Base.Random.bitrand">
<code>Base.Random.bitrand</code><span class="docstring-category">Function</span>
</h3>
<pre>bitrand([rng=GLOBAL_RNG], [dims...])</pre>
<p>Generate a <code>BitArray</code> of random boolean values.</p>
<p><strong>Example</strong></p>
<pre>julia&gt; rng = MersenneTwister(1234);

julia&gt; bitrand(rng, 10)
10-element BitArray{1}:
  true
  true
  true
 false
  true
 false
 false
  true
 false
  true</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/random.jl#L710-L733">source</a><br><h3 id="Base.Random.randn">
<code>Base.Random.randn</code><span class="docstring-category">Function</span>
</h3>
<pre>randn([rng=GLOBAL_RNG], [T=Float64], [dims...])</pre>
<p>Generate a normally-distributed random number of type <code>T</code> with mean 0 and standard deviation 1. Optionally generate an array of normally-distributed random numbers. The <code>Base</code> module currently provides an implementation for the types <a href="#Core.Float16"><code>Float16</code></a>, <a href="#Core.Float32"><code>Float32</code></a>, and <a href="#Core.Float64"><code>Float64</code></a> (the default).</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; rng = MersenneTwister(1234);

julia&gt; randn(rng, Float64)
0.8673472019512456

julia&gt; randn(rng, Float32, (2, 4))
2×4 Array{Float32,2}:
 -0.901744  -0.902914  2.21188   -0.271735
 -0.494479   0.864401  0.532813   0.502334</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/random.jl#L1234-L1255">source</a><br><h3 id="Base.Random.randn!">
<code>Base.Random.randn!</code><span class="docstring-category">Function</span>
</h3>
<pre>randn!([rng=GLOBAL_RNG], A::AbstractArray) -&gt; A</pre>
<p>Fill the array <code>A</code> with normally-distributed (mean 0, standard deviation 1) random numbers. Also see the <a href="#Base.Random.rand"><code>rand</code></a> function.</p>
<p><strong>Example</strong></p>
<pre>julia&gt; rng = MersenneTwister(1234);

julia&gt; randn!(rng, zeros(5))
5-element Array{Float64,1}:
  0.867347
 -0.901744
 -0.494479
 -0.902914
  0.864401</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/random.jl#L1325-L1344">source</a><br><h3 id="Base.Random.randexp">
<code>Base.Random.randexp</code><span class="docstring-category">Function</span>
</h3>
<pre>randexp([rng=GLOBAL_RNG], [T=Float64], [dims...])</pre>
<p>Generate a random number of type <code>T</code> according to the exponential distribution with scale 1. Optionally generate an array of such random numbers. The <code>Base</code> module currently provides an implementation for the types <a href="#Core.Float16"><code>Float16</code></a>, <a href="#Core.Float32"><code>Float32</code></a>, and <a href="#Core.Float64"><code>Float64</code></a> (the default).</p>
<p><strong>Examples</strong></p>
<pre>julia&gt; rng = MersenneTwister(1234);

julia&gt; randexp(rng, Float32)
2.4835055f0

julia&gt; randexp(rng, 3, 3)
3×3 Array{Float64,2}:
 1.5167    1.30652   0.344435
 0.604436  2.78029   0.418516
 0.695867  0.693292  0.643644</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/random.jl#L1282-L1304">source</a><br><h3 id="Base.Random.randexp!">
<code>Base.Random.randexp!</code><span class="docstring-category">Function</span>
</h3>
<pre>randexp!([rng=GLOBAL_RNG], A::AbstractArray) -&gt; A</pre>
<p>Fill the array <code>A</code> with random numbers following the exponential distribution (with scale 1).</p>
<p><strong>Example</strong></p>
<pre>julia&gt; rng = MersenneTwister(1234);

julia&gt; randexp!(rng, zeros(5))
5-element Array{Float64,1}:
 2.48351
 1.5167
 0.604436
 0.695867
 1.30652</pre>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/random.jl#L1347-L1365">source</a><br><h3 id="Base.Random.randjump">
<code>Base.Random.randjump</code><span class="docstring-category">Function</span>
</h3>
<pre>randjump(r::MersenneTwister, jumps::Integer, [jumppoly::AbstractString=dSFMT.JPOLY1e21]) -&gt; Vector{MersenneTwister}</pre>
<p>Create an array of the size <code>jumps</code> of initialized <code>MersenneTwister</code> RNG objects. The first RNG object given as a parameter and following <code>MersenneTwister</code> RNGs in the array are initialized such that a state of the RNG object in the array would be moved forward (without generating numbers) from a previous RNG object array element on a particular number of steps encoded by the jump polynomial <code>jumppoly</code>.</p>
<p>Default jump polynomial moves forward <code>MersenneTwister</code> RNG state by <code>10^20</code> steps.</p>
<a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/tree/d386e40c17d43b79fc89d3e579fc04547241787c/base/random.jl#L158-L168">source</a><br><div class="_attribution">
  <p class="_attribution-p">
    © 2009–2016 Jeff Bezanson, Stefan Karpinski, Viral B. Shah, and other contributors<br>Licensed under the MIT License.<br>
    <a href="https://docs.julialang.org/en/release-0.6/stdlib/numbers/" class="_attribution-link" target="_blank">https://docs.julialang.org/en/release-0.6/stdlib/numbers/</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
