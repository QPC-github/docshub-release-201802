
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>System - Nim - W3cubDocs</title>
  
  <meta name="description" content="The compiler depends on the System module to work properly and the System module depends on the compiler. Most of the routines listed here use &hellip;">
  <meta name="keywords" content="module, system, -, nim">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/nim/system/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-e0f881b0fce8cbe96f33dadc355b7159d5d2912911231446d60eb8f9caffa802.css">
  <script type="text/javascript" src="/assets/application-8fc46316434047265cd383f02b8e7f434ed7dec4a59f920dd633deef8d488d1b.js"></script>
  <script src="/json/nim.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/nim/" class="_nav-link" title="" style="margin-left:0;">Nim</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _nim">
				
<h1 class="title">Module system</h1>  <p class="module-desc">The compiler depends on the System module to work properly and the System module depends on the compiler. Most of the routines listed here use special compiler magic. Each module implicitly imports the System module; it must not be listed explicitly. Because of this there cannot be a user-defined module named <code>system</code>. </p>
<h2 id="module-system">Module system</h2>  <h2 id="7">Types</h2> <dl> <dt id="int"><pre id="int">int</pre></dt> <dd> default integer type; bitwidth depends on architecture, but is always the same as a pointer   </dd> <dt id="int8"><pre id="int8">int8</pre></dt> <dd> signed 8 bit integer type   </dd> <dt id="int16"><pre id="int16">int16</pre></dt> <dd> signed 16 bit integer type   </dd> <dt id="int32"><pre id="int32">int32</pre></dt> <dd> signed 32 bit integer type   </dd> <dt id="int64"><pre id="int64">int64</pre></dt> <dd> signed 64 bit integer type   </dd> <dt id="uint"><pre id="uint">uint</pre></dt> <dd> unsigned default integer type   </dd> <dt id="uint8"><pre id="uint8">uint8</pre></dt> <dd> unsigned 8 bit integer type   </dd> <dt id="uint16"><pre id="uint16">uint16</pre></dt> <dd> unsigned 16 bit integer type   </dd> <dt id="uint32"><pre id="uint32">uint32</pre></dt> <dd> unsigned 32 bit integer type   </dd> <dt id="uint64"><pre id="uint64">uint64</pre></dt> <dd> unsigned 64 bit integer type   </dd> <dt id="float"><pre id="float">float</pre></dt> <dd> default floating point type   </dd> <dt id="float32"><pre id="float32">float32</pre></dt> <dd> 32 bit floating point type   </dd> <dt id="float64"><pre id="float64">float64</pre></dt> <dd> 64 bit floating point type   </dd> <dt id="bool"><pre id="bool" data-language="nim">bool = enum
  false = 0, true = 1</pre></dt> <dd> built-in boolean type   </dd> <dt id="char"><pre id="char">char</pre></dt> <dd> built-in 8 bit character type (unsigned)   </dd> <dt id="string"><pre id="string">string</pre></dt> <dd> built-in string type   </dd> <dt id="cstring"><pre id="cstring">cstring</pre></dt> <dd> built-in cstring (<em>compatible string</em>) type   </dd> <dt id="pointer"><pre id="pointer">pointer</pre></dt> <dd> built-in pointer type, use the <code>addr</code> operator to get a pointer to a variable   </dd> <dt id="typedesc"><pre id="typedesc">typedesc</pre></dt> <dd> meta type to denote a type description   </dd> <dt id="Ordinal"><pre id="Ordinal" data-language="nim">Ordinal[T]</pre></dt> <dd> Generic ordinal type. Includes integer, bool, character, and enumeration types as well as their subtypes. Note <em>uint</em> and <em>uint64</em> are not ordinal types for implementation reasons   </dd> <dt id="ptr"><pre id="ptr" data-language="nim">ptr[T]</pre></dt> <dd> built-in generic untraced pointer type   </dd> <dt id="ref"><pre id="ref" data-language="nim">ref[T]</pre></dt> <dd> built-in generic traced pointer type   </dd> <dt id="expr"><pre id="expr">expr</pre></dt> <dd> meta type to denote an expression (for templates) <strong>Deprecated</strong> since version 0.15. Use <code>untyped</code> instead.   </dd> <dt id="stmt"><pre id="stmt">stmt</pre></dt> <dd> meta type to denote a statement (for templates) <strong>Deprecated</strong> since version 0.15. Use <code>typed</code> instead.   </dd> <dt id="void"><pre id="void">void</pre></dt> <dd> meta type to denote the absence of any type   </dd> <dt id="auto"><pre id="auto">auto</pre></dt> <dd> meta type for automatic type determination   </dd> <dt id="any"><pre id="any">any = distinct auto</pre></dt> <dd> meta type for any supported type   </dd> <dt id="untyped"><pre id="untyped">untyped</pre></dt> <dd> meta type to denote an expression that is not resolved (for templates)   </dd> <dt id="typed"><pre id="typed">typed</pre></dt> <dd> meta type to denote an expression that is resolved (for templates)   </dd> <dt id="SomeSignedInt"><pre id="SomeSignedInt" data-language="nim">SomeSignedInt = int | int8 | int16 | int32 | int64</pre></dt> <dd> type class matching all signed integer types   </dd> <dt id="SomeUnsignedInt"><pre id="SomeUnsignedInt" data-language="nim">SomeUnsignedInt = uint | uint8 | uint16 | uint32 | uint64</pre></dt> <dd> type class matching all unsigned integer types   </dd> <dt id="SomeInteger"><pre id="SomeInteger" data-language="nim">SomeInteger = SomeSignedInt | SomeUnsignedInt</pre></dt> <dd> type class matching all integer types   </dd> <dt id="SomeOrdinal"><pre id="SomeOrdinal" data-language="nim">SomeOrdinal = int | int8 | int16 | int32 | int64 | bool | enum | uint8 | uint16 | uint32</pre></dt> <dd> type class matching all ordinal types; however this includes enums with holes.   </dd> <dt id="SomeReal"><pre id="SomeReal" data-language="nim">SomeReal = float | float32 | float64</pre></dt> <dd> type class matching all floating point number types   </dd> <dt id="SomeNumber"><pre id="SomeNumber" data-language="nim">SomeNumber = SomeInteger | SomeReal</pre></dt> <dd> type class matching all number types   </dd> <dt id="range"><pre id="range" data-language="nim">range[T]</pre></dt> <dd> Generic type to construct range types.   </dd> <dt id="array"><pre id="array" data-language="nim">array[I; T]</pre></dt> <dd> Generic type to construct fixed-length arrays.   </dd> <dt id="openArray"><pre id="openArray" data-language="nim">openArray[T]</pre></dt> <dd> Generic type to construct open arrays. Open arrays are implemented as a pointer to the array data and a length field.   </dd> <dt id="varargs"><pre id="varargs" data-language="nim">varargs[T]</pre></dt> <dd> Generic type to construct a varargs type.   </dd> <dt id="seq"><pre id="seq" data-language="nim">seq[T]</pre></dt> <dd> Generic type to construct sequences.   </dd> <dt id="set"><pre id="set" data-language="nim">set[T]</pre></dt> <dd> Generic type to construct bit sets.   </dd> <dt id="UncheckedArray"><pre id="UncheckedArray" data-language="nim">UncheckedArray[T] = array[0, T]</pre></dt> <dd> Array with no bounds checking   </dd> <dt id="Slice"><pre id="Slice" data-language="nim">Slice[T] = object
  a*, b*: T                     ## the bounds</pre></dt> <dd> builtin slice type   </dd> <dt id="byte"><pre id="byte">byte = uint8</pre></dt> <dd> this is an alias for <code>uint8</code>, that is an unsigned int 8 bits wide.   </dd> <dt id="Natural"><pre id="Natural" data-language="nim">Natural = range[0 .. high(int)]</pre></dt> <dd> is an int type ranging from zero to the maximum value of an int. This type is often useful for documentation and debugging.   </dd> <dt id="Positive"><pre id="Positive" data-language="nim">Positive = range[1 .. high(int)]</pre></dt> <dd> is an int type ranging from one to the maximum value of an int. This type is often useful for documentation and debugging.   </dd> <dt id="RootObj"><pre id="RootObj">RootObj = object</pre></dt> <dd> the root of Nim's object hierarchy. Objects should inherit from RootObj or one of its descendants. However, objects that have no ancestor are allowed.   </dd> <dt id="RootRef"><pre id="RootRef">RootRef = ref RootObj</pre></dt> <dd> reference to RootObj   </dd> <dt id="RootEffect"><pre id="RootEffect">RootEffect = object of RootObj</pre></dt> <dd> base effect class; each effect should inherit from <em>RootEffect</em> unless you know what you doing.   </dd> <dt id="TimeEffect"><pre id="TimeEffect">TimeEffect = object of RootEffect</pre></dt> <dd> Time effect.   </dd> <dt id="IOEffect"><pre id="IOEffect">IOEffect = object of RootEffect</pre></dt> <dd> IO effect.   </dd> <dt id="ReadIOEffect"><pre id="ReadIOEffect">ReadIOEffect = object of IOEffect</pre></dt> <dd> Effect describing a read IO operation.   </dd> <dt id="WriteIOEffect"><pre id="WriteIOEffect">WriteIOEffect = object of IOEffect</pre></dt> <dd> Effect describing a write IO operation.   </dd> <dt id="ExecIOEffect"><pre id="ExecIOEffect">ExecIOEffect = object of IOEffect</pre></dt> <dd> Effect describing an executing IO operation.   </dd> <dt id="Exception"><pre id="Exception" data-language="nim">Exception = object of RootObj
  parent*: ref Exception        ## parent exception (can be used as a stack)
  name*: cstring               ## The exception's name is its Nim identifier.
               ## This field is filled automatically in the
               ## ``raise`` statement.
  msg* {.exportc: "message".}: string ## the exception's message. Not
                                  ## providing an exception message
                                  ## is bad style.
  trace: string
  up: ref Exception</pre></dt> <dd> <p> Base exception class.</p> <p>Each exception has to inherit from <em>Exception</em>. See the full <a href="../manual/#exception-handling-exception-hierarchy">exception hierarchy</a>.</p>   </dd> <dt id="SystemError"><pre id="SystemError">SystemError = object of Exception</pre></dt> <dd> <p> Abstract class for exceptions that the runtime system raises.</p> <p>See the full <a href="../manual/#exception-handling-exception-hierarchy">exception hierarchy</a>.</p>   </dd> <dt id="IOError"><pre id="IOError">IOError = object of SystemError</pre></dt> <dd> <p> Raised if an IO error occurred.</p> <p>See the full <a href="../manual/#exception-handling-exception-hierarchy">exception hierarchy</a>.</p>   </dd> <dt id="EOFError"><pre id="EOFError">EOFError = object of IOError</pre></dt> <dd> <p> Raised if an IO "end of file" error occurred.</p> <p>See the full <a href="../manual/#exception-handling-exception-hierarchy">exception hierarchy</a>.</p>   </dd> <dt id="OSError"><pre id="OSError" data-language="nim">OSError = object of SystemError
  errorCode*: int32            ## OS-defined error code describing this error.</pre></dt> <dd> <p> Raised if an operating system service failed.</p> <p>See the full <a href="../manual/#exception-handling-exception-hierarchy">exception hierarchy</a>.</p>   </dd> <dt id="LibraryError"><pre id="LibraryError">LibraryError = object of OSError</pre></dt> <dd> <p> Raised if a dynamic library could not be loaded.</p> <p>See the full <a href="../manual/#exception-handling-exception-hierarchy">exception hierarchy</a>.</p>   </dd> <dt id="ResourceExhaustedError"><pre id="ResourceExhaustedError">ResourceExhaustedError = object of SystemError</pre></dt> <dd> <p> Raised if a resource request could not be fulfilled.</p> <p>See the full <a href="../manual/#exception-handling-exception-hierarchy">exception hierarchy</a>.</p>   </dd> <dt id="ArithmeticError"><pre id="ArithmeticError">ArithmeticError = object of Exception</pre></dt> <dd> <p> Raised if any kind of arithmetic error occurred.</p> <p>See the full <a href="../manual/#exception-handling-exception-hierarchy">exception hierarchy</a>.</p>   </dd> <dt id="DivByZeroError"><pre id="DivByZeroError">DivByZeroError = object of ArithmeticError</pre></dt> <dd> <p> Raised for runtime integer divide-by-zero errors.</p> <p>See the full <a href="../manual/#exception-handling-exception-hierarchy">exception hierarchy</a>.</p>   </dd> <dt id="OverflowError"><pre id="OverflowError">OverflowError = object of ArithmeticError</pre></dt> <dd> <p> Raised for runtime integer overflows.</p> <p>This happens for calculations whose results are too large to fit in the provided bits. See the full <a href="../manual/#exception-handling-exception-hierarchy">exception hierarchy</a>.</p>   </dd> <dt id="AccessViolationError"><pre id="AccessViolationError">AccessViolationError = object of Exception</pre></dt> <dd> <p> Raised for invalid memory access errors</p> <p>See the full <a href="../manual/#exception-handling-exception-hierarchy">exception hierarchy</a>.</p>   </dd> <dt id="AssertionError"><pre id="AssertionError">AssertionError = object of Exception</pre></dt> <dd> <p> Raised when assertion is proved wrong.</p> <p>Usually the result of using the <a href="#assert">assert() template</a>. See the full <a href="../manual/#exception-handling-exception-hierarchy">exception hierarchy</a>.</p>   </dd> <dt id="ValueError"><pre id="ValueError">ValueError = object of Exception</pre></dt> <dd> Raised for string and object conversion errors.   </dd> <dt id="KeyError"><pre id="KeyError">KeyError = object of ValueError</pre></dt> <dd> <p> Raised if a key cannot be found in a table.</p> <p>Mostly used by the <a href="../tables/">tables</a> module, it can also be raised by other collection modules like <a href="../sets/">sets</a> or <a href="../strtabs/">strtabs</a>. See the full <a href="../manual/#exception-handling-exception-hierarchy">exception hierarchy</a>.</p>   </dd> <dt id="OutOfMemError"><pre id="OutOfMemError">OutOfMemError = object of SystemError</pre></dt> <dd> <p> Raised for unsuccessful attempts to allocate memory.</p> <p>See the full <a href="../manual/#exception-handling-exception-hierarchy">exception hierarchy</a>.</p>   </dd> <dt id="IndexError"><pre id="IndexError">IndexError = object of Exception</pre></dt> <dd> <p> Raised if an array index is out of bounds.</p> <p>See the full <a href="../manual/#exception-handling-exception-hierarchy">exception hierarchy</a>.</p>   </dd> <dt id="FieldError"><pre id="FieldError">FieldError = object of Exception</pre></dt> <dd> <p> Raised if a record field is not accessible because its dicriminant's value does not fit.</p> <p>See the full <a href="../manual/#exception-handling-exception-hierarchy">exception hierarchy</a>.</p>   </dd> <dt id="RangeError"><pre id="RangeError">RangeError = object of Exception</pre></dt> <dd> <p> Raised if a range check error occurred.</p> <p>See the full <a href="../manual/#exception-handling-exception-hierarchy">exception hierarchy</a>.</p>   </dd> <dt id="StackOverflowError"><pre id="StackOverflowError">StackOverflowError = object of SystemError</pre></dt> <dd> <p> Raised if the hardware stack used for subroutine calls overflowed.</p> <p>See the full <a href="../manual/#exception-handling-exception-hierarchy">exception hierarchy</a>.</p>   </dd> <dt id="ReraiseError"><pre id="ReraiseError">ReraiseError = object of Exception</pre></dt> <dd> <p> Raised if there is no exception to reraise.</p> <p>See the full <a href="../manual/#exception-handling-exception-hierarchy">exception hierarchy</a>.</p>   </dd> <dt id="ObjectAssignmentError"><pre id="ObjectAssignmentError">ObjectAssignmentError = object of Exception</pre></dt> <dd> <p> Raised if an object gets assigned to its parent's object.</p> <p>See the full <a href="../manual/#exception-handling-exception-hierarchy">exception hierarchy</a>.</p>   </dd> <dt id="ObjectConversionError"><pre id="ObjectConversionError">ObjectConversionError = object of Exception</pre></dt> <dd> <p> Raised if an object is converted to an incompatible object type. You can use <code>of</code> operator to check if conversion will succeed.</p> <p>See the full <a href="../manual/#exception-handling-exception-hierarchy">exception hierarchy</a>.</p>   </dd> <dt id="FloatingPointError"><pre id="FloatingPointError">FloatingPointError = object of Exception</pre></dt> <dd> <p> Base class for floating point exceptions.</p> <p>See the full <a href="../manual/#exception-handling-exception-hierarchy">exception hierarchy</a>.</p>   </dd> <dt id="FloatInvalidOpError"><pre id="FloatInvalidOpError">FloatInvalidOpError = object of FloatingPointError</pre></dt> <dd> <p> Raised by invalid operations according to IEEE.</p> <p>Raised by <code>0.0/0.0</code>, for example. See the full <a href="../manual/#exception-handling-exception-hierarchy">exception hierarchy</a>.</p>   </dd> <dt id="FloatDivByZeroError"><pre id="FloatDivByZeroError">FloatDivByZeroError = object of FloatingPointError</pre></dt> <dd> <p> Raised by division by zero.</p> <p>Divisor is zero and dividend is a finite nonzero number. See the full <a href="../manual/#exception-handling-exception-hierarchy">exception hierarchy</a>.</p>   </dd> <dt id="FloatOverflowError"><pre id="FloatOverflowError">FloatOverflowError = object of FloatingPointError</pre></dt> <dd> <p> Raised for overflows.</p> <p>The operation produced a result that exceeds the range of the exponent. See the full <a href="../manual/#exception-handling-exception-hierarchy">exception hierarchy</a>.</p>   </dd> <dt id="FloatUnderflowError"><pre id="FloatUnderflowError">FloatUnderflowError = object of FloatingPointError</pre></dt> <dd> <p> Raised for underflows.</p> <p>The operation produced a result that is too small to be represented as a normal number. See the full <a href="../manual/#exception-handling-exception-hierarchy">exception hierarchy</a>.</p>   </dd> <dt id="FloatInexactError"><pre id="FloatInexactError">FloatInexactError = object of FloatingPointError</pre></dt> <dd> <p> Raised for inexact results.</p> <p>The operation produced a result that cannot be represented with infinite precision -- for example: <code>2.0 / 3.0, log(1.1)</code></p> <p><strong>NOTE</strong>: Nim currently does not detect these! See the full <a href="../manual/#exception-handling-exception-hierarchy">exception hierarchy</a>.</p>   </dd> <dt id="DeadThreadError"><pre id="DeadThreadError">DeadThreadError = object of Exception</pre></dt> <dd> <p> Raised if it is attempted to send a message to a dead thread.</p> <p>See the full <a href="../manual/#exception-handling-exception-hierarchy">exception hierarchy</a>.</p>   </dd> <dt id="NilAccessError"><pre id="NilAccessError">NilAccessError = object of SystemError</pre></dt> <dd> <p> Raised on dereferences of <code>nil</code> pointers.</p> <p>This is only raised if the <code>segfaults.nim</code> module was imported!</p>   </dd> <dt id="Endianness"><pre id="Endianness" data-language="nim">Endianness = enum
  littleEndian, bigEndian</pre></dt> <dd> is a type describing the endianness of a processor.   </dd> <dt id="TaintedString"><pre id="TaintedString">TaintedString = string</pre></dt> <dd> a distinct string type that is <span id="tainted_1">tainted</span>, see <a href="../manual/#taint-mode">taint mode</a> for details. It is an alias for <code>string</code> if the taint mode is not turned on.   </dd> <dt id="ByteAddress"><pre id="ByteAddress">ByteAddress = int</pre></dt> <dd> is the signed integer type that should be used for converting pointers to integer addresses for readability.   </dd> <dt id="BiggestInt"><pre id="BiggestInt">BiggestInt = int64</pre></dt> <dd> is an alias for the biggest signed integer type the Nim compiler supports. Currently this is <code>int64</code>, but it is platform-dependant in general.   </dd> <dt id="BiggestFloat"><pre id="BiggestFloat">BiggestFloat = float64</pre></dt> <dd> is an alias for the biggest floating point type the Nim compiler supports. Currently this is <code>float64</code>, but it is platform-dependant in general.   </dd> <dt id="BiggestUInt"><pre id="BiggestUInt">BiggestUInt = uint64</pre></dt> <dd> is an alias for the biggest unsigned integer type the Nim compiler supports. Currently this is <code>uint32</code> for JS and <code>uint64</code> for other targets.   </dd> <dt id="clong"><pre id="clong">clong = int32</pre></dt> <dd> This is the same as the type <code>long</code> in <em>C</em>.   </dd> <dt id="culong"><pre id="culong">culong = uint32</pre></dt> <dd> This is the same as the type <code>unsigned long</code> in <em>C</em>.   </dd> <dt id="cchar"><pre id="cchar">cchar = char</pre></dt> <dd> This is the same as the type <code>char</code> in <em>C</em>.   </dd> <dt id="cschar"><pre id="cschar">cschar = int8</pre></dt> <dd> This is the same as the type <code>signed char</code> in <em>C</em>.   </dd> <dt id="cshort"><pre id="cshort">cshort = int16</pre></dt> <dd> This is the same as the type <code>short</code> in <em>C</em>.   </dd> <dt id="cint"><pre id="cint">cint = int32</pre></dt> <dd> This is the same as the type <code>int</code> in <em>C</em>.   </dd> <dt id="csize"><pre id="csize">csize = int</pre></dt> <dd> This is the same as the type <code>size_t</code> in <em>C</em>.   </dd> <dt id="clonglong"><pre id="clonglong">clonglong = int64</pre></dt> <dd> This is the same as the type <code>long long</code> in <em>C</em>.   </dd> <dt id="cfloat"><pre id="cfloat">cfloat = float32</pre></dt> <dd> This is the same as the type <code>float</code> in <em>C</em>.   </dd> <dt id="cdouble"><pre id="cdouble">cdouble = float64</pre></dt> <dd> This is the same as the type <code>double</code> in <em>C</em>.   </dd> <dt id="clongdouble"><pre id="clongdouble">clongdouble = BiggestFloat</pre></dt> <dd> This is the same as the type <code>long double</code> in <em>C</em>. This C type is not supported by Nim's code generator.   </dd> <dt id="cuchar"><pre id="cuchar">cuchar = char</pre></dt> <dd> This is the same as the type <code>unsigned char</code> in <em>C</em>.   </dd> <dt id="cushort"><pre id="cushort">cushort = uint16</pre></dt> <dd> This is the same as the type <code>unsigned short</code> in <em>C</em>.   </dd> <dt id="cuint"><pre id="cuint">cuint = uint32</pre></dt> <dd> This is the same as the type <code>unsigned int</code> in <em>C</em>.   </dd> <dt id="culonglong"><pre id="culonglong">culonglong = uint64</pre></dt> <dd> This is the same as the type <code>unsigned long long</code> in <em>C</em>.   </dd> <dt id="cstringArray"><pre id="cstringArray" data-language="nim">cstringArray = ptr UncheckedArray[cstring]</pre></dt> <dd> This is binary compatible to the type <code>char**</code> in <em>C</em>. The array's high value is large enough to disable bounds checking in practice. Use <em>cstringArrayToSeq</em> to convert it into a <code>seq[string]</code>.   </dd> <dt id="PFloat32"><pre id="PFloat32">PFloat32 = ptr float32</pre></dt> <dd> an alias for <code>ptr float32</code>   </dd> <dt id="PFloat64"><pre id="PFloat64">PFloat64 = ptr float64</pre></dt> <dd> an alias for <code>ptr float64</code>   </dd> <dt id="PInt64"><pre id="PInt64">PInt64 = ptr int64</pre></dt> <dd> an alias for <code>ptr int64</code>   </dd> <dt id="PInt32"><pre id="PInt32">PInt32 = ptr int32</pre></dt> <dd> an alias for <code>ptr int32</code>   </dd> <dt id="GC_Strategy"><pre id="GC_Strategy" data-language="nim">GC_Strategy = enum
  gcThroughput,               ## optimize for throughput
  gcResponsiveness,           ## optimize for responsiveness (default)
  gcOptimizeTime,             ## optimize for speed
  gcOptimizeSpace             ## optimize for memory footprint</pre></dt> <dd> the strategy the GC should use for the application   </dd> <dt id="PFrame"><pre id="PFrame">PFrame = ptr TFrame</pre></dt> <dd> represents a runtime frame of the call stack; part of the debugger API.   </dd> <dt id="TFrame"><pre id="TFrame" data-language="nim">TFrame = object
  prev*: PFrame                ## previous frame; used for chaining the call stack
  procname*: cstring           ## name of the proc that is currently executing
  line*: int                   ## line number of the proc that is currently executing
  filename*: cstring           ## filename of the proc that is currently executing
  len*: int16                  ## length of the inspectable slots
  calldepth*: int16            ## used for max call depth checking</pre></dt> <dd> the frame itself   </dd> <dt id="FileSeekPos"><pre id="FileSeekPos" data-language="nim">FileSeekPos = enum
  fspSet,                     ## Seek to absolute value
  fspCur,                     ## Seek relative to current position
  fspEnd                      ## Seek relative to end</pre></dt> <dd> Position relative to which seek should happen   </dd> <dt id="File"><pre id="File">File = ptr CFile</pre></dt> <dd> The type representing a file handle.   </dd> <dt id="FileMode"><pre id="FileMode" data-language="nim">FileMode = enum
  fmRead,                     ## Open the file for read access only.
  fmWrite,                    ## Open the file for write access only.
          ## If the file does not exist, it will be
          ## created.
  fmReadWrite,                ## Open the file for read and write access.
              ## If the file does not exist, it will be
              ## created. Existing files will be cleared!
  fmReadWriteExisting,        ## Open the file for read and write access.
                      ## If the file does not exist, it will not be
                      ## created. The existing file will not be cleared.
  fmAppend                    ## Open the file for writing only; append data
          ## at the end.</pre></dt> <dd> The file mode when opening a file.   </dd> <dt id="FileHandle"><pre id="FileHandle">FileHandle = cint</pre></dt> <dd> type that represents an OS file handle; this is useful for low-level file access   </dd> <dt id="ForeignCell"><pre id="ForeignCell" data-language="nim">ForeignCell = object
  data*: pointer
  owner: ptr GcHeap</pre></dt>  <dt id="Utf16Char"><pre id="Utf16Char">Utf16Char = distinct int16</pre></dt>  <dt id="WideCString"><pre id="WideCString" data-language="nim">WideCString = ref UncheckedArray[Utf16Char]</pre></dt>  <dt id="NimNode"><pre id="NimNode">NimNode = ref NimNodeObj</pre></dt> <dd> represents a Nim AST node. Macros operate on this type.   </dd> </dl>  <h2 id="8">Vars</h2> <dl> <dt id="programResult"><pre id="programResult">programResult: int</pre></dt> <dd> modify this variable to specify the exit code of the program under normal circumstances. When the program is terminated prematurely using <code>quit</code>, this value is ignored.   </dd> <dt id="globalRaiseHook"><pre id="globalRaiseHook" data-language="nim">globalRaiseHook: proc (e: ref Exception): bool {.nimcall, gcsafe, locks: 0.}</pre></dt> <dd> with this hook you can influence exception handling on a global level. If not nil, every 'raise' statement ends up calling this hook. Ordinary application code should never set this hook! You better know what you do when setting this. If <code>globalRaiseHook</code> returns false, the exception is caught and does not propagate further through the call stack.   </dd> <dt id="localRaiseHook"><pre id="localRaiseHook" data-language="nim">localRaiseHook: proc (e: ref Exception): bool {.nimcall, gcsafe, locks: 0.}</pre></dt> <dd> with this hook you can influence exception handling on a thread local level. If not nil, every 'raise' statement ends up calling this hook. Ordinary application code should never set this hook! You better know what you do when setting this. If <code>localRaiseHook</code> returns false, the exception is caught and does not propagate further through the call stack.   </dd> <dt id="outOfMemHook"><pre id="outOfMemHook" data-language="nim">outOfMemHook: proc () {.nimcall, tags: [], gcsafe, locks: 0.}</pre></dt> <dd> set this variable to provide a procedure that should be called in case of an <span id="out-of-memory_1">out of memory</span> event. The standard handler writes an error message and terminates the program. <em>outOfMemHook</em> can be used to raise an exception in case of OOM like so:<pre class="listing" data-language="nim">var gOutOfMem: ref EOutOfMemory
new(gOutOfMem) # need to be allocated *before* OOM really happened!
gOutOfMem.msg = "out of memory"

proc handleOOM() =
  raise gOutOfMem

system.outOfMemHook = handleOOM</pre>
<p>If the handler does not raise an exception, ordinary control flow continues and the program is terminated.</p>   </dd> <dt id="stdin"><pre id="stdin">stdin: File</pre></dt> <dd> The standard input stream.   </dd> <dt id="stdout"><pre id="stdout">stdout: File</pre></dt> <dd> The standard output stream.   </dd> <dt id="stderr"><pre id="stderr">stderr: File</pre></dt> <dd> The standard error stream.   </dd> <dt id="errorMessageWriter"><pre id="errorMessageWriter" data-language="nim">errorMessageWriter: (proc (msg: string) {.tags: [WriteIOEffect], gcsafe, locks: 0,
                                      nimcall.})</pre></dt> <dd> Function that will be called instead of stdmsg.write when printing stacktrace. Unstable API.   </dd> <dt id="onUnhandledException"><pre id="onUnhandledException" data-language="nim">onUnhandledException: (proc (errorMsg: string) {.nimcall.})</pre></dt> <dd> set this error handler to override the existing behaviour on an unhandled exception. The default is to write a stacktrace to <code>stderr</code> and then call <code>quit(1)</code>. Unstable API.   </dd> </dl>  <h2 id="9">Lets</h2> <dl> <dt id="nimvm"><pre id="nimvm">nimvm: bool = false</pre></dt> <dd> may be used only in "when" expression. It is true in Nim VM context and false otherwise   </dd> </dl>  <h2 id="10">Consts</h2> <dl> <dt id="on"><pre id="on">on = true</pre></dt> <dd> alias for <code>true</code>   </dd> <dt id="off"><pre id="off">off = false</pre></dt> <dd> alias for <code>false</code>   </dd> <dt id="appType"><pre id="appType" data-language="nim">appType: string = ""</pre></dt> <dd> a string that describes the application type. Possible values: "console", "gui", "lib".   </dd> <dt id="NoFakeVars"><pre id="NoFakeVars">NoFakeVars = false</pre></dt> <dd> true if the backend doesn't support "fake variables" like 'var EBADF {.importc.}: cint'.   </dd> <dt id="isMainModule"><pre id="isMainModule">isMainModule: bool = false</pre></dt> <dd> is true only when accessed in the main module. This works thanks to compiler magic. It is useful to embed testing code in a module.   </dd> <dt id="CompileDate"><pre id="CompileDate" data-language="nim">CompileDate: string = "0000-00-00"</pre></dt> <dd> is the date of compilation as a string of the form <code>YYYY-MM-DD</code>. This works thanks to compiler magic.   </dd> <dt id="CompileTime"><pre id="CompileTime" data-language="nim">CompileTime: string = "00:00:00"</pre></dt> <dd> is the time of compilation as a string of the form <code>HH:MM:SS</code>. This works thanks to compiler magic.   </dd> <dt id="cpuEndian"><pre id="cpuEndian">cpuEndian: Endianness = littleEndian</pre></dt> <dd> is the endianness of the target CPU. This is a valuable piece of information for low-level code only. This works thanks to compiler magic.   </dd> <dt id="hostOS"><pre id="hostOS" data-language="nim">hostOS: string = ""</pre></dt> <dd> a string that describes the host operating system. Possible values: "windows", "macosx", "linux", "netbsd", "freebsd", "openbsd", "solaris", "aix", "standalone".   </dd> <dt id="hostCPU"><pre id="hostCPU" data-language="nim">hostCPU: string = ""</pre></dt> <dd> a string that describes the host CPU. Possible values: "i386", "alpha", "powerpc", "powerpc64", "powerpc64el", "sparc", "amd64", "mips", "mipsel", "arm", "arm64", "mips64", "mips64el".   </dd> <dt id="nimEnableCovariance"><pre id="nimEnableCovariance">nimEnableCovariance = false</pre></dt>  <dt id="QuitSuccess"><pre id="QuitSuccess">QuitSuccess = 0</pre></dt> <dd> is the value that should be passed to <a href="#quit">quit</a> to indicate success.   </dd> <dt id="QuitFailure"><pre id="QuitFailure">QuitFailure = 1</pre></dt> <dd> is the value that should be passed to <a href="#quit">quit</a> to indicate failure.   </dd> <dt id="Inf"><pre id="Inf">Inf = inf</pre></dt> <dd> contains the IEEE floating point value of positive infinity.   </dd> <dt id="NegInf"><pre id="NegInf">NegInf = -inf</pre></dt> <dd> contains the IEEE floating point value of negative infinity.   </dd> <dt id="NaN"><pre id="NaN">NaN = nan</pre></dt> <dd> contains an IEEE floating point value of <em>Not A Number</em>. Note that you cannot compare a floating point value to this value and expect a reasonable result - use the <em>classify</em> procedure in the module <code>math</code> for checking for NaN.   </dd> <dt id="NimMajor"><pre id="NimMajor">NimMajor: int = 0</pre></dt> <dd> is the major number of Nim's version.   </dd> <dt id="NimMinor"><pre id="NimMinor">NimMinor: int = 17</pre></dt> <dd> is the minor number of Nim's version.   </dd> <dt id="NimPatch"><pre id="NimPatch">NimPatch: int = 2</pre></dt> <dd> is the patch number of Nim's version.   </dd> <dt id="NimVersion"><pre id="NimVersion" data-language="nim">NimVersion: string = "0.17.2"</pre></dt> <dd> is the version of Nim as a string.   </dd> <dt id="nimCoroutines"><pre id="nimCoroutines">nimCoroutines = false</pre></dt>  <dt id="nativeStackTraceSupported"><pre id="nativeStackTraceSupported">nativeStackTraceSupported = false</pre></dt>  </dl>  <h2 id="12">Procs</h2> <dl> <dt id="or"><pre id="or,typedesc,typedesc" data-language="nim">proc `or`(a, b: typedesc): typedesc {.magic: "TypeTrait", noSideEffect.}</pre></dt> <dd> Constructs an <em>or</em> meta class   </dd> <dt id="and"><pre id="and,typedesc,typedesc" data-language="nim">proc `and`(a, b: typedesc): typedesc {.magic: "TypeTrait", noSideEffect.}</pre></dt> <dd> Constructs an <em>and</em> meta class   </dd> <dt id="not"><pre id="not,typedesc" data-language="nim">proc `not`(a: typedesc): typedesc {.magic: "TypeTrait", noSideEffect.}</pre></dt> <dd> Constructs an <em>not</em> meta class   </dd> <dt id="defined"><pre id="defined,untyped" data-language="nim">proc defined(x: untyped): bool {.magic: "Defined", noSideEffect, compileTime.}</pre></dt> <dd> Special compile-time procedure that checks whether <em>x</em> is defined. <em>x</em> is an external symbol introduced through the compiler's <a href="../nimc/#compile-time-symbols">-d:x switch</a> to enable build time conditionals:<pre class="listing" data-language="nim">when not defined(release):
  # Do here programmer friendly expensive sanity checks.
# Put here the normal code</pre>   </dd> <dt id="declared"><pre id="declared,untyped" data-language="nim">proc declared(x: untyped): bool {.magic: "Defined", noSideEffect, compileTime.}</pre></dt> <dd> Special compile-time procedure that checks whether <em>x</em> is declared. <em>x</em> has to be an identifier or a qualified identifier. This can be used to check whether a library provides a certain feature or not:<pre class="listing" data-language="nim">when not declared(strutils.toUpper):
  # provide our own toUpper proc here, because strutils is
  # missing it.</pre>   </dd> <dt id="definedInScope"><pre id="definedInScope,untyped" data-language="nim">proc definedInScope(x: untyped): bool {.magic: "DefinedInScope", noSideEffect,
                                    deprecated, compileTime.}</pre></dt> <dd> <strong>Deprecated since version 0.9.6</strong>: Use <code>declaredInScope</code> instead.   </dd> <dt id="declaredInScope"><pre id="declaredInScope,untyped" data-language="nim">proc declaredInScope(x: untyped): bool {.magic: "DefinedInScope", noSideEffect,
                                     compileTime.}</pre></dt> <dd> Special compile-time procedure that checks whether <em>x</em> is declared in the current scope. <em>x</em> has to be an identifier.   </dd> <dt id="addr"><pre id="addr,T" data-language="nim">proc `addr`[T](x: var T): ptr T {.magic: "Addr", noSideEffect.}</pre></dt> <dd> Builtin 'addr' operator for taking the address of a memory location. Cannot be overloaded.<pre class="listing" data-language="nim">var
  buf: seq[char] = @['a','b','c']
  p: pointer = buf[1].addr
echo cast[ptr char](p)[]    # b</pre>   </dd> <dt id="unsafeAddr"><pre id="unsafeAddr,T" data-language="nim">proc unsafeAddr[T](x: T): ptr T {.magic: "Addr", noSideEffect.}</pre></dt> <dd> Builtin 'addr' operator for taking the address of a memory location. This works even for <code>let</code> variables or parameters for better interop with C and so it is considered even more unsafe than the ordinary <code>addr</code>. When you use it to write a wrapper for a C library, you should always check that the original library does never write to data behind the pointer that is returned from this procedure. Cannot be overloaded.   </dd> <dt id="type"><pre id="type,untyped" data-language="nim">proc `type`(x: untyped): typedesc {.magic: "TypeOf", noSideEffect, compileTime.}</pre></dt> <dd> Builtin 'type' operator for accessing the type of an expression. Cannot be overloaded.   </dd> <dt id="not"><pre id="not,bool" data-language="nim">proc `not`(x: bool): bool {.magic: "Not", noSideEffect.}</pre></dt> <dd> Boolean not; returns true iff <code>x == false</code>.   </dd> <dt id="and"><pre id="and,bool,bool" data-language="nim">proc `and`(x, y: bool): bool {.magic: "And", noSideEffect.}</pre></dt> <dd> Boolean <code>and</code>; returns true iff <code>x == y == true</code>. Evaluation is lazy: if <code>x</code> is false, <code>y</code> will not even be evaluated.   </dd> <dt id="or"><pre id="or,bool,bool" data-language="nim">proc `or`(x, y: bool): bool {.magic: "Or", noSideEffect.}</pre></dt> <dd> Boolean <code>or</code>; returns true iff <code>not (not x and not y)</code>. Evaluation is lazy: if <code>x</code> is true, <code>y</code> will not even be evaluated.   </dd> <dt id="xor"><pre id="xor,bool,bool" data-language="nim">proc `xor`(x, y: bool): bool {.magic: "Xor", noSideEffect.}</pre></dt> <dd> Boolean <em>exclusive or</em>; returns true iff <code>x != y</code>.   </dd> <dt id="new"><pre id="new,ref.T" data-language="nim">proc new[T](a: var ref T) {.magic: "New", noSideEffect.}</pre></dt> <dd> creates a new object of type <code>T</code> and returns a safe (traced) reference to it in <code>a</code>.   </dd> <dt id="new"><pre id="new,typedesc" data-language="nim">proc new(T: typedesc): auto</pre></dt> <dd> <p>creates a new object of type <code>T</code> and returns a safe (traced) reference to it as result value.</p> <p>When <code>T</code> is a ref type then the resulting type will be <code>T</code>, otherwise it will be <code>ref T</code>.</p>   </dd> <dt id="internalNew"><pre id="internalNew,ref.T" data-language="nim">proc internalNew[T](a: var ref T) {.magic: "New", noSideEffect.}</pre></dt> <dd> leaked implementation detail. Do not use.   </dd> <dt id="new"><pre id="new,ref.T,proc(ref.T)" data-language="nim">proc new[T](a: var ref T; finalizer: proc (x: ref T) {.nimcall.}) {.magic: "NewFinalize",
    noSideEffect.}</pre></dt> <dd> creates a new object of type <code>T</code> and returns a safe (traced) reference to it in <code>a</code>. When the garbage collector frees the object, <em>finalizer</em> is called. The <em>finalizer</em> may not keep a reference to the object pointed to by <em>x</em>. The <em>finalizer</em> cannot prevent the GC from freeing the object. Note: The <em>finalizer</em> refers to the type <em>T</em>, not to the object! This means that for each object of type <em>T</em> the finalizer will be called!   </dd> <dt id="reset"><pre id="reset,T" data-language="nim">proc reset[T](obj: var T) {.magic: "Reset", noSideEffect.}</pre></dt> <dd> resets an object <em>obj</em> to its initial (binary zero) value. This needs to be called before any possible <span id="object-branch-transition_1">object branch transition</span>.   </dd> <dt id="high"><pre id="high,T" data-language="nim">proc high[T: Ordinal](x: T): T {.magic: "High", noSideEffect.}</pre></dt> <dd> returns the highest possible index of an array, a sequence, a string or the highest possible value of an ordinal value <em>x</em>. As a special semantic rule, <em>x</em> may also be a type identifier. <code>high(int)</code> is Nim's way of writing <span id="int-max_1">INT_MAX</span> or <span id="max-int_1">MAX_INT</span>.<pre class="listing" data-language="nim">var arr = [1,2,3,4,5,6,7]
high(arr) #=&gt; 6
high(2) #=&gt; 9223372036854775807
high(int) #=&gt; 9223372036854775807</pre>   </dd> <dt id="high"><pre id="high,typedesc[T]" data-language="nim">proc high[T: Ordinal](x: typedesc[T]): T {.magic: "High", noSideEffect.}</pre></dt>  <dt id="high"><pre id="high,openArray[T]" data-language="nim">proc high[T](x: openArray[T]): int {.magic: "High", noSideEffect.}</pre></dt>  <dt id="high"><pre id="high,array[I,T]" data-language="nim">proc high[I, T](x: array[I, T]): I {.magic: "High", noSideEffect.}</pre></dt>  <dt id="high"><pre id="high,typedesc[array[I,T]]" data-language="nim">proc high[I, T](x: typedesc[array[I, T]]): I {.magic: "High", noSideEffect.}</pre></dt>  <dt id="high"><pre id="high,cstring" data-language="nim">proc high(x: cstring): int {.magic: "High", noSideEffect.}</pre></dt>  <dt id="high"><pre id="high,string" data-language="nim">proc high(x: string): int {.magic: "High", noSideEffect.}</pre></dt>  <dt id="low"><pre id="low,typedesc[T]" data-language="nim">proc low[T: Ordinal](x: typedesc[T]): T {.magic: "Low", noSideEffect.}</pre></dt>  <dt id="low"><pre id="low,openArray[T]" data-language="nim">proc low[T](x: openArray[T]): int {.magic: "Low", noSideEffect.}</pre></dt>  <dt id="low"><pre id="low,array[I,T]" data-language="nim">proc low[I, T](x: array[I, T]): I {.magic: "Low", noSideEffect.}</pre></dt>  <dt id="low"><pre id="low,T" data-language="nim">proc low[T](x: T): T {.magic: "Low", noSideEffect.}</pre></dt>  <dt id="low"><pre id="low,typedesc[array[I,T]]" data-language="nim">proc low[I, T](x: typedesc[array[I, T]]): I {.magic: "Low", noSideEffect.}</pre></dt>  <dt id="low"><pre id="low,cstring" data-language="nim">proc low(x: cstring): int {.magic: "Low", noSideEffect.}</pre></dt>  <dt id="low"><pre id="low,string" data-language="nim">proc low(x: string): int {.magic: "Low", noSideEffect.}</pre></dt> <dd> returns the lowest possible index of an array, a sequence, a string or the lowest possible value of an ordinal value <em>x</em>. As a special semantic rule, <em>x</em> may also be a type identifier.<pre class="listing" data-language="nim">var arr = [1,2,3,4,5,6,7]
low(arr) #=&gt; 0
low(2) #=&gt; -9223372036854775808
low(int) #=&gt; -9223372036854775808</pre>   </dd> <dt id="[]"><pre id="[],T,I" data-language="nim">proc `[]`[I: Ordinal; T](a: T; i: I): T {.noSideEffect, magic: "ArrGet".}</pre></dt>  <dt id="[]="><pre id="[]=,T,I,S" data-language="nim">proc `[]=`[I: Ordinal; T, S](a: T; i: I; x: S) {.noSideEffect, magic: "ArrPut".}</pre></dt>  <dt id="="><pre id="=,T,T" data-language="nim">proc `=`[T](dest: var T; src: T) {.noSideEffect, magic: "Asgn".}</pre></dt>  <dt id=".."><pre id="..,T,T" data-language="nim">proc `..`[T](a, b: T): Slice[T] {.noSideEffect, inline, magic: "DotDot".}</pre></dt> <dd> <span id="slice_1">slice</span> operator that constructs an interval <code>[a, b]</code>, both <em>a</em> and <em>b</em> are inclusive. Slices can also be used in the set constructor and in ordinal case statements, but then they are special-cased by the compiler.   </dd> <dt id=".."><pre id="..,T" data-language="nim">proc `..`[T](b: T): Slice[T] {.noSideEffect, inline, magic: "DotDot".}</pre></dt> <dd> <span id="slice_2">slice</span> operator that constructs an interval <code>[default(T), b]</code>   </dd> <dt id="=="><pre id="==,Enum,Enum" data-language="nim">proc `==`[Enum: enum](x, y: Enum): bool {.magic: "EqEnum", noSideEffect.}</pre></dt> <dd> Checks whether values within the <em>same enum</em> have the same underlying value<pre class="listing" data-language="nim">type
  Enum1 = enum
    Field1 = 3, Field2
  Enum2 = enum
    Place1, Place2 = 3
var
  e1 = Field1
  e2 = Enum1(Place2)
echo (e1 == e2) # true
echo (e1 == Place2) # raises error</pre>   </dd> <dt id="=="><pre id="==,pointer,pointer" data-language="nim">proc `==`(x, y: pointer): bool {.magic: "EqRef", noSideEffect.}</pre></dt> <dd> <pre class="listing" data-language="nim">var # this is a wildly dangerous example
  a = cast[pointer](0)
  b = cast[pointer](nil)
echo (a == b) # true due to the special meaning of `nil`/0 as a pointer</pre>   </dd> <dt id="=="><pre id="==,string,string" data-language="nim">proc `==`(x, y: string): bool {.magic: "EqStr", noSideEffect.}</pre></dt> <dd> Checks for equality between two <em>string</em> variables   </dd> <dt id="=="><pre id="==,char,char" data-language="nim">proc `==`(x, y: char): bool {.magic: "EqCh", noSideEffect.}</pre></dt> <dd> Checks for equality between two <em>char</em> variables   </dd> <dt id="=="><pre id="==,bool,bool" data-language="nim">proc `==`(x, y: bool): bool {.magic: "EqB", noSideEffect.}</pre></dt> <dd> Checks for equality between two <em>bool</em> variables   </dd> <dt id="=="><pre id="==,set[T],set[T]" data-language="nim">proc `==`[T](x, y: set[T]): bool {.magic: "EqSet", noSideEffect.}</pre></dt> <dd> Checks for equality between two variables of type <em>set</em><pre class="listing" data-language="nim">var a = {1, 2, 2, 3} # duplication in sets is ignored
var b = {1, 2, 3}
echo (a == b) # true</pre>   </dd> <dt id="=="><pre id="==,ref.T,ref.T" data-language="nim">proc `==`[T](x, y: ref T): bool {.magic: "EqRef", noSideEffect.}</pre></dt> <dd> Checks that two <em>ref</em> variables refer to the same item   </dd> <dt id="=="><pre id="==,ptr.T,ptr.T" data-language="nim">proc `==`[T](x, y: ptr T): bool {.magic: "EqRef", noSideEffect.}</pre></dt> <dd> Checks that two <em>ptr</em> variables refer to the same item   </dd> <dt id="=="><pre id="==,T,T" data-language="nim">proc `==`[T: proc](x, y: T): bool {.magic: "EqProc", noSideEffect.}</pre></dt> <dd> Checks that two <em>proc</em> variables refer to the same procedure   </dd> <dt id="&lt;="><pre id="&lt;=,Enum,Enum" data-language="nim">proc `&lt;=`[Enum: enum](x, y: Enum): bool {.magic: "LeEnum", noSideEffect.}</pre></dt>  <dt id="&lt;="><pre id="&lt;=,string,string" data-language="nim">proc `&lt;=`(x, y: string): bool {.magic: "LeStr", noSideEffect.}</pre></dt>  <dt id="&lt;="><pre id="&lt;=,char,char" data-language="nim">proc `&lt;=`(x, y: char): bool {.magic: "LeCh", noSideEffect.}</pre></dt>  <dt id="&lt;="><pre id="&lt;=,set[T],set[T]" data-language="nim">proc `&lt;=`[T](x, y: set[T]): bool {.magic: "LeSet", noSideEffect.}</pre></dt>  <dt id="&lt;="><pre id="&lt;=,bool,bool" data-language="nim">proc `&lt;=`(x, y: bool): bool {.magic: "LeB", noSideEffect.}</pre></dt>  <dt id="&lt;="><pre id="&lt;=,ref.T,ref.T" data-language="nim">proc `&lt;=`[T](x, y: ref T): bool {.magic: "LePtr", noSideEffect.}</pre></dt>  <dt id="&lt;="><pre id="&lt;=,pointer,pointer" data-language="nim">proc `&lt;=`(x, y: pointer): bool {.magic: "LePtr", noSideEffect.}</pre></dt>  <dt id="&lt;"><pre id="&lt;,Enum,Enum" data-language="nim">proc `&lt;`[Enum: enum](x, y: Enum): bool {.magic: "LtEnum", noSideEffect.}</pre></dt>  <dt id="&lt;"><pre id="&lt;,string,string" data-language="nim">proc `&lt;`(x, y: string): bool {.magic: "LtStr", noSideEffect.}</pre></dt>  <dt id="&lt;"><pre id="&lt;,char,char" data-language="nim">proc `&lt;`(x, y: char): bool {.magic: "LtCh", noSideEffect.}</pre></dt>  <dt id="&lt;"><pre id="&lt;,set[T],set[T]" data-language="nim">proc `&lt;`[T](x, y: set[T]): bool {.magic: "LtSet", noSideEffect.}</pre></dt>  <dt id="&lt;"><pre id="&lt;,bool,bool" data-language="nim">proc `&lt;`(x, y: bool): bool {.magic: "LtB", noSideEffect.}</pre></dt>  <dt id="&lt;"><pre id="&lt;,ref.T,ref.T" data-language="nim">proc `&lt;`[T](x, y: ref T): bool {.magic: "LtPtr", noSideEffect.}</pre></dt>  <dt id="&lt;"><pre id="&lt;,ptr.T,ptr.T" data-language="nim">proc `&lt;`[T](x, y: ptr T): bool {.magic: "LtPtr", noSideEffect.}</pre></dt>  <dt id="&lt;"><pre id="&lt;,pointer,pointer" data-language="nim">proc `&lt;`(x, y: pointer): bool {.magic: "LtPtr", noSideEffect.}</pre></dt>  <dt id="unsafeNew"><pre id="unsafeNew,ref.T,Natural" data-language="nim">proc unsafeNew[T](a: var ref T; size: Natural) {.magic: "New", noSideEffect.}</pre></dt> <dd> creates a new object of type <code>T</code> and returns a safe (traced) reference to it in <code>a</code>. This is <strong>unsafe</strong> as it allocates an object of the passed <code>size</code>. This should only be used for optimization purposes when you know what you're doing!   </dd> <dt id="sizeof"><pre id="sizeof,T" data-language="nim">proc sizeof[T](x: T): int {.magic: "SizeOf", noSideEffect.}</pre></dt> <dd> <p>returns the size of <code>x</code> in bytes. Since this is a low-level proc, its usage is discouraged - using <code>new</code> for the most cases suffices that one never needs to know <code>x</code>'s size. As a special semantic rule, <code>x</code> may also be a type identifier (<code>sizeof(int)</code> is valid).</p> <p>Limitations: If used within nim VM context <code>sizeof</code> will only work for simple types.</p> <pre class="listing" data-language="nim">sizeof('A') #=&gt; 1
sizeof(2) #=&gt; 8</pre>   </dd> <dt id="sizeof"><pre id="sizeof,typedesc" data-language="nim">proc sizeof(x: typedesc): int {.magic: "SizeOf", noSideEffect.}</pre></dt>  <dt id="&lt;"><pre id="&lt;,Ordinal[T]" data-language="nim">proc `&lt;`[T](x: Ordinal[T]): T {.magic: "UnaryLt", noSideEffect.}</pre></dt> <dd> unary <code>&lt;</code> that can be used for nice looking excluding ranges:<pre class="listing" data-language="nim">for i in 0 .. &lt;10: echo i #=&gt; 0 1 2 3 4 5 6 7 8 9</pre>
<p>Semantically this is the same as <code>pred</code>.</p>   </dd> <dt id="succ"><pre id="succ,Ordinal[T],int" data-language="nim">proc succ[T](x: Ordinal[T]; y = 1): T {.magic: "Succ", noSideEffect.}</pre></dt> <dd> returns the <code>y</code>-th successor of the value <code>x</code>. <code>T</code> has to be an ordinal type. If such a value does not exist, <code>EOutOfRange</code> is raised or a compile time error occurs.   </dd> <dt id="pred"><pre id="pred,Ordinal[T],int" data-language="nim">proc pred[T](x: Ordinal[T]; y = 1): T {.magic: "Pred", noSideEffect.}</pre></dt> <dd> returns the <code>y</code>-th predecessor of the value <code>x</code>. <code>T</code> has to be an ordinal type. If such a value does not exist, <code>EOutOfRange</code> is raised or a compile time error occurs.   </dd> <dt id="inc"><pre id="inc,T,int" data-language="nim">proc inc[T: Ordinal | uint | uint64](x: var T; y = 1) {.magic: "Inc", noSideEffect.}</pre></dt> <dd> increments the ordinal <code>x</code> by <code>y</code>. If such a value does not exist, <code>EOutOfRange</code> is raised or a compile time error occurs. This is a short notation for: <code>x = succ(x, y)</code>.<pre class="listing" data-language="nim">var i = 2
inc(i) #=&gt; 3
inc(i, 3) #=&gt; 6</pre>   </dd> <dt id="dec"><pre id="dec,T,int" data-language="nim">proc dec[T: Ordinal | uint | uint64](x: var T; y = 1) {.magic: "Dec", noSideEffect.}</pre></dt> <dd> decrements the ordinal <code>x</code> by <code>y</code>. If such a value does not exist, <code>EOutOfRange</code> is raised or a compile time error occurs. This is a short notation for: <code>x = pred(x, y)</code>.<pre class="listing" data-language="nim">var i = 2
dec(i) #=&gt; 1
dec(i, 3) #=&gt; -2</pre>   </dd> <dt id="newSeq"><pre id="newSeq,seq[T],Natural" data-language="nim">proc newSeq[T](s: var seq[T]; len: Natural) {.magic: "NewSeq", noSideEffect.}</pre></dt> <dd> <p>creates a new sequence of type <code>seq[T]</code> with length <code>len</code>. This is equivalent to <code>s = @[]; setlen(s, len)</code>, but more efficient since no reallocation is needed.</p> <p>Note that the sequence will be filled with zeroed entries, which can be a problem for sequences containing strings since their value will be <code>nil</code>. After the creation of the sequence you should assign entries to the sequence instead of adding them. Example:</p> <pre class="listing" data-language="nim">var inputStrings : seq[string]
newSeq(inputStrings, 3)
inputStrings[0] = "The fourth"
inputStrings[1] = "assignment"
inputStrings[2] = "would crash"
#inputStrings[3] = "out of bounds"</pre>   </dd> <dt id="newSeq"><pre id="newSeq," data-language="nim">proc newSeq[T](len = 0.Natural): seq[T]</pre></dt> <dd> <p>creates a new sequence of type <code>seq[T]</code> with length <code>len</code>.</p> <p>Note that the sequence will be filled with zeroed entries, which can be a problem for sequences containing strings since their value will be <code>nil</code>. After the creation of the sequence you should assign entries to the sequence instead of adding them. Example:</p> <pre class="listing" data-language="nim">var inputStrings = newSeq[string](3)
inputStrings[0] = "The fourth"
inputStrings[1] = "assignment"
inputStrings[2] = "would crash"
#inputStrings[3] = "out of bounds"</pre>   </dd> <dt id="newSeqOfCap"><pre id="newSeqOfCap,Natural" data-language="nim">proc newSeqOfCap[T](cap: Natural): seq[T] {.magic: "NewSeqOfCap", noSideEffect.}</pre></dt> <dd> creates a new sequence of type <code>seq[T]</code> with length 0 and capacity <code>cap</code>.   </dd> <dt id="len"><pre id="len,TOpenArray" data-language="nim">proc len[TOpenArray: openArray | varargs](x: TOpenArray): int {.
    magic: "LengthOpenArray", noSideEffect.}</pre></dt>  <dt id="len"><pre id="len,string" data-language="nim">proc len(x: string): int {.magic: "LengthStr", noSideEffect.}</pre></dt>  <dt id="len"><pre id="len,cstring" data-language="nim">proc len(x: cstring): int {.magic: "LengthStr", noSideEffect.}</pre></dt>  <dt id="len"><pre id="len," data-language="nim">proc len(x: (type array) | array): int {.magic: "LengthArray", noSideEffect.}</pre></dt>  <dt id="len"><pre id="len,seq[T]" data-language="nim">proc len[T](x: seq[T]): int {.magic: "LengthSeq", noSideEffect.}</pre></dt> <dd> returns the length of an array, an openarray, a sequence or a string. This is roughly the same as <code>high(T)-low(T)+1</code>, but its resulting type is always an int.<pre class="listing" data-language="nim">var arr = [1,1,1,1,1]
len(arr) #=&gt; 5
for i in 0..&lt;arr.len:
  echo arr[i] #=&gt; 1,1,1,1,1</pre>   </dd> <dt id="incl"><pre id="incl,set[T],T" data-language="nim">proc incl[T](x: var set[T]; y: T) {.magic: "Incl", noSideEffect.}</pre></dt> <dd> includes element <code>y</code> to the set <code>x</code>. This is the same as <code>x = x + {y}</code>, but it might be more efficient.<pre class="listing" data-language="nim">var a = initSet[int](4)
a.incl(2) #=&gt; {2}
a.incl(3) #=&gt; {2, 3}</pre>   </dd> <dt id="excl"><pre id="excl,set[T],T" data-language="nim">proc excl[T](x: var set[T]; y: T) {.magic: "Excl", noSideEffect.}</pre></dt> <dd> excludes element <code>y</code> to the set <code>x</code>. This is the same as <code>x = x - {y}</code>, but it might be more efficient.<pre class="listing" data-language="nim">var b = {2,3,5,6,12,545}
b.excl(5)  #=&gt; {2,3,6,12,545}</pre>   </dd> <dt id="card"><pre id="card,set[T]" data-language="nim">proc card[T](x: set[T]): int {.magic: "Card", noSideEffect.}</pre></dt> <dd> returns the cardinality of the set <code>x</code>, i.e. the number of elements in the set.<pre class="listing" data-language="nim">var i = {1,2,3,4}
card(i) #=&gt; 4</pre>   </dd> <dt id="ord"><pre id="ord,T" data-language="nim">proc ord[T](x: T): int {.magic: "Ord", noSideEffect.}</pre></dt> <dd> returns the internal int value of an ordinal value <code>x</code>.<pre class="listing" data-language="nim">ord('A') #=&gt; 65</pre>   </dd> <dt id="chr"><pre id="chr,range[]" data-language="nim">proc chr(u: range[0 .. 255]): char {.magic: "Chr", noSideEffect.}</pre></dt> <dd> converts an int in the range 0..255 to a character.<pre class="listing" data-language="nim">chr(65) #=&gt; A</pre>   </dd> <dt id="ze"><pre id="ze,int8" data-language="nim">proc ze(x: int8): int {.magic: "Ze8ToI", noSideEffect.}</pre></dt> <dd> zero extends a smaller integer type to <code>int</code>. This treats <em>x</em> as unsigned.   </dd> <dt id="ze"><pre id="ze,int16" data-language="nim">proc ze(x: int16): int {.magic: "Ze16ToI", noSideEffect.}</pre></dt> <dd> zero extends a smaller integer type to <code>int</code>. This treats <em>x</em> as unsigned.   </dd> <dt id="ze64"><pre id="ze64,int8" data-language="nim">proc ze64(x: int8): int64 {.magic: "Ze8ToI64", noSideEffect.}</pre></dt> <dd> zero extends a smaller integer type to <code>int64</code>. This treats <em>x</em> as unsigned.   </dd> <dt id="ze64"><pre id="ze64,int16" data-language="nim">proc ze64(x: int16): int64 {.magic: "Ze16ToI64", noSideEffect.}</pre></dt> <dd> zero extends a smaller integer type to <code>int64</code>. This treats <em>x</em> as unsigned.   </dd> <dt id="ze64"><pre id="ze64,int32" data-language="nim">proc ze64(x: int32): int64 {.magic: "Ze32ToI64", noSideEffect.}</pre></dt> <dd> zero extends a smaller integer type to <code>int64</code>. This treats <em>x</em> as unsigned.   </dd> <dt id="ze64"><pre id="ze64,int" data-language="nim">proc ze64(x: int): int64 {.magic: "ZeIToI64", noSideEffect.}</pre></dt> <dd> zero extends a smaller integer type to <code>int64</code>. This treats <em>x</em> as unsigned. Does nothing if the size of an <code>int</code> is the same as <code>int64</code>. (This is the case on 64 bit processors.)   </dd> <dt id="toU8"><pre id="toU8,int" data-language="nim">proc toU8(x: int): int8 {.magic: "ToU8", noSideEffect.}</pre></dt> <dd> treats <em>x</em> as unsigned and converts it to a byte by taking the last 8 bits from <em>x</em>.   </dd> <dt id="toU16"><pre id="toU16,int" data-language="nim">proc toU16(x: int): int16 {.magic: "ToU16", noSideEffect.}</pre></dt> <dd> treats <em>x</em> as unsigned and converts it to an <code>int16</code> by taking the last 16 bits from <em>x</em>.   </dd> <dt id="toU32"><pre id="toU32,int64" data-language="nim">proc toU32(x: int64): int32 {.magic: "ToU32", noSideEffect.}</pre></dt> <dd> treats <em>x</em> as unsigned and converts it to an <code>int32</code> by taking the last 32 bits from <em>x</em>.   </dd> <dt id="+"><pre id="+,int" data-language="nim">proc `+`(x: int): int {.magic: "UnaryPlusI", noSideEffect.}</pre></dt>  <dt id="+"><pre id="+,int8" data-language="nim">proc `+`(x: int8): int8 {.magic: "UnaryPlusI", noSideEffect.}</pre></dt>  <dt id="+"><pre id="+,int16" data-language="nim">proc `+`(x: int16): int16 {.magic: "UnaryPlusI", noSideEffect.}</pre></dt>  <dt id="+"><pre id="+,int32" data-language="nim">proc `+`(x: int32): int32 {.magic: "UnaryPlusI", noSideEffect.}</pre></dt>  <dt id="+"><pre id="+,int64" data-language="nim">proc `+`(x: int64): int64 {.magic: "UnaryPlusI", noSideEffect.}</pre></dt> <dd> Unary <em>+</em> operator for an integer. Has no effect.   </dd> <dt id="-"><pre id="-,int" data-language="nim">proc `-`(x: int): int {.magic: "UnaryMinusI", noSideEffect.}</pre></dt>  <dt id="-"><pre id="-,int8" data-language="nim">proc `-`(x: int8): int8 {.magic: "UnaryMinusI", noSideEffect.}</pre></dt>  <dt id="-"><pre id="-,int16" data-language="nim">proc `-`(x: int16): int16 {.magic: "UnaryMinusI", noSideEffect.}</pre></dt>  <dt id="-"><pre id="-,int32" data-language="nim">proc `-`(x: int32): int32 {.magic: "UnaryMinusI", noSideEffect.}</pre></dt>  <dt id="-"><pre id="-,int64" data-language="nim">proc `-`(x: int64): int64 {.magic: "UnaryMinusI64", noSideEffect.}</pre></dt> <dd> Unary <em>-</em> operator for an integer. Negates <em>x</em>.   </dd> <dt id="not"><pre id="not,int" data-language="nim">proc `not`(x: int): int {.magic: "BitnotI", noSideEffect.}</pre></dt>  <dt id="not"><pre id="not,int8" data-language="nim">proc `not`(x: int8): int8 {.magic: "BitnotI", noSideEffect.}</pre></dt>  <dt id="not"><pre id="not,int16" data-language="nim">proc `not`(x: int16): int16 {.magic: "BitnotI", noSideEffect.}</pre></dt>  <dt id="not"><pre id="not,int32" data-language="nim">proc `not`(x: int32): int32 {.magic: "BitnotI", noSideEffect.}</pre></dt> <dd> computes the <em>bitwise complement</em> of the integer <em>x</em>.   </dd> <dt id="not"><pre id="not,int64" data-language="nim">proc `not`(x: int64): int64 {.magic: "BitnotI", noSideEffect.}</pre></dt>  <dt id="+"><pre id="+,int,int" data-language="nim">proc `+`(x, y: int): int {.magic: "AddI", noSideEffect.}</pre></dt>  <dt id="+"><pre id="+,int8,int8" data-language="nim">proc `+`(x, y: int8): int8 {.magic: "AddI", noSideEffect.}</pre></dt>  <dt id="+"><pre id="+,int16,int16" data-language="nim">proc `+`(x, y: int16): int16 {.magic: "AddI", noSideEffect.}</pre></dt>  <dt id="+"><pre id="+,int32,int32" data-language="nim">proc `+`(x, y: int32): int32 {.magic: "AddI", noSideEffect.}</pre></dt> <dd> Binary <em>+</em> operator for an integer.   </dd> <dt id="+"><pre id="+,int64,int64" data-language="nim">proc `+`(x, y: int64): int64 {.magic: "AddI", noSideEffect.}</pre></dt>  <dt id="-"><pre id="-,int,int" data-language="nim">proc `-`(x, y: int): int {.magic: "SubI", noSideEffect.}</pre></dt>  <dt id="-"><pre id="-,int8,int8" data-language="nim">proc `-`(x, y: int8): int8 {.magic: "SubI", noSideEffect.}</pre></dt>  <dt id="-"><pre id="-,int16,int16" data-language="nim">proc `-`(x, y: int16): int16 {.magic: "SubI", noSideEffect.}</pre></dt>  <dt id="-"><pre id="-,int32,int32" data-language="nim">proc `-`(x, y: int32): int32 {.magic: "SubI", noSideEffect.}</pre></dt> <dd> Binary <em>-</em> operator for an integer.   </dd> <dt id="-"><pre id="-,int64,int64" data-language="nim">proc `-`(x, y: int64): int64 {.magic: "SubI", noSideEffect.}</pre></dt>  <dt id="*"><pre id="*,int,int" data-language="nim">proc `*`(x, y: int): int {.magic: "MulI", noSideEffect.}</pre></dt>  <dt id="*"><pre id="*,int8,int8" data-language="nim">proc `*`(x, y: int8): int8 {.magic: "MulI", noSideEffect.}</pre></dt>  <dt id="*"><pre id="*,int16,int16" data-language="nim">proc `*`(x, y: int16): int16 {.magic: "MulI", noSideEffect.}</pre></dt>  <dt id="*"><pre id="*,int32,int32" data-language="nim">proc `*`(x, y: int32): int32 {.magic: "MulI", noSideEffect.}</pre></dt> <dd> Binary <em>*</em> operator for an integer.   </dd> <dt id="*"><pre id="*,int64,int64" data-language="nim">proc `*`(x, y: int64): int64 {.magic: "MulI", noSideEffect.}</pre></dt>  <dt id="div"><pre id="div,int,int" data-language="nim">proc `div`(x, y: int): int {.magic: "DivI", noSideEffect.}</pre></dt>  <dt id="div"><pre id="div,int8,int8" data-language="nim">proc `div`(x, y: int8): int8 {.magic: "DivI", noSideEffect.}</pre></dt>  <dt id="div"><pre id="div,int16,int16" data-language="nim">proc `div`(x, y: int16): int16 {.magic: "DivI", noSideEffect.}</pre></dt>  <dt id="div"><pre id="div,int32,int32" data-language="nim">proc `div`(x, y: int32): int32 {.magic: "DivI", noSideEffect.}</pre></dt> <dd> computes the integer division. This is roughly the same as <code>floor(x/y)</code>.<pre class="listing" data-language="nim">1 div 2 == 0
2 div 2 == 1
3 div 2 == 1
7 div 5 == 1</pre>   </dd> <dt id="div"><pre id="div,int64,int64" data-language="nim">proc `div`(x, y: int64): int64 {.magic: "DivI", noSideEffect.}</pre></dt>  <dt id="mod"><pre id="mod,int,int" data-language="nim">proc `mod`(x, y: int): int {.magic: "ModI", noSideEffect.}</pre></dt>  <dt id="mod"><pre id="mod,int8,int8" data-language="nim">proc `mod`(x, y: int8): int8 {.magic: "ModI", noSideEffect.}</pre></dt>  <dt id="mod"><pre id="mod,int16,int16" data-language="nim">proc `mod`(x, y: int16): int16 {.magic: "ModI", noSideEffect.}</pre></dt>  <dt id="mod"><pre id="mod,int32,int32" data-language="nim">proc `mod`(x, y: int32): int32 {.magic: "ModI", noSideEffect.}</pre></dt> <dd> computes the integer modulo operation (remainder). This is the same as <code>x - (x div y) * y</code>.<pre class="listing" data-language="nim">(7 mod 5) == 2</pre>   </dd> <dt id="mod"><pre id="mod,int64,int64" data-language="nim">proc `mod`(x, y: int64): int64 {.magic: "ModI", noSideEffect.}</pre></dt>  <dt id="shr"><pre id="shr,int,SomeInteger" data-language="nim">proc `shr`(x: int; y: SomeInteger): int {.magic: "ShrI", noSideEffect.}</pre></dt>  <dt id="shr"><pre id="shr,int8,SomeInteger" data-language="nim">proc `shr`(x: int8; y: SomeInteger): int8 {.magic: "ShrI", noSideEffect.}</pre></dt>  <dt id="shr"><pre id="shr,int16,SomeInteger" data-language="nim">proc `shr`(x: int16; y: SomeInteger): int16 {.magic: "ShrI", noSideEffect.}</pre></dt>  <dt id="shr"><pre id="shr,int32,SomeInteger" data-language="nim">proc `shr`(x: int32; y: SomeInteger): int32 {.magic: "ShrI", noSideEffect.}</pre></dt>  <dt id="shr"><pre id="shr,int64,SomeInteger" data-language="nim">proc `shr`(x: int64; y: SomeInteger): int64 {.magic: "ShrI", noSideEffect.}</pre></dt> <dd> computes the <em>shift right</em> operation of <em>x</em> and <em>y</em>, filling vacant bit positions with zeros.<pre class="listing" data-language="nim">0b0001_0000'i8 shr 2 == 0b0000_0100'i8
0b1000_0000'i8 shr 8 == 0b0000_0000'i8
0b0000_0001'i8 shr 1 == 0b0000_0000'i8</pre>   </dd> <dt id="shl"><pre id="shl,int,SomeInteger" data-language="nim">proc `shl`(x: int; y: SomeInteger): int {.magic: "ShlI", noSideEffect.}</pre></dt>  <dt id="shl"><pre id="shl,int8,SomeInteger" data-language="nim">proc `shl`(x: int8; y: SomeInteger): int8 {.magic: "ShlI", noSideEffect.}</pre></dt>  <dt id="shl"><pre id="shl,int16,SomeInteger" data-language="nim">proc `shl`(x: int16; y: SomeInteger): int16 {.magic: "ShlI", noSideEffect.}</pre></dt>  <dt id="shl"><pre id="shl,int32,SomeInteger" data-language="nim">proc `shl`(x: int32; y: SomeInteger): int32 {.magic: "ShlI", noSideEffect.}</pre></dt>  <dt id="shl"><pre id="shl,int64,SomeInteger" data-language="nim">proc `shl`(x: int64; y: SomeInteger): int64 {.magic: "ShlI", noSideEffect.}</pre></dt> <dd> computes the <em>shift left</em> operation of <em>x</em> and <em>y</em>.<pre class="listing" data-language="nim">1'i32 shl 4 == 0x0000_0010
1'i64 shl 4 == 0x0000_0000_0000_0010</pre>   </dd> <dt id="and"><pre id="and,int,int" data-language="nim">proc `and`(x, y: int): int {.magic: "BitandI", noSideEffect.}</pre></dt>  <dt id="and"><pre id="and,int8,int8" data-language="nim">proc `and`(x, y: int8): int8 {.magic: "BitandI", noSideEffect.}</pre></dt>  <dt id="and"><pre id="and,int16,int16" data-language="nim">proc `and`(x, y: int16): int16 {.magic: "BitandI", noSideEffect.}</pre></dt>  <dt id="and"><pre id="and,int32,int32" data-language="nim">proc `and`(x, y: int32): int32 {.magic: "BitandI", noSideEffect.}</pre></dt>  <dt id="and"><pre id="and,int64,int64" data-language="nim">proc `and`(x, y: int64): int64 {.magic: "BitandI", noSideEffect.}</pre></dt> <dd> computes the <em>bitwise and</em> of numbers <em>x</em> and <em>y</em>.<pre class="listing" data-language="nim">(0xffff'i16 and 0x0010'i16) == 0x0010</pre>   </dd> <dt id="or"><pre id="or,int,int" data-language="nim">proc `or`(x, y: int): int {.magic: "BitorI", noSideEffect.}</pre></dt>  <dt id="or"><pre id="or,int8,int8" data-language="nim">proc `or`(x, y: int8): int8 {.magic: "BitorI", noSideEffect.}</pre></dt>  <dt id="or"><pre id="or,int16,int16" data-language="nim">proc `or`(x, y: int16): int16 {.magic: "BitorI", noSideEffect.}</pre></dt>  <dt id="or"><pre id="or,int32,int32" data-language="nim">proc `or`(x, y: int32): int32 {.magic: "BitorI", noSideEffect.}</pre></dt>  <dt id="or"><pre id="or,int64,int64" data-language="nim">proc `or`(x, y: int64): int64 {.magic: "BitorI", noSideEffect.}</pre></dt> <dd> computes the <em>bitwise or</em> of numbers <em>x</em> and <em>y</em>.<pre class="listing" data-language="nim">(0x0005'i16 or 0x0010'i16) == 0x0015</pre>   </dd> <dt id="xor"><pre id="xor,int,int" data-language="nim">proc `xor`(x, y: int): int {.magic: "BitxorI", noSideEffect.}</pre></dt>  <dt id="xor"><pre id="xor,int8,int8" data-language="nim">proc `xor`(x, y: int8): int8 {.magic: "BitxorI", noSideEffect.}</pre></dt>  <dt id="xor"><pre id="xor,int16,int16" data-language="nim">proc `xor`(x, y: int16): int16 {.magic: "BitxorI", noSideEffect.}</pre></dt>  <dt id="xor"><pre id="xor,int32,int32" data-language="nim">proc `xor`(x, y: int32): int32 {.magic: "BitxorI", noSideEffect.}</pre></dt>  <dt id="xor"><pre id="xor,int64,int64" data-language="nim">proc `xor`(x, y: int64): int64 {.magic: "BitxorI", noSideEffect.}</pre></dt> <dd> computes the <em>bitwise xor</em> of numbers <em>x</em> and <em>y</em>.<pre class="listing" data-language="nim">(0x1011'i16 xor 0x0101'i16) == 0x1110</pre>   </dd> <dt id="=="><pre id="==,int,int" data-language="nim">proc `==`(x, y: int): bool {.magic: "EqI", noSideEffect.}</pre></dt>  <dt id="=="><pre id="==,int8,int8" data-language="nim">proc `==`(x, y: int8): bool {.magic: "EqI", noSideEffect.}</pre></dt>  <dt id="=="><pre id="==,int16,int16" data-language="nim">proc `==`(x, y: int16): bool {.magic: "EqI", noSideEffect.}</pre></dt>  <dt id="=="><pre id="==,int32,int32" data-language="nim">proc `==`(x, y: int32): bool {.magic: "EqI", noSideEffect.}</pre></dt>  <dt id="=="><pre id="==,int64,int64" data-language="nim">proc `==`(x, y: int64): bool {.magic: "EqI", noSideEffect.}</pre></dt> <dd> Compares two integers for equality.   </dd> <dt id="&lt;="><pre id="&lt;=,int,int" data-language="nim">proc `&lt;=`(x, y: int): bool {.magic: "LeI", noSideEffect.}</pre></dt>  <dt id="&lt;="><pre id="&lt;=,int8,int8" data-language="nim">proc `&lt;=`(x, y: int8): bool {.magic: "LeI", noSideEffect.}</pre></dt>  <dt id="&lt;="><pre id="&lt;=,int16,int16" data-language="nim">proc `&lt;=`(x, y: int16): bool {.magic: "LeI", noSideEffect.}</pre></dt>  <dt id="&lt;="><pre id="&lt;=,int32,int32" data-language="nim">proc `&lt;=`(x, y: int32): bool {.magic: "LeI", noSideEffect.}</pre></dt>  <dt id="&lt;="><pre id="&lt;=,int64,int64" data-language="nim">proc `&lt;=`(x, y: int64): bool {.magic: "LeI", noSideEffect.}</pre></dt> <dd> Returns true iff <em>x</em> is less than or equal to <em>y</em>.   </dd> <dt id="&lt;"><pre id="&lt;,int,int" data-language="nim">proc `&lt;`(x, y: int): bool {.magic: "LtI", noSideEffect.}</pre></dt>  <dt id="&lt;"><pre id="&lt;,int8,int8" data-language="nim">proc `&lt;`(x, y: int8): bool {.magic: "LtI", noSideEffect.}</pre></dt>  <dt id="&lt;"><pre id="&lt;,int16,int16" data-language="nim">proc `&lt;`(x, y: int16): bool {.magic: "LtI", noSideEffect.}</pre></dt>  <dt id="&lt;"><pre id="&lt;,int32,int32" data-language="nim">proc `&lt;`(x, y: int32): bool {.magic: "LtI", noSideEffect.}</pre></dt>  <dt id="&lt;"><pre id="&lt;,int64,int64" data-language="nim">proc `&lt;`(x, y: int64): bool {.magic: "LtI", noSideEffect.}</pre></dt> <dd> Returns true iff <em>x</em> is less than <em>y</em>.   </dd> <dt id="+%"><pre id="+%,IntMax32,IntMax32" data-language="nim">proc `+%`(x, y: IntMax32): IntMax32 {.magic: "AddU", noSideEffect.}</pre></dt>  <dt id="+%"><pre id="+%,int64,int64" data-language="nim">proc `+%`(x, y: int64): int64 {.magic: "AddU", noSideEffect.}</pre></dt> <dd> treats <em>x</em> and <em>y</em> as unsigned and adds them. The result is truncated to fit into the result. This implements modulo arithmetic. No overflow errors are possible.   </dd> <dt id="-%"><pre id="-%,IntMax32,IntMax32" data-language="nim">proc `-%`(x, y: IntMax32): IntMax32 {.magic: "SubU", noSideEffect.}</pre></dt>  <dt id="-%"><pre id="-%,int64,int64" data-language="nim">proc `-%`(x, y: int64): int64 {.magic: "SubU", noSideEffect.}</pre></dt> <dd> treats <em>x</em> and <em>y</em> as unsigned and subtracts them. The result is truncated to fit into the result. This implements modulo arithmetic. No overflow errors are possible.   </dd> <dt id="*%"><pre id="*%,IntMax32,IntMax32" data-language="nim">proc `*%`(x, y: IntMax32): IntMax32 {.magic: "MulU", noSideEffect.}</pre></dt>  <dt id="*%"><pre id="*%,int64,int64" data-language="nim">proc `*%`(x, y: int64): int64 {.magic: "MulU", noSideEffect.}</pre></dt> <dd> treats <em>x</em> and <em>y</em> as unsigned and multiplies them. The result is truncated to fit into the result. This implements modulo arithmetic. No overflow errors are possible.   </dd> <dt id="/%"><pre id="/%,IntMax32,IntMax32" data-language="nim">proc `/%`(x, y: IntMax32): IntMax32 {.magic: "DivU", noSideEffect.}</pre></dt>  <dt id="/%"><pre id="/%,int64,int64" data-language="nim">proc `/%`(x, y: int64): int64 {.magic: "DivU", noSideEffect.}</pre></dt> <dd> treats <em>x</em> and <em>y</em> as unsigned and divides them. The result is truncated to fit into the result. This implements modulo arithmetic. No overflow errors are possible.   </dd> <dt id="%%"><pre id="%%,IntMax32,IntMax32" data-language="nim">proc `%%`(x, y: IntMax32): IntMax32 {.magic: "ModU", noSideEffect.}</pre></dt>  <dt id="%%"><pre id="%%,int64,int64" data-language="nim">proc `%%`(x, y: int64): int64 {.magic: "ModU", noSideEffect.}</pre></dt> <dd> treats <em>x</em> and <em>y</em> as unsigned and compute the modulo of <em>x</em> and <em>y</em>. The result is truncated to fit into the result. This implements modulo arithmetic. No overflow errors are possible.   </dd> <dt id="&lt;=%"><pre id="&lt;=%,IntMax32,IntMax32" data-language="nim">proc `&lt;=%`(x, y: IntMax32): bool {.magic: "LeU", noSideEffect.}</pre></dt>  <dt id="&lt;=%"><pre id="&lt;=%,int64,int64" data-language="nim">proc `&lt;=%`(x, y: int64): bool {.magic: "LeU64", noSideEffect.}</pre></dt> <dd> treats <em>x</em> and <em>y</em> as unsigned and compares them. Returns true iff <code>unsigned(x) &lt;= unsigned(y)</code>.   </dd> <dt id="&lt;%"><pre id="&lt;%,IntMax32,IntMax32" data-language="nim">proc `&lt;%`(x, y: IntMax32): bool {.magic: "LtU", noSideEffect.}</pre></dt>  <dt id="&lt;%"><pre id="&lt;%,int64,int64" data-language="nim">proc `&lt;%`(x, y: int64): bool {.magic: "LtU64", noSideEffect.}</pre></dt> <dd> treats <em>x</em> and <em>y</em> as unsigned and compares them. Returns true iff <code>unsigned(x) &lt; unsigned(y)</code>.   </dd> <dt id="not"><pre id="not,T" data-language="nim">proc `not`[T: SomeUnsignedInt](x: T): T {.magic: "BitnotI", noSideEffect.}</pre></dt> <dd> computes the <em>bitwise complement</em> of the integer <em>x</em>.   </dd> <dt id="shr"><pre id="shr,T,SomeInteger" data-language="nim">proc `shr`[T: SomeUnsignedInt](x: T; y: SomeInteger): T {.magic: "ShrI", noSideEffect.}</pre></dt> <dd> computes the <em>shift right</em> operation of <em>x</em> and <em>y</em>.   </dd> <dt id="shl"><pre id="shl,T,SomeInteger" data-language="nim">proc `shl`[T: SomeUnsignedInt](x: T; y: SomeInteger): T {.magic: "ShlI", noSideEffect.}</pre></dt> <dd> computes the <em>shift left</em> operation of <em>x</em> and <em>y</em>.   </dd> <dt id="and"><pre id="and,T,T" data-language="nim">proc `and`[T: SomeUnsignedInt](x, y: T): T {.magic: "BitandI", noSideEffect.}</pre></dt> <dd> computes the <em>bitwise and</em> of numbers <em>x</em> and <em>y</em>.   </dd> <dt id="or"><pre id="or,T,T" data-language="nim">proc `or`[T: SomeUnsignedInt](x, y: T): T {.magic: "BitorI", noSideEffect.}</pre></dt> <dd> computes the <em>bitwise or</em> of numbers <em>x</em> and <em>y</em>.   </dd> <dt id="xor"><pre id="xor,T,T" data-language="nim">proc `xor`[T: SomeUnsignedInt](x, y: T): T {.magic: "BitxorI", noSideEffect.}</pre></dt> <dd> computes the <em>bitwise xor</em> of numbers <em>x</em> and <em>y</em>.   </dd> <dt id="=="><pre id="==,T,T_2" data-language="nim">proc `==`[T: SomeUnsignedInt](x, y: T): bool {.magic: "EqI", noSideEffect.}</pre></dt> <dd> Compares two unsigned integers for equality.   </dd> <dt id="+"><pre id="+,T,T" data-language="nim">proc `+`[T: SomeUnsignedInt](x, y: T): T {.magic: "AddU", noSideEffect.}</pre></dt> <dd> Binary <em>+</em> operator for unsigned integers.   </dd> <dt id="-"><pre id="-,T,T" data-language="nim">proc `-`[T: SomeUnsignedInt](x, y: T): T {.magic: "SubU", noSideEffect.}</pre></dt> <dd> Binary <em>-</em> operator for unsigned integers.   </dd> <dt id="*"><pre id="*,T,T" data-language="nim">proc `*`[T: SomeUnsignedInt](x, y: T): T {.magic: "MulU", noSideEffect.}</pre></dt> <dd> Binary <em>*</em> operator for unsigned integers.   </dd> <dt id="div"><pre id="div,T,T" data-language="nim">proc `div`[T: SomeUnsignedInt](x, y: T): T {.magic: "DivU", noSideEffect.}</pre></dt> <dd> computes the integer division. This is roughly the same as <code>floor(x/y)</code>.<pre class="listing" data-language="nim">(7 div 5) == 1</pre>   </dd> <dt id="mod"><pre id="mod,T,T" data-language="nim">proc `mod`[T: SomeUnsignedInt](x, y: T): T {.magic: "ModU", noSideEffect.}</pre></dt> <dd> computes the integer modulo operation (remainder). This is the same as <code>x - (x div y) * y</code>.<pre class="listing" data-language="nim">(7 mod 5) == 2</pre>   </dd> <dt id="&lt;="><pre id="&lt;=,T,T" data-language="nim">proc `&lt;=`[T: SomeUnsignedInt](x, y: T): bool {.magic: "LeU", noSideEffect.}</pre></dt> <dd> Returns true iff <code>x &lt;= y</code>.   </dd> <dt id="&lt;"><pre id="&lt;,T,T" data-language="nim">proc `&lt;`[T: SomeUnsignedInt](x, y: T): bool {.magic: "LtU", noSideEffect.}</pre></dt> <dd> Returns true iff <code>unsigned(x) &lt; unsigned(y)</code>.   </dd> <dt id="+"><pre id="+,float32" data-language="nim">proc `+`(x: float32): float32 {.magic: "UnaryPlusF64", noSideEffect.}</pre></dt>  <dt id="-"><pre id="-,float32" data-language="nim">proc `-`(x: float32): float32 {.magic: "UnaryMinusF64", noSideEffect.}</pre></dt>  <dt id="+"><pre id="+,float32,float32" data-language="nim">proc `+`(x, y: float32): float32 {.magic: "AddF64", noSideEffect.}</pre></dt>  <dt id="-"><pre id="-,float32,float32" data-language="nim">proc `-`(x, y: float32): float32 {.magic: "SubF64", noSideEffect.}</pre></dt>  <dt id="*"><pre id="*,float32,float32" data-language="nim">proc `*`(x, y: float32): float32 {.magic: "MulF64", noSideEffect.}</pre></dt>  <dt id="/"><pre id="/,float32,float32" data-language="nim">proc `/`(x, y: float32): float32 {.magic: "DivF64", noSideEffect.}</pre></dt>  <dt id="+"><pre id="+,float" data-language="nim">proc `+`(x: float): float {.magic: "UnaryPlusF64", noSideEffect.}</pre></dt>  <dt id="-"><pre id="-,float" data-language="nim">proc `-`(x: float): float {.magic: "UnaryMinusF64", noSideEffect.}</pre></dt>  <dt id="+"><pre id="+,float,float" data-language="nim">proc `+`(x, y: float): float {.magic: "AddF64", noSideEffect.}</pre></dt>  <dt id="-"><pre id="-,float,float" data-language="nim">proc `-`(x, y: float): float {.magic: "SubF64", noSideEffect.}</pre></dt>  <dt id="*"><pre id="*,float,float" data-language="nim">proc `*`(x, y: float): float {.magic: "MulF64", noSideEffect.}</pre></dt>  <dt id="/"><pre id="/,float,float" data-language="nim">proc `/`(x, y: float): float {.magic: "DivF64", noSideEffect.}</pre></dt> <dd> computes the floating point division   </dd> <dt id="=="><pre id="==,float32,float32" data-language="nim">proc `==`(x, y: float32): bool {.magic: "EqF64", noSideEffect.}</pre></dt>  <dt id="&lt;="><pre id="&lt;=,float32,float32" data-language="nim">proc `&lt;=`(x, y: float32): bool {.magic: "LeF64", noSideEffect.}</pre></dt>  <dt id="&lt;"><pre id="&lt;,float32,float32" data-language="nim">proc `&lt;`(x, y: float32): bool {.magic: "LtF64", noSideEffect.}</pre></dt>  <dt id="=="><pre id="==,float,float" data-language="nim">proc `==`(x, y: float): bool {.magic: "EqF64", noSideEffect.}</pre></dt>  <dt id="&lt;="><pre id="&lt;=,float,float" data-language="nim">proc `&lt;=`(x, y: float): bool {.magic: "LeF64", noSideEffect.}</pre></dt>  <dt id="&lt;"><pre id="&lt;,float,float" data-language="nim">proc `&lt;`(x, y: float): bool {.magic: "LtF64", noSideEffect.}</pre></dt>  <dt id="*"><pre id="*,set[T],set[T]" data-language="nim">proc `*`[T](x, y: set[T]): set[T] {.magic: "MulSet", noSideEffect.}</pre></dt> <dd> This operator computes the intersection of two sets.   </dd> <dt id="+"><pre id="+,set[T],set[T]" data-language="nim">proc `+`[T](x, y: set[T]): set[T] {.magic: "PlusSet", noSideEffect.}</pre></dt> <dd> This operator computes the union of two sets.   </dd> <dt id="-"><pre id="-,set[T],set[T]" data-language="nim">proc `-`[T](x, y: set[T]): set[T] {.magic: "MinusSet", noSideEffect.}</pre></dt> <dd> This operator computes the difference of two sets.   </dd> <dt id="contains"><pre id="contains,set[T],T" data-language="nim">proc contains[T](x: set[T]; y: T): bool {.magic: "InSet", noSideEffect.}</pre></dt> <dd> One should overload this proc if one wants to overload the <code>in</code> operator. The parameters are in reverse order! <code>a in b</code> is a template for <code>contains(b, a)</code>. This is because the unification algorithm that Nim uses for overload resolution works from left to right. But for the <code>in</code> operator that would be the wrong direction for this piece of code:<pre class="listing" data-language="nim">var s: set[range['a'..'z']] = {'a'..'c'}
writeLine(stdout, 'b' in s)</pre>
<p>If <code>in</code> had been declared as <code>[T](elem: T, s: set[T])</code> then <code>T</code> would have been bound to <code>char</code>. But <code>s</code> is not compatible to type <code>set[char]</code>! The solution is to bind <code>T</code> to <code>range['a'..'z']</code>. This is achieved by reversing the parameters for <code>contains</code>; <code>in</code> then passes its arguments in reverse order.</p>   </dd> <dt id="contains"><pre id="contains,Slice[T],T" data-language="nim">proc contains[T](s: Slice[T]; value: T): bool {.noSideEffect, inline.}</pre></dt> <dd> Checks if <em>value</em> is within the range of <em>s</em>; returns true iff <em>value &gt;= s.a and value &lt;= s.b</em><pre class="listing" data-language="nim">assert((1..3).contains(1) == true)
assert((1..3).contains(2) == true)
assert((1..3).contains(4) == false)</pre>   </dd> <dt id="is"><pre id="is,T,S" data-language="nim">proc `is`[T, S](x: T; y: S): bool {.magic: "Is", noSideEffect.}</pre></dt> <dd> Checks if T is of the same type as S<pre class="listing" data-language="nim">proc test[T](a: T): int =
  when (T is int):
    return a
  else:
    return 0

assert(test[int](3) == 3)
assert(test[string]("xyz") == 0)</pre>   </dd> <dt id="of"><pre id="of,typedesc[T],typedesc[S]" data-language="nim">proc `of`[T, S](x: typedesc[T]; y: typedesc[S]): bool {.magic: "Of", noSideEffect.}</pre></dt>  <dt id="of"><pre id="of,T,typedesc[S]" data-language="nim">proc `of`[T, S](x: T; y: typedesc[S]): bool {.magic: "Of", noSideEffect.}</pre></dt>  <dt id="of"><pre id="of,T,S" data-language="nim">proc `of`[T, S](x: T; y: S): bool {.magic: "Of", noSideEffect.}</pre></dt> <dd> Checks if <em>x</em> has a type of <em>y</em><pre class="listing" data-language="nim">assert(FloatingPointError of Exception)
assert(DivByZeroError of Exception)</pre>   </dd> <dt id="cmp"><pre id="cmp,T,T" data-language="nim">proc cmp[T](x, y: T): int {.procvar.}</pre></dt> <dd> Generic compare proc. Returns a value &lt; 0 iff x &lt; y, a value &gt; 0 iff x &gt; y and 0 iff x == y. This is useful for writing generic algorithms without performance loss. This generic implementation uses the <em>==</em> and <em>&lt;</em> operators.<pre class="listing" data-language="nim">import algorithm
echo sorted(@[4,2,6,5,8,7], cmp[int])</pre>   </dd> <dt id="@"><pre id="@,array[IDX,T]" data-language="nim">proc `@`[IDX, T](a: array[IDX, T]): seq[T] {.magic: "ArrToSeq", nosideeffect.}</pre></dt> <dd> turns an array into a sequence. This most often useful for constructing sequences with the array constructor: <code>@[1, 2, 3]</code> has the type <code>seq[int]</code>, while <code>[1, 2, 3]</code> has the type <code>array[0..2, int]</code>.   </dd> <dt id="setLen"><pre id="setLen,seq[T],Natural" data-language="nim">proc setLen[T](s: var seq[T]; newlen: Natural) {.magic: "SetLengthSeq", noSideEffect.}</pre></dt> <dd> sets the length of <em>s</em> to <em>newlen</em>. <code>T</code> may be any sequence type. If the current length is greater than the new length, <code>s</code> will be truncated. <em>s</em> cannot be nil! To initialize a sequence with a size, use <code>newSeq</code> instead.   </dd> <dt id="setLen"><pre id="setLen,string,Natural" data-language="nim">proc setLen(s: var string; newlen: Natural) {.magic: "SetLengthStr", noSideEffect.}</pre></dt> <dd> sets the length of <em>s</em> to <em>newlen</em>. If the current length is greater than the new length, <code>s</code> will be truncated. <em>s</em> cannot be nil! To initialize a string with a size, use <code>newString</code> instead.<pre class="listing" data-language="nim">var myS = "Nim is great!!"
myS.setLen(3)
echo myS, " is fantastic!!"</pre>   </dd> <dt id="newString"><pre id="newString,Natural" data-language="nim">proc newString(len: Natural): string {.magic: "NewString", importc: "mnewString",
                                   noSideEffect.}</pre></dt> <dd> returns a new string of length <code>len</code> but with uninitialized content. One needs to fill the string character after character with the index operator <code>s[i]</code>. This procedure exists only for optimization purposes; the same effect can be achieved with the <code>&amp;</code> operator or with <code>add</code>.   </dd> <dt id="newStringOfCap"><pre id="newStringOfCap,Natural" data-language="nim">proc newStringOfCap(cap: Natural): string {.magic: "NewStringOfCap",
                                        importc: "rawNewString", noSideEffect.}</pre></dt> <dd> returns a new string of length <code>0</code> but with capacity <em>cap</em>.This procedure exists only for optimization purposes; the same effect can be achieved with the <code>&amp;</code> operator or with <code>add</code>.   </dd> <dt id="&amp;"><pre id="&amp;,string,char" data-language="nim">proc `&amp;`(x: string; y: char): string {.magic: "ConStrStr", noSideEffect, merge.}</pre></dt> <dd> Concatenates <em>x</em> with <em>y</em><pre class="listing" data-language="nim">assert("ab" &amp; 'c' == "abc")</pre>   </dd> <dt id="&amp;"><pre id="&amp;,char,char" data-language="nim">proc `&amp;`(x, y: char): string {.magic: "ConStrStr", noSideEffect, merge.}</pre></dt> <dd> Concatenates <em>x</em> and <em>y</em> into a string<pre class="listing" data-language="nim">assert('a' &amp; 'b' == "ab")</pre>   </dd> <dt id="&amp;"><pre id="&amp;,string,string" data-language="nim">proc `&amp;`(x, y: string): string {.magic: "ConStrStr", noSideEffect, merge.}</pre></dt> <dd> Concatenates <em>x</em> and <em>y</em><pre class="listing" data-language="nim">assert("ab" &amp; "cd" == "abcd")</pre>   </dd> <dt id="&amp;"><pre id="&amp;,char,string" data-language="nim">proc `&amp;`(x: char; y: string): string {.magic: "ConStrStr", noSideEffect, merge.}</pre></dt> <dd> Concatenates <em>x</em> with <em>y</em><pre class="listing" data-language="nim">assert('a' &amp; "bc" == "abc")</pre>   </dd> <dt id="add"><pre id="add,string,char" data-language="nim">proc add(x: var string; y: char) {.magic: "AppendStrCh", noSideEffect.}</pre></dt> <dd> Appends <em>y</em> to <em>x</em> in place<pre class="listing" data-language="nim">var tmp = ""
tmp.add('a')
tmp.add('b')
assert(tmp == "ab")</pre>   </dd> <dt id="add"><pre id="add,string,string" data-language="nim">proc add(x: var string; y: string) {.magic: "AppendStrStr", noSideEffect.}</pre></dt> <dd> Concatenates <em>x</em> and <em>y</em> in place<pre class="listing" data-language="nim">var tmp = ""
tmp.add("ab")
tmp.add("cd")
assert(tmp == "abcd")</pre>   </dd> <dt id="compileOption"><pre id="compileOption,string" data-language="nim">proc compileOption(option: string): bool {.magic: "CompileOption", noSideEffect.}</pre></dt> <dd> can be used to determine an on|off compile-time option. Example:<pre class="listing" data-language="nim">when compileOption("floatchecks"):
  echo "compiled with floating point NaN and Inf checks"</pre>   </dd> <dt id="compileOption"><pre id="compileOption,string,string" data-language="nim">proc compileOption(option, arg: string): bool {.magic: "CompileOptionArg", noSideEffect.}</pre></dt> <dd> can be used to determine an enum compile-time option. Example:<pre class="listing" data-language="nim">when compileOption("opt", "size") and compileOption("gc", "boehm"):
  echo "compiled with optimization for size and uses Boehm's GC"</pre>   </dd> <dt id="quit"><pre id="quit,int" data-language="nim">proc quit(errorcode: int = QuitSuccess) {.magic: "Exit", noreturn.}</pre></dt> <dd> <p>Stops the program immediately with an exit code.</p> <p>Before stopping the program the "quit procedures" are called in the opposite order they were added with <a href="#addQuitProc">addQuitProc</a>. <code>quit</code> never returns and ignores any exception that may have been raised by the quit procedures. It does <em>not</em> call the garbage collector to free all the memory, unless a quit procedure calls <a href="#GC_fullCollect">GC_fullCollect</a>.</p> <p>The proc <code>quit(QuitSuccess)</code> is called implicitly when your nim program finishes without incident. A raised unhandled exception is equivalent to calling <code>quit(QuitFailure)</code>.</p> <p>Note that this is a <em>runtime</em> call and using <code>quit</code> inside a macro won't have any compile time effect. If you need to stop the compiler inside a macro, use the <a href="../manual/#error-pragma">error</a> or <a href="../manual/#fatal-pragma">fatal</a> pragmas.</p>   </dd> <dt id="add"><pre id="add,seq[T],T" data-language="nim">proc add[T](x: var seq[T]; y: T) {.magic: "AppendSeqElem", noSideEffect.}</pre></dt>  <dt id="add"><pre id="add,seq[T],openArray[T]" data-language="nim">proc add[T](x: var seq[T]; y: openArray[T]) {.noSideEffect.}</pre></dt> <dd> Generic proc for adding a data item <em>y</em> to a container <em>x</em>. For containers that have an order, <em>add</em> means <em>append</em>. New generic containers should also call their adding proc <em>add</em> for consistency. Generic code becomes much easier to write if the Nim naming scheme is respected.<pre class="listing" data-language="nim">var s: seq[string] = @["test2","test2"]
s.add("test") #=&gt; @[test2, test2, test]</pre>   </dd> <dt id="shallowCopy"><pre id="shallowCopy,T,T" data-language="nim">proc shallowCopy[T](x: var T; y: T) {.noSideEffect, magic: "ShallowCopy".}</pre></dt> <dd> use this instead of <em>=</em> for a <span id="shallow-copy_1">shallow copy</span>. The shallow copy only changes the semantics for sequences and strings (and types which contain those). Be careful with the changed semantics though! There is a reason why the default assignment does a deep copy of sequences and strings.   </dd> <dt id="del"><pre id="del,seq[T],Natural" data-language="nim">proc del[T](x: var seq[T]; i: Natural) {.noSideEffect.}</pre></dt> <dd> deletes the item at index <em>i</em> by putting <code>x[high(x)]</code> into position <em>i</em>. This is an O(1) operation.<pre class="listing" data-language="nim">var i = @[1, 2, 3, 4, 5]
i.del(2) #=&gt; @[1, 2, 5, 4]</pre>   </dd> <dt id="delete"><pre id="delete,seq[T],Natural" data-language="nim">proc delete[T](x: var seq[T]; i: Natural) {.noSideEffect.}</pre></dt> <dd> deletes the item at index <em>i</em> by moving <code>x[i+1..]</code> by one position. This is an O(n) operation.<pre class="listing" data-language="nim">var i = @[1, 2, 3, 4, 5]
i.delete(2) #=&gt; @[1, 2, 4, 5]</pre>   </dd> <dt id="insert"><pre id="insert,seq[T],T" data-language="nim">proc insert[T](x: var seq[T]; item: T; i = 0.Natural) {.noSideEffect.}</pre></dt> <dd> inserts <em>item</em> into <em>x</em> at position <em>i</em>.<pre class="listing" data-language="nim">var i = @[1, 2, 3, 4, 5]
i.insert(2, 4) #=&gt; @[1, 2, 3, 4, 2, 5]</pre>   </dd> <dt id="repr"><pre id="repr,T" data-language="nim">proc repr[T](x: T): string {.magic: "Repr", noSideEffect.}</pre></dt> <dd> takes any Nim variable and returns its string representation. It works even for complex data graphs with cycles. This is a great debugging tool.<pre class="listing" data-language="nim">var s: seq[string] = @["test2", "test2"]
var i = @[1, 2, 3, 4, 5]
repr(s) #=&gt; 0x1055eb050[0x1055ec050"test2", 0x1055ec078"test2"]
repr(i) #=&gt; 0x1055ed050[1, 2, 3, 4, 5]</pre>   </dd> <dt id="toFloat"><pre id="toFloat,int" data-language="nim">proc toFloat(i: int): float {.magic: "ToFloat", noSideEffect, importc: "toFloat".}</pre></dt> <dd> converts an integer <em>i</em> into a <code>float</code>. If the conversion fails, <em>EInvalidValue</em> is raised. However, on most platforms the conversion cannot fail.   </dd> <dt id="toBiggestFloat"><pre id="toBiggestFloat,BiggestInt" data-language="nim">proc toBiggestFloat(i: BiggestInt): BiggestFloat {.magic: "ToBiggestFloat",
    noSideEffect, importc: "toBiggestFloat".}</pre></dt> <dd> converts an biggestint <em>i</em> into a <code>biggestfloat</code>. If the conversion fails, <em>EInvalidValue</em> is raised. However, on most platforms the conversion cannot fail.   </dd> <dt id="toInt"><pre id="toInt,float" data-language="nim">proc toInt(f: float): int {.magic: "ToInt", noSideEffect, importc: "toInt".}</pre></dt> <dd> converts a floating point number <em>f</em> into an <code>int</code>. Conversion rounds <em>f</em> if it does not contain an integer value. If the conversion fails (because <em>f</em> is infinite for example), <em>EInvalidValue</em> is raised.   </dd> <dt id="toBiggestInt"><pre id="toBiggestInt,BiggestFloat" data-language="nim">proc toBiggestInt(f: BiggestFloat): BiggestInt {.magic: "ToBiggestInt", noSideEffect,
    importc: "toBiggestInt".}</pre></dt> <dd> converts a biggestfloat <em>f</em> into a <code>biggestint</code>. Conversion rounds <em>f</em> if it does not contain an integer value. If the conversion fails (because <em>f</em> is infinite for example), <em>EInvalidValue</em> is raised.   </dd> <dt id="addQuitProc"><pre id="addQuitProc,proc)" data-language="nim">proc addQuitProc(QuitProc: proc () {.noconv.}) {.importc: "atexit",
    header: "&lt;stdlib.h&gt;".}</pre></dt> <dd> <p>Adds/registers a quit procedure.</p> <p>Each call to <code>addQuitProc</code> registers another quit procedure. Up to 30 procedures can be registered. They are executed on a last-in, first-out basis (that is, the last function registered is the first to be executed). <code>addQuitProc</code> raises an EOutOfIndex exception if <code>QuitProc</code> cannot be registered.</p>   </dd> <dt id="copy"><pre id="copy,string,int" data-language="nim">proc copy(s: string; first = 0): string {.magic: "CopyStr", importc: "copyStr",
                                   noSideEffect, deprecated.}</pre></dt>  <dt id="copy"><pre id="copy,string,int,int" data-language="nim">proc copy(s: string; first, last: int): string {.magic: "CopyStrLast",
    importc: "copyStrLast", noSideEffect, deprecated.}</pre></dt> <dd> copies a slice of <em>s</em> into a new string and returns this new string. The bounds <em>first</em> and <em>last</em> denote the indices of the first and last characters that shall be copied. If <code>last</code> is omitted, it is treated as <code>high(s)</code>. <strong>Deprecated since version 0.8.12</strong>: Use <code>substr</code> instead.   </dd> <dt id="substr"><pre id="substr,string,int" data-language="nim">proc substr(s: string; first = 0): string {.magic: "CopyStr", importc: "copyStr",
                                     noSideEffect.}</pre></dt>  <dt id="substr"><pre id="substr,string,int,int" data-language="nim">proc substr(s: string; first, last: int): string {.magic: "CopyStrLast",
    importc: "copyStrLast", noSideEffect.}</pre></dt> <dd> copies a slice of <em>s</em> into a new string and returns this new string. The bounds <em>first</em> and <em>last</em> denote the indices of the first and last characters that shall be copied. If <code>last</code> is omitted, it is treated as <code>high(s)</code>. If <code>last &gt;= s.len</code>, <code>s.len</code> is used instead: This means <code>substr</code> can also be used to <span id="cut_1">cut</span> or <span id="limit_1">limit</span> a string's length.   </dd> <dt id="createU"><pre id="createU,typedesc" data-language="nim">proc createU(T: typedesc; size = 1.Positive): ptr T:type {.inline, gcsafe, locks: 0.}</pre></dt> <dd> allocates a new memory block with at least <code>T.sizeof * size</code> bytes. The block has to be freed with <code>resize(block, 0)</code> or <code>free(block)</code>. The block is not initialized, so reading from it before writing to it is undefined behaviour! The allocated memory belongs to its allocating thread! Use <em>createSharedU</em> to allocate from a shared heap.   </dd> <dt id="create"><pre id="create,typedesc" data-language="nim">proc create(T: typedesc; size = 1.Positive): ptr T:type {.inline, gcsafe, locks: 0.}</pre></dt> <dd> allocates a new memory block with at least <code>T.sizeof * size</code> bytes. The block has to be freed with <code>resize(block, 0)</code> or <code>free(block)</code>. The block is initialized with all bytes containing zero, so it is somewhat safer than <code>createU</code>. The allocated memory belongs to its allocating thread! Use <em>createShared</em> to allocate from a shared heap.   </dd> <dt id="resize"><pre id="resize,ptr.T,Natural" data-language="nim">proc resize[T](p: ptr T; newSize: Natural): ptr T {.inline, gcsafe, locks: 0.}</pre></dt> <dd> grows or shrinks a given memory block. If p is <strong>nil</strong> then a new memory block is returned. In either way the block has at least <code>T.sizeof * newSize</code> bytes. If <code>newSize == 0</code> and p is not <strong>nil</strong> <code>resize</code> calls <code>free(p)</code>. In other cases the block has to be freed with <code>free</code>. The allocated memory belongs to its allocating thread! Use <em>resizeShared</em> to reallocate from a shared heap.   </dd> <dt id="createSharedU"><pre id="createSharedU,typedesc" data-language="nim">proc createSharedU(T: typedesc; size = 1.Positive): ptr T:type {.inline,
    gcsafe, locks: 0.}</pre></dt> <dd> allocates a new memory block on the shared heap with at least <code>T.sizeof * size</code> bytes. The block has to be freed with <code>resizeShared(block, 0)</code> or <code>freeShared(block)</code>. The block is not initialized, so reading from it before writing to it is undefined behaviour!   </dd> <dt id="createShared"><pre id="createShared,typedesc" data-language="nim">proc createShared(T: typedesc; size = 1.Positive): ptr T:type {.inline.}</pre></dt> <dd> allocates a new memory block on the shared heap with at least <code>T.sizeof * size</code> bytes. The block has to be freed with <code>resizeShared(block, 0)</code> or <code>freeShared(block)</code>. The block is initialized with all bytes containing zero, so it is somewhat safer than <code>createSharedU</code>.   </dd> <dt id="resizeShared"><pre id="resizeShared,ptr.T,Natural" data-language="nim">proc resizeShared[T](p: ptr T; newSize: Natural): ptr T {.inline.}</pre></dt> <dd> grows or shrinks a given memory block on the heap. If p is <strong>nil</strong> then a new memory block is returned. In either way the block has at least <code>T.sizeof * newSize</code> bytes. If <code>newSize == 0</code> and p is not <strong>nil</strong> <code>resizeShared</code> calls <code>freeShared(p)</code>. In other cases the block has to be freed with <code>freeShared</code>.   </dd> <dt id="freeShared"><pre id="freeShared,ptr.T" data-language="nim">proc freeShared[T](p: ptr T) {.inline, gcsafe, locks: 0.}</pre></dt> <dd> frees the memory allocated with <code>createShared</code>, <code>createSharedU</code> or <code>resizeShared</code>. This procedure is dangerous! If one forgets to free the memory a leak occurs; if one tries to access freed memory (or just freeing it twice!) a core dump may happen or other memory may be corrupted.   </dd> <dt id="swap"><pre id="swap,T,T" data-language="nim">proc swap[T](a, b: var T) {.magic: "Swap", noSideEffect.}</pre></dt> <dd> swaps the values <em>a</em> and <em>b</em>. This is often more efficient than <code>tmp = a; a = b; b = tmp</code>. Particularly useful for sorting algorithms.   </dd> <dt id="$"><pre id="$,int" data-language="nim">proc `$`(x: int): string {.magic: "IntToStr", noSideEffect.}</pre></dt> <dd> The stringify operator for an integer argument. Returns <em>x</em> converted to a decimal string. <code>$</code> is Nim's general way of spelling <span id="tostring_1">toString</span>.   </dd> <dt id="$"><pre id="$,int64" data-language="nim">proc `$`(x: int64): string {.magic: "Int64ToStr", noSideEffect.}</pre></dt> <dd> The stringify operator for an integer argument. Returns <em>x</em> converted to a decimal string.   </dd> <dt id="$"><pre id="$,float" data-language="nim">proc `$`(x: float): string {.magic: "FloatToStr", noSideEffect.}</pre></dt> <dd> The stringify operator for a float argument. Returns <em>x</em> converted to a decimal string.   </dd> <dt id="$"><pre id="$,bool" data-language="nim">proc `$`(x: bool): string {.magic: "BoolToStr", noSideEffect.}</pre></dt> <dd> The stringify operator for a boolean argument. Returns <em>x</em> converted to the string "false" or "true".   </dd> <dt id="$"><pre id="$,char" data-language="nim">proc `$`(x: char): string {.magic: "CharToStr", noSideEffect.}</pre></dt> <dd> The stringify operator for a character argument. Returns <em>x</em> converted to a string.   </dd> <dt id="$"><pre id="$,cstring" data-language="nim">proc `$`(x: cstring): string {.magic: "CStrToStr", noSideEffect.}</pre></dt> <dd> The stringify operator for a CString argument. Returns <em>x</em> converted to a string.   </dd> <dt id="$"><pre id="$,string" data-language="nim">proc `$`(x: string): string {.magic: "StrToStr", noSideEffect.}</pre></dt> <dd> The stringify operator for a string argument. Returns <em>x</em> as it is. This operator is useful for generic code, so that <code>$expr</code> also works if <code>expr</code> is already a string.   </dd> <dt id="$"><pre id="$,Enum" data-language="nim">proc `$`[Enum: enum](x: Enum): string {.magic: "EnumToStr", noSideEffect.}</pre></dt> <dd> The stringify operator for an enumeration argument. This works for any enumeration type thanks to compiler magic. If a <code>$</code> operator for a concrete enumeration is provided, this is used instead. (In other words: <em>Overwriting</em> is possible.)   </dd> <dt id="getRefcount"><pre id="getRefcount,ref.T" data-language="nim">proc getRefcount[T](x: ref T): int {.importc: "getRefcount", noSideEffect.}</pre></dt>  <dt id="getRefcount"><pre id="getRefcount,string" data-language="nim">proc getRefcount(x: string): int {.importc: "getRefcount", noSideEffect.}</pre></dt>  <dt id="getRefcount"><pre id="getRefcount,seq[T]" data-language="nim">proc getRefcount[T](x: seq[T]): int {.importc: "getRefcount", noSideEffect.}</pre></dt> <dd> retrieves the reference count of an heap-allocated object. The value is implementation-dependent.   </dd> <dt id="min"><pre id="min,int,int" data-language="nim">proc min(x, y: int): int {.magic: "MinI", noSideEffect, raises: [], tags: [].}</pre></dt>  <dt id="min"><pre id="min,int8,int8" data-language="nim">proc min(x, y: int8): int8 {.magic: "MinI", noSideEffect, raises: [], tags: [].}</pre></dt>  <dt id="min"><pre id="min,int16,int16" data-language="nim">proc min(x, y: int16): int16 {.magic: "MinI", noSideEffect, raises: [], tags: [].}</pre></dt>  <dt id="min"><pre id="min,int32,int32" data-language="nim">proc min(x, y: int32): int32 {.magic: "MinI", noSideEffect, raises: [], tags: [].}</pre></dt>  <dt id="min"><pre id="min,int64,int64" data-language="nim">proc min(x, y: int64): int64 {.magic: "MinI", noSideEffect, raises: [], tags: [].}</pre></dt> <dd> The minimum value of two integers.   </dd> <dt id="min"><pre id="min,openArray[T]" data-language="nim">proc min[T](x: openArray[T]): T</pre></dt> <dd> The minimum value of <em>x</em>. <code>T</code> needs to have a <code>&lt;</code> operator.   </dd> <dt id="max"><pre id="max,int,int" data-language="nim">proc max(x, y: int): int {.magic: "MaxI", noSideEffect, raises: [], tags: [].}</pre></dt>  <dt id="max"><pre id="max,int8,int8" data-language="nim">proc max(x, y: int8): int8 {.magic: "MaxI", noSideEffect, raises: [], tags: [].}</pre></dt>  <dt id="max"><pre id="max,int16,int16" data-language="nim">proc max(x, y: int16): int16 {.magic: "MaxI", noSideEffect, raises: [], tags: [].}</pre></dt>  <dt id="max"><pre id="max,int32,int32" data-language="nim">proc max(x, y: int32): int32 {.magic: "MaxI", noSideEffect, raises: [], tags: [].}</pre></dt>  <dt id="max"><pre id="max,int64,int64" data-language="nim">proc max(x, y: int64): int64 {.magic: "MaxI", noSideEffect, raises: [], tags: [].}</pre></dt> <dd> The maximum value of two integers.   </dd> <dt id="max"><pre id="max,openArray[T]" data-language="nim">proc max[T](x: openArray[T]): T</pre></dt> <dd> The maximum value of <em>x</em>. <code>T</code> needs to have a <code>&lt;</code> operator.   </dd> <dt id="abs"><pre id="abs,float" data-language="nim">proc abs(x: float): float {.magic: "AbsF64", noSideEffect, raises: [], tags: [].}</pre></dt>  <dt id="min"><pre id="min,float,float" data-language="nim">proc min(x, y: float): float {.magic: "MinF64", noSideEffect, raises: [], tags: [].}</pre></dt>  <dt id="max"><pre id="max,float,float" data-language="nim">proc max(x, y: float): float {.magic: "MaxF64", noSideEffect, raises: [], tags: [].}</pre></dt>  <dt id="min"><pre id="min,T,T" data-language="nim">proc min[T](x, y: T): T</pre></dt>  <dt id="max"><pre id="max,T,T" data-language="nim">proc max[T](x, y: T): T</pre></dt>  <dt id="clamp"><pre id="clamp,T,T,T" data-language="nim">proc clamp[T](x, a, b: T): T</pre></dt> <dd> limits the value <code>x</code> within the interval [a, b]<pre class="listing" data-language="nim">assert((1.4).clamp(0.0, 1.0) == 1.0)
assert((0.5).clamp(0.0, 1.0) == 0.5)</pre>   </dd> <dt id="len"><pre id="len,Slice[T: Ordinal]" data-language="nim">proc len[T: Ordinal](x: Slice[T]): int {.noSideEffect, inline.}</pre></dt> <dd> length of ordinal slice, when x.b &lt; x.a returns zero length<pre class="listing" data-language="nim">assert((0..5).len == 6)
assert((5..2).len == 0)</pre>   </dd> <dt id="isNil"><pre id="isNil,seq[T]" data-language="nim">proc isNil[T](x: seq[T]): bool {.noSideEffect, magic: "IsNil".}</pre></dt>  <dt id="isNil"><pre id="isNil,ref.T" data-language="nim">proc isNil[T](x: ref T): bool {.noSideEffect, magic: "IsNil".}</pre></dt>  <dt id="isNil"><pre id="isNil,string" data-language="nim">proc isNil(x: string): bool {.noSideEffect, magic: "IsNil".}</pre></dt>  <dt id="isNil"><pre id="isNil,ptr.T" data-language="nim">proc isNil[T](x: ptr T): bool {.noSideEffect, magic: "IsNil".}</pre></dt>  <dt id="isNil"><pre id="isNil,pointer" data-language="nim">proc isNil(x: pointer): bool {.noSideEffect, magic: "IsNil".}</pre></dt>  <dt id="isNil"><pre id="isNil,cstring" data-language="nim">proc isNil(x: cstring): bool {.noSideEffect, magic: "IsNil".}</pre></dt>  <dt id="isNil"><pre id="isNil,T" data-language="nim">proc isNil[T: proc](x: T): bool {.noSideEffect, magic: "IsNil".}</pre></dt> <dd> Fast check whether <em>x</em> is nil. This is sometimes more efficient than <code>== nil</code>.   </dd> <dt id="=="><pre id="==,array[I,T],array[I,T]" data-language="nim">proc `==`[I, T](x, y: array[I, T]): bool</pre></dt>  <dt id="@"><pre id="@,openArray[T]" data-language="nim">proc `@`[T](a: openArray[T]): seq[T]</pre></dt> <dd> turns an openarray into a sequence. This is not as efficient as turning a fixed length array into a sequence as it always copies every element of <em>a</em>.   </dd> <dt id="&amp;"><pre id="&amp;,seq[T],seq[T]" data-language="nim">proc `&amp;`[T](x, y: seq[T]): seq[T] {.noSideEffect.}</pre></dt> <dd> Concatenates two sequences. Requires copying of the sequences.<pre class="listing" data-language="nim">assert(@[1, 2, 3, 4] &amp; @[5, 6] == @[1, 2, 3, 4, 5, 6])</pre>   </dd> <dt id="&amp;"><pre id="&amp;,seq[T],T" data-language="nim">proc `&amp;`[T](x: seq[T]; y: T): seq[T] {.noSideEffect.}</pre></dt> <dd> Appends element y to the end of the sequence. Requires copying of the sequence<pre class="listing" data-language="nim">assert(@[1, 2, 3] &amp; 4 == @[1, 2, 3, 4])</pre>   </dd> <dt id="&amp;"><pre id="&amp;,T,seq[T]" data-language="nim">proc `&amp;`[T](x: T; y: seq[T]): seq[T] {.noSideEffect.}</pre></dt> <dd> Prepends the element x to the beginning of the sequence. Requires copying of the sequence<pre class="listing" data-language="nim">assert(1 &amp; @[2, 3, 4] == @[1, 2, 3, 4])</pre>   </dd> <dt id="=="><pre id="==,seq[T],seq[T]" data-language="nim">proc `==`[T](x, y: seq[T]): bool {.noSideEffect.}</pre></dt> <dd> Generic equals operator for sequences: relies on a equals operator for the element type <em>T</em>.   </dd> <dt id="find"><pre id="find,T,S" data-language="nim">proc find[T, S](a: T; item: S): int {.inline.}</pre></dt> <dd> Returns the first index of <em>item</em> in <em>a</em> or -1 if not found. This requires appropriate <em>items</em> and <em>==</em> operations to work.   </dd> <dt id="contains"><pre id="contains,openArray[T],T" data-language="nim">proc contains[T](a: openArray[T]; item: T): bool {.inline.}</pre></dt> <dd> Returns true if <em>item</em> is in <em>a</em> or false if not found. This is a shortcut for <code>find(a, item) &gt;= 0</code>.   </dd> <dt id="pop"><pre id="pop,seq[T]" data-language="nim">proc pop[T](s: var seq[T]): T {.inline, noSideEffect.}</pre></dt> <dd> returns the last item of <em>s</em> and decreases <code>s.len</code> by one. This treats <em>s</em> as a stack and implements the common <em>pop</em> operation.   </dd> <dt id="=="><pre id="==,T,T_3" data-language="nim">proc `==`[T: tuple |
    object](x, y: T): bool</pre></dt> <dd> generic <code>==</code> operator for tuples that is lifted from the components of <em>x</em> and <em>y</em>.   </dd> <dt id="&lt;="><pre id="&lt;=,T,T_2" data-language="nim">proc `&lt;=`[T: tuple](x, y: T): bool</pre></dt> <dd> generic <code>&lt;=</code> operator for tuples that is lifted from the components of <em>x</em> and <em>y</em>. This implementation uses <em>cmp</em>.   </dd> <dt id="&lt;"><pre id="&lt;,T,T_2" data-language="nim">proc `&lt;`[T: tuple](x, y: T): bool</pre></dt> <dd> generic <code>&lt;</code> operator for tuples that is lifted from the components of <em>x</em> and <em>y</em>. This implementation uses <em>cmp</em>.   </dd> <dt id="$"><pre id="$,T" data-language="nim">proc `$`[T: tuple |
    object](x: T): string</pre></dt> <dd> generic <code>$</code> operator for tuples that is lifted from the components of <em>x</em>. Example:<pre class="listing" data-language="nim">$(23, 45) == "(23, 45)"
$() == "()"</pre>   </dd> <dt id="$"><pre id="$,set[T]" data-language="nim">proc `$`[T](x: set[T]): string</pre></dt> <dd> generic <code>$</code> operator for sets that is lifted from the components of <em>x</em>. Example:<pre class="listing" data-language="nim">${23, 45} == "{23, 45}"</pre>   </dd> <dt id="$"><pre id="$,seq[T]" data-language="nim">proc `$`[T](x: seq[T]): string</pre></dt> <dd> generic <code>$</code> operator for seqs that is lifted from the components of <em>x</em>. Example:<pre class="listing" data-language="nim">$(@[23, 45]) == "@[23, 45]"</pre>   </dd> <dt id="GC_ref"><pre id="GC_ref,ref.T" data-language="nim">proc GC_ref[T](x: ref T) {.magic: "GCref", gcsafe, locks: 0.}</pre></dt>  <dt id="GC_ref"><pre id="GC_ref,seq[T]" data-language="nim">proc GC_ref[T](x: seq[T]) {.magic: "GCref", gcsafe, locks: 0.}</pre></dt>  <dt id="GC_ref"><pre id="GC_ref,string" data-language="nim">proc GC_ref(x: string) {.magic: "GCref", gcsafe, locks: 0.}</pre></dt> <dd> marks the object <em>x</em> as referenced, so that it will not be freed until it is unmarked via <em>GC_unref</em>. If called n-times for the same object <em>x</em>, n calls to <em>GC_unref</em> are needed to unmark <em>x</em>.   </dd> <dt id="GC_unref"><pre id="GC_unref,ref.T" data-language="nim">proc GC_unref[T](x: ref T) {.magic: "GCunref", gcsafe, locks: 0.}</pre></dt>  <dt id="GC_unref"><pre id="GC_unref,seq[T]" data-language="nim">proc GC_unref[T](x: seq[T]) {.magic: "GCunref", gcsafe, locks: 0.}</pre></dt>  <dt id="GC_unref"><pre id="GC_unref,string" data-language="nim">proc GC_unref(x: string) {.magic: "GCunref", gcsafe, locks: 0.}</pre></dt> <dd> see the documentation of <em>GC_ref</em>.   </dd> <dt id="add"><pre id="add,string,cstring" data-language="nim">proc add(x: var string; y: cstring) {.raises: [], tags: [].}</pre></dt>  <dt id="echo"><pre id="echo,varargs[typed,]" data-language="nim">proc echo(x: varargs[typed, `$`]) {.magic: "Echo", tags: [WriteIOEffect],
                                gcsafe, locks: 0, sideEffect.}</pre></dt> <dd> <p>Writes and flushes the parameters to the standard output.</p> <p>Special built-in that takes a variable number of arguments. Each argument is converted to a string via <code>$</code>, so it works for user-defined types that have an overloaded <code>$</code> operator. It is roughly equivalent to <code>writeLine(stdout, x); flushFile(stdout)</code>, but available for the JavaScript target too.</p> <p>Unlike other IO operations this is guaranteed to be thread-safe as <code>echo</code> is very often used for debugging convenience. If you want to use <code>echo</code> inside a <a href="../manual/#pragmas-nosideeffect-pragma">proc without side effects</a> you can use <a href="#debugEcho">debugEcho</a> instead.</p>   </dd> <dt id="debugEcho"><pre id="debugEcho,varargs[typed,]" data-language="nim">proc debugEcho(x: varargs[typed, `$`]) {.magic: "Echo", noSideEffect, tags: [],
                                     raises: [].}</pre></dt> <dd> Same as <a href="#echo">echo</a>, but as a special semantic rule, <code>debugEcho</code> pretends to be free of side effects, so that it can be used for debugging routines marked as <a href="../manual/#pragmas-nosideeffect-pragma">noSideEffect</a>.   </dd> <dt id="getTypeInfo"><pre id="getTypeInfo,T" data-language="nim">proc getTypeInfo[T](x: T): pointer {.magic: "GetTypeInfo", gcsafe, locks: 0.}</pre></dt> <dd> get type information for <em>x</em>. Ordinary code should not use this, but the <em>typeinfo</em> module instead.   </dd> <dt id="abs"><pre id="abs,int" data-language="nim">proc abs(x: int): int {.magic: "AbsI", noSideEffect, raises: [], tags: [].}</pre></dt>  <dt id="abs"><pre id="abs,int8" data-language="nim">proc abs(x: int8): int8 {.magic: "AbsI", noSideEffect, raises: [], tags: [].}</pre></dt>  <dt id="abs"><pre id="abs,int16" data-language="nim">proc abs(x: int16): int16 {.magic: "AbsI", noSideEffect, raises: [], tags: [].}</pre></dt>  <dt id="abs"><pre id="abs,int32" data-language="nim">proc abs(x: int32): int32 {.magic: "AbsI", noSideEffect, raises: [], tags: [].}</pre></dt>  <dt id="abs"><pre id="abs,int64" data-language="nim">proc abs(x: int64): int64 {.magic: "AbsI", noSideEffect, raises: [], tags: [].}</pre></dt> <dd> returns the absolute value of <em>x</em>. If <em>x</em> is <code>low(x)</code> (that is -MININT for its type), an overflow exception is thrown (if overflow checking is turned on).   </dd> <dt id="cmp"><pre id="cmp,string,string" data-language="nim">proc cmp(x, y: string): int {.noSideEffect, procvar, raises: [], tags: [].}</pre></dt> <dd> Compare proc for strings. More efficient than the generic version.   </dd> <dt id="open"><pre id="open,File,string,FileMode,int" data-language="nim">proc open(f: var File; filename: string; mode: FileMode = fmRead; bufSize: int = -1): bool {.
    tags: [], gcsafe, locks: 0, raises: [].}</pre></dt> <dd> <p>Opens a file named <em>filename</em> with given <em>mode</em>.</p> <p>Default mode is readonly. Returns true iff the file could be opened. This throws no exception if the file could not be opened.</p>   </dd> <dt id="open"><pre id="open,File,FileHandle,FileMode" data-language="nim">proc open(f: var File; filehandle: FileHandle; mode: FileMode = fmRead): bool {.tags: [],
    gcsafe, locks: 0, raises: [].}</pre></dt> <dd> <p>Creates a <code>File</code> from a <em>filehandle</em> with given <em>mode</em>.</p> <p>Default mode is readonly. Returns true iff the file could be opened.</p>   </dd> <dt id="open"><pre id="open,string,FileMode,int" data-language="nim">proc open(filename: string; mode: FileMode = fmRead; bufSize: int = -1): File {.
    raises: [Exception, IOError], tags: [].}</pre></dt> <dd> <p>Opens a file named <em>filename</em> with given <em>mode</em>.</p> <p>Default mode is readonly. Raises an <code>IO</code> exception if the file could not be opened.</p>   </dd> <dt id="reopen"><pre id="reopen,File,string,FileMode" data-language="nim">proc reopen(f: File; filename: string; mode: FileMode = fmRead): bool {.tags: [],
    gcsafe, locks: 0, raises: [].}</pre></dt> <dd> <p>reopens the file <em>f</em> with given <em>filename</em> and <em>mode</em>. This is often used to redirect the <em>stdin</em>, <em>stdout</em> or <em>stderr</em> file variables.</p> <p>Default mode is readonly. Returns true iff the file could be reopened.</p>   </dd> <dt id="setStdIoUnbuffered"><pre id="setStdIoUnbuffered," data-language="nim">proc setStdIoUnbuffered() {.tags: [], gcsafe, locks: 0, raises: [].}</pre></dt> <dd> Configures <em>stdin</em>, <em>stdout</em> and <em>stderr</em> to be unbuffered.   </dd> <dt id="close"><pre id="close,File" data-language="nim">proc close(f: File) {.tags: [], gcsafe, raises: [].}</pre></dt> <dd> Closes the file.   </dd> <dt id="endOfFile"><pre id="endOfFile,File" data-language="nim">proc endOfFile(f: File): bool {.tags: [], gcsafe, locks: 0, raises: [].}</pre></dt> <dd> Returns true iff <em>f</em> is at the end.   </dd> <dt id="readChar"><pre id="readChar,File" data-language="nim">proc readChar(f: File): char {.tags: [ReadIOEffect], deprecated,
                           raises: [IOError, EOFError].}</pre></dt> <dd> Reads a single character from the stream <em>f</em>. <strong>Deprecated</strong> since version 0.16.2. Use some variant of <code>readBuffer</code> instead.   </dd> <dt id="flushFile"><pre id="flushFile,File" data-language="nim">proc flushFile(f: File) {.tags: [WriteIOEffect], raises: [].}</pre></dt> <dd> Flushes <em>f</em>'s buffer.   </dd> <dt id="readAll"><pre id="readAll,File" data-language="nim">proc readAll(file: File): TaintedString {.tags: [ReadIOEffect], gcsafe, locks: 0,
                                      raises: [IOError].}</pre></dt> <dd> <p>Reads all data from the stream <em>file</em>.</p> <p>Raises an IO exception in case of an error. It is an error if the current file position is not at the beginning of the file.</p>   </dd> <dt id="readFile"><pre id="readFile,string" data-language="nim">proc readFile(filename: string): TaintedString {.tags: [ReadIOEffect],
    gcsafe, locks: 0, raises: [IOError].}</pre></dt> <dd> <p>Opens a file named <em>filename</em> for reading.</p> <p>Then calls <a href="#readAll">readAll</a> and closes the file afterwards. Returns the string. Raises an IO exception in case of an error. If you need to call this inside a compile time macro you can use <a href="#staticRead">staticRead</a>.</p>   </dd> <dt id="writeFile"><pre id="writeFile,string,string" data-language="nim">proc writeFile(filename, content: string) {.tags: [WriteIOEffect],
                                        gcsafe, locks: 0, raises: [IOError].}</pre></dt> <dd> Opens a file named <em>filename</em> for writing. Then writes the <em>content</em> completely to the file and closes the file afterwards. Raises an IO exception in case of an error.   </dd> <dt id="write"><pre id="write,File,float32" data-language="nim">proc write(f: File; r: float32) {.tags: [WriteIOEffect], gcsafe, locks: 0,
                             raises: [IOError].}</pre></dt>  <dt id="write"><pre id="write,File,int" data-language="nim">proc write(f: File; i: int) {.tags: [WriteIOEffect], gcsafe, locks: 0, raises: [IOError].}</pre></dt>  <dt id="write"><pre id="write,File,BiggestInt" data-language="nim">proc write(f: File; i: BiggestInt) {.tags: [WriteIOEffect], gcsafe, locks: 0,
                                raises: [IOError].}</pre></dt>  <dt id="write"><pre id="write,File,BiggestFloat" data-language="nim">proc write(f: File; r: BiggestFloat) {.tags: [WriteIOEffect], gcsafe, locks: 0,
                                  raises: [IOError].}</pre></dt>  <dt id="write"><pre id="write,File,string" data-language="nim">proc write(f: File; s: string) {.tags: [WriteIOEffect], gcsafe, locks: 0,
                            raises: [IOError].}</pre></dt>  <dt id="write"><pre id="write,File,bool" data-language="nim">proc write(f: File; b: bool) {.tags: [WriteIOEffect], gcsafe, locks: 0, raises: [IOError].}</pre></dt>  <dt id="write"><pre id="write,File,char" data-language="nim">proc write(f: File; c: char) {.tags: [WriteIOEffect], gcsafe, locks: 0, raises: [].}</pre></dt>  <dt id="write"><pre id="write,File,cstring" data-language="nim">proc write(f: File; c: cstring) {.tags: [WriteIOEffect], gcsafe, locks: 0,
                             raises: [IOError].}</pre></dt>  <dt id="write"><pre id="write,File,varargs[string,]" data-language="nim">proc write(f: File; a: varargs[string, `$`]) {.tags: [WriteIOEffect],
    gcsafe, locks: 0, raises: [IOError].}</pre></dt> <dd> Writes a value to the file <em>f</em>. May throw an IO exception.   </dd> <dt id="readLine"><pre id="readLine,File" data-language="nim">proc readLine(f: File): TaintedString {.tags: [ReadIOEffect], gcsafe, locks: 0,
                                    raises: [IOError, EOFError].}</pre></dt> <dd> reads a line of text from the file <em>f</em>. May throw an IO exception. A line of text may be delimited by <code>LF</code> or <code>CRLF</code>. The newline character(s) are not part of the returned string.   </dd> <dt id="readLine"><pre id="readLine,File,TaintedString" data-language="nim">proc readLine(f: File; line: var TaintedString): bool {.tags: [ReadIOEffect],
    gcsafe, locks: 0, raises: [IOError].}</pre></dt> <dd> reads a line of text from the file <em>f</em> into <em>line</em>. <em>line</em> must not be <code>nil</code>! May throw an IO exception. A line of text may be delimited by <code>LF</code> or <code>CRLF</code>. The newline character(s) are not part of the returned string. Returns <code>false</code> if the end of the file has been reached, <code>true</code> otherwise. If <code>false</code> is returned <em>line</em> contains no new data.   </dd> <dt id="writeLn"><pre id="writeLn,File,varargs[Ty,]" data-language="nim">proc writeLn[Ty](f: File; x: varargs[Ty, `$`]) {.inline, tags: [WriteIOEffect],
    gcsafe, locks: 0, deprecated.}</pre></dt> <dd> <strong>Deprecated since version 0.11.4:</strong> Use <strong>writeLine</strong> instead.   </dd> <dt id="writeLine"><pre id="writeLine,File,varargs[Ty,]" data-language="nim">proc writeLine[Ty](f: File; x: varargs[Ty, `$`]) {.inline, tags: [WriteIOEffect],
    gcsafe, locks: 0.}</pre></dt> <dd> writes the values <em>x</em> to <em>f</em> and then writes "\n". May throw an IO exception.   </dd> <dt id="getFileSize"><pre id="getFileSize,File" data-language="nim">proc getFileSize(f: File): int64 {.tags: [ReadIOEffect], gcsafe, locks: 0,
                               raises: [IOError].}</pre></dt> <dd> retrieves the file size (in bytes) of <em>f</em>.   </dd> <dt id="readBytes"><pre id="readBytes,File,openArray[],Natural,Natural" data-language="nim">proc readBytes(f: File; a: var openArray[int8 | uint8]; start, len: Natural): int {.
    tags: [ReadIOEffect], gcsafe, locks: 0.}</pre></dt> <dd> reads <em>len</em> bytes into the buffer <em>a</em> starting at <code>a[start]</code>. Returns the actual number of bytes that have been read which may be less than <em>len</em> (if not as many bytes are remaining), but not greater.   </dd> <dt id="readChars"><pre id="readChars,File,openArray[char],Natural,Natural" data-language="nim">proc readChars(f: File; a: var openArray[char]; start, len: Natural): int {.
    tags: [ReadIOEffect], gcsafe, locks: 0, raises: [IOError].}</pre></dt> <dd> <p>reads <em>len</em> bytes into the buffer <em>a</em> starting at <code>a[start]</code>. Returns the actual number of bytes that have been read which may be less than <em>len</em> (if not as many bytes are remaining), but not greater.</p> <p><strong>Warning:</strong> The buffer <em>a</em> must be pre-allocated. This can be done using, for example, <code>newString</code>.</p>   </dd> <dt id="readBuffer"><pre id="readBuffer,File,pointer,Natural" data-language="nim">proc readBuffer(f: File; buffer: pointer; len: Natural): int {.tags: [ReadIOEffect],
    gcsafe, locks: 0, raises: [IOError].}</pre></dt> <dd> reads <em>len</em> bytes into the buffer pointed to by <em>buffer</em>. Returns the actual number of bytes that have been read which may be less than <em>len</em> (if not as many bytes are remaining), but not greater.   </dd> <dt id="writeBytes"><pre id="writeBytes,File,openArray[],Natural,Natural" data-language="nim">proc writeBytes(f: File; a: openArray[int8 | uint8]; start, len: Natural): int {.
    tags: [WriteIOEffect], gcsafe, locks: 0.}</pre></dt> <dd> writes the bytes of <code>a[start..start+len-1]</code> to the file <em>f</em>. Returns the number of actual written bytes, which may be less than <em>len</em> in case of an error.   </dd> <dt id="writeChars"><pre id="writeChars,File,openArray[char],Natural,Natural" data-language="nim">proc writeChars(f: File; a: openArray[char]; start, len: Natural): int {.
    tags: [WriteIOEffect], gcsafe, locks: 0, raises: [IOError].}</pre></dt> <dd> writes the bytes of <code>a[start..start+len-1]</code> to the file <em>f</em>. Returns the number of actual written bytes, which may be less than <em>len</em> in case of an error.   </dd> <dt id="writeBuffer"><pre id="writeBuffer,File,pointer,Natural" data-language="nim">proc writeBuffer(f: File; buffer: pointer; len: Natural): int {.tags: [WriteIOEffect],
    gcsafe, locks: 0, raises: [IOError].}</pre></dt> <dd> writes the bytes of buffer pointed to by the parameter <em>buffer</em> to the file <em>f</em>. Returns the number of actual written bytes, which may be less than <em>len</em> in case of an error.   </dd> <dt id="setFilePos"><pre id="setFilePos,File,int64,FileSeekPos" data-language="nim">proc setFilePos(f: File; pos: int64; relativeTo: FileSeekPos = fspSet) {.
    gcsafe, locks: 0, raises: [IOError], tags: [].}</pre></dt> <dd> sets the position of the file pointer that is used for read/write operations. The file's first byte has the index zero.   </dd> <dt id="getFilePos"><pre id="getFilePos,File" data-language="nim">proc getFilePos(f: File): int64 {.gcsafe, locks: 0, raises: [IOError], tags: [].}</pre></dt> <dd> retrieves the current position of the file pointer that is used to read from the file <em>f</em>. The file's first byte has the index zero.   </dd> <dt id="getFileHandle"><pre id="getFileHandle,File" data-language="nim">proc getFileHandle(f: File): FileHandle {.raises: [], tags: [].}</pre></dt> <dd> returns the OS file handle of the file <code>f</code>. This is only useful for platform specific programming.   </dd> <dt id="cstringArrayToSeq"><pre id="cstringArrayToSeq,cstringArray,Natural" data-language="nim">proc cstringArrayToSeq(a: cstringArray; len: Natural): seq[string] {.raises: [],
    tags: [].}</pre></dt> <dd> converts a <code>cstringArray</code> to a <code>seq[string]</code>. <em>a</em> is supposed to be of length <code>len</code>.   </dd> <dt id="cstringArrayToSeq"><pre id="cstringArrayToSeq,cstringArray" data-language="nim">proc cstringArrayToSeq(a: cstringArray): seq[string] {.raises: [], tags: [].}</pre></dt> <dd> converts a <code>cstringArray</code> to a <code>seq[string]</code>. <em>a</em> is supposed to be terminated by <code>nil</code>.   </dd> <dt id="allocCStringArray"><pre id="allocCStringArray,openArray[string]" data-language="nim">proc allocCStringArray(a: openArray[string]): cstringArray {.raises: [Exception],
    tags: [].}</pre></dt> <dd> creates a NULL terminated cstringArray from <em>a</em>. The result has to be freed with <em>deallocCStringArray</em> after it's not needed anymore.   </dd> <dt id="deallocCStringArray"><pre id="deallocCStringArray,cstringArray" data-language="nim">proc deallocCStringArray(a: cstringArray) {.raises: [Exception], tags: [].}</pre></dt> <dd> frees a NULL terminated cstringArray.   </dd> <dt id="atomicInc"><pre id="atomicInc,int,int" data-language="nim">proc atomicInc(memLoc: var int; x: int = 1): int {.inline, discardable,
    gcsafe, locks: 0, raises: [], tags: [].}</pre></dt> <dd> atomic increment of <em>memLoc</em>. Returns the value after the operation.   </dd> <dt id="atomicDec"><pre id="atomicDec,int,int" data-language="nim">proc atomicDec(memLoc: var int; x: int = 1): int {.inline, discardable,
    gcsafe, locks: 0, raises: [], tags: [].}</pre></dt> <dd> atomic decrement of <em>memLoc</em>. Returns the value after the operation.   </dd> <dt id="addAndFetch"><pre id="addAndFetch,ptr.int,int" data-language="nim">proc addAndFetch(p: ptr int; val: int): int {.inline, raises: [], tags: [].}</pre></dt>  <dt id="atomicInc"><pre id="atomicInc,int,int_2" data-language="nim">proc atomicInc(memLoc: var int; x: int = 1): int {.inline, discardable,
    gcsafe, locks: 0, raises: [], tags: [].}</pre></dt> <dd> atomic increment of <em>memLoc</em>. Returns the value after the operation.   </dd> <dt id="atomicDec"><pre id="atomicDec,int,int_2" data-language="nim">proc atomicDec(memLoc: var int; x: int = 1): int {.inline, discardable,
    gcsafe, locks: 0, raises: [], tags: [].}</pre></dt> <dd> atomic decrement of <em>memLoc</em>. Returns the value after the operation.   </dd> <dt id="cas"><pre id="cas,ptr.T,T,T" data-language="nim">proc cas[T: bool | int | ptr](p: ptr T; oldValue, newValue: T): bool {.
    importc: "__sync_bool_compare_and_swap", nodecl.}</pre></dt>  <dt id="cpuRelax"><pre id="cpuRelax," data-language="nim">proc cpuRelax() {.inline, raises: [], tags: [].}</pre></dt>  <dt id="setControlCHook"><pre id="setControlCHook," data-language="nim">proc setControlCHook(hook: proc () {.noconv.} not nil) {.raises: [Exception],
    tags: [RootEffect].}</pre></dt> <dd> allows you to override the behaviour of your application when CTRL+C is pressed. Only one such hook is supported.   </dd> <dt id="writeStackTrace"><pre id="writeStackTrace," data-language="nim">proc writeStackTrace() {.tags: [WriteIOEffect], gcsafe, raises: [Exception].}</pre></dt> <dd> writes the current stack trace to <code>stderr</code>. This is only works for debug builds.   </dd> <dt id="getStackTrace"><pre id="getStackTrace," data-language="nim">proc getStackTrace(): string {.gcsafe, raises: [], tags: [].}</pre></dt> <dd> gets the current stack trace. This only works for debug builds.   </dd> <dt id="getStackTrace"><pre id="getStackTrace,ref.Exception" data-language="nim">proc getStackTrace(e: ref Exception): string {.gcsafe, raises: [], tags: [].}</pre></dt> <dd> gets the stack trace associated with <em>e</em>, which is the stack that lead to the <code>raise</code> statement. This only works for debug builds.   </dd> <dt id="zeroMem"><pre id="zeroMem,pointer,Natural" data-language="nim">proc zeroMem(p: pointer; size: Natural) {.inline, gcsafe, locks: 0, raises: [], tags: [].}</pre></dt> <dd> overwrites the contents of the memory at <code>p</code> with the value 0. Exactly <code>size</code> bytes will be overwritten. Like any procedure dealing with raw memory this is <em>unsafe</em>.   </dd> <dt id="copyMem"><pre id="copyMem,pointer,pointer,Natural" data-language="nim">proc copyMem(dest, source: pointer; size: Natural) {.inline, gcsafe, locks: 0, tags: [],
    locks: 0, raises: [].}</pre></dt> <dd> copies the contents from the memory at <code>source</code> to the memory at <code>dest</code>. Exactly <code>size</code> bytes will be copied. The memory regions may not overlap. Like any procedure dealing with raw memory this is <em>unsafe</em>.   </dd> <dt id="moveMem"><pre id="moveMem,pointer,pointer,Natural" data-language="nim">proc moveMem(dest, source: pointer; size: Natural) {.inline, gcsafe, locks: 0, tags: [],
    locks: 0, raises: [].}</pre></dt> <dd> copies the contents from the memory at <code>source</code> to the memory at <code>dest</code>. Exactly <code>size</code> bytes will be copied. The memory regions may overlap, <code>moveMem</code> handles this case appropriately and is thus somewhat more safe than <code>copyMem</code>. Like any procedure dealing with raw memory this is still <em>unsafe</em>, though.   </dd> <dt id="equalMem"><pre id="equalMem,pointer,pointer,Natural" data-language="nim">proc equalMem(a, b: pointer; size: Natural): bool {.inline, noSideEffect, tags: [],
    locks: 0, raises: [].}</pre></dt> <dd> compares the memory blocks <code>a</code> and <code>b</code>. <code>size</code> bytes will be compared. If the blocks are equal, true is returned, false otherwise. Like any procedure dealing with raw memory this is <em>unsafe</em>.   </dd> <dt id="getFrameState"><pre id="getFrameState," data-language="nim">proc getFrameState(): FrameState {.compilerproc, inline, raises: [], tags: [].}</pre></dt>  <dt id="setFrameState"><pre id="setFrameState,FrameState" data-language="nim">proc setFrameState(state: FrameState) {.compilerproc, inline, raises: [], tags: [].}</pre></dt>  <dt id="getFrame"><pre id="getFrame," data-language="nim">proc getFrame(): PFrame {.compilerproc, inline, raises: [], tags: [].}</pre></dt>  <dt id="setFrame"><pre id="setFrame,PFrame" data-language="nim">proc setFrame(s: PFrame) {.compilerproc, inline, raises: [], tags: [].}</pre></dt>  <dt id="stackTraceAvailable"><pre id="stackTraceAvailable," data-language="nim">proc stackTraceAvailable(): bool {.raises: [], tags: [].}</pre></dt>  <dt id="stackTraceAvailable"><pre id="stackTraceAvailable,_2" data-language="nim">proc stackTraceAvailable(): bool {.raises: [], tags: [].}</pre></dt>  <dt id="writeStackTrace"><pre id="writeStackTrace,_2" data-language="nim">proc writeStackTrace() {.tags: [WriteIOEffect], gcsafe, raises: [Exception].}</pre></dt> <dd> writes the current stack trace to <code>stderr</code>. This is only works for debug builds.   </dd> <dt id="getStackTrace"><pre id="getStackTrace,_2" data-language="nim">proc getStackTrace(): string {.gcsafe, raises: [], tags: [].}</pre></dt> <dd> gets the current stack trace. This only works for debug builds.   </dd> <dt id="getStackTrace"><pre id="getStackTrace,ref.Exception_2" data-language="nim">proc getStackTrace(e: ref Exception): string {.gcsafe, raises: [], tags: [].}</pre></dt> <dd> gets the stack trace associated with <em>e</em>, which is the stack that lead to the <code>raise</code> statement. This only works for debug builds.   </dd> <dt id="setControlCHook"><pre id="setControlCHook,_2" data-language="nim">proc setControlCHook(hook: proc () {.noconv.} not nil) {.raises: [Exception],
    tags: [RootEffect].}</pre></dt> <dd> allows you to override the behaviour of your application when CTRL+C is pressed. Only one such hook is supported.   </dd> <dt id="iterToProc"><pre id="iterToProc,typed,typedesc,untyped" data-language="nim">proc iterToProc(iter: typed; envType: typedesc; procName: untyped) {.magic: "Plugin",
    compileTime.}</pre></dt>  <dt id="alloc"><pre id="alloc,Natural" data-language="nim">proc alloc(size: Natural): pointer {.noconv, gcsafe, tags: [], gcsafe, locks: 0,
                                 raises: [Exception].}</pre></dt> <dd> allocates a new memory block with at least <code>size</code> bytes. The block has to be freed with <code>realloc(block, 0)</code> or <code>dealloc(block)</code>. The block is not initialized, so reading from it before writing to it is undefined behaviour! The allocated memory belongs to its allocating thread! Use <em>allocShared</em> to allocate from a shared heap.   </dd> <dt id="alloc0"><pre id="alloc0,Natural" data-language="nim">proc alloc0(size: Natural): pointer {.noconv, gcsafe, tags: [], gcsafe, locks: 0,
                                  raises: [Exception].}</pre></dt> <dd> allocates a new memory block with at least <code>size</code> bytes. The block has to be freed with <code>realloc(block, 0)</code> or <code>dealloc(block)</code>. The block is initialized with all bytes containing zero, so it is somewhat safer than <code>alloc</code>. The allocated memory belongs to its allocating thread! Use <em>allocShared0</em> to allocate from a shared heap.   </dd> <dt id="dealloc"><pre id="dealloc,pointer" data-language="nim">proc dealloc(p: pointer) {.noconv, gcsafe, tags: [], gcsafe, locks: 0, raises: [Exception].}</pre></dt> <dd> frees the memory allocated with <code>alloc</code>, <code>alloc0</code> or <code>realloc</code>. This procedure is dangerous! If one forgets to free the memory a leak occurs; if one tries to access freed memory (or just freeing it twice!) a core dump may happen or other memory may be corrupted. The freed memory must belong to its allocating thread! Use <em>deallocShared</em> to deallocate from a shared heap.   </dd> <dt id="realloc"><pre id="realloc,pointer,Natural" data-language="nim">proc realloc(p: pointer; newSize: Natural): pointer {.noconv, gcsafe, tags: [],
    gcsafe, locks: 0, raises: [Exception].}</pre></dt> <dd> grows or shrinks a given memory block. If p is <strong>nil</strong> then a new memory block is returned. In either way the block has at least <code>newSize</code> bytes. If <code>newSize == 0</code> and p is not <strong>nil</strong> <code>realloc</code> calls <code>dealloc(p)</code>. In other cases the block has to be freed with <code>dealloc</code>. The allocated memory belongs to its allocating thread! Use <em>reallocShared</em> to reallocate from a shared heap.   </dd> <dt id="getFreeMem"><pre id="getFreeMem," data-language="nim">proc getFreeMem(): int {.gcsafe, raises: [], tags: [].}</pre></dt> <dd> returns the number of bytes that are owned by the process, but do not hold any meaningful data.   </dd> <dt id="getTotalMem"><pre id="getTotalMem," data-language="nim">proc getTotalMem(): int {.gcsafe, raises: [], tags: [].}</pre></dt> <dd> returns the number of bytes that are owned by the process.   </dd> <dt id="getOccupiedMem"><pre id="getOccupiedMem," data-language="nim">proc getOccupiedMem(): int {.gcsafe, raises: [], tags: [].}</pre></dt> <dd> returns the number of bytes that are owned by the process and hold data.   </dd> <dt id="getMaxMem"><pre id="getMaxMem," data-language="nim">proc getMaxMem(): int {.raises: [], tags: [].}</pre></dt>  <dt id="allocShared"><pre id="allocShared,Natural" data-language="nim">proc allocShared(size: Natural): pointer {.noconv, gcsafe, gcsafe, locks: 0,
                                       raises: [Exception], tags: [].}</pre></dt> <dd> allocates a new memory block on the shared heap with at least <code>size</code> bytes. The block has to be freed with <code>reallocShared(block, 0)</code> or <code>deallocShared(block)</code>. The block is not initialized, so reading from it before writing to it is undefined behaviour!   </dd> <dt id="allocShared0"><pre id="allocShared0,Natural" data-language="nim">proc allocShared0(size: Natural): pointer {.noconv, gcsafe, gcsafe, locks: 0,
                                        raises: [Exception], tags: [].}</pre></dt> <dd> allocates a new memory block on the shared heap with at least <code>size</code> bytes. The block has to be freed with <code>reallocShared(block, 0)</code> or <code>deallocShared(block)</code>. The block is initialized with all bytes containing zero, so it is somewhat safer than <code>allocShared</code>.   </dd> <dt id="deallocShared"><pre id="deallocShared,pointer" data-language="nim">proc deallocShared(p: pointer) {.noconv, gcsafe, gcsafe, locks: 0, raises: [Exception],
                              tags: [].}</pre></dt> <dd> frees the memory allocated with <code>allocShared</code>, <code>allocShared0</code> or <code>reallocShared</code>. This procedure is dangerous! If one forgets to free the memory a leak occurs; if one tries to access freed memory (or just freeing it twice!) a core dump may happen or other memory may be corrupted.   </dd> <dt id="reallocShared"><pre id="reallocShared,pointer,Natural" data-language="nim">proc reallocShared(p: pointer; newSize: Natural): pointer {.noconv, gcsafe,
    gcsafe, locks: 0, raises: [Exception], tags: [].}</pre></dt> <dd> grows or shrinks a given memory block on the heap. If p is <strong>nil</strong> then a new memory block is returned. In either way the block has at least <code>newSize</code> bytes. If <code>newSize == 0</code> and p is not <strong>nil</strong> <code>reallocShared</code> calls <code>deallocShared(p)</code>. In other cases the block has to be freed with <code>deallocShared</code>.   </dd> <dt id="protect"><pre id="protect,pointer" data-language="nim">proc protect(x: pointer): ForeignCell {.raises: [Exception], tags: [].}</pre></dt>  <dt id="dispose"><pre id="dispose,ForeignCell" data-language="nim">proc dispose(x: ForeignCell) {.raises: [Exception], tags: [].}</pre></dt>  <dt id="isNotForeign"><pre id="isNotForeign,ForeignCell" data-language="nim">proc isNotForeign(x: ForeignCell): bool {.raises: [], tags: [].}</pre></dt> <dd> returns true if 'x' belongs to the calling thread. No deep copy has to be performed then.   </dd> <dt id="deallocHeap"><pre id="deallocHeap," data-language="nim">proc deallocHeap(runFinalizers = true; allowGcAfterwards = true) {.raises: [Exception],
    tags: [RootEffect].}</pre></dt> <dd> Frees the thread local heap. Runs every finalizer if <code>runFinalizers``` is true. If ``allowGcAfterwards</code> is true, a minimal amount of allocation happens to ensure the GC can continue to work after the call to <code>deallocHeap</code>.   </dd> <dt id="GC_addCycleRoot"><pre id="GC_addCycleRoot,ref.T" data-language="nim">proc GC_addCycleRoot[T](p: ref T) {.inline.}</pre></dt> <dd> adds 'p' to the cycle candidate set for the cycle collector. It is necessary if you used the 'acyclic' pragma for optimization purposes and need to break cycles manually.   </dd> <dt id="gcInvariant"><pre id="gcInvariant," data-language="nim">proc gcInvariant() {.raises: [], tags: [].}</pre></dt>  <dt id="GC_disable"><pre id="GC_disable," data-language="nim">proc GC_disable() {.gcsafe, inline, gcsafe, locks: 0, raises: [], tags: [].}</pre></dt> <dd> disables the GC. If called n-times, n calls to <em>GC_enable</em> are needed to reactivate the GC. Note that in most circumstances one should only disable the mark and sweep phase with <em>GC_disableMarkAndSweep</em>.   </dd> <dt id="GC_enable"><pre id="GC_enable," data-language="nim">proc GC_enable() {.gcsafe, inline, gcsafe, locks: 0, raises: [AssertionError], tags: [].}</pre></dt> <dd> enables the GC again.   </dd> <dt id="GC_setStrategy"><pre id="GC_setStrategy,GC_Strategy" data-language="nim">proc GC_setStrategy(strategy: GC_Strategy) {.gcsafe, deprecated,
    gcsafe, locks: 0, raises: [], tags: [].}</pre></dt> <dd> tells the GC the desired strategy for the application. <strong>Deprecated</strong> since version 0.8.14. This has always been a nop.   </dd> <dt id="GC_enableMarkAndSweep"><pre id="GC_enableMarkAndSweep," data-language="nim">proc GC_enableMarkAndSweep() {.gcsafe, gcsafe, locks: 0, raises: [], tags: [].}</pre></dt>  <dt id="GC_disableMarkAndSweep"><pre id="GC_disableMarkAndSweep," data-language="nim">proc GC_disableMarkAndSweep() {.gcsafe, gcsafe, locks: 0, raises: [], tags: [].}</pre></dt> <dd> the current implementation uses a reference counting garbage collector with a seldomly run mark and sweep phase to free cycles. The mark and sweep phase may take a long time and is not needed if the application does not create cycles. Thus the mark and sweep phase can be deactivated and activated separately from the rest of the GC.   </dd> <dt id="GC_fullCollect"><pre id="GC_fullCollect," data-language="nim">proc GC_fullCollect() {.gcsafe, gcsafe, locks: 0, raises: [Exception],
                      tags: [RootEffect].}</pre></dt> <dd> forces a full garbage collection pass. Ordinary code does not need to call this (and should not).   </dd> <dt id="GC_getStatistics"><pre id="GC_getStatistics," data-language="nim">proc GC_getStatistics(): string {.gcsafe, gcsafe, locks: 0, raises: [], tags: [].}</pre></dt> <dd> returns an informative string about the GC's activity. This may be useful for tweaking.   </dd> <dt id="add"><pre id="add,string,int64" data-language="nim">proc add(result: var string; x: int64) {.raises: [], tags: [].}</pre></dt>  <dt id="add"><pre id="add,string,float" data-language="nim">proc add(result: var string; x: float) {.raises: [], tags: [].}</pre></dt>  <dt id="readBuffer"><pre id="readBuffer,File,pointer,Natural_2" data-language="nim">proc readBuffer(f: File; buffer: pointer; len: Natural): int {.tags: [ReadIOEffect],
    gcsafe, locks: 0, raises: [IOError].}</pre></dt> <dd> reads <em>len</em> bytes into the buffer pointed to by <em>buffer</em>. Returns the actual number of bytes that have been read which may be less than <em>len</em> (if not as many bytes are remaining), but not greater.   </dd> <dt id="readBytes"><pre id="readBytes,File,openArray[],Natural,Natural_2" data-language="nim">proc readBytes(f: File; a: var openArray[int8 | uint8]; start, len: Natural): int {.
    tags: [ReadIOEffect], gcsafe, locks: 0.}</pre></dt> <dd> reads <em>len</em> bytes into the buffer <em>a</em> starting at <code>a[start]</code>. Returns the actual number of bytes that have been read which may be less than <em>len</em> (if not as many bytes are remaining), but not greater.   </dd> <dt id="readChars"><pre id="readChars,File,openArray[char],Natural,Natural_2" data-language="nim">proc readChars(f: File; a: var openArray[char]; start, len: Natural): int {.
    tags: [ReadIOEffect], gcsafe, locks: 0, raises: [IOError].}</pre></dt> <dd> <p>reads <em>len</em> bytes into the buffer <em>a</em> starting at <code>a[start]</code>. Returns the actual number of bytes that have been read which may be less than <em>len</em> (if not as many bytes are remaining), but not greater.</p> <p><strong>Warning:</strong> The buffer <em>a</em> must be pre-allocated. This can be done using, for example, <code>newString</code>.</p>   </dd> <dt id="write"><pre id="write,File,cstring_2" data-language="nim">proc write(f: File; c: cstring) {.tags: [WriteIOEffect], gcsafe, locks: 0,
                             raises: [IOError].}</pre></dt>  <dt id="writeBuffer"><pre id="writeBuffer,File,pointer,Natural_2" data-language="nim">proc writeBuffer(f: File; buffer: pointer; len: Natural): int {.tags: [WriteIOEffect],
    gcsafe, locks: 0, raises: [IOError].}</pre></dt> <dd> writes the bytes of buffer pointed to by the parameter <em>buffer</em> to the file <em>f</em>. Returns the number of actual written bytes, which may be less than <em>len</em> in case of an error.   </dd> <dt id="writeBytes"><pre id="writeBytes,File,openArray[],Natural,Natural_2" data-language="nim">proc writeBytes(f: File; a: openArray[int8 | uint8]; start, len: Natural): int {.
    tags: [WriteIOEffect], gcsafe, locks: 0.}</pre></dt> <dd> writes the bytes of <code>a[start..start+len-1]</code> to the file <em>f</em>. Returns the number of actual written bytes, which may be less than <em>len</em> in case of an error.   </dd> <dt id="writeChars"><pre id="writeChars,File,openArray[char],Natural,Natural_2" data-language="nim">proc writeChars(f: File; a: openArray[char]; start, len: Natural): int {.
    tags: [WriteIOEffect], gcsafe, locks: 0, raises: [IOError].}</pre></dt> <dd> writes the bytes of <code>a[start..start+len-1]</code> to the file <em>f</em>. Returns the number of actual written bytes, which may be less than <em>len</em> in case of an error.   </dd> <dt id="write"><pre id="write,File,string_2" data-language="nim">proc write(f: File; s: string) {.tags: [WriteIOEffect], gcsafe, locks: 0,
                            raises: [IOError].}</pre></dt>  <dt id="close"><pre id="close,File_2" data-language="nim">proc close(f: File) {.tags: [], gcsafe, raises: [].}</pre></dt> <dd> Closes the file.   </dd> <dt id="readChar"><pre id="readChar,File_2" data-language="nim">proc readChar(f: File): char {.tags: [ReadIOEffect], deprecated,
                           raises: [IOError, EOFError].}</pre></dt> <dd> Reads a single character from the stream <em>f</em>. <strong>Deprecated</strong> since version 0.16.2. Use some variant of <code>readBuffer</code> instead.   </dd> <dt id="flushFile"><pre id="flushFile,File_2" data-language="nim">proc flushFile(f: File) {.tags: [WriteIOEffect], raises: [].}</pre></dt> <dd> Flushes <em>f</em>'s buffer.   </dd> <dt id="getFileHandle"><pre id="getFileHandle,File_2" data-language="nim">proc getFileHandle(f: File): FileHandle {.raises: [], tags: [].}</pre></dt> <dd> returns the OS file handle of the file <code>f</code>. This is only useful for platform specific programming.   </dd> <dt id="readLine"><pre id="readLine,File,TaintedString_2" data-language="nim">proc readLine(f: File; line: var TaintedString): bool {.tags: [ReadIOEffect],
    gcsafe, locks: 0, raises: [IOError].}</pre></dt> <dd> reads a line of text from the file <em>f</em> into <em>line</em>. <em>line</em> must not be <code>nil</code>! May throw an IO exception. A line of text may be delimited by <code>LF</code> or <code>CRLF</code>. The newline character(s) are not part of the returned string. Returns <code>false</code> if the end of the file has been reached, <code>true</code> otherwise. If <code>false</code> is returned <em>line</em> contains no new data.   </dd> <dt id="readLine"><pre id="readLine,File_2" data-language="nim">proc readLine(f: File): TaintedString {.tags: [ReadIOEffect], gcsafe, locks: 0,
                                    raises: [IOError, EOFError].}</pre></dt> <dd> reads a line of text from the file <em>f</em>. May throw an IO exception. A line of text may be delimited by <code>LF</code> or <code>CRLF</code>. The newline character(s) are not part of the returned string.   </dd> <dt id="write"><pre id="write,File,int_2" data-language="nim">proc write(f: File; i: int) {.tags: [WriteIOEffect], gcsafe, locks: 0, raises: [IOError].}</pre></dt>  <dt id="write"><pre id="write,File,BiggestInt_2" data-language="nim">proc write(f: File; i: BiggestInt) {.tags: [WriteIOEffect], gcsafe, locks: 0,
                                raises: [IOError].}</pre></dt>  <dt id="write"><pre id="write,File,bool_2" data-language="nim">proc write(f: File; b: bool) {.tags: [WriteIOEffect], gcsafe, locks: 0, raises: [IOError].}</pre></dt>  <dt id="write"><pre id="write,File,float32_2" data-language="nim">proc write(f: File; r: float32) {.tags: [WriteIOEffect], gcsafe, locks: 0,
                             raises: [IOError].}</pre></dt>  <dt id="write"><pre id="write,File,BiggestFloat_2" data-language="nim">proc write(f: File; r: BiggestFloat) {.tags: [WriteIOEffect], gcsafe, locks: 0,
                                  raises: [IOError].}</pre></dt>  <dt id="write"><pre id="write,File,char_2" data-language="nim">proc write(f: File; c: char) {.tags: [WriteIOEffect], gcsafe, locks: 0, raises: [].}</pre></dt>  <dt id="write"><pre id="write,File,varargs[string,]_2" data-language="nim">proc write(f: File; a: varargs[string, `$`]) {.tags: [WriteIOEffect],
    gcsafe, locks: 0, raises: [IOError].}</pre></dt> <dd> Writes a value to the file <em>f</em>. May throw an IO exception.   </dd> <dt id="endOfFile"><pre id="endOfFile,File_2" data-language="nim">proc endOfFile(f: File): bool {.tags: [], gcsafe, locks: 0, raises: [].}</pre></dt> <dd> Returns true iff <em>f</em> is at the end.   </dd> <dt id="readAll"><pre id="readAll,File_2" data-language="nim">proc readAll(file: File): TaintedString {.tags: [ReadIOEffect], gcsafe, locks: 0,
                                      raises: [IOError].}</pre></dt> <dd> <p>Reads all data from the stream <em>file</em>.</p> <p>Raises an IO exception in case of an error. It is an error if the current file position is not at the beginning of the file.</p>   </dd> <dt id="writeLn"><pre id="writeLn,File,varargs[Ty,]_2" data-language="nim">proc writeLn[Ty](f: File; x: varargs[Ty, `$`]) {.inline, tags: [WriteIOEffect],
    gcsafe, locks: 0, deprecated.}</pre></dt> <dd> <strong>Deprecated since version 0.11.4:</strong> Use <strong>writeLine</strong> instead.   </dd> <dt id="writeLine"><pre id="writeLine,File,varargs[Ty,]_2" data-language="nim">proc writeLine[Ty](f: File; x: varargs[Ty, `$`]) {.inline, tags: [WriteIOEffect],
    gcsafe, locks: 0.}</pre></dt> <dd> writes the values <em>x</em> to <em>f</em> and then writes "\n". May throw an IO exception.   </dd> <dt id="len"><pre id="len,WideCString" data-language="nim">proc len(w: WideCString): int {.raises: [], tags: [].}</pre></dt> <dd> returns the length of a widestring. This traverses the whole string to find the binary zero end marker!   </dd> <dt id="newWideCString"><pre id="newWideCString,cstring,int" data-language="nim">proc newWideCString(source: cstring; L: int): WideCString {.raises: [], tags: [].}</pre></dt> <dd> Returns the unicode character <code>s[i]</code> in <em>result</em>. If <code>doInc == true</code> <em>i</em> is incremented by the number of bytes that have been processed.   </dd> <dt id="newWideCString"><pre id="newWideCString,cstring" data-language="nim">proc newWideCString(s: cstring): WideCString {.raises: [], tags: [].}</pre></dt>  <dt id="newWideCString"><pre id="newWideCString,string" data-language="nim">proc newWideCString(s: string): WideCString {.raises: [], tags: [].}</pre></dt>  <dt id="$"><pre id="$,WideCString,int,int" data-language="nim">proc `$`(w: WideCString; estimate: int; replacement: int = 0x0000FFFD): string {.
    raises: [], tags: [].}</pre></dt>  <dt id="$"><pre id="$,WideCString" data-language="nim">proc `$`(s: WideCString): string {.raises: [], tags: [].}</pre></dt>  <dt id="open"><pre id="open,File,string,FileMode,int_2" data-language="nim">proc open(f: var File; filename: string; mode: FileMode = fmRead; bufSize: int = -1): bool {.
    tags: [], gcsafe, locks: 0, raises: [].}</pre></dt> <dd> <p>Opens a file named <em>filename</em> with given <em>mode</em>.</p> <p>Default mode is readonly. Returns true iff the file could be opened. This throws no exception if the file could not be opened.</p>   </dd> <dt id="reopen"><pre id="reopen,File,string,FileMode_2" data-language="nim">proc reopen(f: File; filename: string; mode: FileMode = fmRead): bool {.tags: [],
    gcsafe, locks: 0, raises: [].}</pre></dt> <dd> <p>reopens the file <em>f</em> with given <em>filename</em> and <em>mode</em>. This is often used to redirect the <em>stdin</em>, <em>stdout</em> or <em>stderr</em> file variables.</p> <p>Default mode is readonly. Returns true iff the file could be reopened.</p>   </dd> <dt id="open"><pre id="open,File,FileHandle,FileMode_2" data-language="nim">proc open(f: var File; filehandle: FileHandle; mode: FileMode = fmRead): bool {.tags: [],
    gcsafe, locks: 0, raises: [].}</pre></dt> <dd> <p>Creates a <code>File</code> from a <em>filehandle</em> with given <em>mode</em>.</p> <p>Default mode is readonly. Returns true iff the file could be opened.</p>   </dd> <dt id="setFilePos"><pre id="setFilePos,File,int64,FileSeekPos_2" data-language="nim">proc setFilePos(f: File; pos: int64; relativeTo: FileSeekPos = fspSet) {.
    gcsafe, locks: 0, raises: [IOError], tags: [].}</pre></dt> <dd> sets the position of the file pointer that is used for read/write operations. The file's first byte has the index zero.   </dd> <dt id="getFilePos"><pre id="getFilePos,File_2" data-language="nim">proc getFilePos(f: File): int64 {.gcsafe, locks: 0, raises: [IOError], tags: [].}</pre></dt> <dd> retrieves the current position of the file pointer that is used to read from the file <em>f</em>. The file's first byte has the index zero.   </dd> <dt id="getFileSize"><pre id="getFileSize,File_2" data-language="nim">proc getFileSize(f: File): int64 {.tags: [ReadIOEffect], gcsafe, locks: 0,
                               raises: [IOError].}</pre></dt> <dd> retrieves the file size (in bytes) of <em>f</em>.   </dd> <dt id="readFile"><pre id="readFile,string_2" data-language="nim">proc readFile(filename: string): TaintedString {.tags: [ReadIOEffect],
    gcsafe, locks: 0, raises: [IOError].}</pre></dt> <dd> <p>Opens a file named <em>filename</em> for reading.</p> <p>Then calls <a href="#readAll">readAll</a> and closes the file afterwards. Returns the string. Raises an IO exception in case of an error. If you need to call this inside a compile time macro you can use <a href="#staticRead">staticRead</a>.</p>   </dd> <dt id="writeFile"><pre id="writeFile,string,string_2" data-language="nim">proc writeFile(filename, content: string) {.tags: [WriteIOEffect],
                                        gcsafe, locks: 0, raises: [IOError].}</pre></dt> <dd> Opens a file named <em>filename</em> for writing. Then writes the <em>content</em> completely to the file and closes the file afterwards. Raises an IO exception in case of an error.   </dd> <dt id="setStdIoUnbuffered"><pre id="setStdIoUnbuffered,_2" data-language="nim">proc setStdIoUnbuffered() {.tags: [], gcsafe, locks: 0, raises: [].}</pre></dt> <dd> Configures <em>stdin</em>, <em>stdout</em> and <em>stderr</em> to be unbuffered.   </dd> <dt id="$"><pre id="$,uint64" data-language="nim">proc `$`(x: uint64): string {.noSideEffect, raises: [], tags: [].}</pre></dt> <dd> The stringify operator for an unsigned integer argument. Returns <em>x</em> converted to a decimal string.   </dd> <dt id="getCurrentException"><pre id="getCurrentException," data-language="nim">proc getCurrentException(): ref Exception {.compilerproc, inline,
                                        gcsafe, locks: 0, raises: [], tags: [].}</pre></dt> <dd> retrieves the current exception; if there is none, nil is returned.   </dd> <dt id="getCurrentExceptionMsg"><pre id="getCurrentExceptionMsg," data-language="nim">proc getCurrentExceptionMsg(): string {.inline, gcsafe, locks: 0, raises: [], tags: [].}</pre></dt> <dd> retrieves the error message that was attached to the current exception; if there is none, "" is returned.   </dd> <dt id="onRaise"><pre id="onRaise,proc(ref.Exception)" data-language="nim">proc onRaise(action: proc (e: ref Exception): bool {.closure.}) {.raises: [], tags: [].}</pre></dt> <dd> can be used in a <code>try</code> statement to setup a Lisp-like <span id="condition-system_1">condition system</span>: This prevents the 'raise' statement to raise an exception but instead calls <code>action</code>. If <code>action</code> returns false, the exception has been handled and does not propagate further through the call stack.   </dd> <dt id="setCurrentException"><pre id="setCurrentException,ref.Exception" data-language="nim">proc setCurrentException(exc: ref Exception) {.inline, gcsafe, locks: 0, raises: [],
    tags: [].}</pre></dt> <dd> <p>sets the current exception.</p> <p><strong>Warning</strong>: Only use this if you know what you are doing.</p>   </dd> <dt id="rawProc"><pre id="rawProc,T" data-language="nim">proc rawProc[T: proc](x: T): pointer {.noSideEffect, inline.}</pre></dt> <dd> retrieves the raw proc pointer of the closure <em>x</em>. This is useful for interfacing closures with C.   </dd> <dt id="rawEnv"><pre id="rawEnv,T" data-language="nim">proc rawEnv[T: proc](x: T): pointer {.noSideEffect, inline.}</pre></dt> <dd> retrieves the raw environment pointer of the closure <em>x</em>. This is useful for interfacing closures with C.   </dd> <dt id="finished"><pre id="finished,T" data-language="nim">proc finished[T: proc](x: T): bool {.noSideEffect, inline.}</pre></dt> <dd> can be used to determine if a first class iterator has finished.   </dd> <dt id="$"><pre id="$,array[IDX,T]" data-language="nim">proc `$`[T, IDX](x: array[IDX, T]): string</pre></dt> <dd> generic <code>$</code> operator for arrays that is lifted from the components   </dd> <dt id="quit"><pre id="quit,string" data-language="nim">proc quit(errormsg: string; errorcode = QuitFailure) {.noReturn, raises: [], tags: [].}</pre></dt> <dd> a shorthand for <code>echo(errormsg); quit(errorcode)</code>.   </dd> <dt id="/"><pre id="/,int,int" data-language="nim">proc `/`(x, y: int): float {.inline, noSideEffect, raises: [], tags: [].}</pre></dt> <dd> integer division that results in a float.   </dd> <dt id="[]"><pre id="[],string,Slice[int]" data-language="nim">proc `[]`(s: string; x: Slice[int]): string {.inline, raises: [], tags: [].}</pre></dt> <dd> slice operation for strings. returns the inclusive range [s[x.a], s[x.b]]:<pre class="listing" data-language="nim">var s = "abcdef"
assert s[1..3] == "bcd"</pre>   </dd> <dt id="[]="><pre id="[]=,string,Slice[int],string" data-language="nim">proc `[]=`(s: var string; x: Slice[int]; b: string) {.raises: [], tags: [].}</pre></dt> <dd> slice assignment for strings. If <code>b.len</code> is not exactly the number of elements that are referred to by <em>x</em>, a <span id="splice_1">splice</span> is performed:<pre class="listing" data-language="nim">var s = "abcdef"
s[1 .. ^2] = "xyz"
assert s == "axyzf"</pre>   </dd> <dt id="[]"><pre id="[],array[Idx,T],Slice[int]" data-language="nim">proc `[]`[Idx, T](a: array[Idx, T]; x: Slice[int]): seq[T]</pre></dt> <dd> slice operation for arrays. returns the inclusive range [a[x.a], a[x.b]]:<pre class="listing" data-language="nim">var a = [1,2,3,4]
assert a[0..2] == @[1,2,3]</pre>   </dd> <dt id="[]="><pre id="[]=,array[Idx,T],Slice[int],openArray[T]" data-language="nim">proc `[]=`[Idx, T](a: var array[Idx, T]; x: Slice[int]; b: openArray[T])</pre></dt> <dd> slice assignment for arrays.   </dd> <dt id="[]"><pre id="[],array[Idx,T],Slice[Idx]" data-language="nim">proc `[]`[Idx, T](a: array[Idx, T]; x: Slice[Idx]): seq[T]</pre></dt> <dd> slice operation for arrays.   </dd> <dt id="[]="><pre id="[]=,array[Idx,T],Slice[Idx],openArray[T]" data-language="nim">proc `[]=`[Idx, T](a: var array[Idx, T]; x: Slice[Idx]; b: openArray[T])</pre></dt> <dd> slice assignment for arrays.   </dd> <dt id="[]"><pre id="[],seq[T],Slice[int]" data-language="nim">proc `[]`[T](s: seq[T]; x: Slice[int]): seq[T]</pre></dt> <dd> slice operation for sequences. returns the inclusive range [s[x.a], s[x.b]]:<pre class="listing" data-language="nim">var s = @[1,2,3,4]
assert s[0..2] == @[1,2,3]</pre>   </dd> <dt id="[]="><pre id="[]=,seq[T],Slice[int],openArray[T]" data-language="nim">proc `[]=`[T](s: var seq[T]; x: Slice[int]; b: openArray[T])</pre></dt> <dd> slice assignment for sequences. If <code>b.len</code> is not exactly the number of elements that are referred to by <em>x</em>, a <span id="splice_2">splice</span> is performed.   </dd> <dt id="slurp"><pre id="slurp,string" data-language="nim">proc slurp(filename: string): string {.magic: "Slurp".}</pre></dt> <dd> This is an alias for <a href="#staticRead">staticRead</a>.   </dd> <dt id="staticRead"><pre id="staticRead,string" data-language="nim">proc staticRead(filename: string): string {.magic: "Slurp".}</pre></dt> <dd> Compile-time <a href="#readFile">readFile</a> proc for easy <span id="resource_1">resource</span> embedding:<pre class="listing" data-language="nim">const myResource = staticRead"mydatafile.bin"</pre>
<p><a href="#slurp">slurp</a> is an alias for <code>staticRead</code>.</p>   </dd> <dt id="gorge"><pre id="gorge,string,string,string" data-language="nim">proc gorge(command: string; input = ""; cache = ""): string {.magic: "StaticExec",
    raises: [], tags: [].}</pre></dt> <dd> This is an alias for <a href="#staticExec">staticExec</a>.   </dd> <dt id="staticExec"><pre id="staticExec,string,string,string" data-language="nim">proc staticExec(command: string; input = ""; cache = ""): string {.magic: "StaticExec",
    raises: [], tags: [].}</pre></dt> <dd> Executes an external process at compile-time. if <em>input</em> is not an empty string, it will be passed as a standard input to the executed program.<pre class="listing" data-language="nim">const buildInfo = "Revision " &amp; staticExec("git rev-parse HEAD") &amp;
                  "\nCompiled on " &amp; staticExec("uname -v")</pre>
<p><a href="#gorge">gorge</a> is an alias for <code>staticExec</code>. Note that you can use this proc inside a pragma like <a href="../nimc/#passc-pragma">passC</a> or <a href="../nimc/#passl-pragma">passL</a>.</p> <p>If <code>cache</code> is not empty, the results of <code>staticExec</code> are cached within the <code>nimcache</code> directory. Use <code>--forceBuild</code> to get rid of this caching behaviour then. <code>command &amp; input &amp; cache</code> (the concatenated string) is used to determine whether the entry in the cache is still valid. You can use versioning information for <code>cache</code>:</p> <pre class="listing" data-language="nim">const stateMachine = staticExec("dfaoptimizer", "input", "0.8.0")</pre>   </dd> <dt id="gorgeEx"><pre id="gorgeEx,string,string,string" data-language="nim">proc gorgeEx(command: string; input = ""; cache = ""): tuple[output: string, exitCode: int] {.
    raises: [], tags: [].}</pre></dt> <dd> Same as <em>gorge</em> but also returns the precious exit code.   </dd> <dt id="+="><pre id="+=,T,T" data-language="nim">proc `+=`[T: SomeOrdinal | uint | uint64](x: var T; y: T) {.magic: "Inc", noSideEffect.}</pre></dt> <dd> Increments an ordinal   </dd> <dt id="-="><pre id="-=,T,T" data-language="nim">proc `-=`[T: SomeOrdinal | uint | uint64](x: var T; y: T) {.magic: "Dec", noSideEffect.}</pre></dt> <dd> Decrements an ordinal   </dd> <dt id="*="><pre id="*=,T,T" data-language="nim">proc `*=`[T: SomeOrdinal | uint | uint64](x: var T; y: T) {.inline, noSideEffect.}</pre></dt> <dd> Binary <em>*=</em> operator for ordinals   </dd> <dt id="+="><pre id="+=,T,T_2" data-language="nim">proc `+=`[T: float | float32 | float64](x: var T; y: T) {.inline, noSideEffect.}</pre></dt> <dd> Increments in place a floating point number   </dd> <dt id="-="><pre id="-=,T,T_2" data-language="nim">proc `-=`[T: float | float32 | float64](x: var T; y: T) {.inline, noSideEffect.}</pre></dt> <dd> Decrements in place a floating point number   </dd> <dt id="*="><pre id="*=,T,T_2" data-language="nim">proc `*=`[T: float | float32 | float64](x: var T; y: T) {.inline, noSideEffect.}</pre></dt> <dd> Multiplies in place a floating point number   </dd> <dt id="/="><pre id="/=,float64,float64" data-language="nim">proc `/=`(x: var float64; y: float64) {.inline, noSideEffect, raises: [], tags: [].}</pre></dt> <dd> Divides in place a floating point number   </dd> <dt id="/="><pre id="/=,T,T" data-language="nim">proc `/=`[T: float | float32](x: var T; y: T) {.inline, noSideEffect.}</pre></dt> <dd> Divides in place a floating point number   </dd> <dt id="&amp;="><pre id="&amp;=,string,string" data-language="nim">proc `&amp;=`(x: var string; y: string) {.magic: "AppendStrStr", noSideEffect.}</pre></dt>  <dt id="astToStr"><pre id="astToStr,T" data-language="nim">proc astToStr[T](x: T): string {.magic: "AstToStr", noSideEffect.}</pre></dt> <dd> converts the AST of <em>x</em> into a string representation. This is very useful for debugging.   </dd> <dt id="instantiationInfo"><pre id="instantiationInfo," data-language="nim">proc instantiationInfo(index = -1; fullPaths = false): tuple[filename: string, line: int] {.
    magic: "InstantiationInfo", noSideEffect.}</pre></dt> <dd> <p>provides access to the compiler's instantiation stack line information of a template.</p> <p>While similar to the <span id="caller-info_1">caller info</span> of other languages, it is determined at compile time.</p> <p>This proc is mostly useful for meta programming (eg. <code>assert</code> template) to retrieve information about the current filename and line number. Example:</p> <pre class="listing" data-language="nim">import strutils

template testException(exception, code: expr): stmt =
  try:
    let pos = instantiationInfo()
    discard(code)
    echo "Test failure at $1:$2 with '$3'" % [pos.filename,
      $pos.line, astToStr(code)]
    assert false, "A test expecting failure succeeded?"
  except exception:
    discard

proc tester(pos: int): int =
  let
    a = @[1, 2, 3]
  result = a[pos]

when isMainModule:
  testException(IndexError, tester(30))
  testException(IndexError, tester(1))
  # --&gt; Test failure at example.nim:20 with 'tester(1)'</pre>   </dd> <dt id="raiseAssert"><pre id="raiseAssert,string" data-language="nim">proc raiseAssert(msg: string) {.noinline, raises: [AssertionError], tags: [].}</pre></dt>  <dt id="failedAssertImpl"><pre id="failedAssertImpl,string" data-language="nim">proc failedAssertImpl(msg: string) {.raises: [], tags: [].}</pre></dt>  <dt id="shallow"><pre id="shallow,seq[T]" data-language="nim">proc shallow[T](s: var seq[T]) {.noSideEffect, inline.}</pre></dt> <dd> marks a sequence <em>s</em> as <span id="shallow_1">shallow</span>. Subsequent assignments will not perform deep copies of <em>s</em>. This is only useful for optimization purposes.   </dd> <dt id="shallow"><pre id="shallow,string" data-language="nim">proc shallow(s: var string) {.noSideEffect, inline, raises: [], tags: [].}</pre></dt> <dd> marks a string <em>s</em> as <span id="shallow_2">shallow</span>. Subsequent assignments will not perform deep copies of <em>s</em>. This is only useful for optimization purposes.   </dd> <dt id="insert"><pre id="insert,string,string" data-language="nim">proc insert(x: var string; item: string; i = 0.Natural) {.noSideEffect, raises: [], tags: [].}</pre></dt> <dd> inserts <em>item</em> into <em>x</em> at position <em>i</em>.   </dd> <dt id="compiles"><pre id="compiles,untyped" data-language="nim">proc compiles(x: untyped): bool {.magic: "Compiles", noSideEffect, compileTime,
                              raises: [], tags: [].}</pre></dt> <dd> Special compile-time procedure that checks whether <em>x</em> can be compiled without any semantic error. This can be used to check whether a type supports some operation:<pre class="listing" data-language="nim">when compiles(3 + 4):
  echo "'+' for integers is available"</pre>   </dd> <dt id="safeAdd"><pre id="safeAdd,seq[T],T" data-language="nim">proc safeAdd[T](x: var seq[T]; y: T) {.noSideEffect.}</pre></dt> <dd> Adds <code>y</code> to <code>x</code> unless <code>x</code> is not yet initialized; in that case, <code>x</code> becomes <code>@[y]</code>   </dd> <dt id="safeAdd"><pre id="safeAdd,string,char" data-language="nim">proc safeAdd(x: var string; y: char) {.raises: [], tags: [].}</pre></dt> <dd> Adds <code>y</code> to <code>x</code>. If <code>x</code> is <code>nil</code> it is initialized to <code>""</code>   </dd> <dt id="safeAdd"><pre id="safeAdd,string,string" data-language="nim">proc safeAdd(x: var string; y: string) {.raises: [], tags: [].}</pre></dt> <dd> Adds <code>y</code> to <code>x</code> unless <code>x</code> is not yet initalized; in that case, <code>x</code> becomes <code>y</code>   </dd> <dt id="locals"><pre id="locals," data-language="nim">proc locals(): RootObj {.magic: "Plugin", noSideEffect, raises: [], tags: [].}</pre></dt> <dd> generates a tuple constructor expression listing all the local variables in the current scope. This is quite fast as it does not rely on any debug or runtime information. Note that in contrast to what the official signature says, the return type is not <code>RootObj</code> but a tuple of a structure that depends on the current scope. Example:<pre class="listing" data-language="nim">proc testLocals() =
  var
    a = "something"
    b = 4
    c = locals()
    d = "super!"
  
  b = 1
  for name, value in fieldPairs(c):
    echo "name ", name, " with value ", value
  echo "B is ", b
# -&gt; name a with value something
# -&gt; name b with value 4
# -&gt; B is 1</pre>   </dd> <dt id="deepCopy"><pre id="deepCopy,T,T" data-language="nim">proc deepCopy[T](x: var T; y: T) {.noSideEffect, magic: "DeepCopy".}</pre></dt> <dd> performs a deep copy of <em>y</em> and copies it into <em>x</em>. This is also used by the code generator for the implementation of <code>spawn</code>.   </dd> <dt id="procCall"><pre id="procCall,untyped" data-language="nim">proc procCall(x: untyped) {.magic: "ProcCall", compileTime, raises: [], tags: [].}</pre></dt> <dd> special magic to prohibit dynamic binding for <span id="method_1">method</span> calls. This is similar to <span id="super_1">super</span> in ordinary OO languages.<pre class="listing" data-language="nim"># 'someMethod' will be resolved fully statically:
procCall someMethod(a, b)</pre>   </dd> <dt id="^"><pre id="^,int,openArray[T]" data-language="nim">proc `^`[T](x: int; y: openArray[T]): int {.noSideEffect, magic: "Roof".}</pre></dt>  <dt id="^"><pre id="^,int" data-language="nim">proc `^`(x: int): int {.noSideEffect, magic: "Roof", raises: [], tags: [].}</pre></dt> <dd> builtin <span id="roof_1">roof</span> operator that can be used for convenient array access. <code>a[^x]</code> is rewritten to <code>a[a.len-x]</code>. However currently the <code>a</code> expression must not have side effects for this to compile. Note that since this is a builtin, it automatically works for all kinds of overloaded <code>[]</code> or <code>[]=</code> accessors.   </dd> <dt id="xlen"><pre id="xlen,string" data-language="nim">proc xlen(x: string): int {.magic: "XLenStr", noSideEffect, raises: [], tags: [].}</pre></dt>  <dt id="xlen"><pre id="xlen,seq[T]" data-language="nim">proc xlen[T](x: seq[T]): int {.magic: "XLenSeq", noSideEffect.}</pre></dt> <dd> returns the length of a sequence or a string without testing for 'nil'. This is an optimization that rarely makes sense.   </dd> <dt id="=="><pre id="==,cstring,cstring" data-language="nim">proc `==`(x, y: cstring): bool {.magic: "EqCString", noSideEffect, inline, raises: [],
                            tags: [].}</pre></dt> <dd> Checks for equality between two <em>cstring</em> variables.   </dd> </dl>  <h2 id="15">Iterators</h2> <dl> <dt id="countdown"><pre id="countdown.i,T,T,int" data-language="nim">iterator countdown[T](a, b: T; step = 1): T {.inline.}</pre></dt> <dd> Counts from ordinal value <em>a</em> down to <em>b</em> (inclusive) with the given step count. <em>T</em> may be any ordinal type, <em>step</em> may only be positive. <strong>Note</strong>: This fails to count to <code>low(int)</code> if T = int for efficiency reasons.   </dd> <dt id="countup"><pre id="countup.i,S,T,int" data-language="nim">iterator countup[S, T](a: S; b: T; step = 1): T {.inline.}</pre></dt> <dd> Counts from ordinal value <em>a</em> up to <em>b</em> (inclusive) with the given step count. <em>S</em>, <em>T</em> may be any ordinal type, <em>step</em> may only be positive. <strong>Note</strong>: This fails to count to <code>high(int)</code> if T = int for efficiency reasons.   </dd> <dt id=".."><pre id="...i,S,T" data-language="nim">iterator `..`[S, T](a: S; b: T): T {.inline.}</pre></dt> <dd> An alias for <em>countup</em>.   </dd> <dt id="||"><pre id="||.i,S,T,string" data-language="nim">iterator `||`[S, T](a: S; b: T; annotation = ""): T {.inline, magic: "OmpParFor", sideEffect.}</pre></dt> <dd> parallel loop iterator. Same as <em>..</em> but the loop may run in parallel. <em>annotation</em> is an additional annotation for the code generator to use. Note that the compiler maps that to the <code>#pragma omp parallel for</code> construct of <span id="openmp_1">OpenMP</span> and as such isn't aware of the parallelism in your code! Be careful! Later versions of <code>||</code> will get proper support by Nim's code generator and GC.   </dd> <dt id="items"><pre id="items.i,openArray[T]" data-language="nim">iterator items[T](a: openArray[T]): T {.inline.}</pre></dt> <dd> iterates over each item of <em>a</em>.   </dd> <dt id="mitems"><pre id="mitems.i,openArray[T]" data-language="nim">iterator mitems[T](a: var openArray[T]): var T {.inline.}</pre></dt> <dd> iterates over each item of <em>a</em> so that you can modify the yielded value.   </dd> <dt id="items"><pre id="items.i,array[IX,T]" data-language="nim">iterator items[IX, T](a: array[IX, T]): T {.inline.}</pre></dt> <dd> iterates over each item of <em>a</em>.   </dd> <dt id="mitems"><pre id="mitems.i,array[IX,T]" data-language="nim">iterator mitems[IX, T](a: var array[IX, T]): var T {.inline.}</pre></dt> <dd> iterates over each item of <em>a</em> so that you can modify the yielded value.   </dd> <dt id="items"><pre id="items.i,set[T]" data-language="nim">iterator items[T](a: set[T]): T {.inline.}</pre></dt> <dd> iterates over each element of <em>a</em>. <em>items</em> iterates only over the elements that are really in the set (and not over the ones the set is able to hold).   </dd> <dt id="items"><pre id="items.i,cstring" data-language="nim">iterator items(a: cstring): char {.inline, raises: [], tags: [].}</pre></dt> <dd> iterates over each item of <em>a</em>.   </dd> <dt id="mitems"><pre id="mitems.i,cstring" data-language="nim">iterator mitems(a: var cstring): var char {.inline, raises: [], tags: [].}</pre></dt> <dd> iterates over each item of <em>a</em> so that you can modify the yielded value.   </dd> <dt id="items"><pre id="items.i,typedesc[]" data-language="nim">iterator items(E: typedesc[enum]): E:type</pre></dt> <dd> iterates over the values of the enum <code>E</code>.   </dd> <dt id="items"><pre id="items.i,Slice[T]" data-language="nim">iterator items[T](s: Slice[T]): T</pre></dt> <dd> iterates over the slice <em>s</em>, yielding each value between <em>s.a</em> and <em>s.b</em> (inclusively).   </dd> <dt id="pairs"><pre id="pairs.i,openArray[T]" data-language="nim">iterator pairs[T](a: openArray[T]): tuple[key: int, val: T] {.inline.}</pre></dt> <dd> iterates over each item of <em>a</em>. Yields <code>(index, a[index])</code> pairs.   </dd> <dt id="mpairs"><pre id="mpairs.i,openArray[T]" data-language="nim">iterator mpairs[T](a: var openArray[T]): tuple[key: int, val: var T] {.inline.}</pre></dt> <dd> iterates over each item of <em>a</em>. Yields <code>(index, a[index])</code> pairs. <code>a[index]</code> can be modified.   </dd> <dt id="pairs"><pre id="pairs.i,array[IX,T]" data-language="nim">iterator pairs[IX, T](a: array[IX, T]): tuple[key: IX, val: T] {.inline.}</pre></dt> <dd> iterates over each item of <em>a</em>. Yields <code>(index, a[index])</code> pairs.   </dd> <dt id="mpairs"><pre id="mpairs.i,array[IX,T]" data-language="nim">iterator mpairs[IX, T](a: var array[IX, T]): tuple[key: IX, val: var T] {.inline.}</pre></dt> <dd> iterates over each item of <em>a</em>. Yields <code>(index, a[index])</code> pairs. <code>a[index]</code> can be modified.   </dd> <dt id="pairs"><pre id="pairs.i,seq[T]" data-language="nim">iterator pairs[T](a: seq[T]): tuple[key: int, val: T] {.inline.}</pre></dt> <dd> iterates over each item of <em>a</em>. Yields <code>(index, a[index])</code> pairs.   </dd> <dt id="mpairs"><pre id="mpairs.i,seq[T]" data-language="nim">iterator mpairs[T](a: var seq[T]): tuple[key: int, val: var T] {.inline.}</pre></dt> <dd> iterates over each item of <em>a</em>. Yields <code>(index, a[index])</code> pairs. <code>a[index]</code> can be modified.   </dd> <dt id="pairs"><pre id="pairs.i,string" data-language="nim">iterator pairs(a: string): tuple[key: int, val: char] {.inline, raises: [], tags: [].}</pre></dt> <dd> iterates over each item of <em>a</em>. Yields <code>(index, a[index])</code> pairs.   </dd> <dt id="mpairs"><pre id="mpairs.i,string" data-language="nim">iterator mpairs(a: var string): tuple[key: int, val: var char] {.inline, raises: [],
    tags: [].}</pre></dt> <dd> iterates over each item of <em>a</em>. Yields <code>(index, a[index])</code> pairs. <code>a[index]</code> can be modified.   </dd> <dt id="pairs"><pre id="pairs.i,cstring" data-language="nim">iterator pairs(a: cstring): tuple[key: int, val: char] {.inline, raises: [], tags: [].}</pre></dt> <dd> iterates over each item of <em>a</em>. Yields <code>(index, a[index])</code> pairs.   </dd> <dt id="mpairs"><pre id="mpairs.i,cstring" data-language="nim">iterator mpairs(a: var cstring): tuple[key: int, val: var char] {.inline, raises: [],
    tags: [].}</pre></dt> <dd> iterates over each item of <em>a</em>. Yields <code>(index, a[index])</code> pairs. <code>a[index]</code> can be modified.   </dd> <dt id="fields"><pre id="fields.i,T" data-language="nim">iterator fields[T: tuple |
    object](x: T): RootObj {.magic: "Fields", noSideEffect.}</pre></dt> <dd> iterates over every field of <em>x</em>. Warning: This really transforms the 'for' and unrolls the loop. The current implementation also has a bug that affects symbol binding in the loop body.   </dd> <dt id="fields"><pre id="fields.i,S,T" data-language="nim">iterator fields[S: tuple |
    object; T: tuple |
    object](x: S; y: T): tuple[a, b: untyped] {.magic: "Fields", noSideEffect.}</pre></dt> <dd> iterates over every field of <em>x</em> and <em>y</em>. Warning: This is really transforms the 'for' and unrolls the loop. The current implementation also has a bug that affects symbol binding in the loop body.   </dd> <dt id="fieldPairs"><pre id="fieldPairs.i,T" data-language="nim">iterator fieldPairs[T: tuple |
    object](x: T): RootObj {.magic: "FieldPairs", noSideEffect.}</pre></dt> <dd> <p>Iterates over every field of <em>x</em> returning their name and value.</p> <p>When you iterate over objects with different field types you have to use the compile time <code>when</code> instead of a runtime <code>if</code> to select the code you want to run for each type. To perform the comparison use the <a href="../manual/#is-operator">is operator</a>. Example:</p> <pre class="listing" data-language="nim">type
  Custom = object
    foo: string
    bar: bool

proc `$`(x: Custom): string =
  result = "Custom:"
  for name, value in x.fieldPairs:
    when value is bool:
      result.add("\n\t" &amp; name &amp; " is " &amp; $value)
    else:
      if value.isNil:
        result.add("\n\t" &amp; name &amp; " (nil)")
      else:
        result.add("\n\t" &amp; name &amp; " '" &amp; value &amp; "'")</pre>
<p>Another way to do the same without <code>when</code> is to leave the task of picking the appropriate code to a secondary proc which you overload for each field type and pass the <em>value</em> to.</p> <p>Warning: This really transforms the 'for' and unrolls the loop. The current implementation also has a bug that affects symbol binding in the loop body.</p>   </dd> <dt id="fieldPairs"><pre id="fieldPairs.i,S,T" data-language="nim">iterator fieldPairs[S: tuple |
    object; T: tuple |
    object](x: S; y: T): tuple[a, b: untyped] {.magic: "FieldPairs", noSideEffect.}</pre></dt> <dd> iterates over every field of <em>x</em> and <em>y</em>. Warning: This really transforms the 'for' and unrolls the loop. The current implementation also has a bug that affects symbol binding in the loop body.   </dd> <dt id="lines"><pre id="lines.i,string" data-language="nim">iterator lines(filename: string): TaintedString {.tags: [ReadIOEffect],
    raises: [Exception, IOError, IOError].}</pre></dt> <dd> <p>Iterates over any line in the file named <em>filename</em>.</p> <p>If the file does not exist <em>EIO</em> is raised. The trailing newline character(s) are removed from the iterated lines. Example:</p> <pre class="listing" data-language="nim">import strutils

proc transformLetters(filename: string) =
  var buffer = ""
  for line in filename.lines:
    buffer.add(line.replace("a", "0") &amp; '\x0A')
  writeFile(filename, buffer)</pre>   </dd> <dt id="lines"><pre id="lines.i,File" data-language="nim">iterator lines(f: File): TaintedString {.tags: [ReadIOEffect], raises: [IOError].}</pre></dt> <dd> <p>Iterate over any line in the file <em>f</em>.</p> <p>The trailing newline character(s) are removed from the iterated lines. Example:</p> <pre class="listing" data-language="nim">proc countZeros(filename: File): tuple[lines, zeros: int] =
  for line in filename.lines:
    for letter in line:
      if letter == '0':
        result.zeros += 1
    result.lines += 1</pre>   </dd> <dt id="items"><pre id="items.i,seq[T]" data-language="nim">iterator items[T](a: seq[T]): T {.inline.}</pre></dt> <dd> iterates over each item of <em>a</em>.   </dd> <dt id="mitems"><pre id="mitems.i,seq[T]" data-language="nim">iterator mitems[T](a: var seq[T]): var T {.inline.}</pre></dt> <dd> iterates over each item of <em>a</em> so that you can modify the yielded value.   </dd> <dt id="items"><pre id="items.i,string" data-language="nim">iterator items(a: string): char {.inline, raises: [], tags: [].}</pre></dt> <dd> iterates over each item of <em>a</em>.   </dd> <dt id="mitems"><pre id="mitems.i,string" data-language="nim">iterator mitems(a: var string): var char {.inline, raises: [], tags: [].}</pre></dt> <dd> iterates over each item of <em>a</em> so that you can modify the yielded value.   </dd> <dt id="..&lt;"><pre id="..&lt;.i,S,T" data-language="nim">iterator `..&lt;`[S, T](a: S; b: T): T</pre></dt>  </dl>  <h2 id="18">Templates</h2> <dl> <dt id="!="><pre id="!=.t,untyped,untyped" data-language="nim">template `!=`(x, y: untyped): untyped</pre></dt> <dd> unequals operator. This is a shorthand for <code>not (x == y)</code>.   </dd> <dt id="&gt;="><pre id="&gt;=.t,untyped,untyped" data-language="nim">template `&gt;=`(x, y: untyped): untyped</pre></dt> <dd> "is greater or equals" operator. This is the same as <code>y &lt;= x</code>.   </dd> <dt id="&gt;"><pre id="&gt;.t,untyped,untyped" data-language="nim">template `&gt;`(x, y: untyped): untyped</pre></dt> <dd> "is greater" operator. This is the same as <code>y &lt; x</code>.   </dd> <dt id="incl"><pre id="incl.t,set[T],set[T]" data-language="nim">template incl[T](s: var set[T]; flags: set[T])</pre></dt> <dd> includes the set of flags to the set <code>x</code>.   </dd> <dt id="excl"><pre id="excl.t,set[T],set[T]" data-language="nim">template excl[T](s: var set[T]; flags: set[T])</pre></dt> <dd> excludes the set of flags to <code>x</code>.   </dd> <dt id="in"><pre id="in.t,untyped,untyped" data-language="nim">template `in`(x, y: untyped): untyped {.dirty.}</pre></dt> <dd> Sugar for contains<pre class="listing" data-language="nim">assert(1 in (1..3) == true)
assert(5 in (1..3) == false)</pre>   </dd> <dt id="notin"><pre id="notin.t,untyped,untyped" data-language="nim">template `notin`(x, y: untyped): untyped {.dirty.}</pre></dt> <dd> Sugar for not containing<pre class="listing" data-language="nim">assert(1 notin (1..3) == false)
assert(5 notin (1..3) == true)</pre>   </dd> <dt id="isnot"><pre id="isnot.t,untyped,untyped" data-language="nim">template `isnot`(x, y: untyped): untyped</pre></dt> <dd> Negated version of <em>is</em>. Equivalent to <code>not(x is y)</code>.   </dd> <dt id="&gt;=%"><pre id="&gt;=%.t,untyped,untyped" data-language="nim">template `&gt;=%`(x, y: untyped): untyped</pre></dt> <dd> treats <em>x</em> and <em>y</em> as unsigned and compares them. Returns true iff <code>unsigned(x) &gt;= unsigned(y)</code>.   </dd> <dt id="&gt;%"><pre id="&gt;%.t,untyped,untyped" data-language="nim">template `&gt;%`(x, y: untyped): untyped</pre></dt> <dd> treats <em>x</em> and <em>y</em> as unsigned and compares them. Returns true iff <code>unsigned(x) &gt; unsigned(y)</code>.   </dd> <dt id="accumulateResult"><pre id="accumulateResult.t,untyped" data-language="nim">template accumulateResult(iter: untyped)</pre></dt> <dd> helps to convert an iterator to a proc.   </dd> <dt id="newException"><pre id="newException.t,typedesc,string,ref.Exception" data-language="nim">template newException(exceptn: typedesc; message: string;
                     parentException: ref Exception = nil): untyped</pre></dt> <dd> creates an exception object of type <code>exceptn</code> and sets its <code>msg</code> field to <em>message</em>. Returns the new exception object.   </dd> <dt id="stdmsg"><pre id="stdmsg.t," data-language="nim">template stdmsg(): File</pre></dt> <dd> Template which expands to either stdout or stderr depending on <em>useStdoutAsStdmsg</em> compile-time switch.   </dd> <dt id="setupForeignThreadGc"><pre id="setupForeignThreadGc.t," data-language="nim">template setupForeignThreadGc()</pre></dt>  <dt id="tearDownForeignThreadGc"><pre id="tearDownForeignThreadGc.t," data-language="nim">template tearDownForeignThreadGc()</pre></dt>  <dt id="likely"><pre id="likely.t,bool" data-language="nim">template likely(val: bool): bool</pre></dt> <dd> <p>Hints the optimizer that <em>val</em> is likely going to be true.</p> <p>You can use this template to decorate a branch condition. On certain platforms this can help the processor predict better which branch is going to be run. Example:</p> <pre class="listing" data-language="nim">for value in inputValues:
  if likely(value &lt;= 100):
    process(value)
  else:
    echo "Value too big!"</pre>
<p>On backends without branch prediction (JS and the nimscript VM), this template will not affect code execution.</p>   </dd> <dt id="unlikely"><pre id="unlikely.t,bool" data-language="nim">template unlikely(val: bool): bool</pre></dt> <dd> <p>Hints the optimizer that <em>val</em> is likely going to be false.</p> <p>You can use this proc to decorate a branch condition. On certain platforms this can help the processor predict better which branch is going to be run. Example:</p> <pre class="listing" data-language="nim">for value in inputValues:
  if unlikely(value &gt; 100):
    echo "Value too big!"
  else:
    process(value)</pre>
<p>On backends without branch prediction (JS and the nimscript VM), this template will not affect code execution.</p>   </dd> <dt id="&amp;="><pre id="&amp;=.t,typed,typed" data-language="nim">template `&amp;=`(x, y: typed)</pre></dt> <dd> generic 'sink' operator for Nim. For files an alias for <code>write</code>. If not specialized further an alias for <code>add</code>.   </dd> <dt id="&amp;="><pre id="&amp;=.t,File,typed" data-language="nim">template `&amp;=`(f: File; x: typed)</pre></dt>  <dt id="currentSourcePath"><pre id="currentSourcePath.t," data-language="nim">template currentSourcePath(): string</pre></dt> <dd> returns the full file-system path of the current source   </dd> <dt id="assert"><pre id="assert.t,bool,string" data-language="nim">template assert(cond: bool; msg = "")</pre></dt> <dd> Raises <code>AssertionError</code> with <em>msg</em> if <em>cond</em> is false. Note that <code>AssertionError</code> is hidden from the effect system, so it doesn't produce <code>{.raises: [AssertionError].}</code>. This exception is only supposed to be caught by unit testing frameworks. The compiler may not generate any code at all for <code>assert</code> if it is advised to do so through the <code>-d:release</code> or <code>--assertions:off</code> <a href="../nimc/#command-line-switches">command line switches</a>.   </dd> <dt id="doAssert"><pre id="doAssert.t,bool,string" data-language="nim">template doAssert(cond: bool; msg = "")</pre></dt> <dd> same as <em>assert</em> but is always turned on and not affected by the <code>--assertions</code> command line switch.   </dd> <dt id="onFailedAssert"><pre id="onFailedAssert.t,untyped,untyped" data-language="nim">template onFailedAssert(msg, code: untyped): untyped {.dirty.}</pre></dt> <dd> Sets an assertion failure handler that will intercept any assert statements following <em>onFailedAssert</em> in the current module scope.<pre class="listing" data-language="nim"># module-wide policy to change the failed assert
# exception type in order to include a lineinfo
onFailedAssert(msg):
  var e = new(TMyError)
  e.msg = msg
  e.lineinfo = instantiationInfo(-2)
  raise e</pre>   </dd> <dt id="..^"><pre id="..^.t,untyped,untyped" data-language="nim">template `..^`(a, b: untyped): untyped</pre></dt> <dd> a shortcut for '.. ^' to avoid the common gotcha that a space between '..' and '^' is required.   </dd> <dt id="..&lt;"><pre id="..&lt;.t,untyped,untyped" data-language="nim">template `..&lt;`(a, b: untyped): untyped {.dirty.}</pre></dt> <dd> a shortcut for '.. &lt;' to avoid the common gotcha that a space between '..' and '&lt;' is required.   </dd> <dt id="closureScope"><pre id="closureScope.t,untyped" data-language="nim">template closureScope(body: untyped): untyped</pre></dt> <dd> Useful when creating a closure in a loop to capture local loop variables by their current iteration values. Example:<pre class="listing" data-language="nim">var myClosure : proc()
# without closureScope:
for i in 0 .. 5:
  let j = i
  if j == 3:
    myClosure = proc() = echo j
myClosure() # outputs 5. `j` is changed after closure creation
# with closureScope:
for i in 0 .. 5:
  closureScope: # Everything in this scope is locked after closure creation
    let j = i
    if j == 3:
      myClosure = proc() = echo j
myClosure() # outputs 3</pre>   </dd> </dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 2006–2017 Andreas Rumpf<br>Licensed under the MIT License.<br>
    <a href="https://nim-lang.org/docs/system.html" class="_attribution-link" target="_blank">https://nim-lang.org/docs/system.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
