
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Unicode - Nim - W3cubDocs</title>
  
  <meta name="description" content=" This module provides support to handle the Unicode UTF-8 encoding. ">
  <meta name="keywords" content="module, unicode, -, nim">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/nim/unicode/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-e0f881b0fce8cbe96f33dadc355b7159d5d2912911231446d60eb8f9caffa802.css">
  <script type="text/javascript" src="/assets/application-8fc46316434047265cd383f02b8e7f434ed7dec4a59f920dd633deef8d488d1b.js"></script>
  <script src="/json/nim.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/nim/" class="_nav-link" title="" style="margin-left:0;">Nim</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _nim">
				
<h1 class="title">Module unicode</h1>  <p class="module-desc">This module provides support to handle the Unicode UTF-8 encoding.</p>  <h2 id="7">Types</h2> <dl> <dt id="Rune"><pre id="Rune">Rune = distinct RuneImpl</pre></dt> <dd> type that can hold any Unicode character   </dd> <dt id="Rune16"><pre id="Rune16">Rune16 = distinct int16</pre></dt> <dd> 16 bit Unicode character   </dd> </dl>  <h2 id="12">Procs</h2> <dl> <dt id="&lt;=%"><pre id="&lt;=%,Rune,Rune" data-language="nim">proc `&lt;=%`(a, b: Rune): bool {.raises: [], tags: [].}</pre></dt>  <dt id="&lt;%"><pre id="&lt;%,Rune,Rune" data-language="nim">proc `&lt;%`(a, b: Rune): bool {.raises: [], tags: [].}</pre></dt>  <dt id="=="><pre id="==,Rune,Rune" data-language="nim">proc `==`(a, b: Rune): bool {.raises: [], tags: [].}</pre></dt>  <dt id="runeLen"><pre id="runeLen,string" data-language="nim">proc runeLen(s: string): int {.gcsafe, extern: "nuc$1", raises: [], tags: [].}</pre></dt> <dd> Returns the number of Unicode characters of the string <code>s</code>   </dd> <dt id="runeLenAt"><pre id="runeLenAt,string,Natural" data-language="nim">proc runeLenAt(s: string; i: Natural): int {.raises: [], tags: [].}</pre></dt> <dd> Returns the number of bytes the rune starting at <code>s[i]</code> takes   </dd> <dt id="validateUtf8"><pre id="validateUtf8,string" data-language="nim">proc validateUtf8(s: string): int {.raises: [], tags: [].}</pre></dt> <dd> Returns the position of the invalid byte in <code>s</code> if the string <code>s</code> does not hold valid UTF-8 data. Otherwise <code>-1</code> is returned.   </dd> <dt id="runeAt"><pre id="runeAt,string,Natural" data-language="nim">proc runeAt(s: string; i: Natural): Rune {.raises: [], tags: [].}</pre></dt> <dd> Returns the unicode character in <code>s</code> at byte index <code>i</code>   </dd> <dt id="toUTF8"><pre id="toUTF8,Rune" data-language="nim">proc toUTF8(c: Rune): string {.gcsafe, extern: "nuc$1", raises: [], tags: [].}</pre></dt> <dd> Converts a rune into its UTF-8 representation   </dd> <dt id="$"><pre id="$,Rune" data-language="nim">proc `$`(rune: Rune): string {.raises: [], tags: [].}</pre></dt> <dd> Converts a Rune to a string   </dd> <dt id="$"><pre id="$,seq[Rune]" data-language="nim">proc `$`(runes: seq[Rune]): string {.raises: [], tags: [].}</pre></dt> <dd> Converts a sequence of Runes to a string   </dd> <dt id="runeOffset"><pre id="runeOffset,string,Natural,Natural" data-language="nim">proc runeOffset(s: string; pos: Natural; start: Natural = 0): int {.raises: [], tags: [].}</pre></dt> <dd> <p>Returns the byte position of unicode character at position pos in s with an optional start byte position. returns the special value -1 if it runs out of the string</p> <p>Beware: This can lead to unoptimized code and slow execution! Most problems are solve more efficient by using an iterator or conversion to a seq of Rune.</p>   </dd> <dt id="runeAtPos"><pre id="runeAtPos,string,int" data-language="nim">proc runeAtPos(s: string; pos: int): Rune {.raises: [], tags: [].}</pre></dt> <dd> <p>Returns the unicode character at position pos</p> <p>Beware: This can lead to unoptimized code and slow execution! Most problems are solve more efficient by using an iterator or conversion to a seq of Rune.</p>   </dd> <dt id="runeStrAtPos"><pre id="runeStrAtPos,string,Natural" data-language="nim">proc runeStrAtPos(s: string; pos: Natural): string {.raises: [], tags: [].}</pre></dt> <dd> <p>Returns the unicode character at position pos as UTF8 String</p> <p>Beware: This can lead to unoptimized code and slow execution! Most problems are solve more efficient by using an iterator or conversion to a seq of Rune.</p>   </dd> <dt id="runeReverseOffset"><pre id="runeReverseOffset,string,Positive" data-language="nim">proc runeReverseOffset(s: string; rev: Positive): (int, int) {.raises: [], tags: [].}</pre></dt> <dd> <p>Returns a tuple with the the byte offset of the unicode character at position <code>rev</code> in s counting from the end (starting with 1) and the total number of runes in the string. Returns a negative value for offset if there are to few runes in the string to satisfy the request.</p> <p>Beware: This can lead to unoptimized code and slow execution! Most problems are solve more efficient by using an iterator or conversion to a seq of Rune.</p>   </dd> <dt id="runeSubStr"><pre id="runeSubStr,string,int,int" data-language="nim">proc runeSubStr(s: string; pos: int; len: int = int.high): string {.raises: [], tags: [].}</pre></dt> <dd> <p>Returns the UTF-8 substring starting at codepoint pos with len codepoints. If pos or len is negativ they count from the end of the string. If len is not given it means the longest possible string.</p> <p>(Needs some examples)</p>   </dd> <dt id="toLower"><pre id="toLower,Rune" data-language="nim">proc toLower(c: Rune): Rune {.gcsafe, extern: "nuc$1", procvar, raises: [], tags: [].}</pre></dt> <dd> Converts <code>c</code> into lower case. This works for any Unicode character. If possible, prefer <code>toLower</code> over <code>toUpper</code>.   </dd> <dt id="toUpper"><pre id="toUpper,Rune" data-language="nim">proc toUpper(c: Rune): Rune {.gcsafe, extern: "nuc$1", procvar, raises: [], tags: [].}</pre></dt> <dd> Converts <code>c</code> into upper case. This works for any Unicode character. If possible, prefer <code>toLower</code> over <code>toUpper</code>.   </dd> <dt id="toTitle"><pre id="toTitle,Rune" data-language="nim">proc toTitle(c: Rune): Rune {.gcsafe, extern: "nuc$1", procvar, raises: [], tags: [].}</pre></dt> <dd> Converts <code>c</code> to title case   </dd> <dt id="isLower"><pre id="isLower,Rune" data-language="nim">proc isLower(c: Rune): bool {.gcsafe, extern: "nuc$1", procvar, raises: [], tags: [].}</pre></dt> <dd> Returns true iff <code>c</code> is a lower case Unicode character. If possible, prefer <code>isLower</code> over <code>isUpper</code>.   </dd> <dt id="isUpper"><pre id="isUpper,Rune" data-language="nim">proc isUpper(c: Rune): bool {.gcsafe, extern: "nuc$1", procvar, raises: [], tags: [].}</pre></dt> <dd> Returns true iff <code>c</code> is a upper case Unicode character. If possible, prefer <code>isLower</code> over <code>isUpper</code>.   </dd> <dt id="isAlpha"><pre id="isAlpha,Rune" data-language="nim">proc isAlpha(c: Rune): bool {.gcsafe, extern: "nuc$1", procvar, raises: [], tags: [].}</pre></dt> <dd> Returns true iff <code>c</code> is an <em>alpha</em> Unicode character (i.e., a letter)   </dd> <dt id="isTitle"><pre id="isTitle,Rune" data-language="nim">proc isTitle(c: Rune): bool {.gcsafe, extern: "nuc$1", procvar, raises: [], tags: [].}</pre></dt> <dd> Returns true iff <code>c</code> is a Unicode titlecase character   </dd> <dt id="isWhiteSpace"><pre id="isWhiteSpace,Rune" data-language="nim">proc isWhiteSpace(c: Rune): bool {.gcsafe, extern: "nuc$1", procvar, raises: [], tags: [].}</pre></dt> <dd> Returns true iff <code>c</code> is a Unicode whitespace character   </dd> <dt id="isCombining"><pre id="isCombining,Rune" data-language="nim">proc isCombining(c: Rune): bool {.gcsafe, extern: "nuc$1", procvar, raises: [], tags: [].}</pre></dt> <dd> Returns true iff <code>c</code> is a Unicode combining character   </dd> <dt id="isUpper"><pre id="isUpper,string" data-language="nim">proc isUpper(s: string): bool {.noSideEffect, procvar, gcsafe, extern: "nuc$1Str",
                            raises: [], tags: [].}</pre></dt> <dd> Returns true iff <em>s</em> contains all upper case unicode characters.   </dd> <dt id="isLower"><pre id="isLower,string" data-language="nim">proc isLower(s: string): bool {.noSideEffect, procvar, gcsafe, extern: "nuc$1Str",
                            raises: [], tags: [].}</pre></dt> <dd> Returns true iff <em>s</em> contains all lower case unicode characters.   </dd> <dt id="isAlpha"><pre id="isAlpha,string" data-language="nim">proc isAlpha(s: string): bool {.noSideEffect, procvar, gcsafe, extern: "nuc$1Str",
                            raises: [], tags: [].}</pre></dt> <dd> Returns true iff <em>s</em> contains all alphabetic unicode characters.   </dd> <dt id="isSpace"><pre id="isSpace,string" data-language="nim">proc isSpace(s: string): bool {.noSideEffect, procvar, gcsafe, extern: "nuc$1Str",
                            raises: [], tags: [].}</pre></dt> <dd> Returns true iff <em>s</em> contains all whitespace unicode characters.   </dd> <dt id="toUpper"><pre id="toUpper,string" data-language="nim">proc toUpper(s: string): string {.noSideEffect, procvar, gcsafe, extern: "nuc$1Str",
                              raises: [], tags: [].}</pre></dt> <dd> Converts <em>s</em> into upper-case unicode characters.   </dd> <dt id="toLower"><pre id="toLower,string" data-language="nim">proc toLower(s: string): string {.noSideEffect, procvar, gcsafe, extern: "nuc$1Str",
                              raises: [], tags: [].}</pre></dt> <dd> Converts <em>s</em> into lower-case unicode characters.   </dd> <dt id="swapCase"><pre id="swapCase,string" data-language="nim">proc swapCase(s: string): string {.noSideEffect, procvar, gcsafe, extern: "nuc$1",
                               raises: [], tags: [].}</pre></dt> <dd> <p>Swaps the case of unicode characters in <em>s</em></p> <p>Returns a new string such that the cases of all unicode characters are swapped if possible</p>   </dd> <dt id="capitalize"><pre id="capitalize,string" data-language="nim">proc capitalize(s: string): string {.noSideEffect, procvar, gcsafe, extern: "nuc$1",
                                 raises: [], tags: [].}</pre></dt> <dd> Converts the first character of <em>s</em> into an upper-case unicode character.   </dd> <dt id="translate"><pre id="translate,string,proc(string)" data-language="nim">proc translate(s: string; replacements: proc (key: string): string): string {.gcsafe,
    extern: "nuc$1", raises: [], tags: [].}</pre></dt> <dd> <p>Translates words in a string using the <em>replacements</em> proc to substitute words inside <em>s</em> with their replacements</p> <p><em>replacements</em> is any proc that takes a word and returns a new word to fill it's place.</p>   </dd> <dt id="title"><pre id="title,string" data-language="nim">proc title(s: string): string {.noSideEffect, procvar, gcsafe, extern: "nuc$1",
                            raises: [], tags: [].}</pre></dt> <dd> <p>Converts <em>s</em> to a unicode title.</p> <p>Returns a new string such that the first character in each word inside <em>s</em> is capitalized</p>   </dd> <dt id="isTitle"><pre id="isTitle,string" data-language="nim">proc isTitle(s: string): bool {.noSideEffect, procvar, gcsafe, extern: "nuc$1Str",
                            raises: [], tags: [].}</pre></dt> <dd> <p>Checks whether or not <em>s</em> is a unicode title.</p> <p>Returns true if the first character in each word inside <em>s</em> are upper case and there is at least one character in <em>s</em>.</p>   </dd> <dt id="toRunes"><pre id="toRunes,string" data-language="nim">proc toRunes(s: string): seq[Rune] {.raises: [], tags: [].}</pre></dt> <dd> Obtains a sequence containing the Runes in <code>s</code>   </dd> <dt id="cmpRunesIgnoreCase"><pre id="cmpRunesIgnoreCase,string,string" data-language="nim">proc cmpRunesIgnoreCase(a, b: string): int {.gcsafe, extern: "nuc$1", procvar,
                                        raises: [], tags: [].}</pre></dt> <dd> Compares two UTF-8 strings and ignores the case. Returns:<p>0 iff a == b<br>&lt; 0 iff a &lt; b<br>&gt; 0 iff a &gt; b<br></p>   </dd> <dt id="reversed"><pre id="reversed,string" data-language="nim">proc reversed(s: string): string {.raises: [], tags: [].}</pre></dt> <dd> Returns the reverse of <code>s</code>, interpreting it as Unicode characters. Unicode combining characters are correctly interpreted as well:<pre class="listing" data-language="nim">assert reversed("Reverse this!") == "!siht esreveR"
assert reversed("先秦兩漢") == "漢兩秦先"
assert reversed("as⃝df̅") == "f̅ds⃝a"
assert reversed("a⃞b⃞c⃞") == "c⃞b⃞a⃞"</pre>   </dd> <dt id="graphemeLen"><pre id="graphemeLen,string,Natural" data-language="nim">proc graphemeLen(s: string; i: Natural): Natural {.raises: [], tags: [].}</pre></dt> <dd> The number of bytes belonging to 's[i]' including following combining characters.   </dd> <dt id="lastRune"><pre id="lastRune,string,int" data-language="nim">proc lastRune(s: string; last: int): (Rune, int) {.raises: [], tags: [].}</pre></dt> <dd> length of the last rune in 's[0..last]'. Returns the rune and its length in bytes.   </dd> </dl>  <h2 id="14">Iterators</h2> <dl> <dt id="runes"><pre id="runes.i,string" data-language="nim">iterator runes(s: string): Rune {.raises: [], tags: [].}</pre></dt> <dd> Iterates over any unicode character of the string <code>s</code> returning runes   </dd> <dt id="utf8"><pre id="utf8.i,string" data-language="nim">iterator utf8(s: string): string {.raises: [], tags: [].}</pre></dt> <dd> Iterates over any unicode character of the string <code>s</code> returning utf8 values   </dd> </dl>  <h2 id="17">Templates</h2> <dl> <dt id="fastRuneAt"><pre id="fastRuneAt.t,string,int,untyped" data-language="nim">template fastRuneAt(s: string; i: int; result: untyped; doInc = true)</pre></dt> <dd> Returns the Unicode character <code>s[i]</code> in <code>result</code>. If <code>doInc == true</code> <code>i</code> is incremented by the number of bytes that have been processed.   </dd> <dt id="fastToUTF8Copy"><pre id="fastToUTF8Copy.t,Rune,string,int" data-language="nim">template fastToUTF8Copy(c: Rune; s: var string; pos: int; doInc = true)</pre></dt> <dd> <p>Copies UTF-8 representation of <em>c</em> into the preallocated string <em>s</em> starting at position <em>pos</em>. If <em>doInc == true</em>, <em>pos</em> is incremented by the number of bytes that have been processed.</p> <p>To be the most efficient, make sure <em>s</em> is preallocated with an additional amount equal to the byte length of <em>c</em>.</p>   </dd> </dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 2006–2017 Andreas Rumpf<br>Licensed under the MIT License.<br>
    <a href="https://nim-lang.org/docs/unicode.html" class="_attribution-link" target="_blank">https://nim-lang.org/docs/unicode.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
