
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Strutils - Nim - W3cubDocs</title>
  
  <meta name="description" content="This module contains various string utility routines. See the module re for regular expression support. See the module pegs for PEG support. This &hellip;">
  <meta name="keywords" content="module, strutils, -, nim">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/nim/strutils/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-e0f881b0fce8cbe96f33dadc355b7159d5d2912911231446d60eb8f9caffa802.css">
  <script type="text/javascript" src="/assets/application-8fc46316434047265cd383f02b8e7f434ed7dec4a59f920dd633deef8d488d1b.js"></script>
  <script src="/json/nim.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/nim/" class="_nav-link" title="" style="margin-left:0;">Nim</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _nim">
				
<h1 class="title">Module strutils</h1>  <p class="module-desc">This module contains various string utility routines. See the module <a href="../re/">re</a> for regular expression support. See the module <a href="../pegs/">pegs</a> for PEG support. This module is available for the <a href="../backends/#the-javascript-target">JavaScript target</a>.</p>  <h2 id="6">Imports</h2> <dl> <a href="../parseutils/">parseutils</a>, <a href="../math/">math</a>, <a href="../algorithm/">algorithm</a> </dl>  <h2 id="7">Types</h2> <dl> <dt id="CharSet"><pre id="CharSet" data-language="nim">CharSet = set[char]</pre></dt>  <dt id="FloatFormatMode"><pre id="FloatFormatMode" data-language="nim">FloatFormatMode = enum
  ffDefault,                  ## use the shorter floating point notation
  ffDecimal,                  ## use decimal floating point notation
  ffScientific                ## use scientific notation (using ``e`` character)</pre></dt> <dd> the different modes of floating point formating   </dd> <dt id="BinaryPrefixMode"><pre id="BinaryPrefixMode" data-language="nim">BinaryPrefixMode = enum
  bpIEC, bpColloquial</pre></dt> <dd> the different names for binary prefixes   </dd> </dl>  <h2 id="10">Consts</h2> <dl> <dt id="Whitespace"><pre id="Whitespace" data-language="nim">Whitespace = {' ', '\x09', '\x0B', '\x0D', '\x0A', '\x0C'}</pre></dt> <dd> All the characters that count as whitespace.   </dd> <dt id="Letters"><pre id="Letters" data-language="nim">Letters = {'A'..'Z', 'a'..'z'}</pre></dt> <dd> the set of letters   </dd> <dt id="Digits"><pre id="Digits" data-language="nim">Digits = {'0'..'9'}</pre></dt> <dd> the set of digits   </dd> <dt id="HexDigits"><pre id="HexDigits" data-language="nim">HexDigits = {'0'..'9', 'A'..'F', 'a'..'f'}</pre></dt> <dd> the set of hexadecimal digits   </dd> <dt id="IdentChars"><pre id="IdentChars" data-language="nim">IdentChars = {'a'..'z', 'A'..'Z', '0'..'9', '_'}</pre></dt> <dd> the set of characters an identifier can consist of   </dd> <dt id="IdentStartChars"><pre id="IdentStartChars" data-language="nim">IdentStartChars = {'a'..'z', 'A'..'Z', '_'}</pre></dt> <dd> the set of characters an identifier can start with   </dd> <dt id="NewLines"><pre id="NewLines" data-language="nim">NewLines = {'\x0D', '\x0A'}</pre></dt> <dd> the set of characters a newline terminator can start with   </dd> <dt id="AllChars"><pre id="AllChars" data-language="nim">AllChars = {'\0'..'\xFF'}</pre></dt> <dd> <p>A set with all the possible characters.</p> <p>Not very useful by its own, you can use it to create <em>inverted</em> sets to make the <a href="#find,string,set%5Bchar%5D,int">find() proc</a> find <strong>invalid</strong> characters in strings. Example:</p> <pre class="listing" data-language="nim">let invalid = AllChars - Digits
doAssert "01234".find(invalid) == -1
doAssert "01A34".find(invalid) == 2</pre>   </dd> </dl>  <h2 id="12">Procs</h2> <dl> <dt id="isAlphaAscii"><pre id="isAlphaAscii,char" data-language="nim">proc isAlphaAscii(c: char): bool {.noSideEffect, procvar, gcsafe,
                               extern: "nsuIsAlphaAsciiChar", raises: [], tags: [].}</pre></dt> <dd> <p>Checks whether or not <em>c</em> is alphabetical.</p> <p>This checks a-z, A-Z ASCII characters only.</p>   </dd> <dt id="isAlphaNumeric"><pre id="isAlphaNumeric,char" data-language="nim">proc isAlphaNumeric(c: char): bool {.noSideEffect, procvar, gcsafe,
                                 extern: "nsuIsAlphaNumericChar", raises: [],
                                 tags: [].}</pre></dt> <dd> <p>Checks whether or not <em>c</em> is alphanumeric.</p> <p>This checks a-z, A-Z, 0-9 ASCII characters only.</p>   </dd> <dt id="isDigit"><pre id="isDigit,char" data-language="nim">proc isDigit(c: char): bool {.noSideEffect, procvar, gcsafe, extern: "nsuIsDigitChar",
                          raises: [], tags: [].}</pre></dt> <dd> <p>Checks whether or not <em>c</em> is a number.</p> <p>This checks 0-9 ASCII characters only.</p>   </dd> <dt id="isSpaceAscii"><pre id="isSpaceAscii,char" data-language="nim">proc isSpaceAscii(c: char): bool {.noSideEffect, procvar, gcsafe,
                               extern: "nsuIsSpaceAsciiChar", raises: [], tags: [].}</pre></dt> <dd> Checks whether or not <em>c</em> is a whitespace character.   </dd> <dt id="isLowerAscii"><pre id="isLowerAscii,char" data-language="nim">proc isLowerAscii(c: char): bool {.noSideEffect, procvar, gcsafe,
                               extern: "nsuIsLowerAsciiChar", raises: [], tags: [].}</pre></dt> <dd> <p>Checks whether or not <em>c</em> is a lower case character.</p> <p>This checks ASCII characters only.</p>   </dd> <dt id="isUpperAscii"><pre id="isUpperAscii,char" data-language="nim">proc isUpperAscii(c: char): bool {.noSideEffect, procvar, gcsafe,
                               extern: "nsuIsUpperAsciiChar", raises: [], tags: [].}</pre></dt> <dd> <p>Checks whether or not <em>c</em> is an upper case character.</p> <p>This checks ASCII characters only.</p>   </dd> <dt id="isAlphaAscii"><pre id="isAlphaAscii,string" data-language="nim">proc isAlphaAscii(s: string): bool {.noSideEffect, procvar, gcsafe,
                                 extern: "nsuIsAlphaAsciiStr", raises: [], tags: [].}</pre></dt> <dd> <p>Checks whether or not <em>s</em> is alphabetical.</p> <p>This checks a-z, A-Z ASCII characters only. Returns true if all characters in <em>s</em> are alphabetic and there is at least one character in <em>s</em>.</p>   </dd> <dt id="isAlphaNumeric"><pre id="isAlphaNumeric,string" data-language="nim">proc isAlphaNumeric(s: string): bool {.noSideEffect, procvar, gcsafe,
                                   extern: "nsuIsAlphaNumericStr", raises: [],
                                   tags: [].}</pre></dt> <dd> <p>Checks whether or not <em>s</em> is alphanumeric.</p> <p>This checks a-z, A-Z, 0-9 ASCII characters only. Returns true if all characters in <em>s</em> are alpanumeric and there is at least one character in <em>s</em>.</p>   </dd> <dt id="isDigit"><pre id="isDigit,string" data-language="nim">proc isDigit(s: string): bool {.noSideEffect, procvar, gcsafe, extern: "nsuIsDigitStr",
                            raises: [], tags: [].}</pre></dt> <dd> <p>Checks whether or not <em>s</em> is a numeric value.</p> <p>This checks 0-9 ASCII characters only. Returns true if all characters in <em>s</em> are numeric and there is at least one character in <em>s</em>.</p>   </dd> <dt id="isSpaceAscii"><pre id="isSpaceAscii,string" data-language="nim">proc isSpaceAscii(s: string): bool {.noSideEffect, procvar, gcsafe,
                                 extern: "nsuIsSpaceAsciiStr", raises: [], tags: [].}</pre></dt> <dd> <p>Checks whether or not <em>s</em> is completely whitespace.</p> <p>Returns true if all characters in <em>s</em> are whitespace characters and there is at least one character in <em>s</em>.</p>   </dd> <dt id="isLowerAscii"><pre id="isLowerAscii,string" data-language="nim">proc isLowerAscii(s: string): bool {.noSideEffect, procvar, gcsafe,
                                 extern: "nsuIsLowerAsciiStr", raises: [], tags: [].}</pre></dt> <dd> <p>Checks whether or not <em>s</em> contains all lower case characters.</p> <p>This checks ASCII characters only. Returns true if all characters in <em>s</em> are lower case and there is at least one character in <em>s</em>.</p>   </dd> <dt id="isUpperAscii"><pre id="isUpperAscii,string" data-language="nim">proc isUpperAscii(s: string): bool {.noSideEffect, procvar, gcsafe,
                                 extern: "nsuIsUpperAsciiStr", raises: [], tags: [].}</pre></dt> <dd> <p>Checks whether or not <em>s</em> contains all upper case characters.</p> <p>This checks ASCII characters only. Returns true if all characters in <em>s</em> are upper case and there is at least one character in <em>s</em>.</p>   </dd> <dt id="toLowerAscii"><pre id="toLowerAscii,char" data-language="nim">proc toLowerAscii(c: char): char {.noSideEffect, procvar, gcsafe,
                               extern: "nsuToLowerAsciiChar", raises: [], tags: [].}</pre></dt> <dd> <p>Converts <em>c</em> into lower case.</p> <p>This works only for the letters <code>A-Z</code>. See <a href="../unicode/#toLower">unicode.toLower</a> for a version that works for any Unicode character.</p>   </dd> <dt id="toLowerAscii"><pre id="toLowerAscii,string" data-language="nim">proc toLowerAscii(s: string): string {.noSideEffect, procvar, gcsafe,
                                   extern: "nsuToLowerAsciiStr", raises: [],
                                   tags: [].}</pre></dt> <dd> <p>Converts <em>s</em> into lower case.</p> <p>This works only for the letters <code>A-Z</code>. See <a href="../unicode/#toLower">unicode.toLower</a> for a version that works for any Unicode character.</p>   </dd> <dt id="toUpperAscii"><pre id="toUpperAscii,char" data-language="nim">proc toUpperAscii(c: char): char {.noSideEffect, procvar, gcsafe,
                               extern: "nsuToUpperAsciiChar", raises: [], tags: [].}</pre></dt> <dd> <p>Converts <em>c</em> into upper case.</p> <p>This works only for the letters <code>A-Z</code>. See <a href="../unicode/#toUpper">unicode.toUpper</a> for a version that works for any Unicode character.</p>   </dd> <dt id="toUpperAscii"><pre id="toUpperAscii,string" data-language="nim">proc toUpperAscii(s: string): string {.noSideEffect, procvar, gcsafe,
                                   extern: "nsuToUpperAsciiStr", raises: [],
                                   tags: [].}</pre></dt> <dd> <p>Converts <em>s</em> into upper case.</p> <p>This works only for the letters <code>A-Z</code>. See <a href="../unicode/#toUpper">unicode.toUpper</a> for a version that works for any Unicode character.</p>   </dd> <dt id="capitalizeAscii"><pre id="capitalizeAscii,string" data-language="nim">proc capitalizeAscii(s: string): string {.noSideEffect, procvar, gcsafe,
                                      extern: "nsuCapitalizeAscii", raises: [],
                                      tags: [].}</pre></dt> <dd> <p>Converts the first character of <em>s</em> into upper case.</p> <p>This works only for the letters <code>A-Z</code>.</p>   </dd> <dt id="isSpace"><pre id="isSpace,char" data-language="nim">proc isSpace(c: char): bool {.noSideEffect, procvar, gcsafe, deprecated,
                          extern: "nsuIsSpaceChar", raises: [], tags: [].}</pre></dt> <dd> <p>Checks whether or not <em>c</em> is a whitespace character.</p> <p><strong>Deprecated since version 0.15.0</strong>: use <code>isSpaceAscii</code> instead.</p>   </dd> <dt id="isLower"><pre id="isLower,char" data-language="nim">proc isLower(c: char): bool {.noSideEffect, procvar, gcsafe, deprecated,
                          extern: "nsuIsLowerChar", raises: [], tags: [].}</pre></dt> <dd> <p>Checks whether or not <em>c</em> is a lower case character.</p> <p>This checks ASCII characters only.</p> <p><strong>Deprecated since version 0.15.0</strong>: use <code>isLowerAscii</code> instead.</p>   </dd> <dt id="isUpper"><pre id="isUpper,char" data-language="nim">proc isUpper(c: char): bool {.noSideEffect, procvar, gcsafe, deprecated,
                          extern: "nsuIsUpperChar", raises: [], tags: [].}</pre></dt> <dd> <p>Checks whether or not <em>c</em> is an upper case character.</p> <p>This checks ASCII characters only.</p> <p><strong>Deprecated since version 0.15.0</strong>: use <code>isUpperAscii</code> instead.</p>   </dd> <dt id="isAlpha"><pre id="isAlpha,char" data-language="nim">proc isAlpha(c: char): bool {.noSideEffect, procvar, gcsafe, deprecated,
                          extern: "nsuIsAlphaChar", raises: [], tags: [].}</pre></dt> <dd> <p>Checks whether or not <em>c</em> is alphabetical.</p> <p>This checks a-z, A-Z ASCII characters only.</p> <p><strong>Deprecated since version 0.15.0</strong>: use <code>isAlphaAscii</code> instead.</p>   </dd> <dt id="isAlpha"><pre id="isAlpha,string" data-language="nim">proc isAlpha(s: string): bool {.noSideEffect, procvar, gcsafe, deprecated,
                            extern: "nsuIsAlphaStr", raises: [], tags: [].}</pre></dt> <dd> <p>Checks whether or not <em>s</em> is alphabetical.</p> <p>This checks a-z, A-Z ASCII characters only. Returns true if all characters in <em>s</em> are alphabetic and there is at least one character in <em>s</em>.</p> <p><strong>Deprecated since version 0.15.0</strong>: use <code>isAlphaAscii</code> instead.</p>   </dd> <dt id="isSpace"><pre id="isSpace,string" data-language="nim">proc isSpace(s: string): bool {.noSideEffect, procvar, gcsafe, deprecated,
                            extern: "nsuIsSpaceStr", raises: [], tags: [].}</pre></dt> <dd> <p>Checks whether or not <em>s</em> is completely whitespace.</p> <p>Returns true if all characters in <em>s</em> are whitespace characters and there is at least one character in <em>s</em>.</p> <p><strong>Deprecated since version 0.15.0</strong>: use <code>isSpaceAscii</code> instead.</p>   </dd> <dt id="isLower"><pre id="isLower,string" data-language="nim">proc isLower(s: string): bool {.noSideEffect, procvar, gcsafe, deprecated,
                            extern: "nsuIsLowerStr", raises: [], tags: [].}</pre></dt> <dd> <p>Checks whether or not <em>s</em> contains all lower case characters.</p> <p>This checks ASCII characters only. Returns true if all characters in <em>s</em> are lower case and there is at least one character in <em>s</em>.</p> <p><strong>Deprecated since version 0.15.0</strong>: use <code>isLowerAscii</code> instead.</p>   </dd> <dt id="isUpper"><pre id="isUpper,string" data-language="nim">proc isUpper(s: string): bool {.noSideEffect, procvar, gcsafe, deprecated,
                            extern: "nsuIsUpperStr", raises: [], tags: [].}</pre></dt> <dd> <p>Checks whether or not <em>s</em> contains all upper case characters.</p> <p>This checks ASCII characters only. Returns true if all characters in <em>s</em> are upper case and there is at least one character in <em>s</em>.</p> <p><strong>Deprecated since version 0.15.0</strong>: use <code>isUpperAscii</code> instead.</p>   </dd> <dt id="toLower"><pre id="toLower,char" data-language="nim">proc toLower(c: char): char {.noSideEffect, procvar, gcsafe, deprecated,
                          extern: "nsuToLowerChar", raises: [], tags: [].}</pre></dt> <dd> <p>Converts <em>c</em> into lower case.</p> <p>This works only for the letters <code>A-Z</code>. See <a href="../unicode/#toLower">unicode.toLower</a> for a version that works for any Unicode character.</p> <p><strong>Deprecated since version 0.15.0</strong>: use <code>toLowerAscii</code> instead.</p>   </dd> <dt id="toLower"><pre id="toLower,string" data-language="nim">proc toLower(s: string): string {.noSideEffect, procvar, gcsafe, deprecated,
                              extern: "nsuToLowerStr", raises: [], tags: [].}</pre></dt> <dd> <p>Converts <em>s</em> into lower case.</p> <p>This works only for the letters <code>A-Z</code>. See <a href="../unicode/#toLower">unicode.toLower</a> for a version that works for any Unicode character.</p> <p><strong>Deprecated since version 0.15.0</strong>: use <code>toLowerAscii</code> instead.</p>   </dd> <dt id="toUpper"><pre id="toUpper,char" data-language="nim">proc toUpper(c: char): char {.noSideEffect, procvar, gcsafe, deprecated,
                          extern: "nsuToUpperChar", raises: [], tags: [].}</pre></dt> <dd> <p>Converts <em>c</em> into upper case.</p> <p>This works only for the letters <code>A-Z</code>. See <a href="../unicode/#toUpper">unicode.toUpper</a> for a version that works for any Unicode character.</p> <p><strong>Deprecated since version 0.15.0</strong>: use <code>toUpperAscii</code> instead.</p>   </dd> <dt id="toUpper"><pre id="toUpper,string" data-language="nim">proc toUpper(s: string): string {.noSideEffect, procvar, gcsafe, deprecated,
                              extern: "nsuToUpperStr", raises: [], tags: [].}</pre></dt> <dd> <p>Converts <em>s</em> into upper case.</p> <p>This works only for the letters <code>A-Z</code>. See <a href="../unicode/#toUpper">unicode.toUpper</a> for a version that works for any Unicode character.</p> <p><strong>Deprecated since version 0.15.0</strong>: use <code>toUpperAscii</code> instead.</p>   </dd> <dt id="capitalize"><pre id="capitalize,string" data-language="nim">proc capitalize(s: string): string {.noSideEffect, procvar, gcsafe, deprecated,
                                 extern: "nsuCapitalize", raises: [], tags: [].}</pre></dt> <dd> <p>Converts the first character of <em>s</em> into upper case.</p> <p>This works only for the letters <code>A-Z</code>.</p> <p><strong>Deprecated since version 0.15.0</strong>: use <code>capitalizeAscii</code> instead.</p>   </dd> <dt id="normalize"><pre id="normalize,string" data-language="nim">proc normalize(s: string): string {.noSideEffect, procvar, gcsafe,
                                extern: "nsuNormalize", raises: [], tags: [].}</pre></dt> <dd> <p>Normalizes the string <em>s</em>.</p> <p>That means to convert it to lower case and remove any '_'. This is needed for Nim identifiers for example.</p>   </dd> <dt id="cmpIgnoreCase"><pre id="cmpIgnoreCase,string,string" data-language="nim">proc cmpIgnoreCase(a, b: string): int {.noSideEffect, gcsafe,
                                   extern: "nsuCmpIgnoreCase", procvar, raises: [],
                                   tags: [].}</pre></dt> <dd> Compares two strings in a case insensitive manner. Returns:<p>0 iff a == b<br>&lt; 0 iff a &lt; b<br>&gt; 0 iff a &gt; b<br></p>   </dd> <dt id="cmpIgnoreStyle"><pre id="cmpIgnoreStyle,string,string" data-language="nim">proc cmpIgnoreStyle(a, b: string): int {.noSideEffect, gcsafe,
                                    extern: "nsuCmpIgnoreStyle", procvar,
                                    raises: [], tags: [].}</pre></dt> <dd> Compares two strings normalized (i.e. case and underscores do not matter). Returns:<p>0 iff a == b<br>&lt; 0 iff a &lt; b<br>&gt; 0 iff a &gt; b<br></p>   </dd> <dt id="strip"><pre id="strip,string,set[char]" data-language="nim">proc strip(s: string; leading = true; trailing = true; chars: set[char] = Whitespace): string {.
    noSideEffect, gcsafe, extern: "nsuStrip", raises: [], tags: [].}</pre></dt> <dd> <p>Strips <em>chars</em> from <em>s</em> and returns the resulting string.</p> <p>If <em>leading</em> is true, leading <em>chars</em> are stripped. If <em>trailing</em> is true, trailing <em>chars</em> are stripped.</p>   </dd> <dt id="toOctal"><pre id="toOctal,char" data-language="nim">proc toOctal(c: char): string {.noSideEffect, gcsafe, extern: "nsuToOctal", raises: [],
                            tags: [].}</pre></dt> <dd> <p>Converts a character <em>c</em> to its octal representation.</p> <p>The resulting string may not have a leading zero. Its length is always exactly 3.</p>   </dd> <dt id="isNilOrEmpty"><pre id="isNilOrEmpty,string" data-language="nim">proc isNilOrEmpty(s: string): bool {.noSideEffect, procvar, gcsafe,
                                 extern: "nsuIsNilOrEmpty", raises: [], tags: [].}</pre></dt> <dd> Checks if <em>s</em> is nil or empty.   </dd> <dt id="isNilOrWhitespace"><pre id="isNilOrWhitespace,string" data-language="nim">proc isNilOrWhitespace(s: string): bool {.noSideEffect, procvar, gcsafe,
                                      extern: "nsuIsNilOrWhitespace", raises: [],
                                      tags: [].}</pre></dt> <dd> Checks if <em>s</em> is nil or consists entirely of whitespace characters.   </dd> <dt id="splitWhitespace"><pre id="splitWhitespace,string" data-language="nim">proc splitWhitespace(s: string): seq[string] {.noSideEffect, gcsafe,
    extern: "nsuSplitWhitespace", raises: [], tags: [].}</pre></dt> <dd> The same as the <a href="#splitWhitespace.i,string">splitWhitespace</a> iterator, but is a proc that returns a sequence of substrings.   </dd> <dt id="splitLines"><pre id="splitLines,string" data-language="nim">proc splitLines(s: string): seq[string] {.noSideEffect, gcsafe,
                                      extern: "nsuSplitLines", raises: [], tags: [].}</pre></dt> <dd> The same as the <a href="#splitLines.i,string">splitLines</a> iterator, but is a proc that returns a sequence of substrings.   </dd> <dt id="countLines"><pre id="countLines,string" data-language="nim">proc countLines(s: string): int {.noSideEffect, gcsafe, extern: "nsuCountLines",
                              raises: [], tags: [].}</pre></dt> <dd> <p>Returns the number of lines in the string <em>s</em>.</p> <p>This is the same as <code>len(splitLines(s))</code>, but much more efficient because it doesn't modify the string creating temporal objects. Every <a href="../manual/#character-literals">character literal</a> newline combination (CR, LF, CR-LF) is supported.</p> <p>In this context, a line is any string seperated by a newline combination. A line can be an empty string.</p>   </dd> <dt id="split"><pre id="split,string,set[char],int" data-language="nim">proc split(s: string; seps: set[char] = Whitespace; maxsplit: int = - 1): seq[string] {.
    noSideEffect, gcsafe, extern: "nsuSplitCharSet", raises: [], tags: [].}</pre></dt> <dd> The same as the <a href="#split.i,string,set%5Bchar%5D">split iterator</a>, but is a proc that returns a sequence of substrings.   </dd> <dt id="split"><pre id="split,string,char,int" data-language="nim">proc split(s: string; sep: char; maxsplit: int = - 1): seq[string] {.noSideEffect,
    gcsafe, extern: "nsuSplitChar", raises: [], tags: [].}</pre></dt> <dd> The same as the <a href="#split.i,string,char">split iterator</a>, but is a proc that returns a sequence of substrings.   </dd> <dt id="split"><pre id="split,string,string,int" data-language="nim">proc split(s: string; sep: string; maxsplit: int = - 1): seq[string] {.noSideEffect,
    gcsafe, extern: "nsuSplitString", raises: [AssertionError], tags: [].}</pre></dt> <dd> <p>Splits the string <em>s</em> into substrings using a string separator.</p> <p>Substrings are separated by the string <em>sep</em>. This is a wrapper around the <a href="#split.i,string,string">split iterator</a>.</p>   </dd> <dt id="rsplit"><pre id="rsplit,string,set[char],int" data-language="nim">proc rsplit(s: string; seps: set[char] = Whitespace; maxsplit: int = - 1): seq[string] {.
    noSideEffect, gcsafe, extern: "nsuRSplitCharSet", raises: [], tags: [].}</pre></dt> <dd> <p>The same as the <a href="#rsplit.i,string,set%5Bchar%5D">rsplit iterator</a>, but is a proc that returns a sequence of substrings.</p> <p>A possible common use case for <em>rsplit</em> is path manipulation, particularly on systems that don't use a common delimiter.</p> <p>For example, if a system had <em>#</em> as a delimiter, you could do the following to get the tail of the path:</p> <pre class="listing" data-language="nim">var tailSplit = rsplit("Root#Object#Method#Index", {'#'}, maxsplit=1)</pre>
<p>Results in <em>tailSplit</em> containing:</p> <pre class="listing" data-language="nim">@["Root#Object#Method", "Index"]</pre>   </dd> <dt id="rsplit"><pre id="rsplit,string,char,int" data-language="nim">proc rsplit(s: string; sep: char; maxsplit: int = - 1): seq[string] {.noSideEffect,
    gcsafe, extern: "nsuRSplitChar", raises: [], tags: [].}</pre></dt> <dd> <p>The same as the <a href="#rsplit.i,string,char">split iterator</a>, but is a proc that returns a sequence of substrings.</p> <p>A possible common use case for <em>rsplit</em> is path manipulation, particularly on systems that don't use a common delimiter.</p> <p>For example, if a system had <em>#</em> as a delimiter, you could do the following to get the tail of the path:</p> <pre class="listing" data-language="nim">var tailSplit = rsplit("Root#Object#Method#Index", '#', maxsplit=1)</pre>
<p>Results in <em>tailSplit</em> containing:</p> <pre class="listing" data-language="nim">@["Root#Object#Method", "Index"]</pre>   </dd> <dt id="rsplit"><pre id="rsplit,string,string,int" data-language="nim">proc rsplit(s: string; sep: string; maxsplit: int = - 1): seq[string] {.noSideEffect,
    gcsafe, extern: "nsuRSplitString", raises: [], tags: [].}</pre></dt> <dd> <p>The same as the <a href="#rsplit.i,string,string">split iterator</a>, but is a proc that returns a sequence of substrings.</p> <p>A possible common use case for <em>rsplit</em> is path manipulation, particularly on systems that don't use a common delimiter.</p> <p>For example, if a system had <em>#</em> as a delimiter, you could do the following to get the tail of the path:</p> <pre class="listing" data-language="nim">var tailSplit = rsplit("Root#Object#Method#Index", "#", maxsplit=1)</pre>
<p>Results in <em>tailSplit</em> containing:</p> <pre class="listing" data-language="nim">@["Root#Object#Method", "Index"]</pre>   </dd> <dt id="toHex"><pre id="toHex,BiggestInt,Positive" data-language="nim">proc toHex(x: BiggestInt; len: Positive): string {.noSideEffect, gcsafe,
    extern: "nsuToHex", raises: [], tags: [].}</pre></dt> <dd> <p>Converts <em>x</em> to its hexadecimal representation.</p> <p>The resulting string will be exactly <em>len</em> characters long. No prefix like <code>0x</code> is generated. <em>x</em> is treated as an unsigned value.</p>   </dd> <dt id="toHex"><pre id="toHex,T" data-language="nim">proc toHex[T](x: T): string</pre></dt> <dd> Shortcut for <code>toHex(x, T.sizeOf * 2)</code>   </dd> <dt id="intToStr"><pre id="intToStr,int,Positive" data-language="nim">proc intToStr(x: int; minchars: Positive = 1): string {.noSideEffect, gcsafe,
    extern: "nsuIntToStr", raises: [], tags: [].}</pre></dt> <dd> <p>Converts <em>x</em> to its decimal representation.</p> <p>The resulting string will be minimally <em>minchars</em> characters long. This is achieved by adding leading zeros.</p>   </dd> <dt id="parseInt"><pre id="parseInt,string" data-language="nim">proc parseInt(s: string): int {.noSideEffect, procvar, gcsafe, extern: "nsuParseInt",
                            raises: [OverflowError, ValueError], tags: [].}</pre></dt> <dd> <p>Parses a decimal integer value contained in <em>s</em>.</p> <p>If <em>s</em> is not a valid integer, <em>ValueError</em> is raised.</p>   </dd> <dt id="parseBiggestInt"><pre id="parseBiggestInt,string" data-language="nim">proc parseBiggestInt(s: string): BiggestInt {.noSideEffect, procvar, gcsafe,
    extern: "nsuParseBiggestInt", raises: [ValueError], tags: [].}</pre></dt> <dd> <p>Parses a decimal integer value contained in <em>s</em>.</p> <p>If <em>s</em> is not a valid integer, <em>ValueError</em> is raised.</p>   </dd> <dt id="parseUInt"><pre id="parseUInt,string" data-language="nim">proc parseUInt(s: string): uint {.noSideEffect, procvar, gcsafe,
                              extern: "nsuParseUInt", raises: [ValueError], tags: [].}</pre></dt> <dd> <p>Parses a decimal unsigned integer value contained in <em>s</em>.</p> <p>If <em>s</em> is not a valid integer, <em>ValueError</em> is raised.</p>   </dd> <dt id="parseBiggestUInt"><pre id="parseBiggestUInt,string" data-language="nim">proc parseBiggestUInt(s: string): BiggestUInt {.noSideEffect, procvar, gcsafe,
    extern: "nsuParseBiggestUInt", raises: [ValueError], tags: [].}</pre></dt> <dd> <p>Parses a decimal unsigned integer value contained in <em>s</em>.</p> <p>If <em>s</em> is not a valid integer, <em>ValueError</em> is raised.</p>   </dd> <dt id="parseFloat"><pre id="parseFloat,string" data-language="nim">proc parseFloat(s: string): float {.noSideEffect, procvar, gcsafe,
                                extern: "nsuParseFloat", raises: [ValueError],
                                tags: [].}</pre></dt> <dd> Parses a decimal floating point value contained in <em>s</em>. If <em>s</em> is not a valid floating point number, <em>ValueError</em> is raised. <code>NAN</code>, <code>INF</code>, <code>-INF</code> are also supported (case insensitive comparison).   </dd> <dt id="parseHexInt"><pre id="parseHexInt,string" data-language="nim">proc parseHexInt(s: string): int {.noSideEffect, procvar, gcsafe,
                               extern: "nsuParseHexInt", raises: [ValueError],
                               tags: [].}</pre></dt> <dd> <p>Parses a hexadecimal integer value contained in <em>s</em>.</p> <p>If <em>s</em> is not a valid integer, <em>ValueError</em> is raised. <em>s</em> can have one of the following optional prefixes: <code>0x</code>, <code>0X</code>, <code>#</code>. Underscores within <em>s</em> are ignored.</p>   </dd> <dt id="parseBool"><pre id="parseBool,string" data-language="nim">proc parseBool(s: string): bool {.raises: [ValueError], tags: [].}</pre></dt> <dd> <p>Parses a value into a <em>bool</em>.</p> <p>If <code>s</code> is one of the following values: <code>y, yes, true, 1, on</code>, then returns <em>true</em>. If <code>s</code> is one of the following values: <code>n, no, false, 0, off</code>, then returns <em>false</em>. If <code>s</code> is something else a <code>ValueError</code> exception is raised.</p>   </dd> <dt id="parseEnum"><pre id="parseEnum,string" data-language="nim">proc parseEnum[T: enum](s: string): T</pre></dt> <dd> <p>Parses an enum <code>T</code>.</p> <p>Raises <code>ValueError</code> for an invalid value in <em>s</em>. The comparison is done in a style insensitive way.</p>   </dd> <dt id="parseEnum"><pre id="parseEnum,string,T" data-language="nim">proc parseEnum[T: enum](s: string; default: T): T</pre></dt> <dd> <p>Parses an enum <code>T</code>.</p> <p>Uses <em>default</em> for an invalid value in <em>s</em>. The comparison is done in a style insensitive way.</p>   </dd> <dt id="repeat"><pre id="repeat,char,Natural" data-language="nim">proc repeat(c: char; count: Natural): string {.noSideEffect, gcsafe,
    extern: "nsuRepeatChar", raises: [], tags: [].}</pre></dt> <dd> Returns a string of length <em>count</em> consisting only of the character <em>c</em>. You can use this proc to left align strings. Example:<pre class="listing" data-language="nim">proc tabexpand(indent: int, text: string, tabsize: int = 4) =
  echo '\t'.repeat(indent div tabsize), ' '.repeat(indent mod tabsize),
      text

tabexpand(4, "At four")
tabexpand(5, "At five")
tabexpand(6, "At six")</pre>   </dd> <dt id="repeat"><pre id="repeat,string,Natural" data-language="nim">proc repeat(s: string; n: Natural): string {.noSideEffect, gcsafe,
                                       extern: "nsuRepeatStr", raises: [], tags: [].}</pre></dt> <dd> Returns String <em>s</em> concatenated <em>n</em> times. Example:<pre class="listing" data-language="nim">echo "+++ STOP ".repeat(4), "+++"</pre>   </dd> <dt id="repeatChar"><pre id="repeatChar,Natural,char" data-language="nim">proc repeatChar(count: Natural; c: char = ' '): string {.deprecated, raises: [], tags: [].}</pre></dt> <dd> deprecated: use repeat() or spaces()   </dd> <dt id="repeatStr"><pre id="repeatStr,Natural,string" data-language="nim">proc repeatStr(count: Natural; s: string): string {.deprecated, raises: [], tags: [].}</pre></dt> <dd> deprecated: use repeat(string, count) or string.repeat(count)   </dd> <dt id="align"><pre id="align,string,Natural,Char" data-language="nim">proc align(s: string; count: Natural; padding = ' '): string {.noSideEffect, gcsafe,
    extern: "nsuAlignString", raises: [], tags: [].}</pre></dt> <dd> <p>Aligns a string <em>s</em> with <em>padding</em>, so that it is of length <em>count</em>.</p> <p><em>padding</em> characters (by default spaces) are added before <em>s</em> resulting in right alignment. If <code>s.len &gt;= count</code>, no spaces are added and <em>s</em> is returned unchanged. If you need to left align a string use the <a href="#repeatChar">repeatChar proc</a>. Example:</p> <pre class="listing" data-language="nim">assert align("abc", 4) == " abc"
assert align("a", 0) == "a"
assert align("1232", 6) == "  1232"
assert align("1232", 6, '#') == "##1232"</pre>   </dd> <dt id="wordWrap"><pre id="wordWrap,string,int,set[char],string" data-language="nim">proc wordWrap(s: string; maxLineWidth = 80; splitLongWords = true;
             seps: set[char] = Whitespace; newLine = "\x0D\x0A"): string {.noSideEffect,
    gcsafe, extern: "nsuWordWrap", raises: [], tags: [].}</pre></dt> <dd> Word wraps <em>s</em>.   </dd> <dt id="indent"><pre id="indent,string,Natural,string" data-language="nim">proc indent(s: string; count: Natural; padding: string = " "): string {.noSideEffect,
    gcsafe, extern: "nsuIndent", raises: [], tags: [].}</pre></dt> <dd> <p>Indents each line in <code>s</code> by <code>count</code> amount of <code>padding</code>.</p> <p><strong>Note:</strong> This does not preserve the new line characters used in <code>s</code>.</p>   </dd> <dt id="unindent"><pre id="unindent,string,Natural,string" data-language="nim">proc unindent(s: string; count: Natural; padding: string = " "): string {.noSideEffect,
    gcsafe, extern: "nsuUnindent", raises: [], tags: [].}</pre></dt> <dd> <p>Unindents each line in <code>s</code> by <code>count</code> amount of <code>padding</code>.</p> <p><strong>Note:</strong> This does not preserve the new line characters used in <code>s</code>.</p>   </dd> <dt id="unindent"><pre id="unindent,string" data-language="nim">proc unindent(s: string): string {.noSideEffect, gcsafe, extern: "nsuUnindentAll",
                               raises: [], tags: [].}</pre></dt> <dd> <p>Removes all indentation composed of whitespace from each line in <code>s</code>.</p> <p>For example:</p> <pre class="listing" data-language="nim">const x = """
  Hello
  There
""".unindent()

doAssert x == "Hello\nThere\n"</pre>   </dd> <dt id="startsWith"><pre id="startsWith,string,string" data-language="nim">proc startsWith(s, prefix: string): bool {.noSideEffect, gcsafe,
                                      extern: "nsuStartsWith", raises: [], tags: [].}</pre></dt> <dd> <p>Returns true iff <code>s</code> starts with <code>prefix</code>.</p> <p>If <code>prefix == ""</code> true is returned.</p>   </dd> <dt id="startsWith"><pre id="startsWith,string,char" data-language="nim">proc startsWith(s: string; prefix: char): bool {.noSideEffect, inline, raises: [],
    tags: [].}</pre></dt> <dd> Returns true iff <code>s</code> starts with <code>prefix</code>.   </dd> <dt id="endsWith"><pre id="endsWith,string,string" data-language="nim">proc endsWith(s, suffix: string): bool {.noSideEffect, gcsafe, extern: "nsuEndsWith",
                                    raises: [], tags: [].}</pre></dt> <dd> <p>Returns true iff <code>s</code> ends with <code>suffix</code>.</p> <p>If <code>suffix == ""</code> true is returned.</p>   </dd> <dt id="endsWith"><pre id="endsWith,string,char" data-language="nim">proc endsWith(s: string; suffix: char): bool {.noSideEffect, inline, raises: [], tags: [].}</pre></dt> <dd> Returns true iff <code>s</code> ends with <code>suffix</code>.   </dd> <dt id="continuesWith"><pre id="continuesWith,string,string,Natural" data-language="nim">proc continuesWith(s, substr: string; start: Natural): bool {.noSideEffect, gcsafe,
    extern: "nsuContinuesWith", raises: [], tags: [].}</pre></dt> <dd> <p>Returns true iff <code>s</code> continues with <code>substr</code> at position <code>start</code>.</p> <p>If <code>substr == ""</code> true is returned.</p>   </dd> <dt id="addSep"><pre id="addSep,string,string,Natural" data-language="nim">proc addSep(dest: var string; sep = ", "; startLen: Natural = 0) {.noSideEffect, inline,
    raises: [], tags: [].}</pre></dt> <dd> <p>Adds a separator to <em>dest</em> only if its length is bigger than <em>startLen</em>.</p> <p>A shorthand for:</p> <pre class="listing" data-language="nim">if dest.len &gt; startLen: add(dest, sep)</pre>
<p>This is often useful for generating some code where the items need to be <em>separated</em> by <em>sep</em>. <em>sep</em> is only added if <em>dest</em> is longer than <em>startLen</em>. The following example creates a string describing an array of integers:</p> <pre class="listing" data-language="nim">var arr = "["
for x in items([2, 3, 5, 7, 11]):
  addSep(arr, startLen=len("["))
  add(arr, $x)
add(arr, "]")</pre>   </dd> <dt id="allCharsInSet"><pre id="allCharsInSet,string,set[char]" data-language="nim">proc allCharsInSet(s: string; theSet: set[char]): bool {.raises: [], tags: [].}</pre></dt> <dd> Returns true iff each character of <em>s</em> is in the set <em>theSet</em>.   </dd> <dt id="abbrev"><pre id="abbrev,string,openArray[string]" data-language="nim">proc abbrev(s: string; possibilities: openArray[string]): int {.raises: [], tags: [].}</pre></dt> <dd> <p>Returns the index of the first item in <em>possibilities</em> if not ambiguous.</p> <p>Returns -1 if no item has been found and -2 if multiple items match.</p>   </dd> <dt id="join"><pre id="join,openArray[string],string" data-language="nim">proc join(a: openArray[string]; sep: string = ""): string {.noSideEffect, gcsafe,
    extern: "nsuJoinSep", raises: [], tags: [].}</pre></dt> <dd> Concatenates all strings in <em>a</em> separating them with <em>sep</em>.   </dd> <dt id="join"><pre id="join,openArray[T],string" data-language="nim">proc join[T: not string](a: openArray[T]; sep: string = ""): string {.noSideEffect,
    gcsafe.}</pre></dt> <dd> Converts all elements in <em>a</em> to strings using <em>$</em> and concatenates them with <em>sep</em>.   </dd> <dt id="find"><pre id="find,string,string,Natural,Natural" data-language="nim">proc find(s, sub: string; start: Natural = 0; last: Natural = 0): int {.noSideEffect,
    gcsafe, extern: "nsuFindStr", raises: [], tags: [].}</pre></dt> <dd> <p>Searches for <em>sub</em> in <em>s</em> inside range <em>start</em>..`last`. If <em>last</em> is unspecified, it defaults to <em>s.high</em>.</p> <p>Searching is case-sensitive. If <em>sub</em> is not in <em>s</em>, -1 is returned.</p>   </dd> <dt id="find"><pre id="find,string,char,Natural,Natural" data-language="nim">proc find(s: string; sub: char; start: Natural = 0; last: Natural = 0): int {.noSideEffect,
    gcsafe, extern: "nsuFindChar", raises: [], tags: [].}</pre></dt> <dd> <p>Searches for <em>sub</em> in <em>s</em> inside range <em>start</em>..`last`. If <em>last</em> is unspecified, it defaults to <em>s.high</em>.</p> <p>Searching is case-sensitive. If <em>sub</em> is not in <em>s</em>, -1 is returned.</p>   </dd> <dt id="find"><pre id="find,string,set[char],Natural,Natural" data-language="nim">proc find(s: string; chars: set[char]; start: Natural = 0; last: Natural = 0): int {.
    noSideEffect, gcsafe, extern: "nsuFindCharSet", raises: [], tags: [].}</pre></dt> <dd> <p>Searches for <em>chars</em> in <em>s</em> inside range <em>start</em>..`last`. If <em>last</em> is unspecified, it defaults to <em>s.high</em>.</p> <p>If <em>s</em> contains none of the characters in <em>chars</em>, -1 is returned.</p>   </dd> <dt id="rfind"><pre id="rfind,string,string,int" data-language="nim">proc rfind(s, sub: string; start: int = - 1): int {.noSideEffect, raises: [], tags: [].}</pre></dt> <dd> <p>Searches for <em>sub</em> in <em>s</em> in reverse, starting at <em>start</em> and going backwards to 0.</p> <p>Searching is case-sensitive. If <em>sub</em> is not in <em>s</em>, -1 is returned.</p>   </dd> <dt id="rfind"><pre id="rfind,string,char,int" data-language="nim">proc rfind(s: string; sub: char; start: int = - 1): int {.noSideEffect, gcsafe, raises: [],
    tags: [].}</pre></dt> <dd> <p>Searches for <em>sub</em> in <em>s</em> in reverse starting at position <em>start</em>.</p> <p>Searching is case-sensitive. If <em>sub</em> is not in <em>s</em>, -1 is returned.</p>   </dd> <dt id="rfind"><pre id="rfind,string,set[char],int" data-language="nim">proc rfind(s: string; chars: set[char]; start: int = - 1): int {.noSideEffect, raises: [],
    tags: [].}</pre></dt> <dd> <p>Searches for <em>chars</em> in <em>s</em> in reverse starting at position <em>start</em>.</p> <p>Searching is case-sensitive. If <em>sub</em> is not in <em>s</em>, -1 is returned.</p>   </dd> <dt id="center"><pre id="center,string,int,char" data-language="nim">proc center(s: string; width: int; fillChar: char = ' '): string {.noSideEffect,
    gcsafe, extern: "nsuCenterString", raises: [], tags: [].}</pre></dt> <dd> <p>Return the contents of <em>s</em> centered in a string <em>width</em> long using <em>fillChar</em> as padding.</p> <p>The original string is returned if <em>width</em> is less than or equal to <em>s.len</em>.</p>   </dd> <dt id="count"><pre id="count,string,string,bool" data-language="nim">proc count(s: string; sub: string; overlapping: bool = false): int {.noSideEffect,
    gcsafe, extern: "nsuCountString", raises: [], tags: [].}</pre></dt> <dd> Count the occurrences of a substring <em>sub</em> in the string <em>s</em>. Overlapping occurrences of <em>sub</em> only count when <em>overlapping</em> is set to true.   </dd> <dt id="count"><pre id="count,string,char" data-language="nim">proc count(s: string; sub: char): int {.noSideEffect, gcsafe, extern: "nsuCountChar",
                                  raises: [], tags: [].}</pre></dt> <dd> Count the occurrences of the character <em>sub</em> in the string <em>s</em>.   </dd> <dt id="count"><pre id="count,string,set[char]" data-language="nim">proc count(s: string; subs: set[char]): int {.noSideEffect, gcsafe,
                                        extern: "nsuCountCharSet", raises: [],
                                        tags: [].}</pre></dt> <dd> Count the occurrences of the group of character <em>subs</em> in the string <em>s</em>.   </dd> <dt id="quoteIfContainsWhite"><pre id="quoteIfContainsWhite,string" data-language="nim">proc quoteIfContainsWhite(s: string): string {.deprecated, raises: [], tags: [].}</pre></dt> <dd> <p>Returns <code>'"' &amp; s &amp; '"'</code> if <em>s</em> contains a space and does not start with a quote, else returns <em>s</em>.</p> <p><strong>DEPRECATED</strong> as it was confused for shell quoting function. For this application use <a href="../osproc/#quoteShell">osproc.quoteShell</a>.</p>   </dd> <dt id="contains"><pre id="contains,string,char" data-language="nim">proc contains(s: string; c: char): bool {.noSideEffect, raises: [], tags: [].}</pre></dt> <dd> Same as <code>find(s, c) &gt;= 0</code>.   </dd> <dt id="contains"><pre id="contains,string,string" data-language="nim">proc contains(s, sub: string): bool {.noSideEffect, raises: [], tags: [].}</pre></dt> <dd> Same as <code>find(s, sub) &gt;= 0</code>.   </dd> <dt id="contains"><pre id="contains,string,set[char]" data-language="nim">proc contains(s: string; chars: set[char]): bool {.noSideEffect, raises: [], tags: [].}</pre></dt> <dd> Same as <code>find(s, chars) &gt;= 0</code>.   </dd> <dt id="replace"><pre id="replace,string,string,string" data-language="nim">proc replace(s, sub: string; by = ""): string {.noSideEffect, gcsafe,
                                        extern: "nsuReplaceStr", raises: [],
                                        tags: [].}</pre></dt> <dd> Replaces <em>sub</em> in <em>s</em> by the string <em>by</em>.   </dd> <dt id="replace"><pre id="replace,string,char,char" data-language="nim">proc replace(s: string; sub, by: char): string {.noSideEffect, gcsafe,
    extern: "nsuReplaceChar", raises: [], tags: [].}</pre></dt> <dd> <p>Replaces <em>sub</em> in <em>s</em> by the character <em>by</em>.</p> <p>Optimized version of <a href="#replace,string,string">replace</a> for characters.</p>   </dd> <dt id="replaceWord"><pre id="replaceWord,string,string,string" data-language="nim">proc replaceWord(s, sub: string; by = ""): string {.noSideEffect, gcsafe,
    extern: "nsuReplaceWord", raises: [], tags: [].}</pre></dt> <dd> <p>Replaces <em>sub</em> in <em>s</em> by the string <em>by</em>.</p> <p>Each occurrence of <em>sub</em> has to be surrounded by word boundaries (comparable to <code>\\w</code> in regular expressions), otherwise it is not replaced.</p>   </dd> <dt id="multiReplace"><pre id="multiReplace,string,varargs[]" data-language="nim">proc multiReplace(s: string; replacements: varargs[(string, string)]): string {.
    noSideEffect, raises: [], tags: [].}</pre></dt> <dd> <p>Same as replace, but specialized for doing multiple replacements in a single pass through the input string.</p> <p>Calling replace multiple times after each other is inefficient and result in too many allocations follwed by immediate deallocations as portions of the string gets replaced. multiReplace performs all replacements in a single pass.</p> <p>If the resulting string is not longer than the original input string, only a single memory allocation is required.</p> <p>The order of the replacements does matter. Earlier replacements are preferred over later replacements in the argument list.</p>   </dd> <dt id="delete"><pre id="delete,string,int,int" data-language="nim">proc delete(s: var string; first, last: int) {.noSideEffect, gcsafe, extern: "nsuDelete",
                                        raises: [], tags: [].}</pre></dt> <dd> <p>Deletes in <em>s</em> the characters at position <em>first</em> .. <em>last</em>.</p> <p>This modifies <em>s</em> itself, it does not return a copy.</p>   </dd> <dt id="parseOctInt"><pre id="parseOctInt,string" data-language="nim">proc parseOctInt(s: string): int {.noSideEffect, gcsafe, extern: "nsuParseOctInt",
                               raises: [ValueError], tags: [].}</pre></dt> <dd> <p>Parses an octal integer value contained in <em>s</em>.</p> <p>If <em>s</em> is not a valid integer, <em>ValueError</em> is raised. <em>s</em> can have one of the following optional prefixes: <code>0o</code>, <code>0O</code>. Underscores within <em>s</em> are ignored.</p>   </dd> <dt id="toOct"><pre id="toOct,BiggestInt,Positive" data-language="nim">proc toOct(x: BiggestInt; len: Positive): string {.noSideEffect, gcsafe,
    extern: "nsuToOct", raises: [], tags: [].}</pre></dt> <dd> <p>Converts <em>x</em> into its octal representation.</p> <p>The resulting string is always <em>len</em> characters long. No leading <code>0o</code> prefix is generated.</p>   </dd> <dt id="toBin"><pre id="toBin,BiggestInt,Positive" data-language="nim">proc toBin(x: BiggestInt; len: Positive): string {.noSideEffect, gcsafe,
    extern: "nsuToBin", raises: [], tags: [].}</pre></dt> <dd> <p>Converts <em>x</em> into its binary representation.</p> <p>The resulting string is always <em>len</em> characters long. No leading <code>0b</code> prefix is generated.</p>   </dd> <dt id="insertSep"><pre id="insertSep,string,Char,int" data-language="nim">proc insertSep(s: string; sep = '_'; digits = 3): string {.noSideEffect, gcsafe,
    extern: "nsuInsertSep", raises: [], tags: [].}</pre></dt> <dd> <p>Inserts the separator <em>sep</em> after <em>digits</em> digits from right to left.</p> <p>Even though the algorithm works with any string <em>s</em>, it is only useful if <em>s</em> contains a number. Example: <code>insertSep("1000000") == "1_000_000"</code></p>   </dd> <dt id="escape"><pre id="escape,string,string,string" data-language="nim">proc escape(s: string; prefix = "\""; suffix = "\""): string {.noSideEffect, gcsafe,
    extern: "nsuEscape", raises: [], tags: [].}</pre></dt> <dd> <p>Escapes a string <em>s</em>.</p> <p>This does these operations (at the same time):</p> <ul class="simple">
<li>replaces any <code>\</code> by <code>\\</code>
</li> <li>replaces any <code>'</code> by <code>\'</code>
</li> <li>replaces any <code>"</code> by <code>\"</code>
</li> <li>replaces any other character in the set <code>{'\0'..'\31', '\127'..'\255'}</code> by <code>\xHH</code> where <code>HH</code> is its hexadecimal value.</li> </ul> <p>The procedure has been designed so that its output is usable for many different common syntaxes. The resulting string is prefixed with <em>prefix</em> and suffixed with <em>suffix</em>. Both may be empty strings. <strong>Note</strong>: This is not correct for producing Ansi C code!</p>   </dd> <dt id="unescape"><pre id="unescape,string,string,string" data-language="nim">proc unescape(s: string; prefix = "\""; suffix = "\""): string {.noSideEffect, gcsafe,
    extern: "nsuUnescape", raises: [ValueError], tags: [].}</pre></dt> <dd> <p>Unescapes a string <em>s</em>.</p> <p>This complements <a href="#escape">escape</a> as it performs the opposite operations.</p> <p>If <em>s</em> does not begin with <code>prefix</code> and end with <code>suffix</code> a ValueError exception will be raised.</p>   </dd> <dt id="validIdentifier"><pre id="validIdentifier,string" data-language="nim">proc validIdentifier(s: string): bool {.noSideEffect, gcsafe,
                                    extern: "nsuValidIdentifier", raises: [],
                                    tags: [].}</pre></dt> <dd> <p>Returns true if <em>s</em> is a valid identifier.</p> <p>A valid identifier starts with a character of the set <em>IdentStartChars</em> and is followed by any number of characters of the set <em>IdentChars</em>.</p>   </dd> <dt id="editDistance"><pre id="editDistance,string,string" data-language="nim">proc editDistance(a, b: string): int {.noSideEffect, gcsafe, extern: "nsuEditDistance",
                                  raises: [], tags: [].}</pre></dt> <dd> <p>Returns the edit distance between <em>a</em> and <em>b</em>.</p> <p>This uses the <span id="levenshtein_1">Levenshtein</span> distance algorithm with only a linear memory overhead. This implementation is highly optimized!</p>   </dd> <dt id="formatBiggestFloat"><pre id="formatBiggestFloat,BiggestFloat,FloatFormatMode,range[],Char" data-language="nim">proc formatBiggestFloat(f: BiggestFloat; format: FloatFormatMode = ffDefault;
                       precision: range[0 .. 32] = 16; decimalSep = '.'): string {.
    noSideEffect, gcsafe, extern: "nsu$1", raises: [], tags: [].}</pre></dt> <dd> <p>Converts a floating point value <em>f</em> to a string.</p> <p>If <code>format == ffDecimal</code> then precision is the number of digits to be printed after the decimal point. If <code>format == ffScientific</code> then precision is the maximum number of significant digits to be printed. <em>precision</em>'s default value is the maximum number of meaningful digits after the decimal point for Nim's <code>biggestFloat</code> type.</p> <p>If <code>precision == 0</code>, it tries to format it nicely.</p>   </dd> <dt id="formatFloat"><pre id="formatFloat,float,FloatFormatMode,range[],Char" data-language="nim">proc formatFloat(f: float; format: FloatFormatMode = ffDefault;
                precision: range[0 .. 32] = 16; decimalSep = '.'): string {.noSideEffect,
    gcsafe, extern: "nsu$1", raises: [], tags: [].}</pre></dt> <dd> <p>Converts a floating point value <em>f</em> to a string.</p> <p>If <code>format == ffDecimal</code> then precision is the number of digits to be printed after the decimal point. If <code>format == ffScientific</code> then precision is the maximum number of significant digits to be printed. <em>precision</em>'s default value is the maximum number of meaningful digits after the decimal point for Nim's <code>float</code> type.</p> <p>If <code>precision == 0</code>, it tries to format it nicely.</p>   </dd> <dt id="trimZeros"><pre id="trimZeros,string" data-language="nim">proc trimZeros(x: var string) {.noSideEffect, raises: [], tags: [].}</pre></dt> <dd> Trim trailing zeros from a formatted floating point value (<em>x</em>). Modifies the passed value.   </dd> <dt id="formatSize"><pre id="formatSize,int64,Char" data-language="nim">proc formatSize(bytes: int64; decimalSep = '.'; prefix = bpIEC; includeSpace = false): string {.
    noSideEffect, raises: [], tags: [].}</pre></dt> <dd> <p>Rounds and formats <em>bytes</em>.</p> <p>By default, uses the IEC/ISO standard binary prefixes, so 1024 will be formatted as 1KiB. Set prefix to <em>bpColloquial</em> to use the colloquial names from the SI standard (e.g. k for 1000 being reused as 1024).</p> <p><em>includeSpace</em> can be set to true to include the (SI preferred) space between the number and the unit (e.g. 1 KiB).</p> <p>Examples:</p> <pre class="listing" data-language="nim">formatSize((1'i64 shl 31) + (300'i64 shl 20)) == "2.293GiB"
formatSize((2.234*1024*1024).int) == "2.234MiB"
formatSize(4096, includeSpace=true) == "4 KiB"
formatSize(4096, prefix=bpColloquial, includeSpace=true) == "4 kB"
formatSize(4096) == "4KiB"
formatSize(5_378_934, prefix=bpColloquial, decimalSep=',') == "5,13MB"</pre>   </dd> <dt id="formatEng"><pre id="formatEng,BiggestFloat,range[],bool,bool,string,Char" data-language="nim">proc formatEng(f: BiggestFloat; precision: range[0 .. 32] = 10; trim: bool = true;
              siPrefix: bool = false; unit: string = nil; decimalSep = '.'): string {.
    noSideEffect, raises: [], tags: [].}</pre></dt> <dd> <p>Converts a floating point value <em>f</em> to a string using engineering notation.</p> <p>Numbers in of the range -1000.0&lt;f&lt;1000.0 will be formatted without an exponent. Numbers outside of this range will be formatted as a significand in the range -1000.0&lt;f&lt;1000.0 and an exponent that will always be an integer multiple of 3, corresponding with the SI prefix scale k, M, G, T etc for numbers with an absolute value greater than 1 and m, μ, n, p etc for numbers with an absolute value less than 1.</p> <p>The default configuration (<em>trim=true</em> and <em>precision=10</em>) shows the <strong>shortest</strong> form that precisely (up to a maximum of 10 decimal places) displays the value. For example, 4.100000 will be displayed as 4.1 (which is mathematically identical) whereas 4.1000003 will be displayed as 4.1000003.</p> <p>If <em>trim</em> is set to true, trailing zeros will be removed; if false, the number of digits specified by <em>precision</em> will always be shown.</p> <p><em>precision</em> can be used to set the number of digits to be shown after the decimal point or (if <em>trim</em> is true) the maximum number of digits to be shown.</p> <pre class="listing" data-language="nim">formatEng(0, 2, trim=false) == "0.00"
formatEng(0, 2) == "0"
formatEng(0.053, 0) == "53e-3"
formatEng(52731234, 2) == "52.73e6"
formatEng(-52731234, 2) == "-52.73e6"</pre>
<p>If <em>siPrefix</em> is set to true, the number will be displayed with the SI prefix corresponding to the exponent. For example 4100 will be displayed as "4.1 k" instead of "4.1e3". Note that <em>u</em> is used for micro- in place of the greek letter mu (μ) as per ISO 2955. Numbers with an absolute value outside of the range 1e-18&lt;f&lt;1000e18 (1a&lt;f&lt;1000E) will be displayed with an exponent rather than an SI prefix, regardless of whether <em>siPrefix</em> is true.</p> <p>If <em>unit</em> is not nil, the provided unit will be appended to the string (with a space as required by the SI standard). This behaviour is slightly different to appending the unit to the result as the location of the space is altered depending on whether there is an exponent.</p> <pre class="listing" data-language="nim">formatEng(4100, siPrefix=true, unit="V") == "4.1 kV"
formatEng(4.1, siPrefix=true, unit="V") == "4.1 V"
formatEng(4.1, siPrefix=true) == "4.1" # Note lack of space
formatEng(4100, siPrefix=true) == "4.1 k"
formatEng(4.1, siPrefix=true, unit="") == "4.1 " # Space with unit=""
formatEng(4100, siPrefix=true, unit="") == "4.1 k"
formatEng(4100) == "4.1e3"
formatEng(4100, unit="V") == "4.1e3 V"
formatEng(4100, unit="") == "4.1e3 " # Space with unit=""</pre>
<p><em>decimalSep</em> is used as the decimal separator</p>   </dd> <dt id="addf"><pre id="addf,string,string,varargs[string,]" data-language="nim">proc addf(s: var string; formatstr: string; a: varargs[string, `$`]) {.noSideEffect,
    gcsafe, extern: "nsuAddf", raises: [ValueError], tags: [].}</pre></dt> <dd> The same as <code>add(s, formatstr % a)</code>, but more efficient.   </dd> <dt id="%"><pre id="%,string,openArray[string]" data-language="nim">proc `%`(formatstr: string; a: openArray[string]): string {.noSideEffect, gcsafe,
    extern: "nsuFormatOpenArray", raises: [ValueError], tags: [].}</pre></dt> <dd> <p>Interpolates a format string with the values from <em>a</em>.</p> <p>The <span id="substitution_1">substitution</span> operator performs string substitutions in <em>formatstr</em> and returns a modified <em>formatstr</em>. This is often called <span id="string-interpolation_1">string interpolation</span>.</p> <p>This is best explained by an example:</p> <pre class="listing" data-language="nim">"$1 eats $2." % ["The cat", "fish"]</pre>
<p>Results in:</p> <pre class="listing" data-language="nim">"The cat eats fish."</pre>
<p>The substitution variables (the thing after the <code>$</code>) are enumerated from 1 to <code>a.len</code>. To produce a verbatim <code>$</code>, use <code>$$</code>. The notation <code>$#</code> can be used to refer to the next substitution variable:</p> <pre class="listing" data-language="nim">"$# eats $#." % ["The cat", "fish"]</pre>
<p>Substitution variables can also be words (that is <code>[A-Za-z_]+[A-Za-z0-9_]*</code>) in which case the arguments in <em>a</em> with even indices are keys and with odd indices are the corresponding values. An example:</p> <pre class="listing" data-language="nim">"$animal eats $food." % ["animal", "The cat", "food", "fish"]</pre>
<p>Results in:</p> <pre class="listing" data-language="nim">"The cat eats fish."</pre>
<p>The variables are compared with <em>cmpIgnoreStyle</em>. <em>ValueError</em> is raised if an ill-formed format string has been passed to the <em>%</em> operator.</p>   </dd> <dt id="%"><pre id="%,string,string" data-language="nim">proc `%`(formatstr, a: string): string {.noSideEffect, gcsafe,
                                    extern: "nsuFormatSingleElem",
                                    raises: [ValueError], tags: [].}</pre></dt> <dd> This is the same as <code>formatstr % [a]</code>.   </dd> <dt id="format"><pre id="format,string,varargs[string,]" data-language="nim">proc format(formatstr: string; a: varargs[string, `$`]): string {.noSideEffect,
    gcsafe, extern: "nsuFormatVarargs", raises: [ValueError], tags: [].}</pre></dt> <dd> This is the same as <code>formatstr % a</code> except that it supports auto stringification.   </dd> <dt id="removeSuffix"><pre id="removeSuffix,string,set[char]" data-language="nim">proc removeSuffix(s: var string; chars: set[char] = Newlines) {.gcsafe,
    extern: "nsuRemoveSuffixCharSet", raises: [], tags: [].}</pre></dt> <dd> Removes the first matching character from the string (in-place) given a set of characters. If the set of characters is only equal to <em>Newlines</em> then it will remove both the newline and return feed. .. code-block:: nim<blockquote>
<dl>
<dt>var</dt> <dd>userInput = "Hello World!rn" otherInput = "Hello!?!"</dd> </dl> <p>userInput.removeSuffix userInput == "Hello World!" userInput.removeSuffix({'!', '?'}) userInput == "Hello World" otherInput.removeSuffix({'!', '?'}) otherInput == "Hello!?"</p> </blockquote>   </dd> <dt id="removeSuffix"><pre id="removeSuffix,string,char" data-language="nim">proc removeSuffix(s: var string; c: char) {.gcsafe, extern: "nsuRemoveSuffixChar",
                                      raises: [], tags: [].}</pre></dt> <dd> Removes a single character (in-place) from a string. .. code-block:: nim<blockquote>
<dl>
<dt>var</dt> <dd>table = "users"</dd> </dl> <p>table.removeSuffix('s') table == "user"</p> </blockquote>   </dd> <dt id="removeSuffix"><pre id="removeSuffix,string,string" data-language="nim">proc removeSuffix(s: var string; suffix: string) {.gcsafe,
    extern: "nsuRemoveSuffixString", raises: [], tags: [].}</pre></dt> <dd> Remove the first matching suffix (in-place) from a string. .. code-block:: nim<blockquote>
<dl>
<dt>var</dt> <dd>answers = "yeses"</dd> </dl> <p>answers.removeSuffix("es") answers == "yes"</p> </blockquote>   </dd> </dl>  <h2 id="14">Iterators</h2> <dl> <dt id="split"><pre id="split.i,string,set[char],int" data-language="nim">iterator split(s: string; seps: set[char] = Whitespace; maxsplit: int = - 1): string {.
    raises: [], tags: [].}</pre></dt> <dd> <p>Splits the string <em>s</em> into substrings using a group of separators.</p> <p>Substrings are separated by a substring containing only <em>seps</em>.</p> <pre class="listing" data-language="nim">for word in split("this\lis an\texample"):
  writeLine(stdout, word)</pre>
<p>...generates this output:</p> <pre class="listing" data-language="nim">"this"
"is"
"an"
"example"</pre>
<p>And the following code:</p> <pre class="listing" data-language="nim">for word in split("this:is;an$example", {';', ':', '$'}):
  writeLine(stdout, word)</pre>
<p>...produces the same output as the first example. The code:</p> <pre class="listing" data-language="nim">let date = "2012-11-20T22:08:08.398990"
let separators = {' ', '-', ':', 'T'}
for number in split(date, separators):
  writeLine(stdout, number)</pre>
<p>...results in:</p> <pre class="listing" data-language="nim">"2012"
"11"
"20"
"22"
"08"
"08.398990"</pre>   </dd> <dt id="splitWhitespace"><pre id="splitWhitespace.i,string" data-language="nim">iterator splitWhitespace(s: string): string {.raises: [], tags: [].}</pre></dt> <dd> Splits at whitespace.   </dd> <dt id="split"><pre id="split.i,string,char,int" data-language="nim">iterator split(s: string; sep: char; maxsplit: int = - 1): string {.raises: [], tags: [].}</pre></dt> <dd> <p>Splits the string <em>s</em> into substrings using a single separator.</p> <p>Substrings are separated by the character <em>sep</em>. The code:</p> <pre class="listing" data-language="nim">for word in split(";;this;is;an;;example;;;", ';'):
  writeLine(stdout, word)</pre>
<p>Results in:</p> <pre class="listing" data-language="nim">""
""
"this"
"is"
"an"
""
"example"
""
""
""</pre>   </dd> <dt id="split"><pre id="split.i,string,string,int" data-language="nim">iterator split(s: string; sep: string; maxsplit: int = - 1): string {.raises: [], tags: [].}</pre></dt> <dd> <p>Splits the string <em>s</em> into substrings using a string separator.</p> <p>Substrings are separated by the string <em>sep</em>. The code:</p> <pre class="listing" data-language="nim">for word in split("thisDATAisDATAcorrupted", "DATA"):
  writeLine(stdout, word)</pre>
<p>Results in:</p> <pre class="listing" data-language="nim">"this"
"is"
"corrupted"</pre>   </dd> <dt id="rsplit"><pre id="rsplit.i,string,set[char],int" data-language="nim">iterator rsplit(s: string; seps: set[char] = Whitespace; maxsplit: int = - 1): string {.
    raises: [], tags: [].}</pre></dt> <dd> Splits the string <em>s</em> into substrings from the right using a string separator. Works exactly the same as <a href="#split.i,string,char">split iterator</a> except in reverse order.<pre class="listing" data-language="nim">for piece in "foo bar".rsplit(WhiteSpace):
  echo piece</pre>
<p>Results in:</p> <pre class="listing" data-language="nim">"bar"
"foo"</pre>
<p>Substrings are separated from the right by the set of chars <em>seps</em></p>   </dd> <dt id="rsplit"><pre id="rsplit.i,string,char,int" data-language="nim">iterator rsplit(s: string; sep: char; maxsplit: int = - 1): string {.raises: [], tags: [].}</pre></dt> <dd> Splits the string <em>s</em> into substrings from the right using a string separator. Works exactly the same as <a href="#split.i,string,char">split iterator</a> except in reverse order.<pre class="listing" data-language="nim">for piece in "foo:bar".rsplit(':'):
  echo piece</pre>
<p>Results in:</p> <pre class="listing" data-language="nim">"bar"
"foo"</pre>
<p>Substrings are separated from the right by the char <em>sep</em></p>   </dd> <dt id="rsplit"><pre id="rsplit.i,string,string,int,bool" data-language="nim">iterator rsplit(s: string; sep: string; maxsplit: int = - 1; keepSeparators: bool = false): string {.
    raises: [], tags: [].}</pre></dt> <dd> Splits the string <em>s</em> into substrings from the right using a string separator. Works exactly the same as <a href="#split.i,string,string">split iterator</a> except in reverse order.<pre class="listing" data-language="nim">for piece in "foothebar".rsplit("the"):
  echo piece</pre>
<p>Results in:</p> <pre class="listing" data-language="nim">"bar"
"foo"</pre>
<p>Substrings are separated from the right by the string <em>sep</em></p>   </dd> <dt id="splitLines"><pre id="splitLines.i,string" data-language="nim">iterator splitLines(s: string): string {.raises: [], tags: [].}</pre></dt> <dd> <p>Splits the string <em>s</em> into its containing lines.</p> <p>Every <a href="../manual/#character-literals">character literal</a> newline combination (CR, LF, CR-LF) is supported. The result strings contain no trailing <code>\n</code>.</p> <p>Example:</p> <pre class="listing" data-language="nim">for line in splitLines("\nthis\nis\nan\n\nexample\n"):
  writeLine(stdout, line)</pre>
<p>Results in:</p> <pre class="listing" data-language="nim">""
"this"
"is"
"an"
""
"example"
""</pre>   </dd> <dt id="tokenize"><pre id="tokenize.i,string,set[char]" data-language="nim">iterator tokenize(s: string; seps: set[char] = Whitespace): tuple[token: string,
    isSep: bool] {.raises: [], tags: [].}</pre></dt> <dd> <p>Tokenizes the string <em>s</em> into substrings.</p> <p>Substrings are separated by a substring containing only <em>seps</em>. Examples:</p> <pre class="listing" data-language="nim">for word in tokenize("  this is an  example  "):
  writeLine(stdout, word)</pre>
<p>Results in:</p> <pre class="listing" data-language="nim">("  ", true)
("this", false)
(" ", true)
("is", false)
(" ", true)
("an", false)
("  ", true)
("example", false)
("  ", true)</pre>   </dd> </dl>  <h2 id="17">Templates</h2> <dl> <dt id="spaces"><pre id="spaces.t,Natural" data-language="nim">template spaces(n: Natural): string</pre></dt> <dd> Returns a String with <em>n</em> space characters. You can use this proc to left align strings. Example:<pre class="listing" data-language="nim">let
  width = 15
  text1 = "Hello user!"
  text2 = "This is a very long string"
echo text1 &amp; spaces(max(0, width - text1.len)) &amp; "|"
echo text2 &amp; spaces(max(0, width - text2.len)) &amp; "|"</pre>   </dd> </dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 2006–2017 Andreas Rumpf<br>Licensed under the MIT License.<br>
    <a href="https://nim-lang.org/docs/strutils.html" class="_attribution-link" target="_blank">https://nim-lang.org/docs/strutils.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
