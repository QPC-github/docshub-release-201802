
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Basic2d - Nim - W3cubDocs</title>
  
  <meta name="description" content="Basic 2d support with vectors, points, matrices and some basic utilities. Vectors are implemented as direction vectors, ie. when transformed with a &hellip;">
  <meta name="keywords" content="module, basic, d, -, nim">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/nim/basic2d/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-e0f881b0fce8cbe96f33dadc355b7159d5d2912911231446d60eb8f9caffa802.css">
  <script type="text/javascript" src="/assets/application-8fc46316434047265cd383f02b8e7f434ed7dec4a59f920dd633deef8d488d1b.js"></script>
  <script src="/json/nim.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/nim/" class="_nav-link" title="" style="margin-left:0;">Nim</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _nim">
				
<h1 class="title">Module basic2d</h1>  
<p>Basic 2d support with vectors, points, matrices and some basic utilities. Vectors are implemented as direction vectors, ie. when transformed with a matrix the translation part of matrix is ignored. Operators <em>+</em> , <em>-</em> , <em>*</em> , <em>/</em> , <em>+=</em> , <em>-=</em> , <em>*=</em> and <em>/=</em> are implemented for vectors and scalars.</p> <p>Quick start example:</p> <pre class="listing" data-language="nim"># Create a matrix which first rotates, then scales and at last translates

var m:Matrix2d=rotate(DEG90) &amp; scale(2.0) &amp; move(100.0,200.0)

# Create a 2d point at (100,0) and a vector (5,2)

var pt:Point2d=point2d(100.0,0.0)

var vec:Vector2d=vector2d(5.0,2.0)


pt &amp;= m # transforms pt in place

var pt2:Point2d=pt &amp; m #concatenates pt with m and returns a new point

var vec2:Vector2d=vec &amp; m #concatenates vec with m and returns a new vector</pre>implements binary operators <code>+</code>, <code>-</code>, <code>*</code> and <code>/</code> for vectorsimplements binary operators <code>+</code>, <code>-</code>, <code>*</code> and <code>/</code> for vectorsimplements binary operators <code>+</code>, <code>-</code>, <code>*</code> and <code>/</code> for vectorsimplements binary operators <code>+</code>, <code>-</code>, <code>*</code> and <code>/</code> for vectorsimplements inplace binary operators <code>+=</code>, <code>-=</code>, <code>/=</code> and <code>*=</code> for vectorsimplements inplace binary operators <code>+=</code>, <code>-=</code>, <code>/=</code> and <code>*=</code> for vectorsimplements inplace binary operators <code>+=</code>, <code>-=</code>, <code>/=</code> and <code>*=</code> for vectorsimplements inplace binary operators <code>+=</code>, <code>-=</code>, <code>/=</code> and <code>*=</code> for vectors  <h2 id="6">Imports</h2> <dl> <a href="../math/">math</a>, <a href="../strutils/">strutils</a> </dl>  <h2 id="7">Types</h2> <dl> <dt id="Matrix2d"><pre id="Matrix2d" data-language="nim">Matrix2d = object
  ax*, ay*, bx*, by*, tx*, ty*: float</pre></dt> <dd> Implements a row major 2d matrix, which means transformations are applied the order they are concatenated. The rightmost column of the 3x3 matrix is left out since normally not used for geometric transformations in 2d.   </dd> <dt id="Point2d"><pre id="Point2d" data-language="nim">Point2d = object
  x*, y*: float</pre></dt> <dd> Implements a non-homogeneous 2d point stored as an <em>x</em> coordinate and an <em>y</em> coordinate.   </dd> <dt id="Vector2d"><pre id="Vector2d" data-language="nim">Vector2d = object
  x*, y*: float</pre></dt> <dd> Implements a 2d <strong>direction vector</strong> stored as an <em>x</em> coordinate and an <em>y</em> coordinate. Direction vector means, that when transforming a vector with a matrix, the translational part of the matrix is ignored.   </dd> </dl>  <h2 id="9">Lets</h2> <dl> <dt id="IDMATRIX"><pre id="IDMATRIX" data-language="nim">IDMATRIX: Matrix2d = matrix2d(1.0, 0.0, 0.0, 1.0, 0.0, 0.0)</pre></dt> <dd> Quick access to an identity matrix   </dd> <dt id="ORIGO"><pre id="ORIGO" data-language="nim">ORIGO: Point2d = point2d(0.0, 0.0)</pre></dt> <dd> Quick access to point (0,0)   </dd> <dt id="XAXIS"><pre id="XAXIS" data-language="nim">XAXIS: Vector2d = vector2d(1.0, 0.0)</pre></dt> <dd> Quick access to an 2d x-axis unit vector   </dd> <dt id="YAXIS"><pre id="YAXIS" data-language="nim">YAXIS: Vector2d = vector2d(0.0, 1.0)</pre></dt> <dd> Quick access to an 2d y-axis unit vector   </dd> </dl>  <h2 id="10">Consts</h2> <dl> <dt id="DEG360"><pre id="DEG360" data-language="nim">DEG360 = 6.283185307179586</pre></dt> <dd> 360 degrees in radians.   </dd> <dt id="DEG270"><pre id="DEG270" data-language="nim">DEG270 = 4.71238898038469</pre></dt> <dd> 270 degrees in radians.   </dd> <dt id="DEG180"><pre id="DEG180" data-language="nim">DEG180 = 3.141592653589793</pre></dt> <dd> 180 degrees in radians.   </dd> <dt id="DEG90"><pre id="DEG90" data-language="nim">DEG90 = 1.570796326794897</pre></dt> <dd> 90 degrees in radians.   </dd> <dt id="DEG60"><pre id="DEG60" data-language="nim">DEG60 = 1.047197551196598</pre></dt> <dd> 60 degrees in radians.   </dd> <dt id="DEG45"><pre id="DEG45" data-language="nim">DEG45 = 0.7853981633974483</pre></dt> <dd> 45 degrees in radians.   </dd> <dt id="DEG30"><pre id="DEG30" data-language="nim">DEG30 = 0.5235987755982988</pre></dt> <dd> 30 degrees in radians.   </dd> <dt id="DEG15"><pre id="DEG15" data-language="nim">DEG15 = 0.2617993877991494</pre></dt> <dd> 15 degrees in radians.   </dd> </dl>  <h2 id="12">Procs</h2> <dl> <dt id="setElements"><pre id="setElements,Matrix2d,float,float,float,float,float,float" data-language="nim">proc setElements(t: var Matrix2d; ax, ay, bx, by, tx, ty: float) {.inline, raises: [],
    tags: [].}</pre></dt> <dd> Sets arbitrary elements in an existing matrix.   </dd> <dt id="matrix2d"><pre id="matrix2d,float,float,float,float,float,float" data-language="nim">proc matrix2d(ax, ay, bx, by, tx, ty: float): Matrix2d {.noInit, raises: [], tags: [].}</pre></dt> <dd> Creates a new matrix. <em>ax</em>,`ay` is the local x axis <em>bx</em>,`by` is the local y axis <em>tx</em>,`ty` is the translation   </dd> <dt id="&amp;"><pre id="&amp;,Matrix2d,Matrix2d" data-language="nim">proc `&amp;`(a, b: Matrix2d): Matrix2d {.noInit, raises: [], tags: [].}</pre></dt> <dd> Concatenates matrices returning a new matrix.   </dd> <dt id="scale"><pre id="scale,float" data-language="nim">proc scale(s: float): Matrix2d {.noInit, raises: [], tags: [].}</pre></dt> <dd> Returns a new scale matrix.   </dd> <dt id="scale"><pre id="scale,float,Point2d" data-language="nim">proc scale(s: float; org: Point2d): Matrix2d {.noInit, raises: [], tags: [].}</pre></dt> <dd> Returns a new scale matrix using, <em>org</em> as scale origin.   </dd> <dt id="stretch"><pre id="stretch,float,float" data-language="nim">proc stretch(sx, sy: float): Matrix2d {.noInit, raises: [], tags: [].}</pre></dt> <dd> Returns new a stretch matrix, which is a scale matrix with non uniform scale in x and y.   </dd> <dt id="stretch"><pre id="stretch,float,float,Point2d" data-language="nim">proc stretch(sx, sy: float; org: Point2d): Matrix2d {.noInit, raises: [], tags: [].}</pre></dt> <dd> Returns a new stretch matrix, which is a scale matrix with non uniform scale in x and y. <em>org</em> is used as stretch origin.   </dd> <dt id="move"><pre id="move,float,float" data-language="nim">proc move(dx, dy: float): Matrix2d {.noInit, raises: [], tags: [].}</pre></dt> <dd> Returns a new translation matrix.   </dd> <dt id="move"><pre id="move,Vector2d" data-language="nim">proc move(v: Vector2d): Matrix2d {.noInit, raises: [], tags: [].}</pre></dt> <dd> Returns a new translation matrix from a vector.   </dd> <dt id="rotate"><pre id="rotate,float" data-language="nim">proc rotate(rad: float): Matrix2d {.noInit, raises: [], tags: [].}</pre></dt> <dd> Returns a new rotation matrix, which represents a rotation by <em>rad</em> radians   </dd> <dt id="rotate"><pre id="rotate,float,Point2d" data-language="nim">proc rotate(rad: float; org: Point2d): Matrix2d {.noInit, raises: [], tags: [].}</pre></dt> <dd> Returns a new rotation matrix, which represents a rotation by <em>rad</em> radians around the origin <em>org</em>   </dd> <dt id="mirror"><pre id="mirror,Vector2d" data-language="nim">proc mirror(v: Vector2d): Matrix2d {.noInit, raises: [], tags: [].}</pre></dt> <dd> Returns a new mirror matrix, mirroring around the line that passes through origo and has the direction of <em>v</em>   </dd> <dt id="mirror"><pre id="mirror,Point2d,Vector2d" data-language="nim">proc mirror(org: Point2d; v: Vector2d): Matrix2d {.noInit, raises: [], tags: [].}</pre></dt> <dd> Returns a new mirror matrix, mirroring around the line that passes through <em>org</em> and has the direction of <em>v</em>   </dd> <dt id="skew"><pre id="skew,float,float" data-language="nim">proc skew(xskew, yskew: float): Matrix2d {.noInit, raises: [], tags: [].}</pre></dt> <dd> Returns a new skew matrix, which has its x axis rotated <em>xskew</em> radians from the local x axis, and y axis rotated <em>yskew</em> radians from the local y axis   </dd> <dt id="$"><pre id="$,Matrix2d" data-language="nim">proc `$`(t: Matrix2d): string {.noInit, raises: [], tags: [].}</pre></dt> <dd> Returns a string representation of the matrix   </dd> <dt id="isUniform"><pre id="isUniform,Matrix2d,float" data-language="nim">proc isUniform(t: Matrix2d; tol = 1e-006): bool {.raises: [], tags: [].}</pre></dt> <dd> Checks if the transform is uniform, that is perpendicular axes of equal length, which means (for example) it cannot transform a circle into an ellipse. <em>tol</em> is used as tolerance for both equal length comparison and perp. comparison.   </dd> <dt id="determinant"><pre id="determinant,Matrix2d" data-language="nim">proc determinant(t: Matrix2d): float {.raises: [], tags: [].}</pre></dt> <dd> Computes the determinant of the matrix.   </dd> <dt id="isMirroring"><pre id="isMirroring,Matrix2d" data-language="nim">proc isMirroring(m: Matrix2d): bool {.raises: [], tags: [].}</pre></dt> <dd> Checks if the <em>m</em> is a mirroring matrix, which means it will reverse direction of a curve transformed with it   </dd> <dt id="inverse"><pre id="inverse,Matrix2d" data-language="nim">proc inverse(m: Matrix2d): Matrix2d {.noInit, raises: [DivByZeroError], tags: [].}</pre></dt> <dd> Returns a new matrix, which is the inverse of the matrix If the matrix is not invertible (determinant=0), an EDivByZero will be raised.   </dd> <dt id="equals"><pre id="equals,Matrix2d,Matrix2d,float" data-language="nim">proc equals(m1: Matrix2d; m2: Matrix2d; tol = 1e-006): bool {.raises: [], tags: [].}</pre></dt> <dd> Checks if all elements of <em>m1`and `m2</em> is equal within a given tolerance <em>tol</em>.   </dd> <dt id="=~"><pre id="=~,Matrix2d,Matrix2d" data-language="nim">proc `=~`(m1, m2: Matrix2d): bool {.raises: [], tags: [].}</pre></dt> <dd> Checks if <em>m1`and `m2</em> is approximately equal, using a tolerance of 1e-6.   </dd> <dt id="isIdentity"><pre id="isIdentity,Matrix2d,float" data-language="nim">proc isIdentity(m: Matrix2d; tol = 1e-006): bool {.raises: [], tags: [].}</pre></dt> <dd> Checks is a matrix is approximately an identity matrix, using <em>tol</em> as tolerance for each element.   </dd> <dt id="apply"><pre id="apply,Matrix2d,float,float" data-language="nim">proc apply(m: Matrix2d; x, y: var float; translate = false) {.raises: [], tags: [].}</pre></dt> <dd> Applies transformation <em>m</em> onto <em>x</em>,`y`, optionally using the translation part of the matrix.   </dd> <dt id="vector2d"><pre id="vector2d,float,float" data-language="nim">proc vector2d(x, y: float): Vector2d {.noInit, inline, raises: [], tags: [].}</pre></dt> <dd> Returns a new vector (<em>x</em>,`y`)   </dd> <dt id="polarVector2d"><pre id="polarVector2d,float,float" data-language="nim">proc polarVector2d(ang: float; len: float): Vector2d {.noInit, raises: [], tags: [].}</pre></dt> <dd> Returns a new vector with angle <em>ang</em> and magnitude <em>len</em>   </dd> <dt id="slopeVector2d"><pre id="slopeVector2d,float,float" data-language="nim">proc slopeVector2d(slope: float; len: float): Vector2d {.noInit, raises: [], tags: [].}</pre></dt> <dd> Returns a new vector having slope (dy/dx) given by <em>slope</em>, and a magnitude of <em>len</em>   </dd> <dt id="len"><pre id="len,Vector2d" data-language="nim">proc len(v: Vector2d): float {.inline, raises: [], tags: [].}</pre></dt> <dd> Returns the length of the vector.   </dd> <dt id="len="><pre id="len=,Vector2d,float" data-language="nim">proc len=(v: var Vector2d; newlen: float) {.noInit, raises: [], tags: [].}</pre></dt> <dd> Sets the length of the vector, keeping its angle.   </dd> <dt id="sqrLen"><pre id="sqrLen,Vector2d" data-language="nim">proc sqrLen(v: Vector2d): float {.inline, raises: [], tags: [].}</pre></dt> <dd> Computes the squared length of the vector, which is faster than computing the absolute length.   </dd> <dt id="angle"><pre id="angle,Vector2d" data-language="nim">proc angle(v: Vector2d): float {.raises: [], tags: [].}</pre></dt> <dd> Returns the angle of the vector. (The counter clockwise plane angle between posetive x axis and <em>v</em>)   </dd> <dt id="$"><pre id="$,Vector2d" data-language="nim">proc `$`(v: Vector2d): string {.raises: [], tags: [].}</pre></dt> <dd> String representation of <em>v</em>   </dd> <dt id="&amp;"><pre id="&amp;,Vector2d,Matrix2d" data-language="nim">proc `&amp;`(v: Vector2d; m: Matrix2d): Vector2d {.noInit, raises: [], tags: [].}</pre></dt> <dd> Concatenate vector <em>v</em> with a transformation matrix. Transforming a vector ignores the translational part of the matrix.   </dd> <dt id="&amp;="><pre id="&amp;=,Vector2d,Matrix2d" data-language="nim">proc `&amp;=`(v: var Vector2d; m: Matrix2d) {.inline, raises: [], tags: [].}</pre></dt> <dd> Applies transformation <em>m</em> onto <em>v</em> in place. Transforming a vector ignores the translational part of the matrix.   </dd> <dt id="tryNormalize"><pre id="tryNormalize,Vector2d" data-language="nim">proc tryNormalize(v: var Vector2d): bool {.raises: [], tags: [].}</pre></dt> <dd> Modifies <em>v</em> to have a length of 1.0, keeping its angle. If <em>v</em> has zero length (and thus no angle), it is left unmodified and false is returned, otherwise true is returned.   </dd> <dt id="normalize"><pre id="normalize,Vector2d" data-language="nim">proc normalize(v: var Vector2d) {.inline, raises: [DivByZeroError], tags: [].}</pre></dt> <dd> Modifies <em>v</em> to have a length of 1.0, keeping its angle. If <em>v</em> has zero length, an EDivByZero will be raised.   </dd> <dt id="transformNorm"><pre id="transformNorm,Vector2d,Matrix2d" data-language="nim">proc transformNorm(v: var Vector2d; t: Matrix2d) {.raises: [DivByZeroError], tags: [].}</pre></dt> <dd> Applies a normal direction transformation <em>t</em> onto <em>v</em> in place. The resulting vector is <em>not</em> normalized. Transforming a vector ignores the translational part of the matrix. If the matrix is not invertible (determinant=0), an EDivByZero will be raised.   </dd> <dt id="transformInv"><pre id="transformInv,Vector2d,Matrix2d" data-language="nim">proc transformInv(v: var Vector2d; t: Matrix2d) {.raises: [DivByZeroError], tags: [].}</pre></dt> <dd> Applies inverse of a transformation <em>t</em> to <em>v</em> in place. This is faster than creating an inverse matrix and apply() it. Transforming a vector ignores the translational part of the matrix. If the matrix is not invertible (determinant=0), an EDivByZero will be raised.   </dd> <dt id="transformNormInv"><pre id="transformNormInv,Vector2d,Matrix2d" data-language="nim">proc transformNormInv(v: var Vector2d; t: Matrix2d) {.raises: [], tags: [].}</pre></dt> <dd> Applies an inverse normal direction transformation <em>t</em> onto <em>v</em> in place. This is faster than creating an inverse matrix and transformNorm(...) it. Transforming a vector ignores the translational part of the matrix.   </dd> <dt id="rotate90"><pre id="rotate90,Vector2d" data-language="nim">proc rotate90(v: var Vector2d) {.inline, raises: [], tags: [].}</pre></dt> <dd> Quickly rotates vector <em>v</em> 90 degrees counter clockwise, without using any trigonometrics.   </dd> <dt id="rotate180"><pre id="rotate180,Vector2d" data-language="nim">proc rotate180(v: var Vector2d) {.inline, raises: [], tags: [].}</pre></dt> <dd> Quickly rotates vector <em>v</em> 180 degrees counter clockwise, without using any trigonometrics.   </dd> <dt id="rotate270"><pre id="rotate270,Vector2d" data-language="nim">proc rotate270(v: var Vector2d) {.inline, raises: [], tags: [].}</pre></dt> <dd> Quickly rotates vector <em>v</em> 270 degrees counter clockwise, without using any trigonometrics.   </dd> <dt id="rotate"><pre id="rotate,Vector2d,float" data-language="nim">proc rotate(v: var Vector2d; rad: float) {.raises: [], tags: [].}</pre></dt> <dd> Rotates vector <em>v</em> <em>rad</em> radians in place.   </dd> <dt id="scale"><pre id="scale,Vector2d,float" data-language="nim">proc scale(v: var Vector2d; fac: float) {.inline, raises: [], tags: [].}</pre></dt> <dd> Scales vector <em>v</em> <em>rad</em> radians in place.   </dd> <dt id="stretch"><pre id="stretch,Vector2d,float,float" data-language="nim">proc stretch(v: var Vector2d; facx, facy: float) {.inline, raises: [], tags: [].}</pre></dt> <dd> Stretches vector <em>v</em> <em>facx</em> times horizontally, and <em>facy</em> times vertically.   </dd> <dt id="mirror"><pre id="mirror,Vector2d,Vector2d" data-language="nim">proc mirror(v: var Vector2d; mirrvec: Vector2d) {.raises: [], tags: [].}</pre></dt> <dd> Mirrors vector <em>v</em> using <em>mirrvec</em> as mirror direction.   </dd> <dt id="-"><pre id="-,Vector2d" data-language="nim">proc `-`(v: Vector2d): Vector2d {.raises: [], tags: [].}</pre></dt> <dd> Negates a vector   </dd> <dt id="+"><pre id="+,Vector2d,Vector2d" data-language="nim">proc `+`(a122589, b122591: Vector2d): Vector2d {.inline, noInit, raises: [], tags: [].}</pre></dt>  <dt id="+"><pre id="+,Vector2d,float" data-language="nim">proc `+`(a122593: Vector2d; b122595: float): Vector2d {.inline, noInit, raises: [],
    tags: [].}</pre></dt>  <dt id="+"><pre id="+,float,Vector2d" data-language="nim">proc `+`(a122597: float; b122599: Vector2d): Vector2d {.inline, noInit, raises: [],
    tags: [].}</pre></dt>  <dt id="-"><pre id="-,Vector2d,Vector2d" data-language="nim">proc `-`(a122610, b122612: Vector2d): Vector2d {.inline, noInit, raises: [], tags: [].}</pre></dt>  <dt id="-"><pre id="-,Vector2d,float" data-language="nim">proc `-`(a122614: Vector2d; b122616: float): Vector2d {.inline, noInit, raises: [],
    tags: [].}</pre></dt>  <dt id="-"><pre id="-,float,Vector2d" data-language="nim">proc `-`(a122618: float; b122620: Vector2d): Vector2d {.inline, noInit, raises: [],
    tags: [].}</pre></dt>  <dt id="*"><pre id="*,Vector2d,Vector2d" data-language="nim">proc `*`(a122631, b122633: Vector2d): Vector2d {.inline, noInit, raises: [], tags: [].}</pre></dt>  <dt id="*"><pre id="*,Vector2d,float" data-language="nim">proc `*`(a122635: Vector2d; b122637: float): Vector2d {.inline, noInit, raises: [],
    tags: [].}</pre></dt>  <dt id="*"><pre id="*,float,Vector2d" data-language="nim">proc `*`(a122639: float; b122641: Vector2d): Vector2d {.inline, noInit, raises: [],
    tags: [].}</pre></dt>  <dt id="/"><pre id="/,Vector2d,Vector2d" data-language="nim">proc `/`(a122652, b122654: Vector2d): Vector2d {.inline, noInit, raises: [], tags: [].}</pre></dt>  <dt id="/"><pre id="/,Vector2d,float" data-language="nim">proc `/`(a122656: Vector2d; b122658: float): Vector2d {.inline, noInit, raises: [],
    tags: [].}</pre></dt>  <dt id="/"><pre id="/,float,Vector2d" data-language="nim">proc `/`(a122660: float; b122662: Vector2d): Vector2d {.inline, noInit, raises: [],
    tags: [].}</pre></dt>  <dt id="+="><pre id="+=,Vector2d,Vector2d" data-language="nim">proc `+=`(a122673: var Vector2d; b122675: Vector2d) {.inline, raises: [], tags: [].}</pre></dt>  <dt id="+="><pre id="+=,Vector2d,float" data-language="nim">proc `+=`(a122677: var Vector2d; b122679: float) {.inline, raises: [], tags: [].}</pre></dt>  <dt id="-="><pre id="-=,Vector2d,Vector2d" data-language="nim">proc `-=`(a122727: var Vector2d; b122729: Vector2d) {.inline, raises: [], tags: [].}</pre></dt>  <dt id="-="><pre id="-=,Vector2d,float" data-language="nim">proc `-=`(a122731: var Vector2d; b122733: float) {.inline, raises: [], tags: [].}</pre></dt>  <dt id="*="><pre id="*=,Vector2d,Vector2d" data-language="nim">proc `*=`(a122781: var Vector2d; b122783: Vector2d) {.inline, raises: [], tags: [].}</pre></dt>  <dt id="*="><pre id="*=,Vector2d,float" data-language="nim">proc `*=`(a122785: var Vector2d; b122787: float) {.inline, raises: [], tags: [].}</pre></dt>  <dt id="/="><pre id="/=,Vector2d,Vector2d" data-language="nim">proc `/=`(a122835: var Vector2d; b122837: Vector2d) {.inline, raises: [], tags: [].}</pre></dt>  <dt id="/="><pre id="/=,Vector2d,float" data-language="nim">proc `/=`(a122839: var Vector2d; b122841: float) {.inline, raises: [], tags: [].}</pre></dt>  <dt id="dot"><pre id="dot,Vector2d,Vector2d" data-language="nim">proc dot(v1, v2: Vector2d): float {.raises: [], tags: [].}</pre></dt> <dd> Computes the dot product of two vectors. Returns 0.0 if the vectors are perpendicular.   </dd> <dt id="cross"><pre id="cross,Vector2d,Vector2d" data-language="nim">proc cross(v1, v2: Vector2d): float {.raises: [], tags: [].}</pre></dt> <dd> Computes the cross product of two vectors, also called the 'perpendicular dot product' in 2d. Returns 0.0 if the vectors are parallel.   </dd> <dt id="equals"><pre id="equals,Vector2d,Vector2d,float" data-language="nim">proc equals(v1, v2: Vector2d; tol = 1e-006): bool {.raises: [], tags: [].}</pre></dt> <dd> Checks if two vectors approximately equals with a tolerance.   </dd> <dt id="=~"><pre id="=~,Vector2d,Vector2d" data-language="nim">proc `=~`(v1, v2: Vector2d): bool {.raises: [], tags: [].}</pre></dt> <dd> Checks if two vectors approximately equals with a hardcoded tolerance 1e-6   </dd> <dt id="angleTo"><pre id="angleTo,Vector2d,Vector2d" data-language="nim">proc angleTo(v1, v2: Vector2d): float {.raises: [], tags: [].}</pre></dt> <dd> Returns the smallest of the two possible angles between <em>v1</em> and <em>v2</em> in radians.   </dd> <dt id="angleCCW"><pre id="angleCCW,Vector2d,Vector2d" data-language="nim">proc angleCCW(v1, v2: Vector2d): float {.raises: [], tags: [].}</pre></dt> <dd> Returns the counter clockwise plane angle from <em>v1</em> to <em>v2</em>, in range 0 - 2*PI   </dd> <dt id="angleCW"><pre id="angleCW,Vector2d,Vector2d" data-language="nim">proc angleCW(v1, v2: Vector2d): float {.raises: [], tags: [].}</pre></dt> <dd> Returns the clockwise plane angle from <em>v1</em> to <em>v2</em>, in range 0 - 2*PI   </dd> <dt id="turnAngle"><pre id="turnAngle,Vector2d,Vector2d" data-language="nim">proc turnAngle(v1, v2: Vector2d): float {.raises: [], tags: [].}</pre></dt> <dd> Returns the amount v1 should be rotated (in radians) to equal v2, in range -PI to PI   </dd> <dt id="bisect"><pre id="bisect,Vector2d,Vector2d" data-language="nim">proc bisect(v1, v2: Vector2d): Vector2d {.noInit, raises: [], tags: [].}</pre></dt> <dd> Computes the bisector between v1 and v2 as a normalized vector. If one of the input vectors has zero length, a normalized version of the other is returned. If both input vectors has zero length, an arbitrary normalized vector is returned.   </dd> <dt id="point2d"><pre id="point2d,float,float" data-language="nim">proc point2d(x, y: float): Point2d {.noInit, inline, raises: [], tags: [].}</pre></dt> <dd> Returns a new point (<em>x</em>,`y`)   </dd> <dt id="sqrDist"><pre id="sqrDist,Point2d,Point2d" data-language="nim">proc sqrDist(a, b: Point2d): float {.raises: [], tags: [].}</pre></dt> <dd> Computes the squared distance between <em>a</em> and <em>b</em>   </dd> <dt id="dist"><pre id="dist,Point2d,Point2d" data-language="nim">proc dist(a, b: Point2d): float {.inline, raises: [], tags: [].}</pre></dt> <dd> Computes the absolute distance between <em>a</em> and <em>b</em>   </dd> <dt id="angle"><pre id="angle,Point2d,Point2d" data-language="nim">proc angle(a, b: Point2d): float {.raises: [], tags: [].}</pre></dt> <dd> Computes the angle of the vector <em>b</em>-<em>a</em>   </dd> <dt id="$"><pre id="$,Point2d" data-language="nim">proc `$`(p: Point2d): string {.raises: [], tags: [].}</pre></dt> <dd> String representation of <em>p</em>   </dd> <dt id="&amp;"><pre id="&amp;,Point2d,Matrix2d" data-language="nim">proc `&amp;`(p: Point2d; t: Matrix2d): Point2d {.noInit, inline, raises: [], tags: [].}</pre></dt> <dd> Concatenates a point <em>p</em> with a transform <em>t</em>, resulting in a new, transformed point.   </dd> <dt id="&amp;="><pre id="&amp;=,Point2d,Matrix2d" data-language="nim">proc `&amp;=`(p: var Point2d; t: Matrix2d) {.inline, raises: [], tags: [].}</pre></dt> <dd> Applies transformation <em>t</em> onto <em>p</em> in place.   </dd> <dt id="transformInv"><pre id="transformInv,Point2d,Matrix2d" data-language="nim">proc transformInv(p: var Point2d; t: Matrix2d) {.inline, raises: [DivByZeroError],
    tags: [].}</pre></dt> <dd> Applies the inverse of transformation <em>t</em> onto <em>p</em> in place. If the matrix is not invertable (determinant=0) , EDivByZero will be raised.   </dd> <dt id="+"><pre id="+,Point2d,Vector2d" data-language="nim">proc `+`(p: Point2d; v: Vector2d): Point2d {.noInit, inline, raises: [], tags: [].}</pre></dt> <dd> Adds a vector <em>v</em> to a point <em>p</em>, resulting in a new point.   </dd> <dt id="+="><pre id="+=,Point2d,Vector2d" data-language="nim">proc `+=`(p: var Point2d; v: Vector2d) {.noInit, inline, raises: [], tags: [].}</pre></dt> <dd> Adds a vector <em>v</em> to a point <em>p</em> in place.   </dd> <dt id="-"><pre id="-,Point2d,Vector2d" data-language="nim">proc `-`(p: Point2d; v: Vector2d): Point2d {.noInit, inline, raises: [], tags: [].}</pre></dt> <dd> Subtracts a vector <em>v</em> from a point <em>p</em>, resulting in a new point.   </dd> <dt id="-"><pre id="-,Point2d,Point2d" data-language="nim">proc `-`(p1, p2: Point2d): Vector2d {.noInit, inline, raises: [], tags: [].}</pre></dt> <dd> Subtracts <em>p2`from `p1</em> resulting in a difference vector.   </dd> <dt id="-="><pre id="-=,Point2d,Vector2d" data-language="nim">proc `-=`(p: var Point2d; v: Vector2d) {.noInit, inline, raises: [], tags: [].}</pre></dt> <dd> Subtracts a vector <em>v</em> from a point <em>p</em> in place.   </dd> <dt id="=~"><pre id="=~,Point2d,Point2d" data-language="nim">proc `=~`(p1, p2: Point2d): bool {.inline, raises: [], tags: [].}</pre></dt> <dd> Checks if two vectors approximately equals with a hardcoded tolerance 1e-6   </dd> <dt id="polar"><pre id="polar,Point2d,float,float" data-language="nim">proc polar(p: Point2d; ang, dist: float): Point2d {.noInit, raises: [], tags: [].}</pre></dt> <dd> Returns a point with a given angle and distance away from <em>p</em>   </dd> <dt id="rotate"><pre id="rotate,Point2d,float" data-language="nim">proc rotate(p: var Point2d; rad: float) {.raises: [], tags: [].}</pre></dt> <dd> Rotates a point in place <em>rad</em> radians around origo.   </dd> <dt id="rotate"><pre id="rotate,Point2d,float,Point2d" data-language="nim">proc rotate(p: var Point2d; rad: float; org: Point2d) {.raises: [], tags: [].}</pre></dt> <dd> Rotates a point in place <em>rad</em> radians using <em>org</em> as center of rotation.   </dd> <dt id="scale"><pre id="scale,Point2d,float" data-language="nim">proc scale(p: var Point2d; fac: float) {.inline, raises: [], tags: [].}</pre></dt> <dd> Scales a point in place <em>fac</em> times with world origo as origin.   </dd> <dt id="scale"><pre id="scale,Point2d,float,Point2d" data-language="nim">proc scale(p: var Point2d; fac: float; org: Point2d) {.inline, raises: [], tags: [].}</pre></dt> <dd> Scales the point in place <em>fac</em> times with <em>org</em> as origin.   </dd> <dt id="stretch"><pre id="stretch,Point2d,float,float" data-language="nim">proc stretch(p: var Point2d; facx, facy: float) {.inline, raises: [], tags: [].}</pre></dt> <dd> Scales a point in place non uniformly <em>facx</em> and <em>facy</em> times with world origo as origin.   </dd> <dt id="stretch"><pre id="stretch,Point2d,float,float,Point2d" data-language="nim">proc stretch(p: var Point2d; facx, facy: float; org: Point2d) {.inline, raises: [], tags: [].}</pre></dt> <dd> Scales the point in place non uniformly <em>facx</em> and <em>facy</em> times with <em>org</em> as origin.   </dd> <dt id="move"><pre id="move,Point2d,float,float" data-language="nim">proc move(p: var Point2d; dx, dy: float) {.inline, raises: [], tags: [].}</pre></dt> <dd> Translates a point <em>dx</em>, <em>dy</em> in place.   </dd> <dt id="move"><pre id="move,Point2d,Vector2d" data-language="nim">proc move(p: var Point2d; v: Vector2d) {.inline, raises: [], tags: [].}</pre></dt> <dd> Translates a point with vector <em>v</em> in place.   </dd> <dt id="sgnArea"><pre id="sgnArea,Point2d,Point2d,Point2d" data-language="nim">proc sgnArea(a, b, c: Point2d): float {.raises: [], tags: [].}</pre></dt> <dd> Computes the signed area of the triangle thru points <em>a</em>,`b` and <em>c</em> result&gt;0.0 for counter clockwise triangle result&lt;0.0 for clockwise triangle This is commonly used to determinate side of a point with respect to a line.   </dd> <dt id="area"><pre id="area,Point2d,Point2d,Point2d" data-language="nim">proc area(a, b, c: Point2d): float {.raises: [], tags: [].}</pre></dt> <dd> Computes the area of the triangle thru points <em>a</em>,`b` and <em>c</em>   </dd> <dt id="closestPoint"><pre id="closestPoint,Point2d,varargs[Point2d]" data-language="nim">proc closestPoint(p: Point2d; pts: varargs[Point2d]): Point2d {.raises: [], tags: [].}</pre></dt> <dd> Returns a point selected from <em>pts</em>, that has the closest euclidean distance to <em>p</em>   </dd> <dt id="normAngle"><pre id="normAngle,float" data-language="nim">proc normAngle(ang: float): float {.raises: [], tags: [].}</pre></dt> <dd> Returns an angle in radians, that is equal to <em>ang</em>, but in the range 0 to &lt;2*PI   </dd> <dt id="degToRad"><pre id="degToRad,float" data-language="nim">proc degToRad(deg: float): float {.inline, raises: [], tags: [].}</pre></dt> <dd> converts <em>deg</em> degrees to radians   </dd> <dt id="radToDeg"><pre id="radToDeg,float" data-language="nim">proc radToDeg(rad: float): float {.inline, raises: [], tags: [].}</pre></dt> <dd> converts <em>rad</em> radians to degrees   </dd> </dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 2006–2017 Andreas Rumpf<br>Licensed under the MIT License.<br>
    <a href="https://nim-lang.org/docs/basic2d.html" class="_attribution-link" target="_blank">https://nim-lang.org/docs/basic2d.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
