
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Ospaths - Nim - W3cubDocs</title>
  
  <meta name="description" content="Include file that implements &#39;osErrorMsg&#39; and friends. Do not import it!Include file that implements &#39;getEnv&#39; and friends. Do not &hellip;">
  <meta name="keywords" content="module, ospaths, -, nim">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/nim/ospaths/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-e0f881b0fce8cbe96f33dadc355b7159d5d2912911231446d60eb8f9caffa802.css">
  <script type="text/javascript" src="/assets/application-8fc46316434047265cd383f02b8e7f434ed7dec4a59f920dd633deef8d488d1b.js"></script>
  <script src="/json/nim.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/nim/" class="_nav-link" title="" style="margin-left:0;">Nim</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _nim">
				
<h1 class="title">Module ospaths</h1>  <p class="module-desc">Include file that implements 'osErrorMsg' and friends. Do not import it!Include file that implements 'getEnv' and friends. Do not import it!</p>  <h2 id="6">Imports</h2> <dl> <a href="../strutils/">strutils</a>, <a href="../winlean/">winlean</a> </dl>  <h2 id="7">Types</h2> <dl> <dt id="ReadEnvEffect"><pre id="ReadEnvEffect">ReadEnvEffect = object of ReadIOEffect</pre></dt> <dd> effect that denotes a read from an environment variable   </dd> <dt id="WriteEnvEffect"><pre id="WriteEnvEffect">WriteEnvEffect = object of WriteIOEffect</pre></dt> <dd> effect that denotes a write to an environment variable   </dd> <dt id="ReadDirEffect"><pre id="ReadDirEffect">ReadDirEffect = object of ReadIOEffect</pre></dt> <dd> effect that denotes a read operation from the directory structure   </dd> <dt id="WriteDirEffect"><pre id="WriteDirEffect">WriteDirEffect = object of WriteIOEffect</pre></dt> <dd> effect that denotes a write operation to the directory structure   </dd> <dt id="OSErrorCode"><pre id="OSErrorCode">OSErrorCode = distinct int32</pre></dt> <dd> Specifies an OS Error Code.   </dd> </dl>  <h2 id="10">Consts</h2> <dl> <dt id="doslikeFileSystem"><pre id="doslikeFileSystem">doslikeFileSystem = true</pre></dt>  <dt id="CurDir"><pre id="CurDir" data-language="nim">CurDir = '.'</pre></dt> <dd> <p>The constant string used by the operating system to refer to the current directory.</p> <p>For example: '.' for POSIX or ':' for the classic Macintosh.</p>   </dd> <dt id="ParDir"><pre id="ParDir" data-language="nim">ParDir = ".."</pre></dt> <dd> <p>The constant string used by the operating system to refer to the parent directory.</p> <p>For example: ".." for POSIX or "::" for the classic Macintosh.</p>   </dd> <dt id="DirSep"><pre id="DirSep" data-language="nim">DirSep = '/'</pre></dt> <dd> The character used by the operating system to separate pathname components, for example, '/' for POSIX or ':' for the classic Macintosh.   </dd> <dt id="AltSep"><pre id="AltSep" data-language="nim">AltSep = '/'</pre></dt> <dd> An alternative character used by the operating system to separate pathname components, or the same as <em>DirSep</em> if only one separator character exists. This is set to '/' on Windows systems where <em>DirSep</em> is a backslash.   </dd> <dt id="PathSep"><pre id="PathSep" data-language="nim">PathSep = ':'</pre></dt> <dd> The character conventionally used by the operating system to separate search patch components (as in PATH), such as ':' for POSIX or ';' for Windows.   </dd> <dt id="FileSystemCaseSensitive"><pre id="FileSystemCaseSensitive">FileSystemCaseSensitive = true</pre></dt> <dd> true if the file system is case sensitive, false otherwise. Used by <em>cmpPaths</em> to compare filenames properly.   </dd> <dt id="ExeExt"><pre id="ExeExt" data-language="nim">ExeExt = ""</pre></dt> <dd> The file extension of native executables. For example: "" for POSIX, "exe" on Windows.   </dd> <dt id="ScriptExt"><pre id="ScriptExt" data-language="nim">ScriptExt = ""</pre></dt> <dd> The file extension of a script file. For example: "" for POSIX, "bat" on Windows.   </dd> <dt id="DynlibFormat"><pre id="DynlibFormat" data-language="nim">DynlibFormat = "lib$1.so"</pre></dt> <dd> The format string to turn a filename into a <span id="dll_1">DLL</span> file (also called <span id="shared-object_1">shared object</span> on some operating systems).   </dd> <dt id="ExtSep"><pre id="ExtSep" data-language="nim">ExtSep = '.'</pre></dt> <dd> The character which separates the base filename from the extension; for example, the '.' in <code>os.nim</code>.   </dd> </dl>  <h2 id="12">Procs</h2> <dl> <dt id="joinPath"><pre id="joinPath,string,string" data-language="nim">proc joinPath(head, tail: string): string {.noSideEffect, gcsafe, extern: "nos$1",
                                       raises: [], tags: [].}</pre></dt> <dd> <p>Joins two directory names to one.</p> <p>For example on Unix:</p> <pre class="listing" data-language="nim">joinPath("usr", "lib")</pre>
<p>results in:</p> <pre class="listing" data-language="nim">"usr/lib"</pre>
<p>If head is the empty string, tail is returned. If tail is the empty string, head is returned with a trailing path separator. If tail starts with a path separator it will be removed when concatenated to head. Other path separators not located on boundaries won't be modified. More examples on Unix:</p> <pre class="listing" data-language="nim">assert joinPath("usr", "") == "usr/"
assert joinPath("", "lib") == "lib"
assert joinPath("", "/lib") == "/lib"
assert joinPath("usr/", "/lib") == "usr/lib"</pre>   </dd> <dt id="joinPath"><pre id="joinPath,varargs[string]" data-language="nim">proc joinPath(parts: varargs[string]): string {.noSideEffect, gcsafe,
    extern: "nos$1OpenArray", raises: [], tags: [].}</pre></dt> <dd> The same as <em>joinPath(head, tail)</em>, but works with any number of directory parts. You need to pass at least one element or the proc will assert in debug builds and crash on release builds.   </dd> <dt id="/"><pre id="/,string,string" data-language="nim">proc `/`(head, tail: string): string {.noSideEffect, raises: [], tags: [].}</pre></dt> <dd> <p>The same as <code>joinPath(head, tail)</code></p> <p>Here are some examples for Unix:</p> <pre class="listing" data-language="nim">assert "usr" / "" == "usr/"
assert "" / "lib" == "lib"
assert "" / "/lib" == "/lib"
assert "usr/" / "/lib" == "usr/lib"</pre>   </dd> <dt id="splitPath"><pre id="splitPath,string" data-language="nim">proc splitPath(path: string): tuple[head, tail: string] {.noSideEffect, gcsafe,
    extern: "nos$1", raises: [], tags: [].}</pre></dt> <dd> <p>Splits a directory into (head, tail), so that <code>head / tail == path</code> (except for edge cases like "/usr").</p> <p>Examples:</p> <pre class="listing" data-language="nim">splitPath("usr/local/bin") -&gt; ("usr/local", "bin")
splitPath("usr/local/bin/") -&gt; ("usr/local/bin", "")
splitPath("bin") -&gt; ("", "bin")
splitPath("/bin") -&gt; ("", "bin")
splitPath("") -&gt; ("", "")</pre>   </dd> <dt id="parentDir"><pre id="parentDir,string" data-language="nim">proc parentDir(path: string): string {.noSideEffect, gcsafe, extern: "nos$1",
                                   raises: [], tags: [].}</pre></dt> <dd> <p>Returns the parent directory of <em>path</em>.</p> <p>This is often the same as the <code>head</code> result of <code>splitPath</code>. If there is no parent, "" is returned.</p>
<p>Example: <code>parentDir("/usr/local/bin") == "/usr/local"</code>.<br>Example: <code>parentDir("/usr/local/bin/") == "/usr/local"</code>.<br></p>   </dd> <dt id="tailDir"><pre id="tailDir,string" data-language="nim">proc tailDir(path: string): string {.noSideEffect, gcsafe, extern: "nos$1", raises: [],
                                 tags: [].}</pre></dt> <dd> Returns the tail part of <em>path</em>..<p>Example: <code>tailDir("/usr/local/bin") == "local/bin"</code>.<br>Example: <code>tailDir("usr/local/bin/") == "local/bin"</code>.<br>Example: <code>tailDir("bin") == ""</code>.<br></p>   </dd> <dt id="isRootDir"><pre id="isRootDir,string" data-language="nim">proc isRootDir(path: string): bool {.noSideEffect, gcsafe, extern: "nos$1", raises: [],
                                 tags: [].}</pre></dt> <dd> Checks whether a given <em>path</em> is a root directory   </dd> <dt id="/../"><pre id="/../,string,string" data-language="nim">proc `/../`(head, tail: string): string {.noSideEffect, raises: [], tags: [].}</pre></dt> <dd> The same as <code>parentDir(head) / tail</code> unless there is no parent directory. Then <code>head / tail</code> is performed instead.   </dd> <dt id="searchExtPos"><pre id="searchExtPos,string" data-language="nim">proc searchExtPos(path: string): int {.raises: [], tags: [].}</pre></dt> <dd> Returns index of the '.' char in <em>path</em> if it signifies the beginning of extension. Returns -1 otherwise.   </dd> <dt id="splitFile"><pre id="splitFile,string" data-language="nim">proc splitFile(path: string): tuple[dir, name, ext: string] {.noSideEffect, gcsafe,
    extern: "nos$1", raises: [], tags: [].}</pre></dt> <dd> <p>Splits a filename into (dir, filename, extension). <em>dir</em> does not end in <em>DirSep</em>. <em>extension</em> includes the leading dot.</p> <p>Example:</p> <pre class="listing" data-language="nim">var (dir, name, ext) = splitFile("usr/local/nimc.html")
assert dir == "usr/local"
assert name == "nimc"
assert ext == ".html"</pre>
<p>If <em>path</em> has no extension, <em>ext</em> is the empty string. If <em>path</em> has no directory component, <em>dir</em> is the empty string. If <em>path</em> has no filename component, <em>name</em> and <em>ext</em> are empty strings.</p>   </dd> <dt id="extractFilename"><pre id="extractFilename,string" data-language="nim">proc extractFilename(path: string): string {.noSideEffect, gcsafe, extern: "nos$1",
    raises: [], tags: [].}</pre></dt> <dd> Extracts the filename of a given <em>path</em>. This is the same as <code>name &amp; ext</code> from <code>splitFile(path)</code>.   </dd> <dt id="changeFileExt"><pre id="changeFileExt,string,string" data-language="nim">proc changeFileExt(filename, ext: string): string {.noSideEffect, gcsafe,
    extern: "nos$1", raises: [], tags: [].}</pre></dt> <dd> <p>Changes the file extension to <em>ext</em>.</p> <p>If the <em>filename</em> has no extension, <em>ext</em> will be added. If <em>ext</em> == "" then any extension is removed. <em>Ext</em> should be given without the leading '.', because some filesystems may use a different character. (Although I know of none such beast.)</p>   </dd> <dt id="addFileExt"><pre id="addFileExt,string,string" data-language="nim">proc addFileExt(filename, ext: string): string {.noSideEffect, gcsafe, extern: "nos$1",
    raises: [], tags: [].}</pre></dt> <dd> <p>Adds the file extension <em>ext</em> to <em>filename</em>, unless <em>filename</em> already has an extension.</p> <p><em>Ext</em> should be given without the leading '.', because some filesystems may use a different character. (Although I know of none such beast.)</p>   </dd> <dt id="cmpPaths"><pre id="cmpPaths,string,string" data-language="nim">proc cmpPaths(pathA, pathB: string): int {.noSideEffect, gcsafe, extern: "nos$1",
                                      raises: [], tags: [].}</pre></dt> <dd> <p>Compares two paths.</p> <p>On a case-sensitive filesystem this is done case-sensitively otherwise case-insensitively. Returns:</p> <p>0 iff pathA == pathB<br>&lt; 0 iff pathA &lt; pathB<br>&gt; 0 iff pathA &gt; pathB<br></p>   </dd> <dt id="isAbsolute"><pre id="isAbsolute,string" data-language="nim">proc isAbsolute(path: string): bool {.gcsafe, noSideEffect, extern: "nos$1", raises: [],
                                  tags: [].}</pre></dt> <dd> <p>Checks whether a given <em>path</em> is absolute.</p> <p>On Windows, network paths are considered absolute too.</p>   </dd> <dt id="unixToNativePath"><pre id="unixToNativePath,string,string" data-language="nim">proc unixToNativePath(path: string; drive = ""): string {.noSideEffect, gcsafe,
    extern: "nos$1", raises: [], tags: [].}</pre></dt> <dd> <p>Converts an UNIX-like path to a native one.</p> <p>On an UNIX system this does nothing. Else it converts '/', '.', '..' to the appropriate things.</p> <p>On systems with a concept of "drives", <em>drive</em> is used to determine which drive label to use during absolute path conversion. <em>drive</em> defaults to the drive of the current working directory, and is ignored on systems that do not have a concept of "drives".</p>   </dd> <dt id="osErrorMsg"><pre id="osErrorMsg," data-language="nim">proc osErrorMsg(): string {.gcsafe, extern: "nos$1", deprecated, raises: [], tags: [].}</pre></dt> <dd> <p>Retrieves the operating system's error flag, <code>errno</code>. On Windows <code>GetLastError</code> is checked before <code>errno</code>. Returns "" if no error occurred.</p> <p><strong>Deprecated since version 0.9.4</strong>: use the other <code>osErrorMsg</code> proc.</p>   </dd> <dt id="raiseOSError"><pre id="raiseOSError,string" data-language="nim">proc raiseOSError(msg: string = "") {.noinline, gcsafe, extern: "nos$1", deprecated,
                                 raises: [OSError], tags: [].}</pre></dt> <dd> <p>raises an OSError exception with the given message <code>msg</code>. If <code>msg == ""</code>, the operating system's error flag (<code>errno</code>) is converted to a readable error message. On Windows <code>GetLastError</code> is checked before <code>errno</code>. If no error flag is set, the message <code>unknown OS error</code> is used.</p> <p><strong>Deprecated since version 0.9.4</strong>: use the other <code>raiseOSError</code> proc.</p>   </dd> <dt id="=="><pre id="==,OSErrorCode,OSErrorCode" data-language="nim">proc `==`(err1, err2: OSErrorCode): bool {.borrow.}</pre></dt>  <dt id="$"><pre id="$,OSErrorCode" data-language="nim">proc `$`(err: OSErrorCode): string {.borrow.}</pre></dt>  <dt id="osErrorMsg"><pre id="osErrorMsg,OSErrorCode" data-language="nim">proc osErrorMsg(errorCode: OSErrorCode): string {.raises: [], tags: [].}</pre></dt> <dd> <p>Converts an OS error code into a human readable string.</p> <p>The error code can be retrieved using the <code>osLastError</code> proc.</p> <p>If conversion fails, or <code>errorCode</code> is <code>0</code> then <code>""</code> will be returned.</p> <p>On Windows, the <code>-d:useWinAnsi</code> compilation flag can be used to make this procedure use the non-unicode Win API calls to retrieve the message.</p>   </dd> <dt id="raiseOSError"><pre id="raiseOSError,OSErrorCode,string" data-language="nim">proc raiseOSError(errorCode: OSErrorCode; additionalInfo = "") {.noinline,
    raises: [OSError], tags: [].}</pre></dt> <dd> <p>Raises an <code>OSError</code> exception. The <code>errorCode</code> will determine the message, <code>osErrorMsg</code> will be used to get this message.</p> <p>The error code can be retrieved using the <code>osLastError</code> proc.</p> <p>If the error code is <code>0</code> or an error message could not be retrieved, the message <code>unknown OS error</code> will be used.</p>   </dd> <dt id="osLastError"><pre id="osLastError," data-language="nim">proc osLastError(): OSErrorCode {.raises: [], tags: [].}</pre></dt> <dd> <p>Retrieves the last operating system error code.</p> <p>This procedure is useful in the event when an OS call fails. In that case this procedure will return the error code describing the reason why the OS call failed. The <code>OSErrorMsg</code> procedure can then be used to convert this code into a string.</p> <p><strong>Warning</strong>: The behaviour of this procedure varies between Windows and POSIX systems. On Windows some OS calls can reset the error code to <code>0</code> causing this procedure to return <code>0</code>. It is therefore advised to call this procedure immediately after an OS call fails. On POSIX systems this is not a problem.</p>   </dd> <dt id="getEnv"><pre id="getEnv,string" data-language="nim">proc getEnv(key: string): TaintedString {.tags: [ReadEnvEffect], raises: [].}</pre></dt> <dd> <p>Returns the value of the <span id="environment-variable_1">environment variable</span> named <em>key</em>.</p> <p>If the variable does not exist, "" is returned. To distinguish whether a variable exists or it's value is just "", call <em>existsEnv(key)</em>.</p>   </dd> <dt id="existsEnv"><pre id="existsEnv,string" data-language="nim">proc existsEnv(key: string): bool {.tags: [ReadEnvEffect], raises: [].}</pre></dt> <dd> Checks whether the environment variable named <em>key</em> exists. Returns true if it exists, false otherwise.   </dd> <dt id="putEnv"><pre id="putEnv,string,string" data-language="nim">proc putEnv(key, val: string) {.tags: [WriteEnvEffect], raises: [OSError].}</pre></dt> <dd> Sets the value of the <span id="environment-variable_2">environment variable</span> named <em>key</em> to <em>val</em>. If an error occurs, <em>EInvalidEnvVar</em> is raised.   </dd> <dt id="getHomeDir"><pre id="getHomeDir," data-language="nim">proc getHomeDir(): string {.gcsafe, extern: "nos$1",
                         tags: [ReadEnvEffect, ReadIOEffect], raises: [].}</pre></dt> <dd> <p>Returns the home directory of the current user.</p> <p>This proc is wrapped by the expandTilde proc for the convenience of processing paths coming from user configuration files.</p>   </dd> <dt id="getConfigDir"><pre id="getConfigDir," data-language="nim">proc getConfigDir(): string {.gcsafe, extern: "nos$1",
                           tags: [ReadEnvEffect, ReadIOEffect], raises: [].}</pre></dt> <dd> <p>Returns the config directory of the current user for applications.</p> <p>On non-Windows OSs, this proc conforms to the XDG Base Directory spec. Thus, this proc returns the value of the XDG_CONFIG_DIR environment variable if it is set, and returns the default configuration directory, "~/.config/", otherwise.</p> <p>An OS-dependent trailing slash is always present at the end of the returned string; <em>\</em> on Windows and <em>/</em> on all other OSs.</p>   </dd> <dt id="getTempDir"><pre id="getTempDir," data-language="nim">proc getTempDir(): string {.gcsafe, extern: "nos$1",
                         tags: [ReadEnvEffect, ReadIOEffect], raises: [].}</pre></dt> <dd> <p>Returns the temporary directory of the current user for applications to save temporary files in.</p> <p><strong>Please do not use this</strong>: On Android, it currently returns <code>getHomeDir()</code>, and on other Unix based systems it can cause security problems too. That said, you can override this implementation by adding <code>-d:tempDir=mytempname</code> to your compiler invokation.</p>   </dd> <dt id="expandTilde"><pre id="expandTilde,string" data-language="nim">proc expandTilde(path: string): string {.tags: [ReadEnvEffect, ReadIOEffect],
                                     raises: [].}</pre></dt> <dd> <p>Expands a path starting with <code>~/</code> to a full path.</p> <p>If <em>path</em> starts with the tilde character and is followed by <em>/</em> or <em>\</em> this proc will return the reminder of the path appended to the result of the getHomeDir() proc, otherwise the input path will be returned without modification.</p> <p>The behaviour of this proc is the same on the Windows platform despite not having this convention. Example:</p> <pre class="listing" data-language="nim">let configFile = expandTilde("~" / "appname.cfg")
echo configFile
# --&gt; C:\Users\amber\appname.cfg</pre>   </dd> </dl>  <h2 id="14">Iterators</h2> <dl> <dt id="parentDirs"><pre id="parentDirs.i,string" data-language="nim">iterator parentDirs(path: string; fromRoot = false; inclusive = true): string {.
    raises: [], tags: [].}</pre></dt> <dd> <p>Walks over all parent directories of a given <em>path</em></p> <p>If <em>fromRoot</em> is set, the traversal will start from the file system root diretory. If <em>inclusive</em> is set, the original argument will be included in the traversal.</p> <p>Relative paths won't be expanded by this proc. Instead, it will traverse only the directories appearing in the relative path.</p>   </dd> <dt id="envPairs"><pre id="envPairs.i," data-language="nim">iterator envPairs(): tuple[key, value: TaintedString] {.tags: [ReadEnvEffect],
    raises: [].}</pre></dt> <dd> Iterate over all <span id="environments-variables_1">environments variables</span>. In the first component of the tuple is the name of the current variable stored, in the second its value.   </dd> </dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 2006–2017 Andreas Rumpf<br>Licensed under the MIT License.<br>
    <a href="https://nim-lang.org/docs/ospaths.html" class="_attribution-link" target="_blank">https://nim-lang.org/docs/ospaths.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
