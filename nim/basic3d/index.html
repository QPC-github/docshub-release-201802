
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Basic3d - Nim - W3cubDocs</title>
  
  <meta name="description" content="Basic 3d support with vectors, points, matrices and some basic utilities. Vectors are implemented as direction vectors, ie. when transformed with a &hellip;">
  <meta name="keywords" content="module, basic, d, -, nim">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/nim/basic3d/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-e0f881b0fce8cbe96f33dadc355b7159d5d2912911231446d60eb8f9caffa802.css">
  <script type="text/javascript" src="/assets/application-8fc46316434047265cd383f02b8e7f434ed7dec4a59f920dd633deef8d488d1b.js"></script>
  <script src="/json/nim.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/nim/" class="_nav-link" title="" style="margin-left:0;">Nim</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _nim">
				
<h1 class="title">Module basic3d</h1>  
<p>Basic 3d support with vectors, points, matrices and some basic utilities. Vectors are implemented as direction vectors, ie. when transformed with a matrix the translation part of matrix is ignored. The coordinate system used is right handed, because its compatible with 2d coordinate system (rotation around zaxis equals 2d rotation). Operators <em>+</em> , <em>-</em> , <em>*</em> , <em>/</em> , <em>+=</em> , <em>-=</em> , <em>*=</em> and <em>/=</em> are implemented for vectors and scalars.</p> <p>Quick start example:</p> <pre class="listing" data-language="nim"># Create a matrix which first rotates, then scales and at last translates

var m:Matrix3d=rotate(PI,vector3d(1,1,2.5)) &amp; scale(2.0) &amp; move(100.0,200.0,300.0)

# Create a 3d point at (100,150,200) and a vector (5,2,3)

var pt:Point3d=point3d(100.0,150.0,200.0)

var vec:Vector3d=vector3d(5.0,2.0,3.0)


pt &amp;= m # transforms pt in place

var pt2:Point3d=pt &amp; m #concatenates pt with m and returns a new point

var vec2:Vector3d=vec &amp; m #concatenates vec with m and returns a new vector</pre>  <h2 id="6">Imports</h2> <dl> <a href="../math/">math</a>, <a href="../strutils/">strutils</a>, <a href="../times/">times</a> </dl>  <h2 id="7">Types</h2> <dl> <dt id="Matrix3d"><pre id="Matrix3d" data-language="nim">Matrix3d = object
  ax*, ay*, az*, aw*, bx*, by*, bz*, bw*, cx*, cy*, cz*, cw*, tx*, ty*, tz*, tw*: float</pre></dt> <dd> Implements a row major 3d matrix, which means transformations are applied the order they are concatenated. This matrix is stored as an 4x4 matrix: [ ax ay az aw ] [ bx by bz bw ] [ cx cy cz cw ] [ tx ty tz tw ]   </dd> <dt id="Point3d"><pre id="Point3d" data-language="nim">Point3d = object
  x*, y*, z*: float</pre></dt> <dd> Implements a non-homogeneous 3d point stored as an <em>x</em> , <em>y</em> and <em>z</em> coordinate.   </dd> <dt id="Vector3d"><pre id="Vector3d" data-language="nim">Vector3d = object
  x*, y*, z*: float</pre></dt> <dd> Implements a 3d <strong>direction vector</strong> stored as an <em>x</em> , <em>y</em> and <em>z</em> coordinate. Direction vector means, that when transforming a vector with a matrix, the translational part of the matrix is ignored.   </dd> </dl>  <h2 id="9">Lets</h2> <dl> <dt id="IDMATRIX"><pre id="IDMATRIX" data-language="nim">IDMATRIX: Matrix3d = matrix3d(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0,
                           0.0, 0.0, 1.0)</pre></dt> <dd> Quick access to a 3d identity matrix   </dd> <dt id="ORIGO"><pre id="ORIGO" data-language="nim">ORIGO: Point3d = point3d(0.0, 0.0, 0.0)</pre></dt> <dd> Quick access to point (0,0)   </dd> <dt id="XAXIS"><pre id="XAXIS" data-language="nim">XAXIS: Vector3d = vector3d(1.0, 0.0, 0.0)</pre></dt> <dd> Quick access to an 3d x-axis unit vector   </dd> <dt id="YAXIS"><pre id="YAXIS" data-language="nim">YAXIS: Vector3d = vector3d(0.0, 1.0, 0.0)</pre></dt> <dd> Quick access to an 3d y-axis unit vector   </dd> <dt id="ZAXIS"><pre id="ZAXIS" data-language="nim">ZAXIS: Vector3d = vector3d(0.0, 0.0, 1.0)</pre></dt> <dd> Quick access to an 3d z-axis unit vector   </dd> </dl>  <h2 id="12">Procs</h2> <dl> <dt id="setElements"><pre id="setElements,Matrix3d,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float" data-language="nim">proc setElements(t: var Matrix3d; ax, ay, az, aw, bx, by, bz, bw, cx, cy, cz, cw, tx, ty, tz, tw: float) {.
    inline, raises: [], tags: [].}</pre></dt> <dd> Sets arbitrary elements in an exisitng matrix.   </dd> <dt id="matrix3d"><pre id="matrix3d,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float,float" data-language="nim">proc matrix3d(ax, ay, az, aw, bx, by, bz, bw, cx, cy, cz, cw, tx, ty, tz, tw: float): Matrix3d {.
    noInit, raises: [], tags: [].}</pre></dt> <dd> Creates a new 4x4 3d transformation matrix. <em>ax</em> , <em>ay</em> , <em>az</em> is the local x axis. <em>bx</em> , <em>by</em> , <em>bz</em> is the local y axis. <em>cx</em> , <em>cy</em> , <em>cz</em> is the local z axis. <em>tx</em> , <em>ty</em> , <em>tz</em> is the translation.   </dd> <dt id="&amp;"><pre id="&amp;,Matrix3d,Matrix3d" data-language="nim">proc `&amp;`(a, b: Matrix3d): Matrix3d {.noinit, raises: [], tags: [].}</pre></dt> <dd> Concatenates matrices returning a new matrix.   </dd> <dt id="scale"><pre id="scale,float" data-language="nim">proc scale(s: float): Matrix3d {.noInit, raises: [], tags: [].}</pre></dt> <dd> Returns a new scaling matrix.   </dd> <dt id="scale"><pre id="scale,float,Point3d" data-language="nim">proc scale(s: float; org: Point3d): Matrix3d {.noInit, raises: [], tags: [].}</pre></dt> <dd> Returns a new scaling matrix using, <em>org</em> as scale origin.   </dd> <dt id="stretch"><pre id="stretch,float,float,float" data-language="nim">proc stretch(sx, sy, sz: float): Matrix3d {.noInit, raises: [], tags: [].}</pre></dt> <dd> Returns new a stretch matrix, which is a scale matrix with non uniform scale in x,y and z.   </dd> <dt id="stretch"><pre id="stretch,float,float,float,Point3d" data-language="nim">proc stretch(sx, sy, sz: float; org: Point3d): Matrix3d {.noInit, raises: [], tags: [].}</pre></dt> <dd> Returns a new stretch matrix, which is a scale matrix with non uniform scale in x,y and z. <em>org</em> is used as stretch origin.   </dd> <dt id="move"><pre id="move,float,float,float" data-language="nim">proc move(dx, dy, dz: float): Matrix3d {.noInit, raises: [], tags: [].}</pre></dt> <dd> Returns a new translation matrix.   </dd> <dt id="move"><pre id="move,Vector3d" data-language="nim">proc move(v: Vector3d): Matrix3d {.noInit, raises: [], tags: [].}</pre></dt> <dd> Returns a new translation matrix from a vector.   </dd> <dt id="rotate"><pre id="rotate,float,Vector3d" data-language="nim">proc rotate(angle: float; axis: Vector3d): Matrix3d {.noInit,
    raises: [Exception, DivByZeroError], tags: [RootEffect].}</pre></dt> <dd> Creates a rotation matrix that rotates <em>angle</em> radians over <em>axis</em>, which passes through origo.   </dd> <dt id="rotate"><pre id="rotate,float,Point3d,Vector3d" data-language="nim">proc rotate(angle: float; org: Point3d; axis: Vector3d): Matrix3d {.noInit,
    raises: [Exception, DivByZeroError], tags: [RootEffect].}</pre></dt> <dd> Creates a rotation matrix that rotates <em>angle</em> radians over <em>axis</em>, which passes through <em>org</em>.   </dd> <dt id="rotateX"><pre id="rotateX,float" data-language="nim">proc rotateX(angle: float): Matrix3d {.noInit, raises: [], tags: [].}</pre></dt> <dd> Creates a matrix that rotates around the x-axis with <em>angle</em> radians, which is also called a 'roll' matrix.   </dd> <dt id="rotateY"><pre id="rotateY,float" data-language="nim">proc rotateY(angle: float): Matrix3d {.noInit, raises: [], tags: [].}</pre></dt> <dd> Creates a matrix that rotates around the y-axis with <em>angle</em> radians, which is also called a 'pitch' matrix.   </dd> <dt id="rotateZ"><pre id="rotateZ,float" data-language="nim">proc rotateZ(angle: float): Matrix3d {.noInit, raises: [], tags: [].}</pre></dt> <dd> Creates a matrix that rotates around the z-axis with <em>angle</em> radians, which is also called a 'yaw' matrix.   </dd> <dt id="isUniform"><pre id="isUniform,Matrix3d,float" data-language="nim">proc isUniform(m: Matrix3d; tol = 1e-006): bool {.raises: [], tags: [].}</pre></dt> <dd> Checks if the transform is uniform, that is perpendicular axes of equal length, which means (for example) it cannot transform a sphere into an ellipsoid. <em>tol</em> is used as tolerance for both equal length comparison and perpendicular comparison.   </dd> <dt id="mirror"><pre id="mirror,Vector3d" data-language="nim">proc mirror(planeperp: Vector3d): Matrix3d {.noInit,
    raises: [Exception, DivByZeroError], tags: [RootEffect].}</pre></dt> <dd> Creates a matrix that mirrors over the plane that has <em>planeperp</em> as normal, and passes through origo. <em>planeperp</em> does not need to be normalized.   </dd> <dt id="mirror"><pre id="mirror,Point3d,Vector3d" data-language="nim">proc mirror(org: Point3d; planeperp: Vector3d): Matrix3d {.noInit,
    raises: [Exception, DivByZeroError], tags: [RootEffect].}</pre></dt> <dd> Creates a matrix that mirrors over the plane that has <em>planeperp</em> as normal, and passes through <em>org</em>. <em>planeperp</em> does not need to be normalized.   </dd> <dt id="determinant"><pre id="determinant,Matrix3d" data-language="nim">proc determinant(m: Matrix3d): float {.raises: [], tags: [].}</pre></dt> <dd> Computes the determinant of matrix <em>m</em>.   </dd> <dt id="inverse"><pre id="inverse,Matrix3d" data-language="nim">proc inverse(m: Matrix3d): Matrix3d {.noInit, raises: [DivByZeroError], tags: [].}</pre></dt> <dd> Computes the inverse of matrix <em>m</em>. If the matrix determinant is zero, thus not invertible, a EDivByZero will be raised.   </dd> <dt id="equals"><pre id="equals,Matrix3d,Matrix3d,float" data-language="nim">proc equals(m1: Matrix3d; m2: Matrix3d; tol = 1e-006): bool {.raises: [], tags: [].}</pre></dt> <dd> Checks if all elements of <em>m1`and `m2</em> is equal within a given tolerance <em>tol</em>.   </dd> <dt id="=~"><pre id="=~,Matrix3d,Matrix3d" data-language="nim">proc `=~`(m1, m2: Matrix3d): bool {.raises: [], tags: [].}</pre></dt> <dd> Checks if <em>m1</em> and <em>m2</em> is approximately equal, using a tolerance of 1e-6.   </dd> <dt id="transpose"><pre id="transpose,Matrix3d" data-language="nim">proc transpose(m: Matrix3d): Matrix3d {.noInit, raises: [], tags: [].}</pre></dt> <dd> Returns the transpose of <em>m</em>   </dd> <dt id="getXAxis"><pre id="getXAxis,Matrix3d" data-language="nim">proc getXAxis(m: Matrix3d): Vector3d {.noInit, raises: [], tags: [].}</pre></dt> <dd> Gets the local x axis of <em>m</em>   </dd> <dt id="getYAxis"><pre id="getYAxis,Matrix3d" data-language="nim">proc getYAxis(m: Matrix3d): Vector3d {.noInit, raises: [], tags: [].}</pre></dt> <dd> Gets the local y axis of <em>m</em>   </dd> <dt id="getZAxis"><pre id="getZAxis,Matrix3d" data-language="nim">proc getZAxis(m: Matrix3d): Vector3d {.noInit, raises: [], tags: [].}</pre></dt> <dd> Gets the local y axis of <em>m</em>   </dd> <dt id="$"><pre id="$,Matrix3d" data-language="nim">proc `$`(m: Matrix3d): string {.raises: [], tags: [].}</pre></dt> <dd> String representation of <em>m</em>   </dd> <dt id="apply"><pre id="apply,Matrix3d,float,float,float" data-language="nim">proc apply(m: Matrix3d; x, y, z: var float; translate = false) {.raises: [], tags: [].}</pre></dt> <dd> Applies transformation <em>m</em> onto <em>x</em> , <em>y</em> , <em>z</em> , optionally using the translation part of the matrix.   </dd> <dt id="vector3d"><pre id="vector3d,float,float,float" data-language="nim">proc vector3d(x, y, z: float): Vector3d {.noInit, inline, raises: [], tags: [].}</pre></dt> <dd> Returns a new 3d vector (<em>x</em>,`y`,`z`)   </dd> <dt id="len"><pre id="len,Vector3d" data-language="nim">proc len(v: Vector3d): float {.raises: [], tags: [].}</pre></dt> <dd> Returns the length of the vector <em>v</em>.   </dd> <dt id="len="><pre id="len=,Vector3d,float" data-language="nim">proc len=(v: var Vector3d; newlen: float) {.noInit, raises: [], tags: [].}</pre></dt> <dd> Sets the length of the vector, keeping its direction. If the vector has zero length before changing it's length, an arbitrary vector of the requested length is returned.   </dd> <dt id="sqrLen"><pre id="sqrLen,Vector3d" data-language="nim">proc sqrLen(v: Vector3d): float {.inline, raises: [], tags: [].}</pre></dt> <dd> Computes the squared length of the vector, which is faster than computing the absolute length.   </dd> <dt id="$"><pre id="$,Vector3d" data-language="nim">proc `$`(v: Vector3d): string {.raises: [], tags: [].}</pre></dt> <dd> String representation of <em>v</em>   </dd> <dt id="&amp;"><pre id="&amp;,Vector3d,Matrix3d" data-language="nim">proc `&amp;`(v: Vector3d; m: Matrix3d): Vector3d {.noInit, raises: [], tags: [].}</pre></dt> <dd> Concatenate vector <em>v</em> with a transformation matrix. Transforming a vector ignores the translational part of the matrix.   </dd> <dt id="&amp;="><pre id="&amp;=,Vector3d,Matrix3d" data-language="nim">proc `&amp;=`(v: var Vector3d; m: Matrix3d) {.noInit, raises: [], tags: [].}</pre></dt> <dd> Applies transformation <em>m</em> onto <em>v</em> in place. Transforming a vector ignores the translational part of the matrix.   </dd> <dt id="transformNorm"><pre id="transformNorm,Vector3d,Matrix3d" data-language="nim">proc transformNorm(v: var Vector3d; m: Matrix3d) {.raises: [DivByZeroError], tags: [].}</pre></dt> <dd> Applies a normal direction transformation <em>m</em> onto <em>v</em> in place. The resulting vector is <em>not</em> normalized. Transforming a vector ignores the translational part of the matrix. If the matrix is not invertible (determinant=0), an EDivByZero will be raised.   </dd> <dt id="transformInv"><pre id="transformInv,Vector3d,Matrix3d" data-language="nim">proc transformInv(v: var Vector3d; m: Matrix3d) {.raises: [DivByZeroError], tags: [].}</pre></dt> <dd> Applies the inverse of <em>m</em> on vector <em>v</em>. Transforming a vector ignores the translational part of the matrix. Transforming a vector ignores the translational part of the matrix. If the matrix is not invertible (determinant=0), an EDivByZero will be raised.   </dd> <dt id="transformNormInv"><pre id="transformNormInv,Vector3d,Matrix3d" data-language="nim">proc transformNormInv(vec: var Vector3d; m: Matrix3d) {.raises: [], tags: [].}</pre></dt> <dd> Applies an inverse normal direction transformation <em>m</em> onto <em>v</em> in place. This is faster than creating an inverse matrix and transformNorm(...) it. Transforming a vector ignores the translational part of the matrix.   </dd> <dt id="tryNormalize"><pre id="tryNormalize,Vector3d" data-language="nim">proc tryNormalize(v: var Vector3d): bool {.raises: [], tags: [].}</pre></dt> <dd> Modifies <em>v</em> to have a length of 1.0, keeping its angle. If <em>v</em> has zero length (and thus no angle), it is left unmodified and false is returned, otherwise true is returned.   </dd> <dt id="normalize"><pre id="normalize,Vector3d" data-language="nim">proc normalize(v: var Vector3d) {.inline, raises: [DivByZeroError], tags: [].}</pre></dt> <dd> Modifies <em>v</em> to have a length of 1.0, keeping its angle. If <em>v</em> has zero length, an EDivByZero will be raised.   </dd> <dt id="rotate"><pre id="rotate,Vector3d,float,Vector3d" data-language="nim">proc rotate(vec: var Vector3d; angle: float; axis: Vector3d) {.raises: [DivByZeroError],
    tags: [].}</pre></dt> <dd> Rotates <em>vec</em> in place, with <em>angle</em> radians over <em>axis</em>, which passes through origo.   </dd> <dt id="scale"><pre id="scale,Vector3d,float" data-language="nim">proc scale(v: var Vector3d; s: float) {.raises: [], tags: [].}</pre></dt> <dd> Scales the vector in place with factor <em>s</em>   </dd> <dt id="stretch"><pre id="stretch,Vector3d,float,float,float" data-language="nim">proc stretch(v: var Vector3d; sx, sy, sz: float) {.raises: [], tags: [].}</pre></dt> <dd> Scales the vector non uniformly with factors <em>sx</em> , <em>sy</em> , <em>sz</em>   </dd> <dt id="mirror"><pre id="mirror,Vector3d,Vector3d" data-language="nim">proc mirror(v: var Vector3d; planeperp: Vector3d) {.raises: [DivByZeroError], tags: [].}</pre></dt> <dd> Computes the mirrored vector of <em>v</em> over the plane that has <em>planeperp</em> as normal direction. <em>planeperp</em> does not need to be normalized.   </dd> <dt id="-"><pre id="-,Vector3d" data-language="nim">proc `-`(v: Vector3d): Vector3d {.raises: [], tags: [].}</pre></dt> <dd> Negates a vector   </dd> <dt id="+"><pre id="+,Vector3d,Vector3d" data-language="nim">proc `+`(a135939, b135941: Vector3d): Vector3d {.inline, noInit, raises: [], tags: [].}</pre></dt>  <dt id="+"><pre id="+,Vector3d,float" data-language="nim">proc `+`(a135943: Vector3d; b135945: float): Vector3d {.inline, noInit, raises: [],
    tags: [].}</pre></dt>  <dt id="+"><pre id="+,float,Vector3d" data-language="nim">proc `+`(a135947: float; b135949: Vector3d): Vector3d {.inline, noInit, raises: [],
    tags: [].}</pre></dt>  <dt id="-"><pre id="-,Vector3d,Vector3d" data-language="nim">proc `-`(a135960, b135962: Vector3d): Vector3d {.inline, noInit, raises: [], tags: [].}</pre></dt>  <dt id="-"><pre id="-,Vector3d,float" data-language="nim">proc `-`(a135964: Vector3d; b135966: float): Vector3d {.inline, noInit, raises: [],
    tags: [].}</pre></dt>  <dt id="-"><pre id="-,float,Vector3d" data-language="nim">proc `-`(a135968: float; b135970: Vector3d): Vector3d {.inline, noInit, raises: [],
    tags: [].}</pre></dt>  <dt id="*"><pre id="*,Vector3d,Vector3d" data-language="nim">proc `*`(a135981, b135983: Vector3d): Vector3d {.inline, noInit, raises: [], tags: [].}</pre></dt>  <dt id="*"><pre id="*,Vector3d,float" data-language="nim">proc `*`(a135985: Vector3d; b135987: float): Vector3d {.inline, noInit, raises: [],
    tags: [].}</pre></dt>  <dt id="*"><pre id="*,float,Vector3d" data-language="nim">proc `*`(a135989: float; b135991: Vector3d): Vector3d {.inline, noInit, raises: [],
    tags: [].}</pre></dt>  <dt id="/"><pre id="/,Vector3d,Vector3d" data-language="nim">proc `/`(a136002, b136004: Vector3d): Vector3d {.inline, noInit, raises: [], tags: [].}</pre></dt>  <dt id="/"><pre id="/,Vector3d,float" data-language="nim">proc `/`(a136006: Vector3d; b136008: float): Vector3d {.inline, noInit, raises: [],
    tags: [].}</pre></dt>  <dt id="/"><pre id="/,float,Vector3d" data-language="nim">proc `/`(a136010: float; b136012: Vector3d): Vector3d {.inline, noInit, raises: [],
    tags: [].}</pre></dt>  <dt id="+="><pre id="+=,Vector3d,Vector3d" data-language="nim">proc `+=`(a136023: var Vector3d; b136025: Vector3d) {.inline, raises: [], tags: [].}</pre></dt>  <dt id="+="><pre id="+=,Vector3d,float" data-language="nim">proc `+=`(a136027: var Vector3d; b136029: float) {.inline, raises: [], tags: [].}</pre></dt>  <dt id="-="><pre id="-=,Vector3d,Vector3d" data-language="nim">proc `-=`(a136097: var Vector3d; b136099: Vector3d) {.inline, raises: [], tags: [].}</pre></dt>  <dt id="-="><pre id="-=,Vector3d,float" data-language="nim">proc `-=`(a136101: var Vector3d; b136103: float) {.inline, raises: [], tags: [].}</pre></dt>  <dt id="*="><pre id="*=,Vector3d,Vector3d" data-language="nim">proc `*=`(a136171: var Vector3d; b136173: Vector3d) {.inline, raises: [], tags: [].}</pre></dt>  <dt id="*="><pre id="*=,Vector3d,float" data-language="nim">proc `*=`(a136175: var Vector3d; b136177: float) {.inline, raises: [], tags: [].}</pre></dt>  <dt id="/="><pre id="/=,Vector3d,Vector3d" data-language="nim">proc `/=`(a136245: var Vector3d; b136247: Vector3d) {.inline, raises: [], tags: [].}</pre></dt>  <dt id="/="><pre id="/=,Vector3d,float" data-language="nim">proc `/=`(a136249: var Vector3d; b136251: float) {.inline, raises: [], tags: [].}</pre></dt>  <dt id="dot"><pre id="dot,Vector3d,Vector3d" data-language="nim">proc dot(v1, v2: Vector3d): float {.inline, raises: [], tags: [].}</pre></dt> <dd> Computes the dot product of two vectors. Returns 0.0 if the vectors are perpendicular.   </dd> <dt id="cross"><pre id="cross,Vector3d,Vector3d" data-language="nim">proc cross(v1, v2: Vector3d): Vector3d {.inline, raises: [], tags: [].}</pre></dt> <dd> Computes the cross product of two vectors. The result is a vector which is perpendicular to the plane of <em>v1</em> and <em>v2</em>, which means cross(xaxis,yaxis)=zaxis. The magnitude of the result is zero if the vectors are colinear.   </dd> <dt id="equals"><pre id="equals,Vector3d,Vector3d,float" data-language="nim">proc equals(v1, v2: Vector3d; tol = 1e-006): bool {.raises: [], tags: [].}</pre></dt> <dd> Checks if two vectors approximately equals with a tolerance.   </dd> <dt id="=~"><pre id="=~,Vector3d,Vector3d" data-language="nim">proc `=~`(v1, v2: Vector3d): bool {.raises: [], tags: [].}</pre></dt> <dd> Checks if two vectors approximately equals with a hardcoded tolerance 1e-6   </dd> <dt id="angleTo"><pre id="angleTo,Vector3d,Vector3d" data-language="nim">proc angleTo(v1, v2: Vector3d): float {.raises: [], tags: [].}</pre></dt> <dd> Returns the smallest angle between v1 and v2, which is in range 0-PI   </dd> <dt id="arbitraryAxis"><pre id="arbitraryAxis,Vector3d" data-language="nim">proc arbitraryAxis(norm: Vector3d): Matrix3d {.noInit, raises: [DivByZeroError],
    tags: [].}</pre></dt> <dd> Computes the rotation matrix that would transform world z vector into <em>norm</em>. The inverse of this matrix is useful to transform a planar 3d object to 2d space. This is the same algorithm used to interpret DXF and DWG files.   </dd> <dt id="bisect"><pre id="bisect,Vector3d,Vector3d" data-language="nim">proc bisect(v1, v2: Vector3d): Vector3d {.noInit, raises: [DivByZeroError], tags: [].}</pre></dt> <dd> Computes the bisector between v1 and v2 as a normalized vector. If one of the input vectors has zero length, a normalized version of the other is returned. If both input vectors has zero length, an arbitrary normalized vector <em>v1</em> is returned.   </dd> <dt id="point3d"><pre id="point3d,float,float,float" data-language="nim">proc point3d(x, y, z: float): Point3d {.noInit, inline, raises: [], tags: [].}</pre></dt> <dd> Returns a new 4d point (<em>x</em>,`y`,`z`)   </dd> <dt id="sqrDist"><pre id="sqrDist,Point3d,Point3d" data-language="nim">proc sqrDist(a, b: Point3d): float {.raises: [], tags: [].}</pre></dt> <dd> Computes the squared distance between <em>a`and `b</em>   </dd> <dt id="dist"><pre id="dist,Point3d,Point3d" data-language="nim">proc dist(a, b: Point3d): float {.inline, raises: [], tags: [].}</pre></dt> <dd> Computes the absolute distance between <em>a`and `b</em>   </dd> <dt id="$"><pre id="$,Point3d" data-language="nim">proc `$`(p: Point3d): string {.raises: [], tags: [].}</pre></dt> <dd> String representation of <em>p</em>   </dd> <dt id="&amp;"><pre id="&amp;,Point3d,Matrix3d" data-language="nim">proc `&amp;`(p: Point3d; m: Matrix3d): Point3d {.raises: [], tags: [].}</pre></dt> <dd> Concatenates a point <em>p</em> with a transform <em>m</em>, resulting in a new, transformed point.   </dd> <dt id="&amp;="><pre id="&amp;=,Point3d,Matrix3d" data-language="nim">proc `&amp;=`(p: var Point3d; m: Matrix3d) {.raises: [], tags: [].}</pre></dt> <dd> Applies transformation <em>m</em> onto <em>p</em> in place.   </dd> <dt id="transformInv"><pre id="transformInv,Point3d,Matrix3d" data-language="nim">proc transformInv(p: var Point3d; m: Matrix3d) {.raises: [DivByZeroError], tags: [].}</pre></dt> <dd> Applies the inverse of transformation <em>m</em> onto <em>p</em> in place. If the matrix is not invertable (determinant=0) , EDivByZero will be raised.   </dd> <dt id="+"><pre id="+,Point3d,Vector3d" data-language="nim">proc `+`(p: Point3d; v: Vector3d): Point3d {.noInit, inline, raises: [], tags: [].}</pre></dt> <dd> Adds a vector <em>v</em> to a point <em>p</em>, resulting in a new point.   </dd> <dt id="+="><pre id="+=,Point3d,Vector3d" data-language="nim">proc `+=`(p: var Point3d; v: Vector3d) {.noInit, inline, raises: [], tags: [].}</pre></dt> <dd> Adds a vector <em>v</em> to a point <em>p</em> in place.   </dd> <dt id="-"><pre id="-,Point3d,Vector3d" data-language="nim">proc `-`(p: Point3d; v: Vector3d): Point3d {.noInit, inline, raises: [], tags: [].}</pre></dt> <dd> Subtracts a vector <em>v</em> from a point <em>p</em>, resulting in a new point.   </dd> <dt id="-"><pre id="-,Point3d,Point3d" data-language="nim">proc `-`(p1, p2: Point3d): Vector3d {.noInit, inline, raises: [], tags: [].}</pre></dt> <dd> Subtracts <em>p2`from `p1</em> resulting in a difference vector.   </dd> <dt id="-="><pre id="-=,Point3d,Vector3d" data-language="nim">proc `-=`(p: var Point3d; v: Vector3d) {.noInit, inline, raises: [], tags: [].}</pre></dt> <dd> Subtracts a vector <em>v</em> from a point <em>p</em> in place.   </dd> <dt id="=~"><pre id="=~,Point3d,Point3d" data-language="nim">proc `=~`(p1, p2: Point3d): bool {.inline, raises: [], tags: [].}</pre></dt> <dd> Checks if two vectors approximately equals with a hardcoded tolerance 1e-6   </dd> <dt id="rotate"><pre id="rotate,Point3d,float,Vector3d" data-language="nim">proc rotate(p: var Point3d; rad: float; axis: Vector3d) {.raises: [DivByZeroError],
    tags: [].}</pre></dt> <dd> Rotates point <em>p</em> in place <em>rad</em> radians about an axis passing through origo.   </dd> <dt id="rotate"><pre id="rotate,Point3d,float,Point3d,Vector3d" data-language="nim">proc rotate(p: var Point3d; angle: float; org: Point3d; axis: Vector3d) {.
    raises: [DivByZeroError], tags: [].}</pre></dt> <dd> Rotates point <em>p</em> in place <em>rad</em> radians about an axis passing through <em>org</em>   </dd> <dt id="scale"><pre id="scale,Point3d,float" data-language="nim">proc scale(p: var Point3d; fac: float) {.inline, raises: [], tags: [].}</pre></dt> <dd> Scales a point in place <em>fac</em> times with world origo as origin.   </dd> <dt id="scale"><pre id="scale,Point3d,float,Point3d" data-language="nim">proc scale(p: var Point3d; fac: float; org: Point3d) {.inline, raises: [], tags: [].}</pre></dt> <dd> Scales the point in place <em>fac</em> times with <em>org</em> as origin.   </dd> <dt id="stretch"><pre id="stretch,Point3d,float,float,float" data-language="nim">proc stretch(p: var Point3d; facx, facy, facz: float) {.inline, raises: [], tags: [].}</pre></dt> <dd> Scales a point in place non uniformly <em>facx</em> , <em>facy</em> , <em>facz</em> times with world origo as origin.   </dd> <dt id="stretch"><pre id="stretch,Point3d,float,float,float,Point3d" data-language="nim">proc stretch(p: var Point3d; facx, facy, facz: float; org: Point3d) {.inline, raises: [],
    tags: [].}</pre></dt> <dd> Scales the point in place non uniformly <em>facx</em> , <em>facy</em> , <em>facz</em> times with <em>org</em> as origin.   </dd> <dt id="move"><pre id="move,Point3d,float,float,float" data-language="nim">proc move(p: var Point3d; dx, dy, dz: float) {.inline, raises: [], tags: [].}</pre></dt> <dd> Translates a point <em>dx</em> , <em>dy</em> , <em>dz</em> in place.   </dd> <dt id="move"><pre id="move,Point3d,Vector3d" data-language="nim">proc move(p: var Point3d; v: Vector3d) {.inline, raises: [], tags: [].}</pre></dt> <dd> Translates a point with vector <em>v</em> in place.   </dd> <dt id="area"><pre id="area,Point3d,Point3d,Point3d" data-language="nim">proc area(a, b, c: Point3d): float {.inline, raises: [], tags: [].}</pre></dt> <dd> Computes the area of the triangle thru points <em>a</em> , <em>b</em> and <em>c</em>   </dd> </dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 2006–2017 Andreas Rumpf<br>Licensed under the MIT License.<br>
    <a href="https://nim-lang.org/docs/basic3d.html" class="_attribution-link" target="_blank">https://nim-lang.org/docs/basic3d.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
