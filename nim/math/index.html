
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Math - Nim - W3cubDocs</title>
  
  <meta name="description" content=" Constructive mathematics is naturally typed. -- Simon Thompson ">
  <meta name="keywords" content="module, math, -, nim">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/nim/math/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-e0f881b0fce8cbe96f33dadc355b7159d5d2912911231446d60eb8f9caffa802.css">
  <script type="text/javascript" src="/assets/application-8fc46316434047265cd383f02b8e7f434ed7dec4a59f920dd633deef8d488d1b.js"></script>
  <script src="/json/nim.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/nim/" class="_nav-link" title="" style="margin-left:0;">Nim</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _nim">
				
<h1 class="title">Module math</h1>  
<p>Constructive mathematics is naturally typed. -- Simon Thompson</p> <p>Basic math routines for Nim. This module is available for the <a href="../backends/#the-javascript-target">JavaScript target</a>.</p> <p>Note that the trigonometric functions naturally operate on radians. The helper functions <em>degToRad</em> and <em>radToDeg</em> provide conversion between radians and degrees.</p>  <h2 id="7">Types</h2> <dl> <dt id="FloatClass"><pre id="FloatClass" data-language="nim">FloatClass = enum
  fcNormal,                   ## value is an ordinary nonzero floating point value
  fcSubnormal,                ## value is a subnormal (a very small) floating point value
  fcZero,                     ## value is zero
  fcNegZero,                  ## value is the negative zero
  fcNan,                      ## value is Not-A-Number (NAN)
  fcInf,                      ## value is positive infinity
  fcNegInf                    ## value is negative infinity</pre></dt> <dd> describes the class a floating point value belongs to. This is the type that is returned by <em>classify</em>.   </dd> </dl>  <h2 id="10">Consts</h2> <dl> <dt id="PI"><pre id="PI" data-language="nim">PI = 3.141592653589793</pre></dt> <dd> the circle constant PI (Ludolph's number)   </dd> <dt id="TAU"><pre id="TAU" data-language="nim">TAU = 6.283185307179586</pre></dt> <dd> the circle constant TAU (= 2 * PI)   </dd> <dt id="E"><pre id="E" data-language="nim">E = 2.718281828459045</pre></dt> <dd> Euler's number   </dd> <dt id="MaxFloat64Precision"><pre id="MaxFloat64Precision">MaxFloat64Precision = 16</pre></dt> <dd> maximum number of meaningful digits after the decimal point for Nim's <code>float64</code> type.   </dd> <dt id="MaxFloat32Precision"><pre id="MaxFloat32Precision">MaxFloat32Precision = 8</pre></dt> <dd> maximum number of meaningful digits after the decimal point for Nim's <code>float32</code> type.   </dd> <dt id="MaxFloatPrecision"><pre id="MaxFloatPrecision">MaxFloatPrecision = 16</pre></dt> <dd> maximum number of meaningful digits after the decimal point for Nim's <code>float</code> type.   </dd> </dl>  <h2 id="12">Procs</h2> <dl> <dt id="binom"><pre id="binom,int,int" data-language="nim">proc binom(n, k: int): int {.noSideEffect, raises: [], tags: [].}</pre></dt> <dd> Computes the binomial coefficient   </dd> <dt id="fac"><pre id="fac,int" data-language="nim">proc fac(n: int): int {.noSideEffect, raises: [], tags: [].}</pre></dt> <dd> Computes the faculty/factorial function.   </dd> <dt id="classify"><pre id="classify,float" data-language="nim">proc classify(x: float): FloatClass {.raises: [], tags: [].}</pre></dt> <dd> Classifies a floating point value. Returns <em>x</em>'s class as specified by <em>FloatClass</em>.   </dd> <dt id="isPowerOfTwo"><pre id="isPowerOfTwo,int" data-language="nim">proc isPowerOfTwo(x: int): bool {.noSideEffect, raises: [], tags: [].}</pre></dt> <dd> Returns true, if <em>x</em> is a power of two, false otherwise. Zero and negative numbers are not a power of two.   </dd> <dt id="nextPowerOfTwo"><pre id="nextPowerOfTwo,int" data-language="nim">proc nextPowerOfTwo(x: int): int {.noSideEffect, raises: [], tags: [].}</pre></dt> <dd> Returns <em>x</em> rounded up to the nearest power of two. Zero and negative numbers get rounded up to 1.   </dd> <dt id="countBits32"><pre id="countBits32,int32" data-language="nim">proc countBits32(n: int32): int {.noSideEffect, raises: [], tags: [].}</pre></dt> <dd> Counts the set bits in <em>n</em>.   </dd> <dt id="sum"><pre id="sum,openArray[T]" data-language="nim">proc sum[T](x: openArray[T]): T {.noSideEffect.}</pre></dt> <dd> Computes the sum of the elements in <em>x</em>. If <em>x</em> is empty, 0 is returned.   </dd> <dt id="sqrt"><pre id="sqrt,float32" data-language="nim">proc sqrt(x: float32): float32 {.importc: "sqrtf", header: "&lt;math.h&gt;".}</pre></dt>  <dt id="sqrt"><pre id="sqrt,float64" data-language="nim">proc sqrt(x: float64): float64 {.importc: "sqrt", header: "&lt;math.h&gt;".}</pre></dt> <dd> Computes the square root of <em>x</em>.   </dd> <dt id="cbrt"><pre id="cbrt,float32" data-language="nim">proc cbrt(x: float32): float32 {.importc: "cbrtf", header: "&lt;math.h&gt;".}</pre></dt>  <dt id="cbrt"><pre id="cbrt,float64" data-language="nim">proc cbrt(x: float64): float64 {.importc: "cbrt", header: "&lt;math.h&gt;".}</pre></dt> <dd> Computes the cubic root of <em>x</em>   </dd> <dt id="ln"><pre id="ln,float32" data-language="nim">proc ln(x: float32): float32 {.importc: "logf", header: "&lt;math.h&gt;".}</pre></dt>  <dt id="ln"><pre id="ln,float64" data-language="nim">proc ln(x: float64): float64 {.importc: "log", header: "&lt;math.h&gt;".}</pre></dt> <dd> Computes the natural log of <em>x</em>   </dd> <dt id="log10"><pre id="log10,float32" data-language="nim">proc log10(x: float32): float32 {.importc: "log10f", header: "&lt;math.h&gt;".}</pre></dt>  <dt id="log10"><pre id="log10,float64" data-language="nim">proc log10(x: float64): float64 {.importc: "log10", header: "&lt;math.h&gt;".}</pre></dt> <dd> Computes the common logarithm (base 10) of <em>x</em>   </dd> <dt id="log2"><pre id="log2,T" data-language="nim">proc log2[T: float32 | float64](x: T): T</pre></dt> <dd> Computes the binary logarithm (base 2) of <em>x</em>   </dd> <dt id="exp"><pre id="exp,float32" data-language="nim">proc exp(x: float32): float32 {.importc: "expf", header: "&lt;math.h&gt;".}</pre></dt>  <dt id="exp"><pre id="exp,float64" data-language="nim">proc exp(x: float64): float64 {.importc: "exp", header: "&lt;math.h&gt;".}</pre></dt> <dd> Computes the exponential function of <em>x</em> (pow(E, x))   </dd> <dt id="arccos"><pre id="arccos,float32" data-language="nim">proc arccos(x: float32): float32 {.importc: "acosf", header: "&lt;math.h&gt;".}</pre></dt>  <dt id="arccos"><pre id="arccos,float64" data-language="nim">proc arccos(x: float64): float64 {.importc: "acos", header: "&lt;math.h&gt;".}</pre></dt> <dd> Computes the arc cosine of <em>x</em>   </dd> <dt id="arcsin"><pre id="arcsin,float32" data-language="nim">proc arcsin(x: float32): float32 {.importc: "asinf", header: "&lt;math.h&gt;".}</pre></dt>  <dt id="arcsin"><pre id="arcsin,float64" data-language="nim">proc arcsin(x: float64): float64 {.importc: "asin", header: "&lt;math.h&gt;".}</pre></dt> <dd> Computes the arc sine of <em>x</em>   </dd> <dt id="arctan"><pre id="arctan,float32" data-language="nim">proc arctan(x: float32): float32 {.importc: "atanf", header: "&lt;math.h&gt;".}</pre></dt>  <dt id="arctan"><pre id="arctan,float64" data-language="nim">proc arctan(x: float64): float64 {.importc: "atan", header: "&lt;math.h&gt;".}</pre></dt> <dd> Calculate the arc tangent of <em>y</em> / <em>x</em>   </dd> <dt id="arctan2"><pre id="arctan2,float32,float32" data-language="nim">proc arctan2(y, x: float32): float32 {.importc: "atan2f", header: "&lt;math.h&gt;".}</pre></dt>  <dt id="arctan2"><pre id="arctan2,float64,float64" data-language="nim">proc arctan2(y, x: float64): float64 {.importc: "atan2", header: "&lt;math.h&gt;".}</pre></dt> <dd> Calculate the arc tangent of <em>y</em> / <em>x</em>. <em>atan2</em> returns the arc tangent of <em>y</em> / <em>x</em>; it produces correct results even when the resulting angle is near pi/2 or -pi/2 (<em>x</em> near 0).   </dd> <dt id="cos"><pre id="cos,float32" data-language="nim">proc cos(x: float32): float32 {.importc: "cosf", header: "&lt;math.h&gt;".}</pre></dt>  <dt id="cos"><pre id="cos,float64" data-language="nim">proc cos(x: float64): float64 {.importc: "cos", header: "&lt;math.h&gt;".}</pre></dt> <dd> Computes the cosine of <em>x</em>   </dd> <dt id="cosh"><pre id="cosh,float32" data-language="nim">proc cosh(x: float32): float32 {.importc: "coshf", header: "&lt;math.h&gt;".}</pre></dt>  <dt id="cosh"><pre id="cosh,float64" data-language="nim">proc cosh(x: float64): float64 {.importc: "cosh", header: "&lt;math.h&gt;".}</pre></dt> <dd> Computes the hyperbolic cosine of <em>x</em>   </dd> <dt id="hypot"><pre id="hypot,float32,float32" data-language="nim">proc hypot(x, y: float32): float32 {.importc: "hypotf", header: "&lt;math.h&gt;".}</pre></dt>  <dt id="hypot"><pre id="hypot,float64,float64" data-language="nim">proc hypot(x, y: float64): float64 {.importc: "hypot", header: "&lt;math.h&gt;".}</pre></dt> <dd> Computes the hypotenuse of a right-angle triangle with <em>x</em> and <em>y</em> as its base and height. Equivalent to <code>sqrt(x*x + y*y)</code>.   </dd> <dt id="sinh"><pre id="sinh,float32" data-language="nim">proc sinh(x: float32): float32 {.importc: "sinhf", header: "&lt;math.h&gt;".}</pre></dt>  <dt id="sinh"><pre id="sinh,float64" data-language="nim">proc sinh(x: float64): float64 {.importc: "sinh", header: "&lt;math.h&gt;".}</pre></dt> <dd> Computes the hyperbolic sine of <em>x</em>   </dd> <dt id="sin"><pre id="sin,float32" data-language="nim">proc sin(x: float32): float32 {.importc: "sinf", header: "&lt;math.h&gt;".}</pre></dt>  <dt id="sin"><pre id="sin,float64" data-language="nim">proc sin(x: float64): float64 {.importc: "sin", header: "&lt;math.h&gt;".}</pre></dt> <dd> Computes the sine of <em>x</em>   </dd> <dt id="tan"><pre id="tan,float32" data-language="nim">proc tan(x: float32): float32 {.importc: "tanf", header: "&lt;math.h&gt;".}</pre></dt>  <dt id="tan"><pre id="tan,float64" data-language="nim">proc tan(x: float64): float64 {.importc: "tan", header: "&lt;math.h&gt;".}</pre></dt> <dd> Computes the tangent of <em>x</em>   </dd> <dt id="tanh"><pre id="tanh,float32" data-language="nim">proc tanh(x: float32): float32 {.importc: "tanhf", header: "&lt;math.h&gt;".}</pre></dt>  <dt id="tanh"><pre id="tanh,float64" data-language="nim">proc tanh(x: float64): float64 {.importc: "tanh", header: "&lt;math.h&gt;".}</pre></dt> <dd> Computes the hyperbolic tangent of <em>x</em>   </dd> <dt id="pow"><pre id="pow,float32,float32" data-language="nim">proc pow(x, y: float32): float32 {.importc: "powf", header: "&lt;math.h&gt;".}</pre></dt>  <dt id="pow"><pre id="pow,float64,float64" data-language="nim">proc pow(x, y: float64): float64 {.importc: "pow", header: "&lt;math.h&gt;".}</pre></dt> <dd> computes x to power raised of y.   </dd> <dt id="erf"><pre id="erf,float32" data-language="nim">proc erf(x: float32): float32 {.importc: "erff", header: "&lt;math.h&gt;".}</pre></dt>  <dt id="erf"><pre id="erf,float64" data-language="nim">proc erf(x: float64): float64 {.importc: "erf", header: "&lt;math.h&gt;".}</pre></dt> <dd> The error function   </dd> <dt id="erfc"><pre id="erfc,float32" data-language="nim">proc erfc(x: float32): float32 {.importc: "erfcf", header: "&lt;math.h&gt;".}</pre></dt>  <dt id="erfc"><pre id="erfc,float64" data-language="nim">proc erfc(x: float64): float64 {.importc: "erfc", header: "&lt;math.h&gt;".}</pre></dt> <dd> The complementary error function   </dd> <dt id="lgamma"><pre id="lgamma,float32" data-language="nim">proc lgamma(x: float32): float32 {.importc: "lgammaf", header: "&lt;math.h&gt;".}</pre></dt>  <dt id="lgamma"><pre id="lgamma,float64" data-language="nim">proc lgamma(x: float64): float64 {.importc: "lgamma", header: "&lt;math.h&gt;".}</pre></dt> <dd> Natural log of the gamma function   </dd> <dt id="tgamma"><pre id="tgamma,float32" data-language="nim">proc tgamma(x: float32): float32 {.importc: "tgammaf", header: "&lt;math.h&gt;".}</pre></dt>  <dt id="tgamma"><pre id="tgamma,float64" data-language="nim">proc tgamma(x: float64): float64 {.importc: "tgamma", header: "&lt;math.h&gt;".}</pre></dt> <dd> The gamma function   </dd> <dt id="floor"><pre id="floor,float32" data-language="nim">proc floor(x: float32): float32 {.importc: "floorf", header: "&lt;math.h&gt;".}</pre></dt>  <dt id="floor"><pre id="floor,float64" data-language="nim">proc floor(x: float64): float64 {.importc: "floor", header: "&lt;math.h&gt;".}</pre></dt> <dd> Computes the floor function (i.e., the largest integer not greater than <em>x</em>)<pre class="listing" data-language="nim">echo floor(-3.5) ## -4.0</pre>   </dd> <dt id="ceil"><pre id="ceil,float32" data-language="nim">proc ceil(x: float32): float32 {.importc: "ceilf", header: "&lt;math.h&gt;".}</pre></dt>  <dt id="ceil"><pre id="ceil,float64" data-language="nim">proc ceil(x: float64): float64 {.importc: "ceil", header: "&lt;math.h&gt;".}</pre></dt> <dd> Computes the ceiling function (i.e., the smallest integer not less than <em>x</em>)<pre class="listing" data-language="nim">echo ceil(-2.1) ## -2.0</pre>   </dd> <dt id="trunc"><pre id="trunc,float32" data-language="nim">proc trunc(x: float32): float32 {.importc: "truncf", header: "&lt;math.h&gt;".}</pre></dt>  <dt id="trunc"><pre id="trunc,float64" data-language="nim">proc trunc(x: float64): float64 {.importc: "trunc", header: "&lt;math.h&gt;".}</pre></dt> <dd> Truncates <em>x</em> to the decimal point<pre class="listing" data-language="nim">echo trunc(PI) # 3.0</pre>   </dd> <dt id="fmod"><pre id="fmod,float32,float32" data-language="nim">proc fmod(x, y: float32): float32 {.importc: "fmodf", header: "&lt;math.h&gt;".}</pre></dt>  <dt id="fmod"><pre id="fmod,float64,float64" data-language="nim">proc fmod(x, y: float64): float64 {.importc: "fmod", header: "&lt;math.h&gt;".}</pre></dt> <dd> Computes the remainder of <em>x</em> divided by <em>y</em><pre class="listing" data-language="nim">echo fmod(-2.5, 0.3) ## -0.1</pre>   </dd> <dt id="round"><pre id="round,T,int" data-language="nim">proc round[T: float32 | float64](x: T; places: int = 0): T</pre></dt> <dd> <p>Round a floating point number.</p> <p>If <em>places</em> is 0 (or omitted), round to the nearest integral value following normal mathematical rounding rules (e.g. <em>round(54.5) -&gt; 55.0</em>). If <em>places</em> is greater than 0, round to the given number of decimal places, e.g. <em>round(54.346, 2) -&gt; 54.35</em>. If <em>places</em> is negative, round to the left of the decimal place, e.g. <em>round(537.345, -1) -&gt; 540.0</em></p>   </dd> <dt id="frexp"><pre id="frexp,float32,int" data-language="nim">proc frexp(x: float32; exponent: var int): float32 {.importc: "frexp", header: "&lt;math.h&gt;".}</pre></dt>  <dt id="frexp"><pre id="frexp,float64,int" data-language="nim">proc frexp(x: float64; exponent: var int): float64 {.importc: "frexp", header: "&lt;math.h&gt;".}</pre></dt> <dd> Split a number into mantissa and exponent. <em>frexp</em> calculates the mantissa m (a float greater than or equal to 0.5 and less than 1) and the integer value n such that <em>x</em> (the original float value) equals m * 2**n. frexp stores n in <em>exponent</em> and returns m.   </dd> <dt id="splitDecimal"><pre id="splitDecimal,T" data-language="nim">proc splitDecimal[T: float32 | float64](x: T): tuple[intpart: T, floatpart: T]</pre></dt> <dd> <p>Breaks <em>x</em> into an integral and a fractional part.</p> <p>Returns a tuple containing intpart and floatpart representing the integer part and the fractional part respectively.</p> <p>Both parts have the same sign as <em>x</em>. Analogous to the <em>modf</em> function in C.</p>   </dd> <dt id="degToRad"><pre id="degToRad,T" data-language="nim">proc degToRad[T: float32 | float64](d: T): T {.inline.}</pre></dt> <dd> Convert from degrees to radians   </dd> <dt id="radToDeg"><pre id="radToDeg,T" data-language="nim">proc radToDeg[T: float32 | float64](d: T): T {.inline.}</pre></dt> <dd> Convert from radians to degrees   </dd> <dt id="sgn"><pre id="sgn,T" data-language="nim">proc sgn[T: SomeNumber](x: T): int {.inline.}</pre></dt> <dd> Sign function. Returns -1 for negative numbers and <em>NegInf</em>, 1 for positive numbers and <em>Inf</em>, and 0 for positive zero, negative zero and <em>NaN</em>.   </dd> <dt id="mod"><pre id="mod,T,T" data-language="nim">proc `mod`[T: float32 | float64](x, y: T): T</pre></dt> <dd> Computes the modulo operation for float operators. Equivalent to <code>x - y * floor(x/y)</code>. Note that the remainder will always have the same sign as the divisor.<pre class="listing" data-language="nim">echo (4.0 mod -3.1) # -2.2</pre>   </dd> <dt id="^"><pre id="^,T,Natural" data-language="nim">proc `^`[T](x: T; y: Natural): T</pre></dt> <dd> Computes <code>x</code> to the power <code>y`. ``x</code> must be non-negative, use <em>pow &lt;#pow,float,float&gt;</em> for negative exponents.   </dd> <dt id="gcd"><pre id="gcd,T,T" data-language="nim">proc gcd[T](x, y: T): T</pre></dt> <dd> Computes the greatest common divisor of <code>x</code> and <code>y</code>. Note that for floats, the result cannot always be interpreted as "greatest decimal <em>z</em> such that <code>z*N == x and z*M == y</code> where N and M are positive integers."   </dd> <dt id="lcm"><pre id="lcm,T,T" data-language="nim">proc lcm[T](x, y: T): T</pre></dt> <dd> Computes the least common multiple of <code>x</code> and <code>y</code>.   </dd> </dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 2006–2017 Andreas Rumpf<br>Licensed under the MIT License.<br>
    <a href="https://nim-lang.org/docs/math.html" class="_attribution-link" target="_blank">https://nim-lang.org/docs/math.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
