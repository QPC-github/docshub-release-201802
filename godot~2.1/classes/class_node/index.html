
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Node - Godot 2.1 - W3cubDocs</title>
  
  <meta name="description" content=" Inherits&#58; Object ">
  <meta name="keywords" content="node, -, godot, godot~2.1">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/godot~2.1/classes/class_node/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-e0f881b0fce8cbe96f33dadc355b7159d5d2912911231446d60eb8f9caffa802.css">
  <script type="text/javascript" src="/assets/application-8fc46316434047265cd383f02b8e7f434ed7dec4a59f920dd633deef8d488d1b.js"></script>
  <script src="/json/godot~2.1.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/godot~2.1/" class="_nav-link" title="" style="margin-left:0;">Godot 2.1</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _sphinx_simple">
				
<h1 id="class-node">Node</h1> <p><strong>Inherits:</strong> <a href="../class_object/#class-object"><span class="std std-ref">Object</span></a></p> <p><strong>Inherited By:</strong> <a href="../class_viewport/#class-viewport"><span class="std std-ref">Viewport</span></a>, <a href="../class_timer/#class-timer"><span class="std std-ref">Timer</span></a>, <a href="../class_canvaslayer/#class-canvaslayer"><span class="std std-ref">CanvasLayer</span></a>, <a href="../class_eventplayer/#class-eventplayer"><span class="std std-ref">EventPlayer</span></a>, <a href="../class_soundroomparams/#class-soundroomparams"><span class="std std-ref">SoundRoomParams</span></a>, <a href="../class_spatial/#class-spatial"><span class="std std-ref">Spatial</span></a>, <a href="../class_animationplayer/#class-animationplayer"><span class="std std-ref">AnimationPlayer</span></a>, <a href="../class_editorplugin/#class-editorplugin"><span class="std std-ref">EditorPlugin</span></a>, <a href="../class_resourcepreloader/#class-resourcepreloader"><span class="std std-ref">ResourcePreloader</span></a>, <a href="../class_animationtreeplayer/#class-animationtreeplayer"><span class="std std-ref">AnimationTreePlayer</span></a>, <a href="../class_sampleplayer/#class-sampleplayer"><span class="std std-ref">SamplePlayer</span></a>, <a href="../class_instanceplaceholder/#class-instanceplaceholder"><span class="std std-ref">InstancePlaceholder</span></a>, <a href="../class_httprequest/#class-httprequest"><span class="std std-ref">HTTPRequest</span></a>, <a href="../class_streamplayer/#class-streamplayer"><span class="std std-ref">StreamPlayer</span></a>, <a href="../class_canvasitem/#class-canvasitem"><span class="std std-ref">CanvasItem</span></a>, <a href="../class_tween/#class-tween"><span class="std std-ref">Tween</span></a></p> <p><strong>Category:</strong> Core</p>  <h2 id="brief-description">Brief Description</h2> <p>Base class for all the <em>scene</em> elements.</p>   <h2 id="member-functions">Member Functions</h2> <table class="docutils">   <tr>
<td>void</td> <td>
<a href="#class-node-enter-tree"><span class="std std-ref">_enter_tree</span></a> <strong>(</strong> <strong>)</strong> virtual</td> </tr> <tr>
<td>void</td> <td>
<a href="#class-node-exit-tree"><span class="std std-ref">_exit_tree</span></a> <strong>(</strong> <strong>)</strong> virtual</td> </tr> <tr>
<td>void</td> <td>
<a href="#class-node-fixed-process"><span class="std std-ref">_fixed_process</span></a> <strong>(</strong> <a href="../class_float/#class-float"><span class="std std-ref">float</span></a> delta <strong>)</strong> virtual</td> </tr> <tr>
<td>void</td> <td>
<a href="#class-node-input"><span class="std std-ref">_input</span></a> <strong>(</strong> <a href="../class_inputevent/#class-inputevent"><span class="std std-ref">InputEvent</span></a> event <strong>)</strong> virtual</td> </tr> <tr>
<td>void</td> <td>
<a href="#class-node-process"><span class="std std-ref">_process</span></a> <strong>(</strong> <a href="../class_float/#class-float"><span class="std std-ref">float</span></a> delta <strong>)</strong> virtual</td> </tr> <tr>
<td>void</td> <td>
<a href="#class-node-ready"><span class="std std-ref">_ready</span></a> <strong>(</strong> <strong>)</strong> virtual</td> </tr> <tr>
<td>void</td> <td>
<a href="#class-node-unhandled-input"><span class="std std-ref">_unhandled_input</span></a> <strong>(</strong> <a href="../class_inputevent/#class-inputevent"><span class="std std-ref">InputEvent</span></a> event <strong>)</strong> virtual</td> </tr> <tr>
<td>void</td> <td>
<a href="#class-node-unhandled-key-input"><span class="std std-ref">_unhandled_key_input</span></a> <strong>(</strong> <a href="../class_inputevent/#class-inputevent"><span class="std std-ref">InputEvent</span></a> key_event <strong>)</strong> virtual</td> </tr> <tr>
<td>void</td> <td>
<a href="#class-node-add-child"><span class="std std-ref">add_child</span></a> <strong>(</strong> <a href="#class-node"><span class="std std-ref">Node</span></a> node, <a href="../class_bool/#class-bool"><span class="std std-ref">bool</span></a> legible_unique_name=false <strong>)</strong>
</td> </tr> <tr>
<td>void</td> <td>
<a href="#class-node-add-to-group"><span class="std std-ref">add_to_group</span></a> <strong>(</strong> <a href="../class_string/#class-string"><span class="std std-ref">String</span></a> group, <a href="../class_bool/#class-bool"><span class="std std-ref">bool</span></a> persistent=false <strong>)</strong>
</td> </tr> <tr>
<td><a href="../class_bool/#class-bool"><span class="std std-ref">bool</span></a></td> <td>
<a href="#class-node-can-process"><span class="std std-ref">can_process</span></a> <strong>(</strong> <strong>)</strong> const</td> </tr> <tr>
<td><a href="#class-node"><span class="std std-ref">Node</span></a></td> <td>
<a href="#class-node-duplicate"><span class="std std-ref">duplicate</span></a> <strong>(</strong> <a href="../class_bool/#class-bool"><span class="std std-ref">bool</span></a> use_instancing=false, <a href="../class_int/#class-int"><span class="std std-ref">int</span></a> flags=7 <strong>)</strong> const</td> </tr> <tr>
<td><a href="#class-node"><span class="std std-ref">Node</span></a></td> <td>
<a href="#class-node-find-node"><span class="std std-ref">find_node</span></a> <strong>(</strong> <a href="../class_string/#class-string"><span class="std std-ref">String</span></a> mask, <a href="../class_bool/#class-bool"><span class="std std-ref">bool</span></a> recursive=true, <a href="../class_bool/#class-bool"><span class="std std-ref">bool</span></a> owned=true <strong>)</strong> const</td> </tr> <tr>
<td><a href="#class-node"><span class="std std-ref">Node</span></a></td> <td>
<a href="#class-node-get-child"><span class="std std-ref">get_child</span></a> <strong>(</strong> <a href="../class_int/#class-int"><span class="std std-ref">int</span></a> idx <strong>)</strong> const</td> </tr> <tr>
<td><a href="../class_int/#class-int"><span class="std std-ref">int</span></a></td> <td>
<a href="#class-node-get-child-count"><span class="std std-ref">get_child_count</span></a> <strong>(</strong> <strong>)</strong> const</td> </tr> <tr>
<td><a href="../class_array/#class-array"><span class="std std-ref">Array</span></a></td> <td>
<a href="#class-node-get-children"><span class="std std-ref">get_children</span></a> <strong>(</strong> <strong>)</strong> const</td> </tr> <tr>
<td><a href="../class_string/#class-string"><span class="std std-ref">String</span></a></td> <td>
<a href="#class-node-get-filename"><span class="std std-ref">get_filename</span></a> <strong>(</strong> <strong>)</strong> const</td> </tr> <tr>
<td><a href="../class_float/#class-float"><span class="std std-ref">float</span></a></td> <td>
<a href="#class-node-get-fixed-process-delta-time"><span class="std std-ref">get_fixed_process_delta_time</span></a> <strong>(</strong> <strong>)</strong> const</td> </tr> <tr>
<td><a href="../class_array/#class-array"><span class="std std-ref">Array</span></a></td> <td>
<a href="#class-node-get-groups"><span class="std std-ref">get_groups</span></a> <strong>(</strong> <strong>)</strong> const</td> </tr> <tr>
<td><a href="../class_int/#class-int"><span class="std std-ref">int</span></a></td> <td>
<a href="#class-node-get-index"><span class="std std-ref">get_index</span></a> <strong>(</strong> <strong>)</strong> const</td> </tr> <tr>
<td><a href="../class_string/#class-string"><span class="std std-ref">String</span></a></td> <td>
<a href="#class-node-get-name"><span class="std std-ref">get_name</span></a> <strong>(</strong> <strong>)</strong> const</td> </tr> <tr>
<td><a href="#class-node"><span class="std std-ref">Node</span></a></td> <td>
<a href="#class-node-get-node"><span class="std std-ref">get_node</span></a> <strong>(</strong> <a href="../class_nodepath/#class-nodepath"><span class="std std-ref">NodePath</span></a> path <strong>)</strong> const</td> </tr> <tr>
<td><a href="../class_array/#class-array"><span class="std std-ref">Array</span></a></td> <td>
<a href="#class-node-get-node-and-resource"><span class="std std-ref">get_node_and_resource</span></a> <strong>(</strong> <a href="../class_nodepath/#class-nodepath"><span class="std std-ref">NodePath</span></a> path <strong>)</strong>
</td> </tr> <tr>
<td><a href="#class-node"><span class="std std-ref">Node</span></a></td> <td>
<a href="#class-node-get-owner"><span class="std std-ref">get_owner</span></a> <strong>(</strong> <strong>)</strong> const</td> </tr> <tr>
<td><a href="#class-node"><span class="std std-ref">Node</span></a></td> <td>
<a href="#class-node-get-parent"><span class="std std-ref">get_parent</span></a> <strong>(</strong> <strong>)</strong> const</td> </tr> <tr>
<td><a href="../class_nodepath/#class-nodepath"><span class="std std-ref">NodePath</span></a></td> <td>
<a href="#class-node-get-path"><span class="std std-ref">get_path</span></a> <strong>(</strong> <strong>)</strong> const</td> </tr> <tr>
<td><a href="../class_nodepath/#class-nodepath"><span class="std std-ref">NodePath</span></a></td> <td>
<a href="#class-node-get-path-to"><span class="std std-ref">get_path_to</span></a> <strong>(</strong> <a href="#class-node"><span class="std std-ref">Node</span></a> node <strong>)</strong> const</td> </tr> <tr>
<td><a href="../class_int/#class-int"><span class="std std-ref">int</span></a></td> <td>
<a href="#class-node-get-pause-mode"><span class="std std-ref">get_pause_mode</span></a> <strong>(</strong> <strong>)</strong> const</td> </tr> <tr>
<td><a href="../class_int/#class-int"><span class="std std-ref">int</span></a></td> <td>
<a href="#class-node-get-position-in-parent"><span class="std std-ref">get_position_in_parent</span></a> <strong>(</strong> <strong>)</strong> const</td> </tr> <tr>
<td><a href="../class_float/#class-float"><span class="std std-ref">float</span></a></td> <td>
<a href="#class-node-get-process-delta-time"><span class="std std-ref">get_process_delta_time</span></a> <strong>(</strong> <strong>)</strong> const</td> </tr> <tr>
<td><a href="../class_bool/#class-bool"><span class="std std-ref">bool</span></a></td> <td>
<a href="#class-node-get-scene-instance-load-placeholder"><span class="std std-ref">get_scene_instance_load_placeholder</span></a> <strong>(</strong> <strong>)</strong> const</td> </tr> <tr>
<td><a href="../class_scenetree/#class-scenetree"><span class="std std-ref">SceneTree</span></a></td> <td>
<a href="#class-node-get-tree"><span class="std std-ref">get_tree</span></a> <strong>(</strong> <strong>)</strong> const</td> </tr> <tr>
<td><a href="../class_object/#class-object"><span class="std std-ref">Object</span></a></td> <td>
<a href="#class-node-get-viewport"><span class="std std-ref">get_viewport</span></a> <strong>(</strong> <strong>)</strong> const</td> </tr> <tr>
<td><a href="../class_bool/#class-bool"><span class="std std-ref">bool</span></a></td> <td>
<a href="#class-node-has-node"><span class="std std-ref">has_node</span></a> <strong>(</strong> <a href="../class_nodepath/#class-nodepath"><span class="std std-ref">NodePath</span></a> path <strong>)</strong> const</td> </tr> <tr>
<td><a href="../class_bool/#class-bool"><span class="std std-ref">bool</span></a></td> <td>
<a href="#class-node-has-node-and-resource"><span class="std std-ref">has_node_and_resource</span></a> <strong>(</strong> <a href="../class_nodepath/#class-nodepath"><span class="std std-ref">NodePath</span></a> path <strong>)</strong> const</td> </tr> <tr>
<td><a href="../class_bool/#class-bool"><span class="std std-ref">bool</span></a></td> <td>
<a href="#class-node-is-a-parent-of"><span class="std std-ref">is_a_parent_of</span></a> <strong>(</strong> <a href="#class-node"><span class="std std-ref">Node</span></a> node <strong>)</strong> const</td> </tr> <tr>
<td><a href="../class_bool/#class-bool"><span class="std std-ref">bool</span></a></td> <td>
<a href="#class-node-is-displayed-folded"><span class="std std-ref">is_displayed_folded</span></a> <strong>(</strong> <strong>)</strong> const</td> </tr> <tr>
<td><a href="../class_bool/#class-bool"><span class="std std-ref">bool</span></a></td> <td>
<a href="#class-node-is-fixed-processing"><span class="std std-ref">is_fixed_processing</span></a> <strong>(</strong> <strong>)</strong> const</td> </tr> <tr>
<td><a href="../class_bool/#class-bool"><span class="std std-ref">bool</span></a></td> <td>
<a href="#class-node-is-greater-than"><span class="std std-ref">is_greater_than</span></a> <strong>(</strong> <a href="#class-node"><span class="std std-ref">Node</span></a> node <strong>)</strong> const</td> </tr> <tr>
<td><a href="../class_bool/#class-bool"><span class="std std-ref">bool</span></a></td> <td>
<a href="#class-node-is-in-group"><span class="std std-ref">is_in_group</span></a> <strong>(</strong> <a href="../class_string/#class-string"><span class="std std-ref">String</span></a> group <strong>)</strong> const</td> </tr> <tr>
<td><a href="../class_bool/#class-bool"><span class="std std-ref">bool</span></a></td> <td>
<a href="#class-node-is-inside-tree"><span class="std std-ref">is_inside_tree</span></a> <strong>(</strong> <strong>)</strong> const</td> </tr> <tr>
<td><a href="../class_bool/#class-bool"><span class="std std-ref">bool</span></a></td> <td>
<a href="#class-node-is-processing"><span class="std std-ref">is_processing</span></a> <strong>(</strong> <strong>)</strong> const</td> </tr> <tr>
<td><a href="../class_bool/#class-bool"><span class="std std-ref">bool</span></a></td> <td>
<a href="#class-node-is-processing-input"><span class="std std-ref">is_processing_input</span></a> <strong>(</strong> <strong>)</strong> const</td> </tr> <tr>
<td><a href="../class_bool/#class-bool"><span class="std std-ref">bool</span></a></td> <td>
<a href="#class-node-is-processing-unhandled-input"><span class="std std-ref">is_processing_unhandled_input</span></a> <strong>(</strong> <strong>)</strong> const</td> </tr> <tr>
<td><a href="../class_bool/#class-bool"><span class="std std-ref">bool</span></a></td> <td>
<a href="#class-node-is-processing-unhandled-key-input"><span class="std std-ref">is_processing_unhandled_key_input</span></a> <strong>(</strong> <strong>)</strong> const</td> </tr> <tr>
<td>void</td> <td>
<a href="#class-node-move-child"><span class="std std-ref">move_child</span></a> <strong>(</strong> <a href="#class-node"><span class="std std-ref">Node</span></a> child_node, <a href="../class_int/#class-int"><span class="std std-ref">int</span></a> to_pos <strong>)</strong>
</td> </tr> <tr>
<td>void</td> <td>
<a href="#class-node-print-stray-nodes"><span class="std std-ref">print_stray_nodes</span></a> <strong>(</strong> <strong>)</strong>
</td> </tr> <tr>
<td>void</td> <td>
<a href="#class-node-print-tree"><span class="std std-ref">print_tree</span></a> <strong>(</strong> <strong>)</strong>
</td> </tr> <tr>
<td>void</td> <td>
<a href="#class-node-propagate-notification"><span class="std std-ref">propagate_notification</span></a> <strong>(</strong> <a href="../class_int/#class-int"><span class="std std-ref">int</span></a> what <strong>)</strong>
</td> </tr> <tr>
<td>void</td> <td>
<a href="#class-node-queue-free"><span class="std std-ref">queue_free</span></a> <strong>(</strong> <strong>)</strong>
</td> </tr> <tr>
<td>void</td> <td>
<a href="#class-node-raise"><span class="std std-ref">raise</span></a> <strong>(</strong> <strong>)</strong>
</td> </tr> <tr>
<td>void</td> <td>
<a href="#class-node-remove-and-skip"><span class="std std-ref">remove_and_skip</span></a> <strong>(</strong> <strong>)</strong>
</td> </tr> <tr>
<td>void</td> <td>
<a href="#class-node-remove-child"><span class="std std-ref">remove_child</span></a> <strong>(</strong> <a href="#class-node"><span class="std std-ref">Node</span></a> node <strong>)</strong>
</td> </tr> <tr>
<td>void</td> <td>
<a href="#class-node-remove-from-group"><span class="std std-ref">remove_from_group</span></a> <strong>(</strong> <a href="../class_string/#class-string"><span class="std std-ref">String</span></a> group <strong>)</strong>
</td> </tr> <tr>
<td>void</td> <td>
<a href="#class-node-replace-by"><span class="std std-ref">replace_by</span></a> <strong>(</strong> <a href="#class-node"><span class="std std-ref">Node</span></a> node, <a href="../class_bool/#class-bool"><span class="std std-ref">bool</span></a> keep_data=false <strong>)</strong>
</td> </tr> <tr>
<td>void</td> <td>
<a href="#class-node-set-display-folded"><span class="std std-ref">set_display_folded</span></a> <strong>(</strong> <a href="../class_bool/#class-bool"><span class="std std-ref">bool</span></a> fold <strong>)</strong>
</td> </tr> <tr>
<td>void</td> <td>
<a href="#class-node-set-filename"><span class="std std-ref">set_filename</span></a> <strong>(</strong> <a href="../class_string/#class-string"><span class="std std-ref">String</span></a> filename <strong>)</strong>
</td> </tr> <tr>
<td>void</td> <td>
<a href="#class-node-set-fixed-process"><span class="std std-ref">set_fixed_process</span></a> <strong>(</strong> <a href="../class_bool/#class-bool"><span class="std std-ref">bool</span></a> enable <strong>)</strong>
</td> </tr> <tr>
<td>void</td> <td>
<a href="#class-node-set-name"><span class="std std-ref">set_name</span></a> <strong>(</strong> <a href="../class_string/#class-string"><span class="std std-ref">String</span></a> name <strong>)</strong>
</td> </tr> <tr>
<td>void</td> <td>
<a href="#class-node-set-owner"><span class="std std-ref">set_owner</span></a> <strong>(</strong> <a href="#class-node"><span class="std std-ref">Node</span></a> owner <strong>)</strong>
</td> </tr> <tr>
<td>void</td> <td>
<a href="#class-node-set-pause-mode"><span class="std std-ref">set_pause_mode</span></a> <strong>(</strong> <a href="../class_int/#class-int"><span class="std std-ref">int</span></a> mode <strong>)</strong>
</td> </tr> <tr>
<td>void</td> <td>
<a href="#class-node-set-process"><span class="std std-ref">set_process</span></a> <strong>(</strong> <a href="../class_bool/#class-bool"><span class="std std-ref">bool</span></a> enable <strong>)</strong>
</td> </tr> <tr>
<td>void</td> <td>
<a href="#class-node-set-process-input"><span class="std std-ref">set_process_input</span></a> <strong>(</strong> <a href="../class_bool/#class-bool"><span class="std std-ref">bool</span></a> enable <strong>)</strong>
</td> </tr> <tr>
<td>void</td> <td>
<a href="#class-node-set-process-unhandled-input"><span class="std std-ref">set_process_unhandled_input</span></a> <strong>(</strong> <a href="../class_bool/#class-bool"><span class="std std-ref">bool</span></a> enable <strong>)</strong>
</td> </tr> <tr>
<td>void</td> <td>
<a href="#class-node-set-process-unhandled-key-input"><span class="std std-ref">set_process_unhandled_key_input</span></a> <strong>(</strong> <a href="../class_bool/#class-bool"><span class="std std-ref">bool</span></a> enable <strong>)</strong>
</td> </tr> <tr>
<td>void</td> <td>
<a href="#class-node-set-scene-instance-load-placeholder"><span class="std std-ref">set_scene_instance_load_placeholder</span></a> <strong>(</strong> <a href="../class_bool/#class-bool"><span class="std std-ref">bool</span></a> load_placeholder <strong>)</strong>
</td> </tr>  </table>   <h2 id="signals">Signals</h2> <ul class="simple"> <li>
<strong>enter_tree</strong> <strong>(</strong> <strong>)</strong>
</li> <li>
<strong>exit_tree</strong> <strong>(</strong> <strong>)</strong>
</li> <li>
<strong>renamed</strong> <strong>(</strong> <strong>)</strong>
</li> </ul> <p>Emitted when the node is renamed.</p>   <h2 id="numeric-constants">Numeric Constants</h2> <ul class="simple"> <li>
<strong>NOTIFICATION_ENTER_TREE</strong> = <strong>10</strong>
</li> <li>
<strong>NOTIFICATION_EXIT_TREE</strong> = <strong>11</strong>
</li> <li>
<strong>NOTIFICATION_MOVED_IN_PARENT</strong> = <strong>12</strong>
</li> <li>
<strong>NOTIFICATION_READY</strong> = <strong>13</strong>
</li> <li>
<strong>NOTIFICATION_FIXED_PROCESS</strong> = <strong>16</strong>
</li> <li>
<strong>NOTIFICATION_PROCESS</strong> = <strong>17</strong> — Notification received every frame when the process flag is set (see <a href="#class-node-set-process"><span class="std std-ref">set_process</span></a>).</li> <li>
<strong>NOTIFICATION_PARENTED</strong> = <strong>18</strong> — Notification received when a node is set as a child of another node. Note that this doesn’t mean that a node entered the Scene Tree.</li> <li>
<strong>NOTIFICATION_UNPARENTED</strong> = <strong>19</strong> — Notification received when a node is unparented (parent removed it from the list of children).</li> <li>
<strong>NOTIFICATION_PAUSED</strong> = <strong>14</strong>
</li> <li>
<strong>NOTIFICATION_UNPAUSED</strong> = <strong>15</strong>
</li> <li>
<strong>NOTIFICATION_INSTANCED</strong> = <strong>20</strong>
</li> <li>
<strong>NOTIFICATION_DRAG_BEGIN</strong> = <strong>21</strong>
</li> <li>
<strong>NOTIFICATION_DRAG_END</strong> = <strong>22</strong>
</li> <li>
<strong>PAUSE_MODE_INHERIT</strong> = <strong>0</strong>
</li> <li>
<strong>PAUSE_MODE_STOP</strong> = <strong>1</strong>
</li> <li>
<strong>PAUSE_MODE_PROCESS</strong> = <strong>2</strong>
</li> <li>
<strong>DUPLICATE_SIGNALS</strong> = <strong>1</strong>
</li> <li>
<strong>DUPLICATE_GROUPS</strong> = <strong>2</strong>
</li> <li>
<strong>DUPLICATE_SCRIPTS</strong> = <strong>4</strong>
</li> </ul>   <h2 id="description">Description</h2> <p>Nodes are the base bricks with which Godot games are developed. They can be set as children of other nodes, resulting in a tree arrangement. A given node can contain any number of nodes as children (but there is only one scene tree root node) with the requirement that all siblings (direct children of a node) should have unique names.</p> <p>Any tree of nodes is called a <em>scene</em>. Scenes can be saved to the disk and then instanced into other scenes. This allows for very high flexibility in the architecture and data model of the projects. Nodes can optionally be added to groups. This makes it easy to reach a number of nodes from the code (for example an “enemies” group) to perform grouped actions.</p> <p><strong>Scene tree:</strong> The <a href="../class_scenetree/#class-scenetree"><span class="std std-ref">SceneTree</span></a> contains the active tree of nodes. When a node is added to the scene tree, it receives the NOTIFICATION_ENTER_TREE notification and its <a href="#class-node-enter-tree"><span class="std std-ref">_enter_tree</span></a> callback is triggered. Children nodes are always added <em>after</em> their parent node, i.e. the <a href="#class-node-enter-tree"><span class="std std-ref">_enter_tree</span></a> callback of a parent node will be triggered before its child’s.</p> <p>Once all nodes have been added in the scene tree, they receive the NOTIFICATION_READY notification and their respective <a href="#class-node-ready"><span class="std std-ref">_ready</span></a> callbacks are triggered. For groups of nodes, the <a href="#class-node-ready"><span class="std std-ref">_ready</span></a> callback is called in reverse order, from the children up to the parent nodes.</p> <p>It means that when adding a scene to the scene tree, the following order will be used for the callbacks: <a href="#class-node-enter-tree"><span class="std std-ref">_enter_tree</span></a> of the parent, <a href="#class-node-enter-tree"><span class="std std-ref">_enter_tree</span></a> of the children, <a href="#class-node-ready"><span class="std std-ref">_ready</span></a> of the children and finally <a href="#class-node-ready"><span class="std std-ref">_ready</span></a> of the parent (and that recursively for the whole scene).</p> <p><strong>Processing:</strong> Nodes can be set to the “process” state, so that they receive a callback on each frame requesting them to process (do something). Normal processing (callback <a href="#class-node-process"><span class="std std-ref">_process</span></a>, toggled with <a href="#class-node-set-process"><span class="std std-ref">set_process</span></a>) happens as fast as possible and is dependent on the frame rate, so the processing time <em>delta</em> is variable. Fixed processing (callback <a href="#class-node-fixed-process"><span class="std std-ref">_fixed_process</span></a>, toggled with <a href="#class-node-set-fixed-process"><span class="std std-ref">set_fixed_process</span></a>) happens a fixed amount of times per second (by default 60) and is useful to link itself to the physics.</p> <p>Nodes can also process input events. When set, the <a href="#class-node-input"><span class="std std-ref">_input</span></a> function will be called for each input that the program receives. In many cases, this can be overkill (unless used for simple projects), and the <a href="#class-node-unhandled-input"><span class="std std-ref">_unhandled_input</span></a> function might be preferred; it is called when the input event was not handled by anyone else (typically, GUI <a href="../class_control/#class-control"><span class="std std-ref">Control</span></a> nodes), ensuring that the node only receives the events that were meant for it.</p> <p>To keep track of the scene hierarchy (especially when instancing scenes into other scenes), an “owner” can be set for the node with <a href="#class-node-set-owner"><span class="std std-ref">set_owner</span></a>. This keeps track of who instanced what. This is mostly useful when writing editors and tools, though.</p> <p>Finally, when a node is freed with <span class="xref std std-ref">free</span> or <a href="#class-node-queue-free"><span class="std std-ref">queue_free</span></a>, it will also free all its children.</p>   <h2 id="member-function-description">Member Function Description</h2> <h3 id="class-node-enter-tree">void _enter_tree ( ) virtual</h3> <p>Called when the node enters the <a href="../class_scenetree/#class-scenetree"><span class="std std-ref">SceneTree</span></a> (e.g. upon instancing, scene changing or after calling <a href="#class-node-add-child"><span class="std std-ref">add_child</span></a> in a script). If the node has children, its <a href="#class-node-enter-tree"><span class="std std-ref">_enter_tree</span></a> callback will be called first, and then that of the children.</p> <p>Corresponds to the NOTIFICATION_ENTER_TREE notification in <a href="../class_object/#class-object-notification"><span class="std std-ref">Object._notification</span></a>.</p> <h3 id="class-node-exit-tree">void _exit_tree ( ) virtual</h3> <p>Called when the node leaves the <a href="../class_scenetree/#class-scenetree"><span class="std std-ref">SceneTree</span></a> (e.g. upon freeing, scene changing or after calling <a href="#class-node-remove-child"><span class="std std-ref">remove_child</span></a> in a script). If the node has children, its <a href="#class-node-exit-tree"><span class="std std-ref">_exit_tree</span></a> callback will be called last, after all its children have left the tree.</p> <p>Corresponds to the NOTIFICATION_EXIT_TREE notification in <a href="../class_object/#class-object-notification"><span class="std std-ref">Object._notification</span></a>.</p> <h3 id="class-node-fixed-process">void _fixed_process ( <a href="../class_float/#class-float"><span class="std std-ref">float</span></a> delta ) virtual</h3> <p>Called during the fixed processing step of the main loop. Fixed processing means that the frame rate is synced to the physics, i.e. the <code>delta</code> variable should be constant.</p> <p>It is only called if fixed processing has been enabled with <a href="#class-node-set-fixed-process"><span class="std std-ref">set_fixed_process</span></a>.</p> <p>Corresponds to the NOTIFICATION_FIXED_PROCESS notification in <a href="../class_object/#class-object-notification"><span class="std std-ref">Object._notification</span></a>.</p> <h3 id="class-node-input">void _input ( <a href="../class_inputevent/#class-inputevent"><span class="std std-ref">InputEvent</span></a> event ) virtual</h3> <p>Called for every input event.</p> <p>It has to be enabled with <a href="#class-node-set-process-input"><span class="std std-ref">set_process_input</span></a> or the corresponding property in the inspector.</p> <h3 id="class-node-process">void _process ( <a href="../class_float/#class-float"><span class="std std-ref">float</span></a> delta ) virtual</h3> <p>Called during the processing step of the main loop. Processing happens at every frame and as fast as possible, so the <code>delta</code> time since the previous frame is not constant.</p> <p>It is only called if processing has been enabled with <a href="#class-node-set-process"><span class="std std-ref">set_process</span></a>.</p> <p>Corresponds to the NOTIFICATION_PROCESS notification in <a href="../class_object/#class-object-notification"><span class="std std-ref">Object._notification</span></a>.</p> <h3 id="class-node-ready">void _ready ( ) virtual</h3> <p>Called when the node is “ready”, i.e. when both the node and its children have entered the scene tree. If the node has children, their <a href="#class-node-ready"><span class="std std-ref">_ready</span></a> callback gets triggered first, and the node will receive the ready notification only afterwards.</p> <p>Corresponds to the NOTIFICATION_READY notification in <a href="../class_object/#class-object-notification"><span class="std std-ref">Object._notification</span></a>.</p> <h3 id="class-node-unhandled-input">void _unhandled_input ( <a href="../class_inputevent/#class-inputevent"><span class="std std-ref">InputEvent</span></a> event ) virtual</h3> <p>Called for every input event that has not already been handled by another node.</p> <p>It has to be enabled with <a href="#class-node-set-process-unhandled-input"><span class="std std-ref">set_process_unhandled_input</span></a> or the corresponding property in the inspector.</p> <h3 id="class-node-unhandled-key-input">void _unhandled_key_input ( <a href="../class_inputevent/#class-inputevent"><span class="std std-ref">InputEvent</span></a> key_event ) virtual</h3> <p>Called for every <em>key</em> input event that has not already been handled by another node.</p> <p>It has to be enabled with <a href="#class-node-set-process-unhandled-key-input"><span class="std std-ref">set_process_unhandled_key_input</span></a> or the corresponding property in the inspector.</p> <h3 id="class-node-add-child">void add_child ( <a href="#class-node"><span class="std std-ref">Node</span></a> node, <a href="../class_bool/#class-bool"><span class="std std-ref">bool</span></a> legible_unique_name=false )</h3> <p>Add a child <a href="#class-node"><span class="std std-ref">Node</span></a>. Nodes can have as many children as they want, but every child must have a unique name. Children nodes are automatically deleted when the parent node is deleted, so deleting a whole scene is performed by deleting its topmost node.</p> <p>The optional boolean argument enforces creating child nodes with human-readable names, based on the name of the node being instanced instead of its type only.</p> <h3 id="class-node-add-to-group">void add_to_group ( <a href="../class_string/#class-string"><span class="std std-ref">String</span></a> group, <a href="../class_bool/#class-bool"><span class="std std-ref">bool</span></a> persistent=false )</h3> <p>Add a node to a group. Groups are helpers to name and organize a subset of nodes, like for example “enemies” or “collectables”. A <a href="#class-node"><span class="std std-ref">Node</span></a> can be in any number of groups. Nodes can be assigned a group at any time, but will not be added to it until they are inside the scene tree (see <a href="#class-node-is-inside-tree"><span class="std std-ref">is_inside_tree</span></a>).</p> <h3 id="class-node-can-process">
<a href="../class_bool/#class-bool"><span class="std std-ref">bool</span></a> can_process ( ) const</h3> <p>Return true if the node can process, i.e. whether its pause mode allows processing while the scene tree is paused (see <a href="#class-node-set-pause-mode"><span class="std std-ref">set_pause_mode</span></a>). Always returns true if the scene tree is not paused, and false if the node is not in the tree. FIXME: Why FAIL_COND?</p> <h3 id="class-node-duplicate">
<a href="#class-node"><span class="std std-ref">Node</span></a> duplicate ( <a href="../class_bool/#class-bool"><span class="std std-ref">bool</span></a> use_instancing=false, <a href="../class_int/#class-int"><span class="std std-ref">int</span></a> flags=7 ) const</h3> <p>Duplicate the node, returning a new <a href="#class-node"><span class="std std-ref">Node</span></a>. If <code>use_instancing</code> is true, the duplicated node will be a new instance of the original <a href="../class_packedscene/#class-packedscene"><span class="std std-ref">PackedScene</span></a>, if not it will be an independent node.</p> <p>The flags are used to define what attributes (groups, signals, scripts) should be duplicated, as specified by the DUPLICATE_* constants. The default value is all of them.</p> <h3 id="class-node-find-node">
<a href="#class-node"><span class="std std-ref">Node</span></a> find_node ( <a href="../class_string/#class-string"><span class="std std-ref">String</span></a> mask, <a href="../class_bool/#class-bool"><span class="std std-ref">bool</span></a> recursive=true, <a href="../class_bool/#class-bool"><span class="std std-ref">bool</span></a> owned=true ) const</h3> <p>Find a descendant of this node whose name matches <code>mask</code> as in <a href="../class_string/#class-string-match"><span class="std std-ref">String.match</span></a> (i.e. case sensitive, but ‘*’ matches zero or more characters and ‘?’ matches any single character except ‘.’). Note that it does not match against the full path, just against individual node names.</p> <h3 id="class-node-get-child">
<a href="#class-node"><span class="std std-ref">Node</span></a> get_child ( <a href="../class_int/#class-int"><span class="std std-ref">int</span></a> idx ) const</h3> <p>Return a child node by its index (see <a href="#class-node-get-child-count"><span class="std std-ref">get_child_count</span></a>). This method is often used for iterating all children of a node.</p> <h3 id="class-node-get-child-count">
<a href="../class_int/#class-int"><span class="std std-ref">int</span></a> get_child_count ( ) const</h3> <p>Return the amount of child nodes.</p> <h3 id="class-node-get-children">
<a href="../class_array/#class-array"><span class="std std-ref">Array</span></a> get_children ( ) const</h3> <p>Return an array of references (<a href="#class-node"><span class="std std-ref">Node</span></a>) to the child nodes.</p> <h3 id="class-node-get-filename">
<a href="../class_string/#class-string"><span class="std std-ref">String</span></a> get_filename ( ) const</h3> <p>Return a filename that may be contained by the node. When a scene is instanced from a file, it topmost node contains the filename from where it was loaded (see <a href="#class-node-set-filename"><span class="std std-ref">set_filename</span></a>).</p> <h3 id="class-node-get-fixed-process-delta-time">
<a href="../class_float/#class-float"><span class="std std-ref">float</span></a> get_fixed_process_delta_time ( ) const</h3> <p>Return the time elapsed since the last fixed frame (see <a href="#class-node-fixed-process"><span class="std std-ref">_fixed_process</span></a>). This is always the same in fixed processing unless the frames per second is changed in <a href="../class_os/#class-os"><span class="std std-ref">OS</span></a>.</p> <h3 id="class-node-get-groups">
<a href="../class_array/#class-array"><span class="std std-ref">Array</span></a> get_groups ( ) const</h3> <p>Return an array listing the groups that the node is part of.</p> <h3 id="class-node-get-index">
<a href="../class_int/#class-int"><span class="std std-ref">int</span></a> get_index ( ) const</h3> <p>Get the node index, i.e. its position among the siblings of its parent.</p> <h3 id="class-node-get-name">
<a href="../class_string/#class-string"><span class="std std-ref">String</span></a> get_name ( ) const</h3> <p>Return the name of the node. This name is unique among the siblings (other child nodes from the same parent).</p> <h3 id="class-node-get-node">
<a href="#class-node"><span class="std std-ref">Node</span></a> get_node ( <a href="../class_nodepath/#class-nodepath"><span class="std std-ref">NodePath</span></a> path ) const</h3> <p>Fetch a node. The <a href="../class_nodepath/#class-nodepath"><span class="std std-ref">NodePath</span></a> must be valid (or else an error will be raised) and can be either the path to child node, a relative path (from the current node to another node), or an absolute path to a node.</p> <p>Note: fetching absolute paths only works when the node is inside the scene tree (see <a href="#class-node-is-inside-tree"><span class="std std-ref">is_inside_tree</span></a>).</p> <p><em>Example:</em> Assume your current node is Character and the following tree:</p> <pre data-language="gdscript">/root
/root/Character
/root/Character/Sword
/root/Character/Backpack/Dagger
/root/MyGame
/root/Swamp/Alligator
/root/Swamp/Mosquito
/root/Swamp/Goblin
</pre> <p>Possible paths are:</p> <pre data-language="gdscript">get_node("Sword")
get_node("Backpack/Dagger")
get_node("../Swamp/Alligator")
get_node("/root/MyGame")
</pre> <h3 id="class-node-get-node-and-resource">
<a href="../class_array/#class-array"><span class="std std-ref">Array</span></a> get_node_and_resource ( <a href="../class_nodepath/#class-nodepath"><span class="std std-ref">NodePath</span></a> path )</h3> <h3 id="class-node-get-owner">
<a href="#class-node"><span class="std std-ref">Node</span></a> get_owner ( ) const</h3> <p>Get the node owner (see <a href="#class-node-set-owner"><span class="std std-ref">set_owner</span></a>).</p> <h3 id="class-node-get-parent">
<a href="#class-node"><span class="std std-ref">Node</span></a> get_parent ( ) const</h3> <p>Return the parent node of the current node, or an empty <a href="#class-node"><span class="std std-ref">Node</span></a> if the node lacks a parent.</p> <h3 id="class-node-get-path">
<a href="../class_nodepath/#class-nodepath"><span class="std std-ref">NodePath</span></a> get_path ( ) const</h3> <p>Return the absolute path of the current node. This only works if the current node is inside the scene tree (see <a href="#class-node-is-inside-tree"><span class="std std-ref">is_inside_tree</span></a>).</p> <h3 id="class-node-get-path-to">
<a href="../class_nodepath/#class-nodepath"><span class="std std-ref">NodePath</span></a> get_path_to ( <a href="#class-node"><span class="std std-ref">Node</span></a> node ) const</h3> <p>Return the relative path from the current node to the specified node in “node” argument. Both nodes must be in the same scene, or else the function will fail.</p> <h3 id="class-node-get-pause-mode">
<a href="../class_int/#class-int"><span class="std std-ref">int</span></a> get_pause_mode ( ) const</h3> <h3 id="class-node-get-position-in-parent">
<a href="../class_int/#class-int"><span class="std std-ref">int</span></a> get_position_in_parent ( ) const</h3> <h3 id="class-node-get-process-delta-time">
<a href="../class_float/#class-float"><span class="std std-ref">float</span></a> get_process_delta_time ( ) const</h3> <p>Return the time elapsed (in seconds) since the last process callback. This is almost always different each time.</p> <h3 id="class-node-get-scene-instance-load-placeholder">
<a href="../class_bool/#class-bool"><span class="std std-ref">bool</span></a> get_scene_instance_load_placeholder ( ) const</h3> <h3 id="class-node-get-tree">
<a href="../class_scenetree/#class-scenetree"><span class="std std-ref">SceneTree</span></a> get_tree ( ) const</h3> <h3 id="class-node-get-viewport">
<a href="../class_object/#class-object"><span class="std std-ref">Object</span></a> get_viewport ( ) const</h3> <h3 id="class-node-has-node">
<a href="../class_bool/#class-bool"><span class="std std-ref">bool</span></a> has_node ( <a href="../class_nodepath/#class-nodepath"><span class="std std-ref">NodePath</span></a> path ) const</h3> <h3 id="class-node-has-node-and-resource">
<a href="../class_bool/#class-bool"><span class="std std-ref">bool</span></a> has_node_and_resource ( <a href="../class_nodepath/#class-nodepath"><span class="std std-ref">NodePath</span></a> path ) const</h3> <h3 id="class-node-is-a-parent-of">
<a href="../class_bool/#class-bool"><span class="std std-ref">bool</span></a> is_a_parent_of ( <a href="#class-node"><span class="std std-ref">Node</span></a> node ) const</h3> <p>Return <em>true</em> if the “node” argument is a direct or indirect child of the current node, otherwise return <em>false</em>.</p> <h3 id="class-node-is-displayed-folded">
<a href="../class_bool/#class-bool"><span class="std std-ref">bool</span></a> is_displayed_folded ( ) const</h3> <h3 id="class-node-is-fixed-processing">
<a href="../class_bool/#class-bool"><span class="std std-ref">bool</span></a> is_fixed_processing ( ) const</h3> <p>Return true if fixed processing is enabled (see <a href="#class-node-set-fixed-process"><span class="std std-ref">set_fixed_process</span></a>).</p> <h3 id="class-node-is-greater-than">
<a href="../class_bool/#class-bool"><span class="std std-ref">bool</span></a> is_greater_than ( <a href="#class-node"><span class="std std-ref">Node</span></a> node ) const</h3> <p>Return <em>true</em> if “node” occurs later in the scene hierarchy than the current node, otherwise return <em>false</em>.</p> <h3 id="class-node-is-in-group">
<a href="../class_bool/#class-bool"><span class="std std-ref">bool</span></a> is_in_group ( <a href="../class_string/#class-string"><span class="std std-ref">String</span></a> group ) const</h3> <h3 id="class-node-is-inside-tree">
<a href="../class_bool/#class-bool"><span class="std std-ref">bool</span></a> is_inside_tree ( ) const</h3> <h3 id="class-node-is-processing">
<a href="../class_bool/#class-bool"><span class="std std-ref">bool</span></a> is_processing ( ) const</h3> <p>Return whether processing is enabled in the current node (see <a href="#class-node-set-process"><span class="std std-ref">set_process</span></a>).</p> <h3 id="class-node-is-processing-input">
<a href="../class_bool/#class-bool"><span class="std std-ref">bool</span></a> is_processing_input ( ) const</h3> <p>Return true if the node is processing input (see <a href="#class-node-set-process-input"><span class="std std-ref">set_process_input</span></a>).</p> <h3 id="class-node-is-processing-unhandled-input">
<a href="../class_bool/#class-bool"><span class="std std-ref">bool</span></a> is_processing_unhandled_input ( ) const</h3> <p>Return true if the node is processing unhandled input (see <a href="#class-node-set-process-unhandled-input"><span class="std std-ref">set_process_unhandled_input</span></a>).</p> <h3 id="class-node-is-processing-unhandled-key-input">
<a href="../class_bool/#class-bool"><span class="std std-ref">bool</span></a> is_processing_unhandled_key_input ( ) const</h3> <h3 id="class-node-move-child">void move_child ( <a href="#class-node"><span class="std std-ref">Node</span></a> child_node, <a href="../class_int/#class-int"><span class="std std-ref">int</span></a> to_pos )</h3> <p>Move a child node to a different position (order) amongst the other children. Since calls, signals, etc are performed by tree order, changing the order of children nodes may be useful.</p> <h3 id="class-node-print-stray-nodes">void print_stray_nodes ( )</h3> <h3 id="class-node-print-tree">void print_tree ( )</h3> <p>Print the scene to stdout. Used mainly for debugging purposes.</p> <h3 id="class-node-propagate-notification">void propagate_notification ( <a href="../class_int/#class-int"><span class="std std-ref">int</span></a> what )</h3> <p>Notify the current node and all its children recursively by calling notification() in all of them.</p> <h3 id="class-node-queue-free">void queue_free ( )</h3> <h3 id="class-node-raise">void raise ( )</h3> <p>Move this node to the top of the array of nodes of the parent node. This is often useful on GUIs (<a href="../class_control/#class-control"><span class="std std-ref">Control</span></a>), because their order of drawing fully depends on their order in the tree.</p> <h3 id="class-node-remove-and-skip">void remove_and_skip ( )</h3> <p>Remove a node and set all its children as children of the parent node (if exists). All even subscriptions that pass by the removed node will be unsubscribed.</p> <h3 id="class-node-remove-child">void remove_child ( <a href="#class-node"><span class="std std-ref">Node</span></a> node )</h3> <p>Remove a child <a href="#class-node"><span class="std std-ref">Node</span></a>. Node is NOT deleted and will have to be deleted manually.</p> <h3 id="class-node-remove-from-group">void remove_from_group ( <a href="../class_string/#class-string"><span class="std std-ref">String</span></a> group )</h3> <p>Remove a node from a group.</p> <h3 id="class-node-replace-by">void replace_by ( <a href="#class-node"><span class="std std-ref">Node</span></a> node, <a href="../class_bool/#class-bool"><span class="std std-ref">bool</span></a> keep_data=false )</h3> <p>Replace a node in a scene by a given one. Subscriptions that pass through this node will be lost.</p> <h3 id="class-node-set-display-folded">void set_display_folded ( <a href="../class_bool/#class-bool"><span class="std std-ref">bool</span></a> fold )</h3> <h3 id="class-node-set-filename">void set_filename ( <a href="../class_string/#class-string"><span class="std std-ref">String</span></a> filename )</h3> <p>A node can contain a filename. This filename should not be changed by the user, unless writing editors and tools. When a scene is instanced from a file, it topmost node contains the filename from where it was loaded.</p> <h3 id="class-node-set-fixed-process">void set_fixed_process ( <a href="../class_bool/#class-bool"><span class="std std-ref">bool</span></a> enable )</h3> <p>Enables or disables node fixed framerate processing. When a node is being processed, it will receive a NOTIFICATION_PROCESS at a fixed (usually 60 fps, check <a href="../class_os/#class-os"><span class="std std-ref">OS</span></a> to change that) interval (and the <a href="#class-node-fixed-process"><span class="std std-ref">_fixed_process</span></a> callback will be called if exists). It is common to check how much time was elapsed since the previous frame by calling <a href="#class-node-get-fixed-process-delta-time"><span class="std std-ref">get_fixed_process_delta_time</span></a>.</p> <h3 id="class-node-set-name">void set_name ( <a href="../class_string/#class-string"><span class="std std-ref">String</span></a> name )</h3> <p>Set the name of the <a href="#class-node"><span class="std std-ref">Node</span></a>. Name must be unique within parent, and setting an already existing name will cause for the node to be automatically renamed.</p> <h3 id="class-node-set-owner">void set_owner ( <a href="#class-node"><span class="std std-ref">Node</span></a> owner )</h3> <p>Set the node owner. A node can have any other node as owner (as long as a valid parent, grandparent, etc ascending in the tree). When saving a node (using SceneSaver) all the nodes it owns will be saved with it. This allows to create complex SceneTrees, with instancing and subinstancing.</p> <h3 id="class-node-set-pause-mode">void set_pause_mode ( <a href="../class_int/#class-int"><span class="std std-ref">int</span></a> mode )</h3> <h3 id="class-node-set-process">void set_process ( <a href="../class_bool/#class-bool"><span class="std std-ref">bool</span></a> enable )</h3> <p>Enables or disables node processing. When a node is being processed, it will receive a NOTIFICATION_PROCESS on every drawn frame (and the <a href="#class-node-process"><span class="std std-ref">_process</span></a> callback will be called if exists). It is common to check how much time was elapsed since the previous frame by calling <a href="#class-node-get-process-delta-time"><span class="std std-ref">get_process_delta_time</span></a>.</p> <h3 id="class-node-set-process-input">void set_process_input ( <a href="../class_bool/#class-bool"><span class="std std-ref">bool</span></a> enable )</h3> <p>Enable input processing for node. This is not required for GUI controls! It hooks up the node to receive all input (see <a href="#class-node-input"><span class="std std-ref">_input</span></a>).</p> <h3 id="class-node-set-process-unhandled-input">void set_process_unhandled_input ( <a href="../class_bool/#class-bool"><span class="std std-ref">bool</span></a> enable )</h3> <p>Enable unhandled input processing for node. This is not required for GUI controls! It hooks up the node to receive all input that was not previously handled before (usually by a <a href="../class_control/#class-control"><span class="std std-ref">Control</span></a>). (see <a href="#class-node-unhandled-input"><span class="std std-ref">_unhandled_input</span></a>).</p> <h3 id="class-node-set-process-unhandled-key-input">void set_process_unhandled_key_input ( <a href="../class_bool/#class-bool"><span class="std std-ref">bool</span></a> enable )</h3> <h3 id="class-node-set-scene-instance-load-placeholder">void set_scene_instance_load_placeholder ( <a href="../class_bool/#class-bool"><span class="std std-ref">bool</span></a> load_placeholder )</h3>
<div class="_attribution">
  <p class="_attribution-p">
    © 2014–2017 Juan Linietsky, Ariel Manzur, Godot Engine contributors<br>Licensed under the MIT License.<br>
    <a href="http://docs.godotengine.org/en/2.1/classes/class_node.html" class="_attribution-link" target="_blank">http://docs.godotengine.org/en/2.1/classes/class_node.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
