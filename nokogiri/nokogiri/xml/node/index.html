
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Nokogiri&#58;&#58;XML&#58;&#58;Node - Nokogiri - W3cubDocs</title>
  
  <meta name="description" content="Nokogiri&#58;&#58;XML&#58;&#58;Node is your window to the fun filled world of dealing with XML and HTML tags. A Nokogiri&#58;&#58;XML&#58;&#58;Node &hellip;">
  <meta name="keywords" content="class, nokogiri, xml, node, -">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/nokogiri/nokogiri/xml/node/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-e0f881b0fce8cbe96f33dadc355b7159d5d2912911231446d60eb8f9caffa802.css">
  <script type="text/javascript" src="/assets/application-8fc46316434047265cd383f02b8e7f434ed7dec4a59f920dd633deef8d488d1b.js"></script>
  <script src="/json/nokogiri.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/nokogiri/" class="_nav-link" title="" style="margin-left:0;">Nokogiri</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _rdoc">
				
<h1 id="class-Nokogiri::XML::Node" class="class"> class Nokogiri::XML::Node </h1>
<dl class="meta">
<dt>Parent:</dt>
<dd class="meta-parent"><span>Object</span></dd>
<dt>Included modules:</dt>
<dd class="meta-includes">
<a class="include" href="../pp/node/">Nokogiri::XML::PP::Node</a>, <a class="include" href="../searchable/">Nokogiri::XML::Searchable</a>
</dd>
</dl> <section class="description"> <p><a href="../node/">Nokogiri::XML::Node</a> is your window to the fun filled world of dealing with <a href="../../xml/">XML</a> and <a href="../../html/">HTML</a> tags. A <a href="../node/">Nokogiri::XML::Node</a> may be treated similarly to a hash with regard to attributes. For example (from irb):</p> <pre>irb(main):004:0&gt; node
=&gt; &lt;a href="#foo" id="link"&gt;link&lt;/a&gt;
irb(main):005:0&gt; node['href']
=&gt; "#foo"
irb(main):006:0&gt; node.keys
=&gt; ["href", "id"]
irb(main):007:0&gt; node.values
=&gt; ["#foo", "link"]
irb(main):008:0&gt; node['class'] = 'green'
=&gt; "green"
irb(main):009:0&gt; node
=&gt; &lt;a href="#foo" id="link" class="green"&gt;link&lt;/a&gt;
irb(main):010:0&gt;</pre> <p>See <a href="../node/#method-i-5B-5D">#[]</a> and Nokogiri::XML#[]= for more information.</p> <p><a href="../node/">Nokogiri::XML::Node</a> also has methods that let you move around your tree. For navigating your tree, see:</p> <ul>
<li> <p><a href="../node/#method-i-parent">#parent</a></p> </li>
<li> <p><a href="../node/#method-i-children">#children</a></p> </li>
<li> <p><a href="../node/#method-i-next">#next</a></p> </li>
<li> <p><a href="../node/#method-i-previous">#previous</a></p> </li>
</ul> <p>When printing or otherwise emitting a document or a node (and its subtree), there are a few methods you might want to use:</p> <ul>
<li> <p>content, text, <a href="../node/#method-i-inner_text">#inner_text</a>, <a href="../node/#method-i-to_str">#to_str</a>: emit plaintext</p> <p>These methods will all emit the plaintext version of your document, meaning that entities will be replaced (e.g., “&amp;lt;” will be replaced with “&lt;”), meaning that any sanitizing will likely be un-done in the output.</p> </li>
<li> <p><a href="../node/#method-i-to_s">#to_s</a>, <a href="../node/#method-i-to_xml">#to_xml</a>, <a href="../node/#method-i-to_html">#to_html</a>, <a href="../node/#method-i-inner_html">#inner_html</a>: emit well-formed markup</p> <p>These methods will all emit properly-escaped markup, meaning that it's suitable for consumption by browsers, parsers, etc.</p> </li>
</ul> <p>You may search this node's subtree using <a href="../searchable/#method-i-xpath">Nokogiri::XML::Searchable#xpath</a> and <a href="../searchable/#method-i-css">Nokogiri::XML::Searchable#css</a></p> </section> <section id="5Buntitled-5D" class="documentation-section"> <section class="constants-list"> <header> <h3>Constants</h3> </header> <dl> <dt id="ATTRIBUTE_DECL">ATTRIBUTE_DECL </dt>
<dd>
<p>Attribute declaration type</p> </dd>
<dt id="ATTRIBUTE_NODE">ATTRIBUTE_NODE </dt>
<dd>
<p>Attribute node type</p> </dd>
<dt id="CDATA_SECTION_NODE">CDATA_SECTION_NODE </dt>
<dd>
<p><a href="../cdata/">CDATA</a> node type, see <a href="../node/#method-i-cdata-3F">#cdata?</a></p> </dd>
<dt id="COMMENT_NODE">COMMENT_NODE </dt>
<dd>
<p><a href="../comment/">Comment</a> node type, see <a href="../node/#method-i-comment-3F">#comment?</a></p> </dd>
<dt id="DOCB_DOCUMENT_NODE">DOCB_DOCUMENT_NODE </dt>
<dd>
<p>DOCB document node type</p> </dd>
<dt id="DOCUMENT_FRAG_NODE">DOCUMENT_FRAG_NODE </dt>
<dd>
<p><a href="../document/">Document</a> fragment node type</p> </dd>
<dt id="DOCUMENT_NODE">DOCUMENT_NODE </dt>
<dd>
<p><a href="../document/">Document</a> node type, see <a href="../node/#method-i-xml-3F">#xml?</a></p> </dd>
<dt id="DOCUMENT_TYPE_NODE">DOCUMENT_TYPE_NODE </dt>
<dd>
<p><a href="../document/">Document</a> type node type</p> </dd>
<dt id="DTD_NODE">DTD_NODE </dt>
<dd>
<p><a href="../dtd/">DTD</a> node type</p> </dd>
<dt id="ELEMENT_DECL">ELEMENT_DECL </dt>
<dd>
<p><a href="../element/">Element</a> declaration type</p> </dd>
<dt id="ELEMENT_NODE">ELEMENT_NODE </dt>
<dd>
<p><a href="../element/">Element</a> node type, see <a href="../node/#method-i-element-3F">#element?</a></p> </dd>
<dt id="ENTITY_DECL">ENTITY_DECL </dt>
<dd>
<p>Entity declaration type</p> </dd>
<dt id="ENTITY_NODE">ENTITY_NODE </dt>
<dd>
<p>Entity node type</p> </dd>
<dt id="ENTITY_REF_NODE">ENTITY_REF_NODE </dt>
<dd>
<p>Entity reference node type</p> </dd>
<dt id="HTML_DOCUMENT_NODE">HTML_DOCUMENT_NODE </dt>
<dd>
<p><a href="../../html/">HTML</a> document node type, see <a href="../node/#method-i-html-3F">#html?</a></p> </dd>
<dt id="NAMESPACE_DECL">NAMESPACE_DECL </dt>
<dd>
<p><a href="../namespace/">Namespace</a> declaration type</p> </dd>
<dt id="NOTATION_NODE">NOTATION_NODE </dt>
<dd>
<p><a href="../notation/">Notation</a> node type</p> </dd>
<dt id="PI_NODE">PI_NODE </dt>
<dd>
<p>PI node type</p> </dd>
<dt id="TEXT_NODE">TEXT_NODE </dt>
<dd>
<p><a href="../text/">Text</a> node type, see <a href="../node/#method-i-text-3F">#text?</a></p> </dd>
<dt id="XINCLUDE_END">XINCLUDE_END </dt>
<dd>
<p>XInclude end type</p> </dd>
<dt id="XINCLUDE_START">XINCLUDE_START </dt>
<dd>
<p>XInclude start type</p> </dd>
</dl> </section> <section id="public-class-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Class Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-c-new"> <span class="method-callseq"> new(name, document) </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Create a new node with <code>name</code> sharing GC lifecycle with <code>document</code></p> <div class="method-source-code" id="new-source"> <pre class="c" data-language="c">static VALUE new(int argc, VALUE *argv, VALUE klass)
{
  xmlDocPtr doc;
  xmlNodePtr node;
  VALUE name;
  VALUE document;
  VALUE rest;
  VALUE rb_node;

  rb_scan_args(argc, argv, "2*", &amp;name, &amp;document, &amp;rest);

  Data_Get_Struct(document, xmlDoc, doc);

  node = xmlNewNode(NULL, (xmlChar *)StringValueCStr(name));
  node-&gt;doc = doc-&gt;doc;
  nokogiri_root_node(node);

  rb_node = Nokogiri_wrap_xml_node(
      klass == cNokogiriXmlNode ? (VALUE)NULL : klass,
      node
  );
  rb_obj_call_init(rb_node, argc, argv);

  if(rb_block_given_p()) rb_yield(rb_node);

  return rb_node;
}</pre> </div> </div> </div> </section> <section id="public-instance-5Buntitled-5D-method-details" class="method-section"> <header> <h3>Public Instance Methods</h3> </header> <div class="method-detail "> <div class="method-heading" id="method-i-3C-3C"> <span class="method-name">&lt;&lt;</span><span class="method-args">(node_or_tags)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Add <code>node_or_tags</code> as a child of this <a href="../node/">Node</a>. <code>node_or_tags</code> can be a <a href="../node/">Nokogiri::XML::Node</a>, a ::DocumentFragment, a ::NodeSet, or a string containing markup.</p> <p>Returns self, to support chaining of calls (e.g., root &lt;&lt; child1 &lt;&lt; child2)</p> <p>Also see related method <code>add_child</code>.</p> <div class="method-source-code" id="3C-3C-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 170
def &lt;&lt; node_or_tags
  add_child node_or_tags
  self
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-3C-3D-3E"> <span class="method-name">&lt;=&gt;</span><span class="method-args">(other)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Compare two <a href="../node/">Node</a> objects with respect to their <a href="../document/">Document</a>. Nodes from different documents cannot be compared.</p> <div class="method-source-code" id="3C-3D-3E-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 731
def &lt;=&gt; other
  return nil unless other.is_a?(Nokogiri::XML::Node)
  return nil unless document == other.document
  compare other
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-3D-3D"> <span class="method-name">==</span><span class="method-args">(other)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Test to see if this <a href="../node/">Node</a> is equal to <code>other</code></p> <div class="method-source-code" id="3D-3D-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 596
def == other
  return false unless other
  return false unless other.respond_to?(:pointer_id)
  pointer_id == other.pointer_id
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-3E"> <span class="method-name">&gt;</span><span class="method-args">(selector)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Search this node's immediate children using <a href="../../css/">CSS</a> selector <code>selector</code></p> <div class="method-source-code" id="3E-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 112
def &gt; selector
  ns = document.root.namespaces
  xpath CSS.xpath_for(selector, :prefix =&gt; "./", :ns =&gt; ns).first
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-5B-5D"> <span class="method-name">[]</span><span class="method-args">(name)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Get the attribute value for the attribute <code>name</code></p> <div class="method-source-code" id="5B-5D-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 119
def [] name
  get(name.to_s)
end</pre> </div> </div> <div class="aliases"> Also aliased as: <a href="../node/#method-i-get_attribute">get_attribute</a>, <a href="../node/#method-i-attr">attr</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-5B-5D-3D"> <span class="method-name">[]=</span><span class="method-args">(name, value)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Set the attribute value for the attribute <code>name</code> to <code>value</code></p> <div class="method-source-code" id="5B-5D-3D-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 125
def []= name, value
  set name.to_s, value.to_s
end</pre> </div> </div> <div class="aliases"> Also aliased as: <a href="../node/#method-i-set_attribute">set_attribute</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-accept"> <span class="method-name">accept</span><span class="method-args">(visitor)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Accept a visitor. This method calls “visit” on <code>visitor</code> with self.</p> <div class="method-source-code" id="accept-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 590
def accept visitor
  visitor.visit(self)
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-add_child"> <span class="method-name">add_child</span><span class="method-args">(node_or_tags)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Add <code>node_or_tags</code> as a child of this <a href="../node/">Node</a>. <code>node_or_tags</code> can be a <a href="../node/">Nokogiri::XML::Node</a>, a ::DocumentFragment, a ::NodeSet, or a string containing markup.</p> <p>Returns the reparented node (if <code>node_or_tags</code> is a <a href="../node/">Node</a>), or <a href="../nodeset/">NodeSet</a> (if <code>node_or_tags</code> is a <a href="../documentfragment/">DocumentFragment</a>, <a href="../nodeset/">NodeSet</a>, or string).</p> <p>Also see related method +&lt;&lt;+.</p> <div class="method-source-code" id="add_child-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 136
def add_child node_or_tags
  node_or_tags = coerce(node_or_tags)
  if node_or_tags.is_a?(XML::NodeSet)
    node_or_tags.each { |n| add_child_node_and_reparent_attrs n }
  else
    add_child_node_and_reparent_attrs node_or_tags
  end
  node_or_tags
end</pre> </div> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-add_namespace"> <span class="method-name">add_namespace</span><span class="method-args">(p1, p2)</span> </div>  <div class="aliases"> Alias for: <a href="../node/#method-i-add_namespace_definition">add_namespace_definition</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-add_namespace_definition"> <span class="method-callseq"> add_namespace_definition(prefix, href) </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Adds a namespace definition with <code>prefix</code> using <code>href</code> value. The result is as if parsed <a href="../../xml/">XML</a> for this node had included an attribute 'xmlns:prefix=value'. A default namespace for this node (“xmlns=”) can be added by passing 'nil' for prefix. Namespaces added this way will not show up in <a href="../node/#method-i-attributes">attributes</a>, but they will be included as an xmlns attribute when the node is serialized to <a href="../../xml/">XML</a>.</p> <div class="method-source-code" id="add_namespace_definition-source"> <pre class="c" data-language="c">static VALUE add_namespace_definition(VALUE self, VALUE prefix, VALUE href)
{
  xmlNodePtr node, namespacee;
  xmlNsPtr ns;

  Data_Get_Struct(self, xmlNode, node);
  namespacee = node ;

  ns = xmlSearchNs(
      node-&gt;doc,
      node,
      (const xmlChar *)(NIL_P(prefix) ? NULL : StringValueCStr(prefix))
  );

  if(!ns) {
    if (node-&gt;type != XML_ELEMENT_NODE) {
      namespacee = node-&gt;parent;
    }
    ns = xmlNewNs(
        namespacee,
        (const xmlChar *)StringValueCStr(href),
        (const xmlChar *)(NIL_P(prefix) ? NULL : StringValueCStr(prefix))
    );
  }

  if (!ns) return Qnil ;

  if(NIL_P(prefix) || node != namespacee) xmlSetNs(node, ns);

  return Nokogiri_wrap_xml_namespace(node-&gt;doc, ns);
}</pre> </div> </div> <div class="aliases"> Also aliased as: <a href="../node/#method-i-add_namespace">add_namespace</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-add_next_sibling"> <span class="method-name">add_next_sibling</span><span class="method-args">(node_or_tags)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Insert <code>node_or_tags</code> after this <a href="../node/">Node</a> (as a sibling). <code>node_or_tags</code> can be a <a href="../node/">Nokogiri::XML::Node</a>, a ::DocumentFragment, a ::NodeSet, or a string containing markup.</p> <p>Returns the reparented node (if <code>node_or_tags</code> is a <a href="../node/">Node</a>), or <a href="../nodeset/">NodeSet</a> (if <code>node_or_tags</code> is a <a href="../documentfragment/">DocumentFragment</a>, <a href="../nodeset/">NodeSet</a>, or string).</p> <p>Also see related method <code>after</code>.</p> <div class="method-source-code" id="add_next_sibling-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 195
def add_next_sibling node_or_tags
  raise ArgumentError.new("A document may not have multiple root nodes.") if (parent &amp;&amp; parent.document?) &amp;&amp; !(node_or_tags.comment? || node_or_tags.processing_instruction?)

  add_sibling :next, node_or_tags
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-add_previous_sibling"> <span class="method-name">add_previous_sibling</span><span class="method-args">(node_or_tags)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Insert <code>node_or_tags</code> before this <a href="../node/">Node</a> (as a sibling). <code>node_or_tags</code> can be a <a href="../node/">Nokogiri::XML::Node</a>, a ::DocumentFragment, a ::NodeSet, or a string containing markup.</p> <p>Returns the reparented node (if <code>node_or_tags</code> is a <a href="../node/">Node</a>), or <a href="../nodeset/">NodeSet</a> (if <code>node_or_tags</code> is a <a href="../documentfragment/">DocumentFragment</a>, <a href="../nodeset/">NodeSet</a>, or string).</p> <p>Also see related method <code>before</code>.</p> <div class="method-source-code" id="add_previous_sibling-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 182
def add_previous_sibling node_or_tags
  raise ArgumentError.new("A document may not have multiple root nodes.") if (parent &amp;&amp; parent.document?) &amp;&amp; !(node_or_tags.comment? || node_or_tags.processing_instruction?)

  add_sibling :previous, node_or_tags
end</pre> </div> </div> <div class="aliases"> Also aliased as: <a href="../node/#method-i-previous-3D">previous=</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-after"> <span class="method-name">after</span><span class="method-args">(node_or_tags)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Insert <code>node_or_tags</code> after this node (as a sibling). <code>node_or_tags</code> can be a <a href="../node/">Nokogiri::XML::Node</a>, a <a href="../documentfragment/">Nokogiri::XML::DocumentFragment</a>, or a string containing markup.</p> <p>Returns self, to support chaining of calls.</p> <p>Also see related method <code>add_next_sibling</code>.</p> <div class="method-source-code" id="after-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 220
def after node_or_tags
  add_next_sibling node_or_tags
  self
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-ancestors"> <span class="method-name">ancestors</span><span class="method-args">(selector = nil)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Get a list of ancestor <a href="../node/">Node</a> for this <a href="../node/">Node</a>. If <code>selector</code> is given, the ancestors must match <code>selector</code></p> <div class="method-source-code" id="ancestors-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 530
def ancestors selector = nil
  return NodeSet.new(document) unless respond_to?(:parent)
  return NodeSet.new(document) unless parent

  parents = [parent]

  while parents.last.respond_to?(:parent)
    break unless ctx_parent = parents.last.parent
    parents &lt;&lt; ctx_parent
  end

  return NodeSet.new(document, parents) unless selector

  root = parents.last
  search_results = root.search(selector)

  NodeSet.new(document, parents.find_all { |parent|
    search_results.include?(parent)
  })
end</pre> </div> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-attr"> <span class="method-name">attr</span><span class="method-args">(name)</span> </div>  <div class="aliases"> Alias for: <a href="../node/#method-i-5B-5D">[]</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-attribute"> <span class="method-callseq"> attribute(name) </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Get the attribute node with <code>name</code></p> <div class="method-source-code" id="attribute-source"> <pre class="c" data-language="c">static VALUE attr(VALUE self, VALUE name)
{
  xmlNodePtr node;
  xmlAttrPtr prop;
  Data_Get_Struct(self, xmlNode, node);
  prop = xmlHasProp(node, (xmlChar *)StringValueCStr(name));

  if(! prop) return Qnil;
  return Nokogiri_wrap_xml_node(Qnil, (xmlNodePtr)prop);
}</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-attribute_nodes"> <span class="method-callseq"> attribute_nodes() </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>returns a list containing the <a href="../node/">Node</a> attributes.</p> <div class="method-source-code" id="attribute_nodes-source"> <pre class="c" data-language="c">static VALUE attribute_nodes(VALUE self)
{
    /* this code in the mode of xmlHasProp() */
    xmlNodePtr node;
    VALUE attr;

    Data_Get_Struct(self, xmlNode, node);

    attr = rb_ary_new();
    Nokogiri_xml_node_properties(node, attr);

    return attr ;
}</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-attribute_with_ns"> <span class="method-callseq"> attribute_with_ns(name, namespace) </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Get the attribute node with <code>name</code> and <code>namespace</code></p> <div class="method-source-code" id="attribute_with_ns-source"> <pre class="c" data-language="c">static VALUE attribute_with_ns(VALUE self, VALUE name, VALUE namespace)
{
  xmlNodePtr node;
  xmlAttrPtr prop;
  Data_Get_Struct(self, xmlNode, node);
  prop = xmlHasNsProp(node, (xmlChar *)StringValueCStr(name),
      NIL_P(namespace) ? NULL : (xmlChar *)StringValueCStr(namespace));

  if(! prop) return Qnil;
  return Nokogiri_wrap_xml_node(Qnil, (xmlNodePtr)prop);
}</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-attributes"> <span class="method-name">attributes</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns a hash containing the node's attributes. The key is the attribute name without any namespace, the value is a <a href="../attr/">Nokogiri::XML::Attr</a> representing the attribute. If you need to distinguish attributes with the same name, with different namespaces use <a href="../node/#method-i-attribute_nodes">attribute_nodes</a> instead.</p> <div class="method-source-code" id="attributes-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 326
def attributes
  Hash[attribute_nodes.map { |node|
    [node.node_name, node]
  }]
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-before"> <span class="method-name">before</span><span class="method-args">(node_or_tags)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Insert <code>node_or_tags</code> before this node (as a sibling). <code>node_or_tags</code> can be a <a href="../node/">Nokogiri::XML::Node</a>, a ::DocumentFragment, a ::NodeSet, or a string containing markup.</p> <p>Returns self, to support chaining of calls.</p> <p>Also see related method <code>add_previous_sibling</code>.</p> <div class="method-source-code" id="before-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 208
def before node_or_tags
  add_previous_sibling node_or_tags
  self
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-blank-3F"> <span class="method-callseq"> blank? </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Is this node blank?</p> <div class="method-source-code" id="blank-3F-source"> <pre class="c" data-language="c">static VALUE blank_eh(VALUE self)
{
  xmlNodePtr node;
  Data_Get_Struct(self, xmlNode, node);
  return (1 == xmlIsBlankNode(node)) ? Qtrue : Qfalse ;
}</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-canonicalize"> <span class="method-name">canonicalize</span><span class="method-args">(mode=XML::XML_C14N_1_0,inclusive_namespaces=nil,with_comments=false)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <div class="method-source-code" id="canonicalize-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 751
def canonicalize(mode=XML::XML_C14N_1_0,inclusive_namespaces=nil,with_comments=false)
  c14n_root = self
  document.canonicalize(mode, inclusive_namespaces, with_comments) do |node, parent|
    tn = node.is_a?(XML::Node) ? node : parent
    tn == c14n_root || tn.ancestors.include?(c14n_root)
  end
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-cdata-3F"> <span class="method-name">cdata?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns true if this is a <a href="../cdata/">CDATA</a></p> <div class="method-source-code" id="cdata-3F-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 453
def cdata?
  type == CDATA_SECTION_NODE
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-child"> <span class="method-callseq"> child </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns the child node</p> <div class="method-source-code" id="child-source"> <pre class="c" data-language="c">static VALUE child(VALUE self)
{
  xmlNodePtr node, child;
  Data_Get_Struct(self, xmlNode, node);

  child = node-&gt;children;
  if(!child) return Qnil;

  return Nokogiri_wrap_xml_node(Qnil, child);
}</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-children"> <span class="method-callseq"> children </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Get the list of children for this node as a <a href="../nodeset/">NodeSet</a></p> <div class="method-source-code" id="children-source"> <pre class="c" data-language="c">static VALUE children(VALUE self)
{
  xmlNodePtr node;
  xmlNodePtr child;
  xmlNodeSetPtr set;
  VALUE document;
  VALUE node_set;

  Data_Get_Struct(self, xmlNode, node);

  child = node-&gt;children;
  set = xmlXPathNodeSetCreate(child);

  document = DOC_RUBY_OBJECT(node-&gt;doc);

  if(!child) return Nokogiri_wrap_xml_node_set(set, document);

  child = child-&gt;next;
  while(NULL != child) {
    xmlXPathNodeSetAddUnique(set, child);
    child = child-&gt;next;
  }

  node_set = Nokogiri_wrap_xml_node_set(set, document);

  return node_set;
}</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-children-3D"> <span class="method-name">children=</span><span class="method-args">(node_or_tags)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Set the inner html for this <a href="../node/">Node</a> <code>node_or_tags</code> <code>node_or_tags</code> can be a <a href="../node/">Nokogiri::XML::Node</a>, a <a href="../documentfragment/">Nokogiri::XML::DocumentFragment</a>, or a string containing markup.</p> <p>Returns the reparented node (if <code>node_or_tags</code> is a <a href="../node/">Node</a>), or <a href="../nodeset/">NodeSet</a> (if <code>node_or_tags</code> is a <a href="../documentfragment/">DocumentFragment</a>, <a href="../nodeset/">NodeSet</a>, or string).</p> <p>Also see related method <code>inner_html=</code></p> <div class="method-source-code" id="children-3D-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 244
def children= node_or_tags
  node_or_tags = coerce(node_or_tags)
  children.unlink
  if node_or_tags.is_a?(XML::NodeSet)
    node_or_tags.each { |n| add_child_node_and_reparent_attrs n }
  else
    add_child_node_and_reparent_attrs node_or_tags
  end
  node_or_tags
end</pre> </div> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-clone"> <span class="method-name">clone</span><span class="method-args">(p1 = v1)</span> </div>  <div class="aliases"> Alias for: <a href="../node/#method-i-dup">dup</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-comment-3F"> <span class="method-name">comment?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns true if this is a <a href="../comment/">Comment</a></p> <div class="method-source-code" id="comment-3F-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 448
def comment?
  type == COMMENT_NODE
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-content"> <span class="method-callseq"> content </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns the content for this <a href="../node/">Node</a></p> <div class="method-source-code" id="content-source"> <pre class="c" data-language="c">static VALUE get_native_content(VALUE self)
{
  xmlNodePtr node;
  xmlChar * content;

  Data_Get_Struct(self, xmlNode, node);

  content = xmlNodeGetContent(node);
  if(content) {
    VALUE rval = NOKOGIRI_STR_NEW2(content);
    xmlFree(content);
    return rval;
  }
  return Qnil;
}</pre> </div> </div> <div class="aliases"> Also aliased as: <a href="../node/#method-i-text">text</a>, <a href="../node/#method-i-inner_text">inner_text</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-content-3D"> <span class="method-name">content=</span><span class="method-args">(string)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Set the Node's content to a <a href="../text/">Text</a> node containing <code>string</code>. The string gets <a href="../../xml/">XML</a> escaped, not interpreted as markup.</p> <div class="method-source-code" id="content-3D-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 415
def content= string
  self.native_content = encode_special_chars(string.to_s)
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-create_external_subset"> <span class="method-callseq"> create_external_subset(name, external_id, system_id) </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Create an external subset</p> <div class="method-source-code" id="create_external_subset-source"> <pre class="c" data-language="c">static VALUE create_external_subset(VALUE self, VALUE name, VALUE external_id, VALUE system_id)
{
  xmlNodePtr node;
  xmlDocPtr doc;
  xmlDtdPtr dtd;

  Data_Get_Struct(self, xmlNode, node);

  doc = node-&gt;doc;

  if(doc-&gt;extSubset)
    rb_raise(rb_eRuntimeError, "Document already has an external subset");

  dtd = xmlNewDtd(
      doc,
      NIL_P(name)        ? NULL : (const xmlChar *)StringValueCStr(name),
      NIL_P(external_id) ? NULL : (const xmlChar *)StringValueCStr(external_id),
      NIL_P(system_id)   ? NULL : (const xmlChar *)StringValueCStr(system_id)
  );

  if(!dtd) return Qnil;

  return Nokogiri_wrap_xml_node(Qnil, (xmlNodePtr)dtd);
}</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-create_internal_subset"> <span class="method-callseq"> create_internal_subset(name, external_id, system_id) </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Create the internal subset of a document.</p> <pre class="ruby" data-language="ruby">doc.create_internal_subset("chapter", "-//OASIS//DTD DocBook XML//EN", "chapter.dtd")
# =&gt; &lt;!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML//EN" "chapter.dtd"&gt;

doc.create_internal_subset("chapter", nil, "chapter.dtd")
# =&gt; &lt;!DOCTYPE chapter SYSTEM "chapter.dtd"&gt;
</pre> <div class="method-source-code" id="create_internal_subset-source"> <pre class="c" data-language="c">static VALUE create_internal_subset(VALUE self, VALUE name, VALUE external_id, VALUE system_id)
{
  xmlNodePtr node;
  xmlDocPtr doc;
  xmlDtdPtr dtd;

  Data_Get_Struct(self, xmlNode, node);

  doc = node-&gt;doc;

  if(xmlGetIntSubset(doc))
    rb_raise(rb_eRuntimeError, "Document already has an internal subset");

  dtd = xmlCreateIntSubset(
      doc,
      NIL_P(name)        ? NULL : (const xmlChar *)StringValueCStr(name),
      NIL_P(external_id) ? NULL : (const xmlChar *)StringValueCStr(external_id),
      NIL_P(system_id)   ? NULL : (const xmlChar *)StringValueCStr(system_id)
  );

  if(!dtd) return Qnil;

  return Nokogiri_wrap_xml_node(Qnil, (xmlNodePtr)dtd);
}</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-css_path"> <span class="method-name">css_path</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Get the path to this node as a <a href="../../css/">CSS</a> expression</p> <div class="method-source-code" id="css_path-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 521
def css_path
  path.split(/\//).map { |part|
    part.length == 0 ? nil : part.gsub(/\[(\d+)\]/, ':nth-of-type(\1)')
  }.compact.join(' &gt; ')
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-decorate-21"> <span class="method-name">decorate!</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Decorate this node with the decorators set up in this node's <a href="../document/">Document</a></p> <div class="method-source-code" id="decorate-21-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 106
def decorate!
  document.decorate(self)
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-default_namespace-3D"> <span class="method-name">default_namespace=</span><span class="method-args">(url)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Adds a default namespace supplied as a string <code>url</code> href, to self. The consequence is as an xmlns attribute with supplied argument were present in parsed <a href="../../xml/">XML</a>. A default namespace set with this method will now show up in <a href="../node/#method-i-attributes">attributes</a>, but when this node is serialized to <a href="../../xml/">XML</a> an “xmlns” attribute will appear. See also <a href="../node/#method-i-namespace">namespace</a> and <a href="../node/#method-i-namespace-3D">namespace=</a></p> <div class="method-source-code" id="default_namespace-3D-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 557
def default_namespace= url
  add_namespace_definition(nil, url)
end</pre> </div> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-delete"> <span class="method-name">delete</span><span class="method-args">(name)</span> </div>  <div class="aliases"> Alias for: <a href="../node/#method-i-remove_attribute">remove_attribute</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-description"> <span class="method-name">description</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Fetch the <a href="../../html/elementdescription/">Nokogiri::HTML::ElementDescription</a> for this node. Returns nil on <a href="../../xml/">XML</a> documents and on unknown tags.</p> <div class="method-source-code" id="description-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 490
def description
  return nil if document.xml?
  Nokogiri::HTML::ElementDescription[name]
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-do_xinclude"> <span class="method-name">do_xinclude</span><span class="method-args">(options = XML::ParseOptions::DEFAULT_XML) { |options| ... }</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Do xinclude substitution on the subtree below node. If given a block, a <a href="../parseoptions/">Nokogiri::XML::ParseOptions</a> object initialized from <code>options</code>, will be passed to it, allowing more convenient modification of the parser options.</p> <div class="method-source-code" id="do_xinclude-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 741
def do_xinclude options = XML::ParseOptions::DEFAULT_XML, &amp;block
  options = Nokogiri::XML::ParseOptions.new(options) if Integer === options

  # give options to user
  yield options if block_given?

  # call c extension
  process_xincludes(options.to_i)
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-document"> <span class="method-callseq"> document </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Get the document for this <a href="../node/">Node</a></p> <div class="method-source-code" id="document-source"> <pre class="c" data-language="c">static VALUE document(VALUE self)
{
  xmlNodePtr node;
  Data_Get_Struct(self, xmlNode, node);
  return DOC_RUBY_OBJECT(node-&gt;doc);
}</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-document-3F"> <span class="method-name">document?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns true if this is a <a href="../document/">Document</a></p> <div class="method-source-code" id="document-3F-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 468
def document?
  is_a? XML::Document
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-dup"> <span class="method-callseq"> dup </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Copy this node. An optional depth may be passed in, but it defaults to a deep copy. 0 is a shallow copy, 1 is a deep copy.</p> <div class="method-source-code" id="dup-source"> <pre class="c" data-language="c">static VALUE duplicate_node(int argc, VALUE *argv, VALUE self)
{
  VALUE level;
  xmlNodePtr node, dup;

  if(rb_scan_args(argc, argv, "01", &amp;level) == 0)
    level = INT2NUM((long)1);

  Data_Get_Struct(self, xmlNode, node);

  dup = xmlDocCopyNode(node, node-&gt;doc, (int)NUM2INT(level));
  if(dup == NULL) return Qnil;

  nokogiri_root_node(dup);

  return Nokogiri_wrap_xml_node(rb_obj_class(self), dup);
}</pre> </div> </div> <div class="aliases"> Also aliased as: <a href="../node/#method-i-clone">clone</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-each"> <span class="method-name">each</span><span class="method-args">() { |node_name, value| ... }</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Iterate over each attribute name and value pair for this <a href="../node/">Node</a>.</p> <div class="method-source-code" id="each-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 346
def each
  attribute_nodes.each { |node|
    yield [node.node_name, node.value]
  }
end</pre> </div> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-elem-3F"> <span class="method-name">elem?</span><span class="method-args">()</span> </div>  <div class="aliases"> Alias for: <a href="../node/#method-i-element-3F">element?</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-element-3F"> <span class="method-name">element?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns true if this is an <a href="../element/">Element</a> node</p> <div class="method-source-code" id="element-3F-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 503
def element?
  type == ELEMENT_NODE
end</pre> </div> </div> <div class="aliases"> Also aliased as: <a href="../node/#method-i-elem-3F">elem?</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-element_children"> <span class="method-callseq"> element_children </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Get the list of children for this node as a <a href="../nodeset/">NodeSet</a>. All nodes will be element nodes.</p> <p>Example:</p> <pre class="ruby" data-language="ruby">@doc.root.element_children.all? { |x| x.element? } # =&gt; true
</pre> <div class="method-source-code" id="element_children-source"> <pre class="c" data-language="c">static VALUE element_children(VALUE self)
{
  xmlNodePtr node;
  xmlNodePtr child;
  xmlNodeSetPtr set;
  VALUE document;
  VALUE node_set;

  Data_Get_Struct(self, xmlNode, node);

  child = xmlFirstElementChild(node);
  set = xmlXPathNodeSetCreate(child);

  document = DOC_RUBY_OBJECT(node-&gt;doc);

  if(!child) return Nokogiri_wrap_xml_node_set(set, document);

  child = xmlNextElementSibling(child);
  while(NULL != child) {
    xmlXPathNodeSetAddUnique(set, child);
    child = xmlNextElementSibling(child);
  }

  node_set = Nokogiri_wrap_xml_node_set(set, document);

  return node_set;
}</pre> </div> </div> <div class="aliases"> Also aliased as: <a href="../node/#method-i-elements">elements</a> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-elements"> <span class="method-name">elements</span><span class="method-args">()</span> </div>  <div class="aliases"> Alias for: <a href="../node/#method-i-element_children">element_children</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-encode_special_chars"> <span class="method-callseq"> encode_special_chars(string) </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Encode any special characters in <code>string</code></p> <div class="method-source-code" id="encode_special_chars-source"> <pre class="c" data-language="c">static VALUE encode_special_chars(VALUE self, VALUE string)
{
  xmlNodePtr node;
  xmlChar *encoded;
  VALUE encoded_str;

  Data_Get_Struct(self, xmlNode, node);
  encoded = xmlEncodeSpecialChars(
      node-&gt;doc,
      (const xmlChar *)StringValueCStr(string)
  );

  encoded_str = NOKOGIRI_STR_NEW2(encoded);
  xmlFree(encoded);

  return encoded_str;
}</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-external_subset"> <span class="method-callseq"> external_subset </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Get the external subset</p> <div class="method-source-code" id="external_subset-source"> <pre class="c" data-language="c">static VALUE external_subset(VALUE self)
{
  xmlNodePtr node;
  xmlDocPtr doc;
  xmlDtdPtr dtd;

  Data_Get_Struct(self, xmlNode, node);

  if(!node-&gt;doc) return Qnil;

  doc = node-&gt;doc;
  dtd = doc-&gt;extSubset;

  if(!dtd) return Qnil;

  return Nokogiri_wrap_xml_node(Qnil, (xmlNodePtr)dtd);
}</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-first_element_child"> <span class="method-callseq"> first_element_child </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns the first child node of this node that is an element.</p> <p>Example:</p> <pre class="ruby" data-language="ruby">@doc.root.first_element_child.element? # =&gt; true
</pre> <div class="method-source-code" id="first_element_child-source"> <pre class="c" data-language="c">static VALUE first_element_child(VALUE self)
{
  xmlNodePtr node, child;
  Data_Get_Struct(self, xmlNode, node);

  child = xmlFirstElementChild(node);
  if(!child) return Qnil;

  return Nokogiri_wrap_xml_node(Qnil, child);
}</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-fragment"> <span class="method-name">fragment</span><span class="method-args">(tags)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Create a <a href="../documentfragment/">DocumentFragment</a> containing <code>tags</code> that is relative to <em>this</em> context node.</p> <div class="method-source-code" id="fragment-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 370
def fragment tags
  type = document.html? ? Nokogiri::HTML : Nokogiri::XML
  type::DocumentFragment.new(document, tags, self)
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-fragment-3F"> <span class="method-name">fragment?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns true if this is a <a href="../documentfragment/">DocumentFragment</a></p> <div class="method-source-code" id="fragment-3F-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 483
def fragment?
  type == DOCUMENT_FRAG_NODE
end</pre> </div> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-get_attribute"> <span class="method-name">get_attribute</span><span class="method-args">(name)</span> </div>  <div class="aliases"> Alias for: <a href="../node/#method-i-5B-5D">[]</a> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-has_attribute-3F"> <span class="method-name">has_attribute?</span><span class="method-args">(p1)</span> </div>  <div class="aliases"> Alias for: <a href="../node/#method-i-key-3F">key?</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-html-3F"> <span class="method-name">html?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns true if this is an <a href="../../html/document/">HTML::Document</a> node</p> <div class="method-source-code" id="html-3F-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 463
def html?
  type == HTML_DOCUMENT_NODE
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-inner_html"> <span class="method-name">inner_html</span><span class="method-args">(*args)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Get the <a href="../node/#method-i-inner_html">#inner_html</a> for this node's <a href="../node/#method-i-children">#children</a></p> <div class="method-source-code" id="inner_html-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 516
def inner_html *args
  children.map { |x| x.to_html(*args) }.join
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-inner_html-3D"> <span class="method-name">inner_html=</span><span class="method-args">(node_or_tags)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Set the inner html for this <a href="../node/">Node</a> to <code>node_or_tags</code> <code>node_or_tags</code> can be a <a href="../node/">Nokogiri::XML::Node</a>, a <a href="../documentfragment/">Nokogiri::XML::DocumentFragment</a>, or a string containing markup.</p> <p>Returns self.</p> <p>Also see related method <code>children=</code></p> <div class="method-source-code" id="inner_html-3D-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 232
def inner_html= node_or_tags
  self.children = node_or_tags
  self
end</pre> </div> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-inner_text"> <span class="method-name">inner_text</span><span class="method-args">()</span> </div>  <div class="aliases"> Alias for: <a href="../node/#method-i-content">content</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-internal_subset"> <span class="method-callseq"> internal_subset </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Get the internal subset</p> <div class="method-source-code" id="internal_subset-source"> <pre class="c" data-language="c">static VALUE internal_subset(VALUE self)
{
  xmlNodePtr node;
  xmlDocPtr doc;
  xmlDtdPtr dtd;

  Data_Get_Struct(self, xmlNode, node);

  if(!node-&gt;doc) return Qnil;

  doc = node-&gt;doc;
  dtd = xmlGetIntSubset(doc);

  if(!dtd) return Qnil;

  return Nokogiri_wrap_xml_node(Qnil, (xmlNodePtr)dtd);
}</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-key-3F"> <span class="method-callseq"> key?(attribute) </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns true if <code>attribute</code> is set</p> <div class="method-source-code" id="key-3F-source"> <pre class="c" data-language="c">static VALUE key_eh(VALUE self, VALUE attribute)
{
  xmlNodePtr node;
  Data_Get_Struct(self, xmlNode, node);
  if(xmlHasProp(node, (xmlChar *)StringValueCStr(attribute)))
    return Qtrue;
  return Qfalse;
}</pre> </div> </div> <div class="aliases"> Also aliased as: <a href="../node/#method-i-has_attribute-3F">has_attribute?</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-keys"> <span class="method-name">keys</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Get the attribute names for this <a href="../node/">Node</a>.</p> <div class="method-source-code" id="keys-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 340
def keys
  attribute_nodes.map(&amp;:node_name)
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-lang"> <span class="method-callseq"> lang </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Searches the language of a node, i.e. the values of the xml:lang attribute or the one carried by the nearest ancestor.</p> <div class="method-source-code" id="lang-source"> <pre class="c" data-language="c">static VALUE get_lang(VALUE self_rb)
{
  xmlNodePtr self ;
  xmlChar* lang ;
  VALUE lang_rb ;

  Data_Get_Struct(self_rb, xmlNode, self);

  lang = xmlNodeGetLang(self);
  if (lang) {
    lang_rb = NOKOGIRI_STR_NEW2(lang);
    xmlFree(lang);
    return lang_rb ;
  }

  return Qnil ;
}</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-lang-3D"> <span class="method-callseq"> lang= </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Set the language of a node, i.e. the values of the xml:lang attribute.</p> <div class="method-source-code" id="lang-3D-source"> <pre class="c" data-language="c">static VALUE set_lang(VALUE self_rb, VALUE lang_rb)
{
  xmlNodePtr self ;
  xmlChar* lang ;

  Data_Get_Struct(self_rb, xmlNode, self);
  lang = (xmlChar*)StringValueCStr(lang_rb);

  xmlNodeSetLang(self, lang);

  return Qnil ;
}</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-last_element_child"> <span class="method-callseq"> last_element_child </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns the last child node of this node that is an element.</p> <p>Example:</p> <pre class="ruby" data-language="ruby">@doc.root.last_element_child.element? # =&gt; true
</pre> <div class="method-source-code" id="last_element_child-source"> <pre class="c" data-language="c">static VALUE last_element_child(VALUE self)
{
  xmlNodePtr node, child;
  Data_Get_Struct(self, xmlNode, node);

  child = xmlLastElementChild(node);
  if(!child) return Qnil;

  return Nokogiri_wrap_xml_node(Qnil, child);
}</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-line"> <span class="method-callseq"> line </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns the line for this <a href="../node/">Node</a></p> <div class="method-source-code" id="line-source"> <pre class="c" data-language="c">static VALUE line(VALUE self)
{
  xmlNodePtr node;
  Data_Get_Struct(self, xmlNode, node);

  return INT2NUM(xmlGetLineNo(node));
}</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-matches-3F"> <span class="method-name">matches?</span><span class="method-args">(selector)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns true if this <a href="../node/">Node</a> matches <code>selector</code></p> <div class="method-source-code" id="matches-3F-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 363
def matches? selector
  ancestors.last.search(selector).include?(self)
end</pre> </div> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-name"> <span class="method-name">name</span><span class="method-args">()</span> </div>  <div class="aliases"> Alias for: <a href="../node/#method-i-node_name">node_name</a> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-name-3D"> <span class="method-name">name=</span><span class="method-args">(p1)</span> </div>  <div class="aliases"> Alias for: <a href="../node/#method-i-node_name-3D">node_name=</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-namespace"> <span class="method-callseq"> namespace() </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>returns the namespace of the element or attribute node as a <a href="../namespace/">Namespace</a> object, or nil if there is no namespace for the element or attribute.</p> <div class="method-source-code" id="namespace-source"> <pre class="c" data-language="c">static VALUE namespace(VALUE self)
{
  xmlNodePtr node ;
  Data_Get_Struct(self, xmlNode, node);

  if (node-&gt;ns)
    return Nokogiri_wrap_xml_namespace(node-&gt;doc, node-&gt;ns);

  return Qnil ;
}</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-namespace-3D"> <span class="method-name">namespace=</span><span class="method-args">(ns)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Set the default namespace on this node (as would be defined with an “xmlns=” attribute in <a href="../../xml/">XML</a> source), as a <a href="../namespace/">Namespace</a> object <code>ns</code>. Note that a <a href="../namespace/">Namespace</a> added this way will NOT be serialized as an xmlns attribute for this node. You probably want <a href="../node/#method-i-default_namespace-3D">default_namespace=</a> instead, or perhaps <a href="../node/#method-i-add_namespace_definition">add_namespace_definition</a> with a nil prefix argument.</p> <div class="method-source-code" id="namespace-3D-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 568
def namespace= ns
  return set_namespace(ns) unless ns

  unless Nokogiri::XML::Namespace === ns
    raise TypeError, "#{ns.class} can't be coerced into Nokogiri::XML::Namespace"
  end
  if ns.document != document
    raise ArgumentError, 'namespace must be declared on the same document'
  end

  set_namespace ns
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-namespace_definitions"> <span class="method-callseq"> namespace_definitions() </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>returns namespaces defined on self element directly, as an array of <a href="../namespace/">Namespace</a> objects. Includes both a default namespace (as in“xmlns=”), and prefixed namespaces (as in “xmlns:prefix=”).</p> <div class="method-source-code" id="namespace_definitions-source"> <pre class="c" data-language="c">static VALUE namespace_definitions(VALUE self)
{
  /* this code in the mode of xmlHasProp() */
  xmlNodePtr node ;
  VALUE list;
  xmlNsPtr ns;

  Data_Get_Struct(self, xmlNode, node);

  list = rb_ary_new();

  ns = node-&gt;nsDef;

  if(!ns) return list;

  while(NULL != ns) {
    rb_ary_push(list, Nokogiri_wrap_xml_namespace(node-&gt;doc, ns));
    ns = ns-&gt;next;
  }

  return list;
}</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-namespace_scopes"> <span class="method-callseq"> namespace_scopes() </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>returns namespaces in scope for self – those defined on self element directly or any ancestor node – as an array of <a href="../namespace/">Namespace</a> objects. Default namespaces (“xmlns=” style) for self are included in this array; Default namespaces for ancestors, however, are not. See also <a href="../node/#method-i-namespaces">namespaces</a></p> <div class="method-source-code" id="namespace_scopes-source"> <pre class="c" data-language="c">static VALUE namespace_scopes(VALUE self)
{
  xmlNodePtr node ;
  VALUE list;
  xmlNsPtr *ns_list;
  int j;

  Data_Get_Struct(self, xmlNode, node);

  list = rb_ary_new();
  ns_list = xmlGetNsList(node-&gt;doc, node);

  if(!ns_list) return list;

  for (j = 0 ; ns_list[j] != NULL ; ++j) {
    rb_ary_push(list, Nokogiri_wrap_xml_namespace(node-&gt;doc, ns_list[j]));
  }

  xmlFree(ns_list);
  return list;
}</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-namespaced_key-3F"> <span class="method-callseq"> namespaced_key?(attribute, namespace) </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns true if <code>attribute</code> is set with <code>namespace</code></p> <div class="method-source-code" id="namespaced_key-3F-source"> <pre class="c" data-language="c">static VALUE namespaced_key_eh(VALUE self, VALUE attribute, VALUE namespace)
{
  xmlNodePtr node;
  Data_Get_Struct(self, xmlNode, node);
  if(xmlHasNsProp(node, (xmlChar *)StringValueCStr(attribute),
        NIL_P(namespace) ? NULL : (xmlChar *)StringValueCStr(namespace)))
    return Qtrue;
  return Qfalse;
}</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-namespaces"> <span class="method-name">namespaces</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns a Hash of {prefix =&gt; value} for all namespaces on this node and its ancestors.</p> <p>This method returns the same namespaces as <a href="../node/#method-i-namespace_scopes">namespace_scopes</a>.</p> <p>Returns namespaces in scope for self – those defined on self element directly or any ancestor node – as a Hash of attribute-name/value pairs. Note that the keys in this hash <a href="../../xml/">XML</a> attributes that would be used to define this namespace, such as “xmlns:prefix”, not just the prefix. Default namespace set on self will be included with key “xmlns”. However, default namespaces set on ancestor will NOT be, even if self has no explicit default namespace.</p> <div class="method-source-code" id="namespaces-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 440
def namespaces
  Hash[namespace_scopes.map { |nd|
    key = ['xmlns', nd.prefix].compact.join(':')
    [key, nd.href]
  }]
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-native_content-3D"> <span class="method-callseq"> content= </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Set the content for this <a href="../node/">Node</a></p> <div class="method-source-code" id="native_content-3D-source"> <pre class="c" data-language="c">static VALUE set_native_content(VALUE self, VALUE content)
{
  xmlNodePtr node, child, next ;
  Data_Get_Struct(self, xmlNode, node);

  child = node-&gt;children;
  while (NULL != child) {
    next = child-&gt;next ;
    xmlUnlinkNode(child) ;
    nokogiri_root_node(child);
    child = next ;
  }

  xmlNodeSetContent(node, (xmlChar *)StringValueCStr(content));
  return content;
}</pre> </div> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-next"> <span class="method-name">next</span><span class="method-args">()</span> </div>  <div class="aliases"> Alias for: <a href="../node/#method-i-next_sibling">next_sibling</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-next_element"> <span class="method-callseq"> next_element </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns the next <a href="../element/">Nokogiri::XML::Element</a> type sibling node.</p> <div class="method-source-code" id="next_element-source"> <pre class="c" data-language="c">static VALUE next_element(VALUE self)
{
  xmlNodePtr node, sibling;
  Data_Get_Struct(self, xmlNode, node);

  sibling = xmlNextElementSibling(node);
  if(!sibling) return Qnil;

  return Nokogiri_wrap_xml_node(Qnil, sibling);
}</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-next_sibling"> <span class="method-callseq"> next_sibling </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns the next sibling node</p> <div class="method-source-code" id="next_sibling-source"> <pre class="c" data-language="c">static VALUE next_sibling(VALUE self)
{
  xmlNodePtr node, sibling;
  Data_Get_Struct(self, xmlNode, node);

  sibling = node-&gt;next;
  if(!sibling) return Qnil;

  return Nokogiri_wrap_xml_node(Qnil, sibling) ;
}</pre> </div> </div> <div class="aliases"> Also aliased as: <a href="../node/#method-i-next">next</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-node_name"> <span class="method-callseq"> name </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns the name for this <a href="../node/">Node</a></p> <div class="method-source-code" id="node_name-source"> <pre class="c" data-language="c">static VALUE get_name(VALUE self)
{
  xmlNodePtr node;
  Data_Get_Struct(self, xmlNode, node);
  if(node-&gt;name)
    return NOKOGIRI_STR_NEW2(node-&gt;name);
  return Qnil;
}</pre> </div> </div> <div class="aliases"> Also aliased as: <a href="../node/#method-i-name">name</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-node_name-3D"> <span class="method-callseq"> name=(new_name) </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Set the name for this <a href="../node/">Node</a></p> <div class="method-source-code" id="node_name-3D-source"> <pre class="c" data-language="c">static VALUE set_name(VALUE self, VALUE new_name)
{
  xmlNodePtr node;
  Data_Get_Struct(self, xmlNode, node);
  xmlNodeSetName(node, (xmlChar*)StringValueCStr(new_name));
  return new_name;
}</pre> </div> </div> <div class="aliases"> Also aliased as: <a href="../node/#method-i-name-3D">name=</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-node_type"> <span class="method-callseq"> node_type </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Get the type for this <a href="../node/">Node</a></p> <div class="method-source-code" id="node_type-source"> <pre class="c" data-language="c">static VALUE node_type(VALUE self)
{
  xmlNodePtr node;
  Data_Get_Struct(self, xmlNode, node);
  return INT2NUM((long)node-&gt;type);
}</pre> </div> </div> <div class="aliases"> Also aliased as: <a href="../node/#method-i-type">type</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-parent"> <span class="method-callseq"> parent </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Get the parent <a href="../node/">Node</a> for this <a href="../node/">Node</a></p> <div class="method-source-code" id="parent-source"> <pre class="c" data-language="c">static VALUE get_parent(VALUE self)
{
  xmlNodePtr node, parent;
  Data_Get_Struct(self, xmlNode, node);

  parent = node-&gt;parent;
  if(!parent) return Qnil;

  return Nokogiri_wrap_xml_node(Qnil, parent) ;
}</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-parent-3D"> <span class="method-name">parent=</span><span class="method-args">(parent_node)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Set the parent <a href="../node/">Node</a> for this <a href="../node/">Node</a></p> <div class="method-source-code" id="parent-3D-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 421
def parent= parent_node
  parent_node.add_child(self)
  parent_node
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-parse"> <span class="method-name">parse</span><span class="method-args">(string_or_io, options = nil) { |options| ... }</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Parse <code>string_or_io</code> as a document fragment within the context of <strong>this</strong> node. Returns a <a href="../nodeset/">XML::NodeSet</a> containing the nodes parsed from <code>string_or_io</code>.</p> <div class="method-source-code" id="parse-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 379
def parse string_or_io, options = nil
  ##
  # When the current node is unparented and not an element node, use the
  # document as the parsing context instead. Otherwise, the in-context
  # parser cannot find an element or a document node.
  # Document Fragments are also not usable by the in-context parser.
  if !element? &amp;&amp; !document? &amp;&amp; (!parent || parent.fragment?)
    return document.parse(string_or_io, options)
  end

  options ||= (document.html? ? ParseOptions::DEFAULT_HTML : ParseOptions::DEFAULT_XML)
  if Integer === options
    options = Nokogiri::XML::ParseOptions.new(options)
  end
  # Give the options to the user
  yield options if block_given?

  contents = string_or_io.respond_to?(:read) ?
    string_or_io.read :
    string_or_io

  return Nokogiri::XML::NodeSet.new(document) if contents.empty?

  ##
  # This is a horrible hack, but I don't care. See #313 for background.
  error_count = document.errors.length
  node_set = in_context(contents, options.to_i)
  if node_set.empty? and document.errors.length &gt; error_count and options.recover?
    fragment = Nokogiri::HTML::DocumentFragment.parse contents
    node_set = fragment.children
  end
  node_set
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-path"> <span class="method-callseq"> path </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns the path associated with this <a href="../node/">Node</a></p> <div class="method-source-code" id="path-source"> <pre class="c" data-language="c">static VALUE path(VALUE self)
{
  xmlNodePtr node;
  xmlChar *path ;
  VALUE rval;

  Data_Get_Struct(self, xmlNode, node);

  path = xmlGetNodePath(node);
  rval = NOKOGIRI_STR_NEW2(path);
  xmlFree(path);
  return rval ;
}</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-pointer_id"> <span class="method-callseq"> pointer_id </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Get the internal pointer number</p> <div class="method-source-code" id="pointer_id-source"> <pre class="c" data-language="c">static VALUE pointer_id(VALUE self)
{
  xmlNodePtr node;
  Data_Get_Struct(self, xmlNode, node);

  return INT2NUM((long)(node));
}</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-prepend_child"> <span class="method-name">prepend_child</span><span class="method-args">(node_or_tags)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Add <code>node_or_tags</code> as the first child of this <a href="../node/">Node</a>. <code>node_or_tags</code> can be a <a href="../node/">Nokogiri::XML::Node</a>, a ::DocumentFragment, a ::NodeSet, or a string containing markup.</p> <p>Returns the reparented node (if <code>node_or_tags</code> is a <a href="../node/">Node</a>), or <a href="../nodeset/">NodeSet</a> (if <code>node_or_tags</code> is a <a href="../documentfragment/">DocumentFragment</a>, <a href="../nodeset/">NodeSet</a>, or string).</p> <p>Also see related method <code>add_child</code>.</p> <div class="method-source-code" id="prepend_child-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 153
def prepend_child node_or_tags
  if first = children.first
    # Mimic the error add_child would raise.
    raise RuntimeError, "Document already has a root node" if document? &amp;&amp; !(node_or_tags.comment? || node_or_tags.processing_instruction?)
    first.__send__(:add_sibling, :previous, node_or_tags)
  else
    add_child(node_or_tags)
  end
end</pre> </div> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-previous"> <span class="method-name">previous</span><span class="method-args">()</span> </div>  <div class="aliases"> Alias for: <a href="../node/#method-i-previous_sibling">previous_sibling</a> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-previous-3D"> <span class="method-name">previous=</span><span class="method-args">(node_or_tags)</span> </div>  <div class="aliases"> Alias for: <a href="../node/#method-i-add_previous_sibling">add_previous_sibling</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-previous_element"> <span class="method-callseq"> previous_element </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns the previous <a href="../element/">Nokogiri::XML::Element</a> type sibling node.</p> <div class="method-source-code" id="previous_element-source"> <pre class="c" data-language="c">static VALUE previous_element(VALUE self)
{
  xmlNodePtr node, sibling;
  Data_Get_Struct(self, xmlNode, node);

  /*
   *  note that we don't use xmlPreviousElementSibling here because it's buggy pre-2.7.7.
   */
  sibling = node-&gt;prev;
  if(!sibling) return Qnil;

  while(sibling &amp;&amp; sibling-&gt;type != XML_ELEMENT_NODE)
    sibling = sibling-&gt;prev;

  return sibling ? Nokogiri_wrap_xml_node(Qnil, sibling) : Qnil ;
}</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-previous_sibling"> <span class="method-callseq"> previous_sibling </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns the previous sibling node</p> <div class="method-source-code" id="previous_sibling-source"> <pre class="c" data-language="c">static VALUE previous_sibling(VALUE self)
{
  xmlNodePtr node, sibling;
  Data_Get_Struct(self, xmlNode, node);

  sibling = node-&gt;prev;
  if(!sibling) return Qnil;

  return Nokogiri_wrap_xml_node(Qnil, sibling);
}</pre> </div> </div> <div class="aliases"> Also aliased as: <a href="../node/#method-i-previous">previous</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-processing_instruction-3F"> <span class="method-name">processing_instruction?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns true if this is a <a href="../processinginstruction/">ProcessingInstruction</a> node</p> <div class="method-source-code" id="processing_instruction-3F-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 473
def processing_instruction?
  type == PI_NODE
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-read_only-3F"> <span class="method-name">read_only?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Is this a read only node?</p> <div class="method-source-code" id="read_only-3F-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 497
def read_only?
  # According to gdome2, these are read-only node types
  [NOTATION_NODE, ENTITY_NODE, ENTITY_DECL].include?(type)
end</pre> </div> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-remove"> <span class="method-name">remove</span><span class="method-args">()</span> </div>  <div class="aliases"> Alias for: <a href="../node/#method-i-unlink">unlink</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-remove_attribute"> <span class="method-name">remove_attribute</span><span class="method-args">(name)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Remove the attribute named <code>name</code></p> <div class="method-source-code" id="remove_attribute-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 354
def remove_attribute name
  attr = attributes[name].remove if key? name
  clear_xpath_context if Nokogiri.jruby?
  attr
end</pre> </div> </div> <div class="aliases"> Also aliased as: <a href="../node/#method-i-delete">delete</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-replace"> <span class="method-name">replace</span><span class="method-args">(node_or_tags)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Replace this <a href="../node/">Node</a> with <code>node_or_tags</code>. <code>node_or_tags</code> can be a <a href="../node/">Nokogiri::XML::Node</a>, a ::DocumentFragment, a ::NodeSet, or a string containing markup.</p> <p>Returns the reparented node (if <code>node_or_tags</code> is a <a href="../node/">Node</a>), or <a href="../nodeset/">NodeSet</a> (if <code>node_or_tags</code> is a <a href="../documentfragment/">DocumentFragment</a>, <a href="../nodeset/">NodeSet</a>, or string).</p> <p>Also see related method <code>swap</code>.</p> <div class="method-source-code" id="replace-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 262
def replace node_or_tags
  # We cannot replace a text node directly, otherwise libxml will return
  # an internal error at parser.c:13031, I don't know exactly why
  # libxml is trying to find a parent node that is an element or document
  # so I can't tell if this is bug in libxml or not. issue #775.
  if text?
    replacee = Nokogiri::XML::Node.new 'dummy', document
    add_previous_sibling_node replacee
    unlink
    return replacee.replace node_or_tags
  end

  node_or_tags = coerce(node_or_tags)

  if node_or_tags.is_a?(XML::NodeSet)
    node_or_tags.each { |n| add_previous_sibling n }
    unlink
  else
    replace_node node_or_tags
  end
  node_or_tags
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-serialize"> <span class="method-name">serialize</span><span class="method-args">(*args, &amp;block)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Serialize <a href="../node/">Node</a> using <code>options</code>. Save options can also be set using a block. See <a href="../node/saveoptions/">SaveOptions</a>.</p> <p>These two statements are equivalent:</p> <pre class="ruby" data-language="ruby">node.serialize(:encoding =&gt; 'UTF-8', :save_with =&gt; FORMAT | AS_XML)
</pre> <p>or</p> <pre class="ruby" data-language="ruby">node.serialize(:encoding =&gt; 'UTF-8') do |config|
  config.format.as_xml
end
</pre> <div class="method-source-code" id="serialize-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 616
def serialize *args, &amp;block
  options = args.first.is_a?(Hash) ? args.shift : {
    :encoding   =&gt; args[0],
    :save_with  =&gt; args[1]
  }

  encoding = options[:encoding] || document.encoding
  options[:encoding] = encoding

  outstring = String.new
  if encoding &amp;&amp; outstring.respond_to?(:force_encoding)
    outstring.force_encoding(Encoding.find(encoding))
  end
  io = StringIO.new(outstring)
  write_to io, options, &amp;block
  io.string
end</pre> </div> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-set_attribute"> <span class="method-name">set_attribute</span><span class="method-args">(name, value)</span> </div>  <div class="aliases"> Alias for: <a href="../node/#method-i-5B-5D-3D">[]=</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-swap"> <span class="method-name">swap</span><span class="method-args">(node_or_tags)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Swap this <a href="../node/">Node</a> for <code>node_or_tags</code> <code>node_or_tags</code> can be a <a href="../node/">Nokogiri::XML::Node</a>, a ::DocumentFragment, a ::NodeSet, or a string containing markup.</p> <p>Returns self, to support chaining of calls.</p> <p>Also see related method <code>replace</code>.</p> <div class="method-source-code" id="swap-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 292
def swap node_or_tags
  replace node_or_tags
  self
end</pre> </div> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-text"> <span class="method-name">text</span><span class="method-args">()</span> </div>  <div class="aliases"> Also aliased as: <a href="../node/#method-i-to_str">to_str</a> </div> <div class="aliases"> Alias for: <a href="../node/#method-i-content">content</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-text-3F"> <span class="method-name">text?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns true if this is a <a href="../text/">Text</a> node</p> <div class="method-source-code" id="text-3F-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 478
def text?
  type == TEXT_NODE
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-to_html"> <span class="method-name">to_html</span><span class="method-args">(options = {})</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Serialize this <a href="../node/">Node</a> to <a href="../../html/">HTML</a></p> <pre class="ruby" data-language="ruby">doc.to_html
</pre> <p>See <a href="../node/#method-i-write_to">#write_to</a> for a list of <code>options</code>. For formatted output, use <a href="../node/#method-i-to_xhtml">#to_xhtml</a> instead.</p> <div class="method-source-code" id="to_html-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 641
def to_html options = {}
  to_format SaveOptions::DEFAULT_HTML, options
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-to_s"> <span class="method-name">to_s</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Turn this node in to a string. If the document is <a href="../../html/">HTML</a>, this method returns html. If the document is <a href="../../xml/">XML</a>, this method returns <a href="../../xml/">XML</a>.</p> <div class="method-source-code" id="to_s-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 511
def to_s
  document.xml? ? to_xml : to_html
end</pre> </div> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-to_str"> <span class="method-name">to_str</span><span class="method-args">()</span> </div>  <div class="aliases"> Alias for: <a href="../node/#method-i-text">text</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-to_xhtml"> <span class="method-name">to_xhtml</span><span class="method-args">(options = {})</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Serialize this <a href="../node/">Node</a> to XHTML using <code>options</code></p> <pre class="ruby" data-language="ruby">doc.to_xhtml(:indent =&gt; 5, :encoding =&gt; 'UTF-8')
</pre> <p>See <a href="../node/#method-i-write_to">#write_to</a> for a list of <code>options</code></p> <div class="method-source-code" id="to_xhtml-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 662
def to_xhtml options = {}
  to_format SaveOptions::DEFAULT_XHTML, options
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-to_xml"> <span class="method-name">to_xml</span><span class="method-args">(options = {})</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Serialize this <a href="../node/">Node</a> to <a href="../../xml/">XML</a> using <code>options</code></p> <pre class="ruby" data-language="ruby">doc.to_xml(:indent =&gt; 5, :encoding =&gt; 'UTF-8')
</pre> <p>See <a href="../node/#method-i-write_to">#write_to</a> for a list of <code>options</code></p> <div class="method-source-code" id="to_xml-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 651
def to_xml options = {}
  options[:save_with] ||= SaveOptions::DEFAULT_XML
  serialize(options)
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-traverse"> <span class="method-name">traverse</span><span class="method-args">(&amp;block)</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Yields self and all children to <code>block</code> recursively.</p> <div class="method-source-code" id="traverse-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 583
def traverse &amp;block
  children.each{|j| j.traverse(&amp;block) }
  block.call(self)
end</pre> </div> </div> </div> <div class="method-detail method-alias"> <div class="method-heading" id="method-i-type"> <span class="method-name">type</span><span class="method-args">()</span> </div>  <div class="aliases"> Alias for: <a href="../node/#method-i-node_type">node_type</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-unlink"> <span class="method-callseq"> unlink </span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Unlink this node from its current context.</p> <div class="method-source-code" id="unlink-source"> <pre class="c" data-language="c">static VALUE unlink_node(VALUE self)
{
  xmlNodePtr node;
  Data_Get_Struct(self, xmlNode, node);
  xmlUnlinkNode(node);
  nokogiri_root_node(node);
  return self;
}</pre> </div> </div> <div class="aliases"> Also aliased as: <a href="../node/#method-i-remove">remove</a> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-values"> <span class="method-name">values</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Get the attribute values for this <a href="../node/">Node</a>.</p> <div class="method-source-code" id="values-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 334
def values
  attribute_nodes.map(&amp;:value)
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-write_html_to"> <span class="method-name">write_html_to</span><span class="method-args">(io, options = {})</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Write <a href="../node/">Node</a> as <a href="../../html/">HTML</a> to <code>io</code> with <code>options</code></p> <p>See <a href="../node/#method-i-write_to">#write_to</a> for a list of <code>options</code></p> <div class="method-source-code" id="write_html_to-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 705
def write_html_to io, options = {}
  write_format_to SaveOptions::DEFAULT_HTML, io, options
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-write_to"> <span class="method-name">write_to</span><span class="method-args">(io, *options) { |config| ... }</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Write <a href="../node/">Node</a> to <code>io</code> with <code>options</code>. <code>options</code> modify the output of this method. Valid options are:</p> <ul>
<li> <p><code>:encoding</code> for changing the encoding</p> </li>
<li> <p><code>:indent_text</code> the indentation text, defaults to one space</p> </li>
<li> <p><code>:indent</code> the number of <code>:indent_text</code> to use, defaults to 2</p> </li>
<li> <p><code>:save_with</code> a combination of <a href="../node/saveoptions/">SaveOptions</a> constants.</p> </li>
</ul> <p>To save with UTF-8 indented twice:</p> <pre class="ruby" data-language="ruby">node.write_to(io, :encoding =&gt; 'UTF-8', :indent =&gt; 2)
</pre> <p>To save indented with two dashes:</p> <pre class="ruby" data-language="ruby">node.write_to(io, :indent_text =&gt; '-', :indent =&gt; 2)
</pre> <div class="method-source-code" id="write_to-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 683
def write_to io, *options
  options       = options.first.is_a?(Hash) ? options.shift : {}
  encoding      = options[:encoding] || options[0]
  if Nokogiri.jruby?
    save_options  = options[:save_with] || options[1]
    indent_times  = options[:indent] || 0
  else
    save_options  = options[:save_with] || options[1] || SaveOptions::FORMAT
    indent_times  = options[:indent] || 2
  end
  indent_text   = options[:indent_text] || ' '

  config = SaveOptions.new(save_options.to_i)
  yield config if block_given?

  native_write_to(io, encoding, indent_text * indent_times, config.options)
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-write_xhtml_to"> <span class="method-name">write_xhtml_to</span><span class="method-args">(io, options = {})</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Write <a href="../node/">Node</a> as XHTML to <code>io</code> with <code>options</code></p> <p>See <a href="../node/#method-i-write_to">#write_to</a> for a list of <code>options</code></p> <div class="method-source-code" id="write_xhtml_to-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 713
def write_xhtml_to io, options = {}
  write_format_to SaveOptions::DEFAULT_XHTML, io, options
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-write_xml_to"> <span class="method-name">write_xml_to</span><span class="method-args">(io, options = {})</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Write <a href="../node/">Node</a> as <a href="../../xml/">XML</a> to <code>io</code> with <code>options</code></p> <pre class="ruby" data-language="ruby">doc.write_xml_to io, :encoding =&gt; 'UTF-8'
</pre> <p>See <a href="../node/#method-i-write_to">#write_to</a> for a list of options</p> <div class="method-source-code" id="write_xml_to-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 723
def write_xml_to io, options = {}
  options[:save_with] ||= SaveOptions::DEFAULT_XML
  write_to io, options
end</pre> </div> </div> </div> <div class="method-detail "> <div class="method-heading" id="method-i-xml-3F"> <span class="method-name">xml?</span><span class="method-args">()</span> <a class="method-click-advice">Show source</a> </div> <div class="method-description"> <p>Returns true if this is an <a href="../document/">XML::Document</a> node</p> <div class="method-source-code" id="xml-3F-source"> <pre class="ruby" data-language="ruby"># File lib/nokogiri/xml/node.rb, line 458
def xml?
  type == DOCUMENT_NODE
end</pre> </div> </div> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    © 2008–2017 Aaron Patterson, Mike Dalessio, Charles Nutter, Sergio Arbeo<br>Patrick Mahoney, Yoko Harada, Akinori Musha, John Shahid<br>Licensed under the MIT License.<br>
    
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
