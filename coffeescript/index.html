
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>CoffeeScript 2 Documentation - W3cubDocs</title>
  
  <meta name="description" content=" CoffeeScript 2 documentation ">
  <meta name="keywords" content="coffeescript, documentation">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/coffeescript/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-e0f881b0fce8cbe96f33dadc355b7159d5d2912911231446d60eb8f9caffa802.css">
  <script type="text/javascript" src="/assets/application-8fc46316434047265cd383f02b8e7f434ed7dec4a59f920dd633deef8d488d1b.js"></script>
  <script src="/json/coffeescript.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/coffeescript/" class="_nav-link" title="" style="margin-left:0;">CoffeeScript 2</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _coffeescript">
				
<h1>CoffeeScript</h1>  <p id="overview"><strong>CoffeeScript is a little language that compiles into JavaScript.</strong> Underneath that awkward Java-esque patina, JavaScript has always had a gorgeous heart. CoffeeScript is an attempt to expose the good parts of JavaScript in a simple way.</p> <p>The golden rule of CoffeeScript is: <em>“It’s just JavaScript”</em>. The code compiles one-to-one into the equivalent JS, and there is no interpretation at runtime. You can use any existing JavaScript library seamlessly from CoffeeScript (and vice-versa). The compiled output is readable, pretty-printed, and tends to run as fast or faster than the equivalent handwritten JavaScript.</p> <p>The CoffeeScript compiler goes to great lengths to generate output JavaScript that runs in every JavaScript runtime, but there are exceptions. Use <a href="#generator-functions">generator functions</a>, <a href="#generator-iteration"><code>for…from</code></a>, or <a href="#tagged-template-literals">tagged template literals</a> only if you know that your <a href="http://kangax.github.io/compat-table/es6/" target="_blank">target runtimes can support them</a>. If you use <a href="#modules">modules</a>, you will need to <a href="#modules-note">use an additional tool to resolve them</a>.</p> <p><strong>Latest Version:</strong> <a href="https://github.com/jashkenas/coffeescript/tarball/1.12.6" target="_blank">1.12.6</a></p> <pre>npm install -g coffeescript
</pre>
<p><strong>CoffeeScript 2 is coming!</strong> It adds support for <a href="http://coffeescript.org/v2/#classes" target="_blank">ES2015 classes</a>, <a href="http://coffeescript.org/v2/#fat-arrow" target="_blank"><code>async</code>/<code>await</code></a>, and generates JavaScript using ES2015+ syntax. <a href="http://coffeescript.org/v2/" target="_blank">Learn more</a>.</p> <h2>Overview</h2> <p><em>CoffeeScript on the left, compiled JavaScript output on the right.</em></p> <div class="code">
<pre data-language="coffeescript"># Assignment:
number   = 42
opposite = true

# Conditions:
number = -42 if opposite

# Functions:
square = (x) -&gt; x * x

# Arrays:
list = [1, 2, 3, 4, 5]

# Objects:
math =
  root:   Math.sqrt
  square: square
  cube:   (x) -&gt; x * square x

# Splats:
race = (winner, runners...) -&gt;
  print winner, runners

# Existence:
alert "I knew it!" if elvis?

# Array comprehensions:
cubes = (math.cube num for num in list)
</pre>
<pre data-language="javascript">var cubes, list, math, num, number, opposite, race, square,
  slice = [].slice;

number = 42;

opposite = true;

if (opposite) {
  number = -42;
}

square = function(x) {
  return x * x;
};

list = [1, 2, 3, 4, 5];

math = {
  root: Math.sqrt,
  square: square,
  cube: function(x) {
    return x * square(x);
  }
};

race = function() {
  var runners, winner;
  winner = arguments[0], runners = 2 &lt;= arguments.length ? slice.call(arguments, 1) : [];
  return print(winner, runners);
};

if (typeof elvis !== "undefined" &amp;&amp; elvis !== null) {
  alert("I knew it!");
}

cubes = (function() {
  var i, len, results;
  results = [];
  for (i = 0, len = list.length; i &lt; len; i++) {
    num = list[i];
    results.push(math.cube(num));
  }
  return results;
})();
</pre>
</div>  <h2 id="installation">Installation</h2> <p>The command-line version of <code>coffee</code> is available as a <a href="https://nodejs.org/" target="_blank">Node.js</a> utility. The <a href="http://coffeescript.org/v1/browser-compiler/coffee-script.js" target="_blank">core compiler</a> however, does not depend on Node, and can be run in any JavaScript environment, or in the browser (see <a href="#try">Try CoffeeScript</a>).</p> <p>To install, first make sure you have a working copy of the latest stable version of <a href="https://nodejs.org/" target="_blank">Node.js</a>. You can then install CoffeeScript globally with <a href="https://www.npmjs.com/" target="_blank">npm</a>:</p> <pre>npm install --global coffeescript
</pre>
<p>This will make the <code>coffee</code> and <code>cake</code> commands available globally.</p> <p>When you need CoffeeScript as a dependency of a project, within that project’s folder you can install it locally:</p> <pre>npm install --save coffeescript
</pre>
<p>The <code>coffee</code> and <code>cake</code> commands will first look in the current folder to see if CoffeeScript is installed locally, and use that version if so. This allows different versions of CoffeeScript to be installed globally and locally.</p>  <h2 id="usage">Usage</h2> <p>Once installed, you should have access to the <code>coffee</code> command, which can execute scripts, compile <code>.coffee</code> files into <code>.js</code>, and provide an interactive REPL. The <code>coffee</code> command takes the following options:</p> <table> <thead> <tr> <th>Option</th> <th>Description</th> </tr> </thead> <tbody> <tr> <td><code>-c, --compile</code></td> <td>Compile a <code>.coffee</code> script into a <code>.js</code> JavaScript file of the same name.</td> </tr> <tr> <td><code>-m, --map</code></td> <td>Generate source maps alongside the compiled JavaScript files. Adds <code>sourceMappingURL</code> directives to the JavaScript as well.</td> </tr> <tr> <td><code>-M, --inline-map</code></td> <td>Just like <code>--map</code>, but include the source map directly in the compiled JavaScript files, rather than in a separate file.</td> </tr> <tr> <td><code>-i, --interactive</code></td> <td>Launch an interactive CoffeeScript session to try short snippets. Identical to calling <code>coffee</code> with no arguments.</td> </tr> <tr> <td><code>-o, --output [DIR]</code></td> <td>Write out all compiled JavaScript files into the specified directory. Use in conjunction with <code>--compile</code> or <code>--watch</code>.</td> </tr> <tr> <td><code>-w, --watch</code></td> <td>Watch files for changes, rerunning the specified command when any file is updated.</td> </tr> <tr> <td><code>-p, --print</code></td> <td>Instead of writing out the JavaScript as a file, print it directly to <strong>stdout</strong>.</td> </tr> <tr> <td><code>-s, --stdio</code></td> <td>Pipe in CoffeeScript to STDIN and get back JavaScript over STDOUT. Good for use with processes written in other languages. An example:<br><code>cat src/cake.coffee | coffee -sc</code>
</td> </tr> <tr> <td><code>-l, --literate</code></td> <td>Parses the code as Literate CoffeeScript. You only need to specify this when passing in code directly over <strong>stdio</strong>, or using some sort of extension-less file name.</td> </tr> <tr> <td><code>-e, --eval</code></td> <td>Compile and print a little snippet of CoffeeScript directly from the command line. For example:<br><code>coffee -e "console.log num for num in [10..1]"</code>
</td> </tr> <tr> <td>
<code>-r, --require [MODULE]</code> </td> <td>
<code>require()</code> the given module before starting the REPL or evaluating the code given with the <code>--eval</code> flag.</td> </tr> <tr> <td><code>-b, --bare</code></td> <td>Compile the JavaScript without the <a href="#lexical-scope">top-level function safety wrapper</a>.</td> </tr> <tr> <td><code>-t, --tokens</code></td> <td>Instead of parsing the CoffeeScript, just lex it, and print out the token stream. Used for debugging the compiler.</td> </tr> <tr> <td><code>-n, --nodes</code></td> <td>Instead of compiling the CoffeeScript, just lex and parse it, and print out the parse tree. Used for debugging the compiler.</td> </tr> <tr> <td><code>--nodejs</code></td> <td>The <code>node</code> executable has some useful options you can set, such as <code>--debug</code>, <code>--debug-brk</code>, <code>--max-stack-size</code>, and <code>--expose-gc</code>. Use this flag to forward options directly to Node.js. To pass multiple flags, use <code>--nodejs</code> multiple times.</td> </tr> <tr> <td><code>--no-header</code></td> <td>Suppress the “Generated by CoffeeScript” header.</td> </tr> </tbody> </table> <h3>Examples:</h3> <ul> <li>Compile a directory tree of <code>.coffee</code> files in <code>src</code> into a parallel tree of <code>.js</code> files in <code>lib</code>:<br> <code>coffee --compile --output lib/ src/</code>
</li> <li>Watch a file for changes, and recompile it every time the file is saved:<br> <code>coffee --watch --compile experimental.coffee</code>
</li> <li>Concatenate a list of files into a single script:<br> <code>coffee --join project.js --compile src/*.coffee</code>
</li> <li>Print out the compiled JS from a one-liner:<br> <code>coffee -bpe "alert i for i in [0..10]"</code>
</li> <li>All together now, watch and recompile an entire project as you work on it:<br> <code>coffee -o lib/ -cw src/</code>
</li> <li>Start the CoffeeScript REPL (<code>Ctrl-D</code> to exit, <code>Ctrl-V</code>for multi-line):<br> <code>coffee</code>
</li> </ul>  <h2 id="literate">Literate CoffeeScript</h2> <p>Besides being used as an ordinary programming language, CoffeeScript may also be written in “literate” mode. If you name your file with a <code>.litcoffee</code> extension, you can write it as a Markdown document — a document that also happens to be executable CoffeeScript code. The compiler will treat any indented blocks (Markdown’s way of indicating source code) as code, and ignore the rest as comments.</p> <p>Just for kicks, a little bit of the compiler is currently implemented in this fashion: See it <a href="https://gist.github.com/jashkenas/3fc3c1a8b1009c00d9df" target="_blank">as a document</a>, <a href="https://raw.githubusercontent.com/jashkenas/coffeescript/master/src/scope.litcoffee" target="_blank">raw</a>, and <a href="http://cl.ly/LxEu" target="_blank">properly highlighted in a text editor</a>.</p>  <h2 id="language">Language Reference</h2> <p><em>This reference is structured so that it can be read from top to bottom, if you like. Later sections use ideas and syntax previously introduced. Familiarity with JavaScript is assumed. In all of the following examples, the source CoffeeScript is provided on the left, and the direct compilation into JavaScript is on the right.</em></p> <p><em>Many of the examples can be run (where it makes sense) by pressing the <strong>run</strong> button on the right, and can be loaded into the “Try CoffeeScript” console by pressing the <strong>load</strong> button on the left.</em></p> <p>First, the basics: CoffeeScript uses significant whitespace to delimit blocks of code. You don’t need to use semicolons <code>;</code> to terminate expressions, ending the line will do just as well (although semicolons can still be used to fit multiple expressions onto a single line). Instead of using curly braces <code>{ }</code> to surround blocks of code in <a href="#literals">functions</a>, <a href="#conditionals">if-statements</a>, <a href="#switch">switch</a>, and <a href="#try">try/catch</a>, use indentation.</p> <p>You don’t need to use parentheses to invoke a function if you’re passing arguments. The implicit call wraps forward to the end of the line or block expression.<br> <code>console.log sys.inspect object</code> → <code>console.log(sys.inspect(object));</code></p>  <h2 id="literals">Functions</h2> <p>Functions are defined by an optional list of parameters in parentheses, an arrow, and the function body. The empty function looks like this: <code>-&gt;</code></p> <div class="code">
<pre data-language="coffeescript">square = (x) -&gt; x * x
cube   = (x) -&gt; square(x) * x
</pre>
<pre data-language="javascript">var cube, square;

square = function(x) {
  return x * x;
};

cube = function(x) {
  return square(x) * x;
};
</pre>
</div>
<p>Functions may also have default values for arguments, which will be used if the incoming argument is missing (<code>null</code> or <code>undefined</code>).</p> <div class="code">
<pre data-language="coffeescript">fill = (container, liquid = "coffee") -&gt;
  "Filling the #{container} with #{liquid}..."
</pre>
<pre data-language="javascript">var fill;

fill = function(container, liquid) {
  if (liquid == null) {
    liquid = "coffee";
  }
  return "Filling the " + container + " with " + liquid + "...";
};
</pre>
</div>  <h2 id="objects-and-arrays">Objects and Arrays</h2> <p>The CoffeeScript literals for objects and arrays look very similar to their JavaScript cousins. When each property is listed on its own line, the commas are optional. Objects may be created using indentation instead of explicit braces, similar to <a href="http://yaml.org" target="_blank">YAML</a>.</p> <div class="code">
<pre data-language="coffeescript">song = ["do", "re", "mi", "fa", "so"]

singers = {Jagger: "Rock", Elvis: "Roll"}

bitlist = [
  1, 0, 1
  0, 0, 1
  1, 1, 0
]

kids =
  brother:
    name: "Max"
    age:  11
  sister:
    name: "Ida"
    age:  9
</pre>
<pre data-language="javascript">var bitlist, kids, singers, song;

song = ["do", "re", "mi", "fa", "so"];

singers = {
  Jagger: "Rock",
  Elvis: "Roll"
};

bitlist = [1, 0, 1, 0, 0, 1, 1, 1, 0];

kids = {
  brother: {
    name: "Max",
    age: 11
  },
  sister: {
    name: "Ida",
    age: 9
  }
};
</pre>
</div>
<p>In JavaScript, you can’t use reserved words, like <code>class</code>, as properties of an object, without quoting them as strings. CoffeeScript notices reserved words used as keys in objects and quotes them for you, so you don’t have to worry about it (say, when using jQuery).</p> <div class="code">
<pre data-language="coffeescript">$('.account').attr class: 'active'

log object.class
</pre>
<pre data-language="javascript">$('.account').attr({
  "class": 'active'
});

log(object["class"]);
</pre>
</div>
<p>CoffeeScript has a shortcut for creating objects when you want the key to be set with a variable of the same name.</p> <div class="code">
<pre data-language="coffeescript">name = "Michelangelo"
mask = "orange"
weapon = "nunchuks"
turtle = {name, mask, weapon}
output = "#{turtle.name} wears an #{turtle.mask} mask. Watch out for his #{turtle.weapon}!"
</pre>
<pre data-language="javascript">var mask, name, output, turtle, weapon;

name = "Michelangelo";

mask = "orange";

weapon = "nunchuks";

turtle = {
  name: name,
  mask: mask,
  weapon: weapon
};

output = turtle.name + " wears an " + turtle.mask + " mask. Watch out for his " + turtle.weapon + "!";
</pre>
</div>  <h2 id="lexical-scope">Lexical Scoping and Variable Safety</h2> <p>The CoffeeScript compiler takes care to make sure that all of your variables are properly declared within lexical scope — you never need to write <code>var</code> yourself.</p> <div class="code">
<pre data-language="coffeescript">outer = 1
changeNumbers = -&gt;
  inner = -1
  outer = 10
inner = changeNumbers()
</pre>
<pre data-language="javascript">var changeNumbers, inner, outer;

outer = 1;

changeNumbers = function() {
  var inner;
  inner = -1;
  return outer = 10;
};

inner = changeNumbers();
</pre>
</div>
<p>Notice how all of the variable declarations have been pushed up to the top of the closest scope, the first time they appear. <strong>outer</strong> is not redeclared within the inner function, because it’s already in scope; <strong>inner</strong> within the function, on the other hand, should not be able to change the value of the external variable of the same name, and therefore has a declaration of its own.</p> <p>This behavior is effectively identical to Ruby’s scope for local variables. Because you don’t have direct access to the <code>var</code> keyword, it’s impossible to shadow an outer variable on purpose, you may only refer to it. So be careful that you’re not reusing the name of an external variable accidentally, if you’re writing a deeply nested function.</p> <p>Although suppressed within this documentation for clarity, all CoffeeScript output is wrapped in an anonymous function: <code>(function(){ … })();</code> This safety wrapper, combined with the automatic generation of the <code>var</code> keyword, make it exceedingly difficult to pollute the global namespace by accident.</p> <p>If you’d like to create top-level variables for other scripts to use, attach them as properties on <strong>window</strong>; attach them as properties on the <strong>exports</strong> object in CommonJS; or use an <a href="#modules"><code>export</code> statement</a>. If you’re targeting both CommonJS and the browser, the <strong>existential operator</strong> (covered below), gives you a reliable way to figure out where to add them: <code>exports ? this</code></p>  <h2 id="conditionals">If, Else, Unless, and Conditional Assignment</h2> <p><strong>If/else</strong> statements can be written without the use of parentheses and curly brackets. As with functions and other block expressions, multi-line conditionals are delimited by indentation. There’s also a handy postfix form, with the <code>if</code> or <code>unless</code> at the end.</p> <p>CoffeeScript can compile <strong>if</strong> statements into JavaScript expressions, using the ternary operator when possible, and closure wrapping otherwise. There is no explicit ternary statement in CoffeeScript — you simply use a regular <strong>if</strong> statement on a single line.</p> <div class="code">
<pre data-language="coffeescript">mood = greatlyImproved if singing

if happy and knowsIt
  clapsHands()
  chaChaCha()
else
  showIt()

date = if friday then sue else jill
</pre>
<pre data-language="javascript">var date, mood;

if (singing) {
  mood = greatlyImproved;
}

if (happy &amp;&amp; knowsIt) {
  clapsHands();
  chaChaCha();
} else {
  showIt();
}

date = friday ? sue : jill;
</pre>
</div>  <h2 id="splats">Splats…</h2> <p>The JavaScript <strong>arguments object</strong> is a useful way to work with functions that accept variable numbers of arguments. CoffeeScript provides splats <code>...</code>, both for function definition as well as invocation, making variable numbers of arguments a little bit more palatable.</p> <div class="code">
<pre data-language="coffeescript">gold = silver = rest = "unknown"

awardMedals = (first, second, others...) -&gt;
  gold   = first
  silver = second
  rest   = others

contenders = [
  "Michael Phelps"
  "Liu Xiang"
  "Yao Ming"
  "Allyson Felix"
  "Shawn Johnson"
  "Roman Sebrle"
  "Guo Jingjing"
  "Tyson Gay"
  "Asafa Powell"
  "Usain Bolt"
]

awardMedals contenders...

alert "Gold: " + gold
alert "Silver: " + silver
alert "The Field: " + rest
</pre>
<pre data-language="javascript">var awardMedals, contenders, gold, rest, silver,
  slice = [].slice;

gold = silver = rest = "unknown";

awardMedals = function() {
  var first, others, second;
  first = arguments[0], second = arguments[1], others = 3 &lt;= arguments.length ? slice.call(arguments, 2) : [];
  gold = first;
  silver = second;
  return rest = others;
};

contenders = ["Michael Phelps", "Liu Xiang", "Yao Ming", "Allyson Felix", "Shawn Johnson", "Roman Sebrle", "Guo Jingjing", "Tyson Gay", "Asafa Powell", "Usain Bolt"];

awardMedals.apply(null, contenders);

alert("Gold: " + gold);

alert("Silver: " + silver);

alert("The Field: " + rest);
</pre>
</div>  <h2 id="loops">Loops and Comprehensions</h2> <p>Most of the loops you’ll write in CoffeeScript will be <strong>comprehensions</strong> over arrays, objects, and ranges. Comprehensions replace (and compile into) <strong>for</strong> loops, with optional guard clauses and the value of the current array index. Unlike for loops, array comprehensions are expressions, and can be returned and assigned.</p> <div class="code">
<pre data-language="coffeescript"># Eat lunch.
eat food for food in ['toast', 'cheese', 'wine']

# Fine five course dining.
courses = ['greens', 'caviar', 'truffles', 'roast', 'cake']
menu i + 1, dish for dish, i in courses

# Health conscious meal.
foods = ['broccoli', 'spinach', 'chocolate']
eat food for food in foods when food isnt 'chocolate'
</pre>
<pre data-language="javascript">var courses, dish, food, foods, i, j, k, l, len, len1, len2, ref;

ref = ['toast', 'cheese', 'wine'];
for (j = 0, len = ref.length; j &lt; len; j++) {
  food = ref[j];
  eat(food);
}

courses = ['greens', 'caviar', 'truffles', 'roast', 'cake'];

for (i = k = 0, len1 = courses.length; k &lt; len1; i = ++k) {
  dish = courses[i];
  menu(i + 1, dish);
}

foods = ['broccoli', 'spinach', 'chocolate'];

for (l = 0, len2 = foods.length; l &lt; len2; l++) {
  food = foods[l];
  if (food !== 'chocolate') {
    eat(food);
  }
}
</pre>
</div>
<p>Comprehensions should be able to handle most places where you otherwise would use a loop, <strong>each</strong>/<strong>forEach</strong>, <strong>map</strong>, or <strong>select</strong>/<strong>filter</strong>, for example:<br> <code>shortNames = (name for name in list when name.length &lt; 5)</code><br> If you know the start and end of your loop, or would like to step through in fixed-size increments, you can use a range to specify the start and end of your comprehension.</p> <div class="code">
<pre data-language="coffeescript">countdown = (num for num in [10..1])
</pre>
<pre data-language="javascript">var countdown, num;

countdown = (function() {
  var i, results;
  results = [];
  for (num = i = 10; i &gt;= 1; num = --i) {
    results.push(num);
  }
  return results;
})();
</pre>
</div>
<p>Note how because we are assigning the value of the comprehensions to a variable in the example above, CoffeeScript is collecting the result of each iteration into an array. Sometimes functions end with loops that are intended to run only for their side-effects. Be careful that you’re not accidentally returning the results of the comprehension in these cases, by adding a meaningful return value — like <code>true</code> — or <code>null</code>, to the bottom of your function.</p> <p>To step through a range comprehension in fixed-size chunks, use <code>by</code>, for example: <code>evens = (x for x in [0..10] by 2)</code></p> <p>If you don’t need the current iteration value you may omit it: <code>browser.closeCurrentTab() for [0...count]</code></p> <p>Comprehensions can also be used to iterate over the keys and values in an object. Use <code>of</code> to signal comprehension over the properties of an object instead of the values in an array.</p> <div class="code">
<pre data-language="coffeescript">yearsOld = max: 10, ida: 9, tim: 11

ages = for child, age of yearsOld
  "#{child} is #{age}"
</pre>
<pre data-language="javascript">var age, ages, child, yearsOld;

yearsOld = {
  max: 10,
  ida: 9,
  tim: 11
};

ages = (function() {
  var results;
  results = [];
  for (child in yearsOld) {
    age = yearsOld[child];
    results.push(child + " is " + age);
  }
  return results;
})();
</pre>
</div>
<p>If you would like to iterate over just the keys that are defined on the object itself, by adding a <code>hasOwnProperty</code> check to avoid properties that may be inherited from the prototype, use <code>for own key, value of object</code>.</p> <p>To iterate a generator function, use <code>from</code>. See <a href="#generator-iteration">Generator Functions</a>.</p> <p>The only low-level loop that CoffeeScript provides is the <strong>while</strong> loop. The main difference from JavaScript is that the <strong>while</strong> loop can be used as an expression, returning an array containing the result of each iteration through the loop.</p> <div class="code">
<pre data-language="coffeescript"># Econ 101
if this.studyingEconomics
  buy()  while supply &gt; demand
  sell() until supply &gt; demand

# Nursery Rhyme
num = 6
lyrics = while num -= 1
  "#{num} little monkeys, jumping on the bed.
    One fell out and bumped his head."
</pre>
<pre data-language="javascript">var lyrics, num;

if (this.studyingEconomics) {
  while (supply &gt; demand) {
    buy();
  }
  while (!(supply &gt; demand)) {
    sell();
  }
}

num = 6;

lyrics = (function() {
  var results;
  results = [];
  while (num -= 1) {
    results.push(num + " little monkeys, jumping on the bed. One fell out and bumped his head.");
  }
  return results;
})();
</pre>
</div>
<p>For readability, the <strong>until</strong> keyword is equivalent to <code>while not</code>, and the <strong>loop</strong> keyword is equivalent to <code>while true</code>.</p> <p>When using a JavaScript loop to generate functions, it’s common to insert a closure wrapper in order to ensure that loop variables are closed over, and all the generated functions don’t just share the final values. CoffeeScript provides the <code>do</code> keyword, which immediately invokes a passed function, forwarding any arguments.</p> <div class="code">
<pre data-language="coffeescript">for filename in list
  do (filename) -&gt;
    fs.readFile filename, (err, contents) -&gt;
      compile filename, contents.toString()
</pre>
<pre data-language="javascript">var filename, fn, i, len;

fn = function(filename) {
  return fs.readFile(filename, function(err, contents) {
    return compile(filename, contents.toString());
  });
};
for (i = 0, len = list.length; i &lt; len; i++) {
  filename = list[i];
  fn(filename);
}
</pre>
</div>  <h2 id="slices">Array Slicing and Splicing with Ranges</h2> <p>Ranges can also be used to extract slices of arrays. With two dots (<code>3..6</code>), the range is inclusive (<code>3, 4, 5, 6</code>); with three dots (<code>3...6</code>), the range excludes the end (<code>3, 4, 5</code>). Slices indices have useful defaults. An omitted first index defaults to zero and an omitted second index defaults to the size of the array.</p> <div class="code">
<pre data-language="coffeescript">numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]

start   = numbers[0..2]

middle  = numbers[3...-2]

end     = numbers[-2..]

copy    = numbers[..]
</pre>
<pre data-language="javascript">var copy, end, middle, numbers, start;

numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];

start = numbers.slice(0, 3);

middle = numbers.slice(3, -2);

end = numbers.slice(-2);

copy = numbers.slice(0);
</pre>
</div>
<p>The same syntax can be used with assignment to replace a segment of an array with new values, splicing it.</p> <div class="code">
<pre data-language="coffeescript">numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

numbers[3..6] = [-3, -4, -5, -6]
</pre>
<pre data-language="javascript">var numbers, ref;

numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];

[].splice.apply(numbers, [3, 4].concat(ref = [-3, -4, -5, -6])), ref;
</pre>
</div>
<p>Note that JavaScript strings are immutable, and can’t be spliced.</p>  <h2 id="expressions">Everything is an Expression (at least, as much as possible)</h2> <p>You might have noticed how even though we don’t add return statements to CoffeeScript functions, they nonetheless return their final value. The CoffeeScript compiler tries to make sure that all statements in the language can be used as expressions. Watch how the <code>return</code> gets pushed down into each possible branch of execution in the function below.</p> <div class="code">
<pre data-language="coffeescript">grade = (student) -&gt;
  if student.excellentWork
    "A+"
  else if student.okayStuff
    if student.triedHard then "B" else "B-"
  else
    "C"

eldest = if 24 &gt; 21 then "Liz" else "Ike"
</pre>
<pre data-language="javascript">var eldest, grade;

grade = function(student) {
  if (student.excellentWork) {
    return "A+";
  } else if (student.okayStuff) {
    if (student.triedHard) {
      return "B";
    } else {
      return "B-";
    }
  } else {
    return "C";
  }
};

eldest = 24 &gt; 21 ? "Liz" : "Ike";
</pre>
</div>
<p>Even though functions will always return their final value, it’s both possible and encouraged to return early from a function body writing out the explicit return (<code>return value</code>), when you know that you’re done.</p> <p>Because variable declarations occur at the top of scope, assignment can be used within expressions, even for variables that haven’t been seen before:</p> <div class="code">
<pre data-language="coffeescript">six = (one = 1) + (two = 2) + (three = 3)
</pre>
<pre data-language="javascript">var one, six, three, two;

six = (one = 1) + (two = 2) + (three = 3);
</pre>
</div>
<p>Things that would otherwise be statements in JavaScript, when used as part of an expression in CoffeeScript, are converted into expressions by wrapping them in a closure. This lets you do useful things, like assign the result of a comprehension to a variable:</p> <div class="code">
<pre data-language="coffeescript"># The first ten global properties.

globals = (name for name of window)[0...10]
</pre>
<pre data-language="javascript">var globals, name;

globals = ((function() {
  var results;
  results = [];
  for (name in window) {
    results.push(name);
  }
  return results;
})()).slice(0, 10);
</pre>
</div>
<p>As well as silly things, like passing a <strong>try/catch</strong> statement directly into a function call:</p> <div class="code">
<pre data-language="coffeescript">alert(
  try
    nonexistent / undefined
  catch error
    "And the error is ... #{error}"
)
</pre>
<pre data-language="javascript">var error;

alert((function() {
  try {
    return nonexistent / void 0;
  } catch (error1) {
    error = error1;
    return "And the error is ... " + error;
  }
})());
</pre>
</div>
<p>There are a handful of statements in JavaScript that can’t be meaningfully converted into expressions, namely <code>break</code>, <code>continue</code>, and <code>return</code>. If you make use of them within a block of code, CoffeeScript won’t try to perform the conversion.</p>  <h2 id="operators">Operators and Aliases</h2> <p>Because the <code>==</code> operator frequently causes undesirable coercion, is intransitive, and has a different meaning than in other languages, CoffeeScript compiles <code>==</code> into <code>===</code>, and <code>!=</code> into <code>!==</code>. In addition, <code>is</code> compiles into <code>===</code>, and <code>isnt</code> into <code>!==</code>.</p> <p>You can use <code>not</code> as an alias for <code>!</code>.</p> <p>For logic, <code>and</code> compiles to <code>&amp;&amp;</code>, and <code>or</code> into <code>||</code>.</p> <p>Instead of a newline or semicolon, <code>then</code> can be used to separate conditions from expressions, in <strong>while</strong>, <strong>if</strong>/<strong>else</strong>, and <strong>switch</strong>/<strong>when</strong> statements.</p> <p>As in <a href="http://yaml.org/" target="_blank">YAML</a>, <code>on</code> and <code>yes</code> are the same as boolean <code>true</code>, while <code>off</code> and <code>no</code> are boolean <code>false</code>.</p> <p><code>unless</code> can be used as the inverse of <code>if</code>.</p> <p>As a shortcut for <code>this.property</code>, you can use <code>@property</code>.</p> <p>You can use <code>in</code> to test for array presence, and <code>of</code> to test for JavaScript object-key presence.</p> <p>To simplify math expressions, <code>**</code> can be used for exponentiation and <code>//</code> performs integer division. <code>%</code> works just like in JavaScript, while <code>%%</code> provides <a href="https://en.wikipedia.org/wiki/Modulo_operation" target="_blank">“dividend dependent modulo”</a>:</p> <div class="code">
<pre data-language="coffeescript">-7 % 5 == -2 # The remainder of 7 / 5
-7 %% 5 == 3 # n %% 5 is always between 0 and 4

tabs.selectTabAtIndex((tabs.currentIndex - count) %% tabs.length)
</pre>
<pre data-language="javascript">var modulo = function(a, b) { return (+a % (b = +b) + b) % b; };

-7 % 5 === -2;

modulo(-7, 5) === 3;

tabs.selectTabAtIndex(modulo(tabs.currentIndex - count, tabs.length));
</pre>
</div>
<p>All together now:</p> <table> <thead> <tr> <th>CoffeeScript</th> <th>JavaScript</th> </tr> </thead> <tbody> <tr> <td><code id="is">is</code></td> <td><code>===</code></td> </tr> <tr> <td><code id="isnt">isnt</code></td> <td><code>!==</code></td> </tr> <tr> <td><code id="not">not</code></td> <td><code>!</code></td> </tr> <tr> <td><code id="and">and</code></td> <td><code>&amp;&amp;</code></td> </tr> <tr> <td><code id="or">or</code></td> <td><code>||</code></td> </tr> <tr> <td>
<code>true</code>, <code>yes</code>, <code>on</code>
</td> <td><code>true</code></td> </tr> <tr> <td>
<code>false</code>, <code>no</code>, <code>off</code> </td> <td><code>false</code></td> </tr> <tr> <td>
<code id="this">@</code>, <code>this</code>
</td> <td><code>this</code></td> </tr> <tr> <td><code id="of">of</code></td> <td><code>in</code></td> </tr> <tr> <td><code id="in">in</code></td> <td><em>no JS equivalent</em></td> </tr> <tr> <td><code id="pow">a ** b</code></td> <td><code>Math.pow(a, b)</code></td> </tr> <tr> <td><code id="floor">a // b</code></td> <td><code>Math.floor(a / b)</code></td> </tr> <tr> <td><code id="mod">a %% b</code></td> <td><code>(a % b + b) % b</code></td> </tr> </tbody> </table> <div class="code">
<pre data-language="coffeescript">launch() if ignition is on

volume = 10 if band isnt SpinalTap

letTheWildRumpusBegin() unless answer is no

if car.speed &lt; limit then accelerate()

winner = yes if pick in [47, 92, 13]

print inspect "My name is #{@name}"
</pre>
<pre data-language="javascript">var volume, winner;

if (ignition === true) {
  launch();
}

if (band !== SpinalTap) {
  volume = 10;
}

if (answer !== false) {
  letTheWildRumpusBegin();
}

if (car.speed &lt; limit) {
  accelerate();
}

if (pick === 47 || pick === 92 || pick === 13) {
  winner = true;
}

print(inspect("My name is " + this.name));
</pre>
</div>  <h2 id="existential-operator">The Existential Operator</h2> <p>It’s a little difficult to check for the existence of a variable in JavaScript. <code>if (variable) …</code> comes close, but fails for zero, the empty string, and false. CoffeeScript’s existential operator <code>?</code> returns true unless a variable is <strong>null</strong> or <strong>undefined</strong>, which makes it analogous to Ruby’s <code>nil?</code></p> <p>It can also be used for safer conditional assignment than <code>||=</code> provides, for cases where you may be handling numbers or strings.</p> <div class="code">
<pre data-language="coffeescript">solipsism = true if mind? and not world?

speed = 0
speed ?= 15

footprints = yeti ? "bear"
</pre>
<pre data-language="javascript">var footprints, solipsism, speed;

if ((typeof mind !== "undefined" &amp;&amp; mind !== null) &amp;&amp; (typeof world === "undefined" || world === null)) {
  solipsism = true;
}

speed = 0;

if (speed == null) {
  speed = 15;
}

footprints = typeof yeti !== "undefined" &amp;&amp; yeti !== null ? yeti : "bear";
</pre>
</div>
<p>The accessor variant of the existential operator <code>?.</code> can be used to soak up null references in a chain of properties. Use it instead of the dot accessor <code>.</code> in cases where the base value may be <strong>null</strong> or <strong>undefined</strong>. If all of the properties exist then you’ll get the expected result, if the chain is broken, <strong>undefined</strong> is returned instead of the <strong>TypeError</strong> that would be raised otherwise.</p> <div class="code">
<pre data-language="coffeescript">zip = lottery.drawWinner?().address?.zipcode
</pre>
<pre data-language="javascript">var ref, zip;

zip = typeof lottery.drawWinner === "function" ? (ref = lottery.drawWinner().address) != null ? ref.zipcode : void 0 : void 0;
</pre>
</div>
<p>Soaking up nulls is similar to Ruby’s <a href="https://rubygems.org/gems/andand" target="_blank">andand gem</a>, and to the <a href="http://docs.groovy-lang.org/latest/html/documentation/index.html#_safe_navigation_operator" target="_blank">safe navigation operator</a> in Groovy.</p>  <h2 id="classes">Classes, Inheritance, and Super</h2> <p>JavaScript’s prototypal inheritance has always been a bit of a brain-bender, with a whole family tree of libraries that provide a cleaner syntax for classical inheritance on top of JavaScript’s prototypes: <a href="https://code.google.com/p/base2/" target="_blank">Base2</a>, <a href="http://prototypejs.org/" target="_blank">Prototype.js</a>, <a href="http://jsclass.jcoglan.com/" target="_blank">JS.Class</a>, etc. The libraries provide syntactic sugar, but the built-in inheritance would be completely usable if it weren’t for a couple of small exceptions: it’s awkward to call <strong>super</strong> (the prototype object’s implementation of the current function), and it’s awkward to correctly set the prototype chain.</p> <p>Instead of repetitively attaching functions to a prototype, CoffeeScript provides a basic <code>class</code> structure that allows you to name your class, set the superclass, assign prototypal properties, and define the constructor, in a single assignable expression.</p> <p>Constructor functions are named, to better support helpful stack traces. In the first class in the example below, <code>this.constructor.name is "Animal"</code>.</p> <div class="code">
<pre data-language="coffeescript">class Animal
  constructor: (@name) -&gt;

  move: (meters) -&gt;
    alert @name + " moved #{meters}m."

class Snake extends Animal
  move: -&gt;
    alert "Slithering..."
    super 5

class Horse extends Animal
  move: -&gt;
    alert "Galloping..."
    super 45

sam = new Snake "Sammy the Python"
tom = new Horse "Tommy the Palomino"

sam.move()
tom.move()
</pre>
<pre data-language="javascript">var Animal, Horse, Snake, sam, tom,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Animal = (function() {
  function Animal(name) {
    this.name = name;
  }

  Animal.prototype.move = function(meters) {
    return alert(this.name + (" moved " + meters + "m."));
  };

  return Animal;

})();

Snake = (function(superClass) {
  extend(Snake, superClass);

  function Snake() {
    return Snake.__super__.constructor.apply(this, arguments);
  }

  Snake.prototype.move = function() {
    alert("Slithering...");
    return Snake.__super__.move.call(this, 5);
  };

  return Snake;

})(Animal);

Horse = (function(superClass) {
  extend(Horse, superClass);

  function Horse() {
    return Horse.__super__.constructor.apply(this, arguments);
  }

  Horse.prototype.move = function() {
    alert("Galloping...");
    return Horse.__super__.move.call(this, 45);
  };

  return Horse;

})(Animal);

sam = new Snake("Sammy the Python");

tom = new Horse("Tommy the Palomino");

sam.move();

tom.move();
</pre>
</div>
<p>If structuring your prototypes classically isn’t your cup of tea, CoffeeScript provides a couple of lower-level conveniences. The <code>extends</code> operator helps with proper prototype setup, and can be used to create an inheritance chain between any pair of constructor functions; <code>::</code> gives you quick access to an object’s prototype; and <code>super()</code> is converted into a call against the immediate ancestor’s method of the same name.</p> <div class="code">
<pre data-language="coffeescript">String::dasherize = -&gt;
  this.replace /_/g, "-"
</pre>
<pre data-language="javascript">String.prototype.dasherize = function() {
  return this.replace(/_/g, "-");
};
</pre>
</div>
<p>Finally, class definitions are blocks of executable code, which make for interesting metaprogramming possibilities. Because in the context of a class definition, <code>this</code> is the class object itself (the constructor function), you can assign static properties by using <code>@property: value</code>, and call functions defined in parent classes: <code>@attr 'title', type: 'text'</code></p>  <h2 id="destructuring">Destructuring Assignment</h2> <p>Just like JavaScript (since ES2015), CoffeeScript has destructuring assignment syntax. When you assign an array or object literal to a value, CoffeeScript breaks up and matches both sides against each other, assigning the values on the right to the variables on the left. In the simplest case, it can be used for parallel assignment:</p> <div class="code">
<pre data-language="coffeescript">theBait   = 1000
theSwitch = 0

[theBait, theSwitch] = [theSwitch, theBait]
</pre>
<pre data-language="javascript">var ref, theBait, theSwitch;

theBait = 1000;

theSwitch = 0;

ref = [theSwitch, theBait], theBait = ref[0], theSwitch = ref[1];
</pre>
</div>
<p>But it’s also helpful for dealing with functions that return multiple values.</p> <div class="code">
<pre data-language="coffeescript">weatherReport = (location) -&gt;
  # Make an Ajax request to fetch the weather...
  [location, 72, "Mostly Sunny"]

[city, temp, forecast] = weatherReport "Berkeley, CA"
</pre>
<pre data-language="javascript">var city, forecast, ref, temp, weatherReport;

weatherReport = function(location) {
  return [location, 72, "Mostly Sunny"];
};

ref = weatherReport("Berkeley, CA"), city = ref[0], temp = ref[1], forecast = ref[2];
</pre>
</div>
<p>Destructuring assignment can be used with any depth of array and object nesting, to help pull out deeply nested properties.</p> <div class="code">
<pre data-language="coffeescript">futurists =
  sculptor: "Umberto Boccioni"
  painter:  "Vladimir Burliuk"
  poet:
    name:   "F.T. Marinetti"
    address: [
      "Via Roma 42R"
      "Bellagio, Italy 22021"
    ]

{sculptor} = futurists

{poet: {name, address: [street, city]}} = futurists
</pre>
<pre data-language="javascript">var city, futurists, name, ref, ref1, sculptor, street;

futurists = {
  sculptor: "Umberto Boccioni",
  painter: "Vladimir Burliuk",
  poet: {
    name: "F.T. Marinetti",
    address: ["Via Roma 42R", "Bellagio, Italy 22021"]
  }
};

sculptor = futurists.sculptor;

ref = futurists.poet, name = ref.name, (ref1 = ref.address, street = ref1[0], city = ref1[1]);
</pre>
</div>
<p>Destructuring assignment can even be combined with splats.</p> <div class="code">
<pre data-language="coffeescript">tag = "&lt;impossible&gt;"

[open, contents..., close] = tag.split("")
</pre>
<pre data-language="javascript">var close, contents, i, open, ref, tag,
  slice = [].slice;

tag = "&lt;impossible&gt;";

ref = tag.split(""), open = ref[0], contents = 3 &lt;= ref.length ? slice.call(ref, 1, i = ref.length - 1) : (i = 1, []), close = ref[i++];
</pre>
</div>
<p>Expansion can be used to retrieve elements from the end of an array without having to assign the rest of its values. It works in function parameter lists as well.</p> <div class="code">
<pre data-language="coffeescript">text = "Every literary critic believes he will
        outwit history and have the last word"

[first, ..., last] = text.split " "
</pre>
<pre data-language="javascript">var first, last, ref, text;

text = "Every literary critic believes he will outwit history and have the last word";

ref = text.split(" "), first = ref[0], last = ref[ref.length - 1];
</pre>
</div>
<p>Destructuring assignment is also useful when combined with class constructors to assign properties to your instance from an options object passed to the constructor.</p> <div class="code">
<pre data-language="coffeescript">class Person
  constructor: (options) -&gt;
    {@name, @age, @height = 'average'} = options

tim = new Person name: 'Tim', age: 4
</pre>
<pre data-language="javascript">var Person, tim;

Person = (function() {
  function Person(options) {
    var ref;
    this.name = options.name, this.age = options.age, this.height = (ref = options.height) != null ? ref : 'average';
  }

  return Person;

})();

tim = new Person({
  name: 'Tim',
  age: 4
});
</pre>
</div>
<p>The above example also demonstrates that if properties are missing in the destructured object or array, you can, just like in JavaScript, provide defaults. The difference with JavaScript is that CoffeeScript, as always, treats both null and undefined the same.</p>  <h2 id="fat-arrow">Bound Functions, Generator Functions</h2> <p>In JavaScript, the <code>this</code> keyword is dynamically scoped to mean the object that the current function is attached to. If you pass a function as a callback or attach it to a different object, the original value of <code>this</code> will be lost. If you’re not familiar with this behavior, <a href="http://64.13.255.16/articles/scope_in_javascript/" target="_blank">this Digital Web article</a> gives a good overview of the quirks.</p> <p>The fat arrow <code>=&gt;</code> can be used to both define a function, and to bind it to the current value of <code>this</code>, right on the spot. This is helpful when using callback-based libraries like Prototype or jQuery, for creating iterator functions to pass to <code>each</code>, or event-handler functions to use with <code>on</code>. Functions created with the fat arrow are able to access properties of the <code>this</code> where they’re defined.</p> <div class="code">
<pre data-language="coffeescript">Account = (customer, cart) -&gt;
  @customer = customer
  @cart = cart

  $('.shopping_cart').on 'click', (event) =&gt;
    @customer.purchase @cart
</pre>
<pre data-language="javascript">var Account;

Account = function(customer, cart) {
  this.customer = customer;
  this.cart = cart;
  return $('.shopping_cart').on('click', (function(_this) {
    return function(event) {
      return _this.customer.purchase(_this.cart);
    };
  })(this));
};
</pre>
</div>
<p>If we had used <code>-&gt;</code> in the callback above, <code>@customer</code> would have referred to the undefined “customer” property of the DOM element, and trying to call <code>purchase()</code> on it would have raised an exception.</p> <p>When used in a class definition, methods declared with the fat arrow will be automatically bound to each instance of the class when the instance is constructed.</p>  <p id="generator-functions">CoffeeScript functions also support <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*" target="_blank">ES2015 generator functions</a> through the <code>yield</code> keyword. There’s no <code>function*(){}</code> nonsense — a generator in CoffeeScript is simply a function that yields.</p> <div class="code">
<pre data-language="coffeescript">perfectSquares = -&gt;
  num = 0
  loop
    num += 1
    yield num * num
  return

window.ps or= perfectSquares()
</pre>
<pre data-language="javascript">var perfectSquares;

perfectSquares = function*() {
  var num;
  num = 0;
  while (true) {
    num += 1;
    yield num * num;
  }
};

window.ps || (window.ps = perfectSquares());
</pre>
</div>
<p><code>yield*</code> is called <code>yield from</code>, and <code>yield return</code> may be used if you need to force a generator that doesn’t yield.</p>  <p id="generator-iteration">You can iterate over a generator function using <code>for…from</code>.</p> <div class="code">
<pre data-language="coffeescript">fibonacci = -&gt;
  [previous, current] = [1, 1]
  loop
    [previous, current] = [current, previous + current]
    yield current
  return

getFibonacciNumbers = (length) -&gt;
  results = [1]
  for n from fibonacci()
    results.push n
    break if results.length is length
  results
</pre>
<pre data-language="javascript">var fibonacci, getFibonacciNumbers;

fibonacci = function*() {
  var current, previous, ref, ref1;
  ref = [1, 1], previous = ref[0], current = ref[1];
  while (true) {
    ref1 = [current, previous + current], previous = ref1[0], current = ref1[1];
    yield current;
  }
};

getFibonacciNumbers = function(length) {
  var n, ref, results;
  results = [1];
  ref = fibonacci();
  for (n of ref) {
    results.push(n);
    if (results.length === length) {
      break;
    }
  }
  return results;
};
</pre>
</div>  <h2 id="embedded">Embedded JavaScript</h2> <p>Hopefully, you’ll never need to use it, but if you ever need to intersperse snippets of JavaScript within your CoffeeScript, you can use backticks to pass it straight through.</p> <div class="code">
<pre data-language="coffeescript">hi = `function() {
  return [document.title, "Hello JavaScript"].join(": ");
}`
</pre>
<pre data-language="javascript">var hi;

hi = function() {
  return [document.title, "Hello JavaScript"].join(": ");
};
</pre>
</div>
<p>Escape backticks with backslashes: <code>\`​</code> becomes <code>`​</code>.</p> <p>Escape backslashes before backticks with more backslashes: <code>\\\`​</code> becomes <code>\`​</code>.</p> <div class="code">
<pre data-language="coffeescript">markdown = `function () {
  return \`In Markdown, write code like \\\`this\\\`\`;
}`
</pre>
<pre data-language="javascript">var markdown;

markdown = function () {
  return `In Markdown, write code like \`this\``;
};
</pre>
</div>
<p>You can also embed blocks of JavaScript using triple backticks. That’s easier than escaping backticks, if you need them inside your JavaScript block.</p> <div class="code">
<pre data-language="coffeescript">```
function time() {
  return `The time is ${new Date().toLocaleTimeString()}`;
}
```
</pre>
<pre data-language="javascript">
function time() {
  return `The time is ${new Date().toLocaleTimeString()}`;
}
;

</pre>
</div>  <h2 id="switch">Switch/When/Else</h2> <p><strong>Switch</strong> statements in JavaScript are a bit awkward. You need to remember to <strong>break</strong> at the end of every <strong>case</strong> statement to avoid accidentally falling through to the default case. CoffeeScript prevents accidental fall-through, and can convert the <code>switch</code> into a returnable, assignable expression. The format is: <code>switch</code> condition, <code>when</code> clauses, <code>else</code> the default case.</p> <p>As in Ruby, <strong>switch</strong> statements in CoffeeScript can take multiple values for each <strong>when</strong> clause. If any of the values match, the clause runs.</p> <div class="code">
<pre data-language="coffeescript">switch day
  when "Mon" then go work
  when "Tue" then go relax
  when "Thu" then go iceFishing
  when "Fri", "Sat"
    if day is bingoDay
      go bingo
      go dancing
  when "Sun" then go church
  else go work
</pre>
<pre data-language="javascript">switch (day) {
  case "Mon":
    go(work);
    break;
  case "Tue":
    go(relax);
    break;
  case "Thu":
    go(iceFishing);
    break;
  case "Fri":
  case "Sat":
    if (day === bingoDay) {
      go(bingo);
      go(dancing);
    }
    break;
  case "Sun":
    go(church);
    break;
  default:
    go(work);
}
</pre>
</div>
<p>Switch statements can also be used without a control expression, turning them in to a cleaner alternative to if/else chains.</p> <div class="code">
<pre data-language="coffeescript">score = 76
grade = switch
  when score &lt; 60 then 'F'
  when score &lt; 70 then 'D'
  when score &lt; 80 then 'C'
  when score &lt; 90 then 'B'
  else 'A'
# grade == 'C'
</pre>
<pre data-language="javascript">var grade, score;

score = 76;

grade = (function() {
  switch (false) {
    case !(score &lt; 60):
      return 'F';
    case !(score &lt; 70):
      return 'D';
    case !(score &lt; 80):
      return 'C';
    case !(score &lt; 90):
      return 'B';
    default:
      return 'A';
  }
})();
</pre>
</div>  <h2 id="try-catch">Try/Catch/Finally</h2> <p>Try-expressions have the same semantics as try-statements in JavaScript, though in CoffeeScript, you may omit <em>both</em> the catch and finally parts. The catch part may also omit the error parameter if it is not needed.</p> <div class="code">
<pre data-language="coffeescript">try
  allHellBreaksLoose()
  catsAndDogsLivingTogether()
catch error
  print error
finally
  cleanUp()
</pre>
<pre data-language="javascript">var error;

try {
  allHellBreaksLoose();
  catsAndDogsLivingTogether();
} catch (error1) {
  error = error1;
  print(error);
} finally {
  cleanUp();
}
</pre>
</div>  <h2 id="comparisons">Chained Comparisons</h2> <p>CoffeeScript borrows <a href="https://docs.python.org/3/reference/expressions.html#not-in" target="_blank">chained comparisons</a> from Python — making it easy to test if a value falls within a certain range.</p> <div class="code">
<pre data-language="coffeescript">cholesterol = 127

healthy = 200 &gt; cholesterol &gt; 60
</pre>
<pre data-language="javascript">var cholesterol, healthy;

cholesterol = 127;

healthy = (200 &gt; cholesterol &amp;&amp; cholesterol &gt; 60);
</pre>
</div>  <h2 id="strings">String Interpolation, Block Strings, and Block Comments</h2> <p>Ruby-style string interpolation is included in CoffeeScript. Double-quoted strings allow for interpolated values, using <code>#{ … }</code>, and single-quoted strings are literal. You may even use interpolation in object keys.</p> <div class="code">
<pre data-language="coffeescript">author = "Wittgenstein"
quote  = "A picture is a fact. -- #{ author }"

sentence = "#{ 22 / 7 } is a decent approximation of π"
</pre>
<pre data-language="javascript">var author, quote, sentence;

author = "Wittgenstein";

quote = "A picture is a fact. -- " + author;

sentence = (22 / 7) + " is a decent approximation of π";
</pre>
</div>
<p>Multiline strings are allowed in CoffeeScript. Lines are joined by a single space unless they end with a backslash. Indentation is ignored.</p> <div class="code">
<pre data-language="coffeescript">mobyDick = "Call me Ishmael. Some years ago --
  never mind how long precisely -- having little
  or no money in my purse, and nothing particular
  to interest me on shore, I thought I would sail
  about a little and see the watery part of the
  world..."
</pre>
<pre data-language="javascript">var mobyDick;

mobyDick = "Call me Ishmael. Some years ago -- never mind how long precisely -- having little or no money in my purse, and nothing particular to interest me on shore, I thought I would sail about a little and see the watery part of the world...";
</pre>
</div>
<p>Block strings can be used to hold formatted or indentation-sensitive text (or, if you just don’t feel like escaping quotes and apostrophes). The indentation level that begins the block is maintained throughout, so you can keep it all aligned with the body of your code.</p> <div class="code">
<pre data-language="coffeescript">html = """
       &lt;strong&gt;
         cup of coffeescript
       &lt;/strong&gt;
       """
</pre>
<pre data-language="javascript">var html;

html = "&lt;strong&gt;\n  cup of coffeescript\n&lt;/strong&gt;";
</pre>
</div>
<p>Double-quoted block strings, like other double-quoted strings, allow interpolation.</p> <p>Sometimes you’d like to pass a block comment through to the generated JavaScript. For example, when you need to embed a licensing header at the top of a file. Block comments, which mirror the syntax for block strings, are preserved in the generated code.</p> <div class="code">
<pre data-language="coffeescript">###
SkinnyMochaHalfCaffScript Compiler v1.0
Released under the MIT License
###
</pre>
<pre data-language="javascript">
/*
SkinnyMochaHalfCaffScript Compiler v1.0
Released under the MIT License
 */

</pre>
</div>  <h2 id="tagged-template-literals">Tagged Template Literals</h2> <p>CoffeeScript supports <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals" target="_blank">ES2015 tagged template literals</a>, which enable customized string interpolation. If you immediately prefix a string with a function name (no space between the two), CoffeeScript will output this “function plus string” combination as an ES2015 tagged template literal, which will <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals" target="_blank">behave accordingly</a>: the function is called, with the parameters being the input text and expression parts that make up the interpolated string. The function can then assemble these parts into an output string, providing custom string interpolation.</p> <p>Be aware that the CoffeeScript compiler is outputting ES2015 syntax for this feature, so your target JavaScript runtime(s) must support this syntax for your code to work; or you could use tools like <a href="http://babeljs.io/" target="_blank">Babel</a> or <a href="https://github.com/google/traceur-compiler" target="_blank">Traceur Compiler</a> to convert this ES2015 syntax into compatible JavaScript.</p> <div class="code">
<pre data-language="coffeescript">upperCaseExpr = (textParts, expressions...) -&gt;
  textParts.reduce (text, textPart, i) -&gt;
    text + expressions[i - 1].toUpperCase() + textPart

greet = (name, adjective) -&gt;
  upperCaseExpr"""
               Hi #{name}. You look #{adjective}!
               """
</pre>
<pre data-language="javascript">var greet, upperCaseExpr,
  slice = [].slice;

upperCaseExpr = function() {
  var expressions, textParts;
  textParts = arguments[0], expressions = 2 &lt;= arguments.length ? slice.call(arguments, 1) : [];
  return textParts.reduce(function(text, textPart, i) {
    return text + expressions[i - 1].toUpperCase() + textPart;
  });
};

greet = function(name, adjective) {
  return upperCaseExpr`Hi ${name}. You look ${adjective}!`;
};
</pre>
</div>  <h2 id="regexes">Block Regular Expressions</h2> <p>Similar to block strings and comments, CoffeeScript supports block regexes — extended regular expressions that ignore internal whitespace and can contain comments and interpolation. Modeled after Perl’s <code>/x</code> modifier, CoffeeScript’s block regexes are delimited by <code>///</code> and go a long way towards making complex regular expressions readable. To quote from the CoffeeScript source:</p> <div class="code">
<pre data-language="coffeescript">OPERATOR = /// ^ (
  ?: [-=]&gt;             # function
   | [-+*/%&lt;&gt;&amp;|^!?=]=  # compound assign / compare
   | &gt;&gt;&gt;=?             # zero-fill right shift
   | ([-+:])\1         # doubles
   | ([&amp;|&lt;&gt;])\2=?      # logic / shift
   | \?\.              # soak access
   | \.{2,3}           # range or splat
) ///
</pre>
<pre data-language="javascript">var OPERATOR;

OPERATOR = /^(?:[-=]&gt;|[-+*\/%&lt;&gt;&amp;|^!?=]=|&gt;&gt;&gt;=?|([-+:])\1|([&amp;|&lt;&gt;])\2=?|\?\.|\.{2,3})/;
</pre>
</div>  <h2 id="modules">Modules</h2> <p>ES2015 modules are supported in CoffeeScript, with very similar <code>import</code> and <code>export</code> syntax:</p> <div class="code">
<pre data-language="coffeescript">import 'local-file.coffee'
import 'coffeescript'

import _ from 'underscore'
import * as underscore from 'underscore'

import { now } from 'underscore'
import { now as currentTimestamp } from 'underscore'
import { first, last } from 'underscore'
import utilityBelt, { each } from 'underscore'

export default Math
export square = (x) -&gt; x * x
export class Mathematics
  least: (x, y) -&gt; if x &lt; y then x else y

export { sqrt }
export { sqrt as squareRoot }
export { Mathematics as default, sqrt as squareRoot }

export * from 'underscore'
export { max, min } from 'underscore'
</pre>
<pre data-language="javascript">import 'local-file.coffee';

import 'coffeescript';

import _ from 'underscore';

import * as underscore from 'underscore';

import {
  now
} from 'underscore';

import {
  now as currentTimestamp
} from 'underscore';

import {
  first,
  last
} from 'underscore';

import utilityBelt, {
  each
} from 'underscore';

export default Math;

export var square = function(x) {
  return x * x;
};

export var Mathematics = (function() {
  function Mathematics() {}

  Mathematics.prototype.least = function(x, y) {
    if (x &lt; y) {
      return x;
    } else {
      return y;
    }
  };

  return Mathematics;

})();

export {
  sqrt
};

export {
  sqrt as squareRoot
};

export {
  Mathematics as default,
  sqrt as squareRoot
};

export * from 'underscore';

export {
  max,
  min
} from 'underscore';
</pre>
</div> <p id="modules-note">Note that the CoffeeScript compiler <strong>does not resolve modules</strong>; writing an <code>import</code> or <code>export</code> statement in CoffeeScript will produce an <code>import</code> or <code>export</code> statement in the resulting output. It is your responsibility attach another transpiler, such as <a href="https://github.com/google/traceur-compiler" target="_blank">Traceur Compiler</a>, <a href="http://babeljs.io/" target="_blank">Babel</a> or <a href="https://github.com/rollup/rollup" target="_blank">Rollup</a>, to convert this ES2015 syntax into code that will work in your target runtimes.</p> <p>Also note that any file with an <code>import</code> or <code>export</code> statement will be output without a <a href="#lexical-scope">top-level function safety wrapper</a>; in other words, importing or exporting modules will automatically trigger <a href="#usage">bare</a> mode for that file. This is because per the ES2015 spec, <code>import</code> or <code>export</code> statements must occur at the topmost scope.</p>  <h2 id="cake">Cake, and Cakefiles</h2> <p>CoffeeScript includes a (very) simple build system similar to <a href="http://www.gnu.org/software/make/" target="_blank">Make</a> and <a href="http://rake.rubyforge.org/" target="_blank">Rake</a>. Naturally, it’s called Cake, and is used for the tasks that build and test the CoffeeScript language itself. Tasks are defined in a file named <code>Cakefile</code>, and can be invoked by running <code>cake [task]</code> from within the directory. To print a list of all the tasks and options, just type <code>cake</code>.</p> <p>Task definitions are written in CoffeeScript, so you can put arbitrary code in your Cakefile. Define a task with a name, a long description, and the function to invoke when the task is run. If your task takes a command-line option, you can define the option with short and long flags, and it will be made available in the <code>options</code> object. Here’s a task that uses the Node.js API to rebuild CoffeeScript’s parser:</p> <div class="code">
<pre data-language="coffeescript">fs = require 'fs'

option '-o', '--output [DIR]', 'directory for compiled code'

task 'build:parser', 'rebuild the Jison parser', (options) -&gt;
  require 'jison'
  code = require('./lib/grammar').parser.generate()
  dir  = options.output or 'lib'
  fs.writeFile "#{dir}/parser.js", code
</pre>
<pre data-language="javascript">var fs;

fs = require('fs');

option('-o', '--output [DIR]', 'directory for compiled code');

task('build:parser', 'rebuild the Jison parser', function(options) {
  var code, dir;
  require('jison');
  code = require('./lib/grammar').parser.generate();
  dir = options.output || 'lib';
  return fs.writeFile(dir + "/parser.js", code);
});
</pre>
</div>
<p>If you need to invoke one task before another — for example, running <code>build</code> before <code>test</code>, you can use the <code>invoke</code> function: <code>invoke 'build'</code>. Cake tasks are a minimal way to expose your CoffeeScript functions to the command line, so <a href="http://coffeescript.org/v1/annotated-source/cake.html" target="_blank">don’t expect any fanciness built-in</a>. If you need dependencies, or async callbacks, it’s best to put them in your code itself — not the cake task.</p>  <h2 id="source-maps">Source Maps</h2> <p>CoffeeScript 1.6.1 and above include support for generating source maps, a way to tell your JavaScript engine what part of your CoffeeScript program matches up with the code being evaluated. Browsers that support it can automatically use source maps to show your original source code in the debugger. To generate source maps alongside your JavaScript files, pass the <code>--map</code> or <code>-m</code> flag to the compiler.</p> <p>For a full introduction to source maps, how they work, and how to hook them up in your browser, read the <a href="https://www.html5rocks.com/en/tutorials/developertools/sourcemaps/" target="_blank">HTML5 Tutorial</a>.</p>  <h2 id="scripts">“text/coffeescript” Script Tags</h2> <p>While it’s not recommended for serious use, CoffeeScripts may be included directly within the browser using <code>&lt;script type="text/coffeescript"&gt;</code> tags. The source includes a compressed and minified version of the compiler (<a href="http://coffeescript.org/v1/browser-compiler/coffee-script.js" target="_blank">Download current version here, 51k when gzipped</a>) as <code>v1/browser-compiler/coffee-script.js</code>. Include this file on a page with inline CoffeeScript tags, and it will compile and evaluate them in order.</p> <p>In fact, the little bit of glue script that runs “Try CoffeeScript” above, as well as the jQuery for the menu, is implemented in just this way. View source and look at the bottom of the page to see the example. Including the script also gives you access to <code>CoffeeScript.compile()</code> so you can pop open Firebug and try compiling some strings.</p> <p>The usual caveats about CoffeeScript apply — your inline scripts will run within a closure wrapper, so if you want to expose global variables or functions, attach them to the <code>window</code> object.</p>
<div class="_attribution">
  <p class="_attribution-p">
    © 2009–2017 Jeremy Ashkenas<br>Licensed under the MIT License.<br>
    <a href="http://coffeescript.org/" class="_attribution-link" target="_blank">http://coffeescript.org/</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
