
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Crypto&#47;x509 - Go - W3cubDocs</title>
  
  <meta name="description" content=" Package x509 parses X.509-encoded keys and certificates. ">
  <meta name="keywords" content="package, x, crypto, -, go">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/go/crypto/x509/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-e0f881b0fce8cbe96f33dadc355b7159d5d2912911231446d60eb8f9caffa802.css">
  <script type="text/javascript" src="/assets/application-8fc46316434047265cd383f02b8e7f434ed7dec4a59f920dd633deef8d488d1b.js"></script>
  <script src="/json/go.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/go/" class="_nav-link" title="" style="margin-left:0;">Go</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _go">
				
<h1> Package x509  </h1>     <ul id="short-nav">
<li><code>import "crypto/x509"</code></li>
<li><a href="#pkg-overview" class="overviewLink">Overview</a></li>
<li><a href="#pkg-index" class="indexLink">Index</a></li>
<li><a href="#pkg-examples" class="examplesLink">Examples</a></li>
<li><a href="#pkg-subdirectories">Subdirectories</a></li>
</ul>     <h2>Overview </h2> <p> Package x509 parses X.509-encoded keys and certificates. </p> <p> On UNIX systems the environment variables SSL_CERT_FILE and SSL_CERT_DIR can be used to override the system default locations for the SSL certificate file and SSL certificate files directory, respectively. </p>      <h2>Index </h2>  <ul id="manual-nav">
<li><a href="#pkg-variables">Variables</a></li>
<li><a href="#CreateCertificate">func CreateCertificate(rand io.Reader, template, parent *Certificate, pub, priv interface{}) (cert []byte, err error)</a></li>
<li><a href="#CreateCertificateRequest">func CreateCertificateRequest(rand io.Reader, template *CertificateRequest, priv interface{}) (csr []byte, err error)</a></li>
<li><a href="#DecryptPEMBlock">func DecryptPEMBlock(b *pem.Block, password []byte) ([]byte, error)</a></li>
<li><a href="#EncryptPEMBlock">func EncryptPEMBlock(rand io.Reader, blockType string, data, password []byte, alg PEMCipher) (*pem.Block, error)</a></li>
<li><a href="#IsEncryptedPEMBlock">func IsEncryptedPEMBlock(b *pem.Block) bool</a></li>
<li><a href="#MarshalECPrivateKey">func MarshalECPrivateKey(key *ecdsa.PrivateKey) ([]byte, error)</a></li>
<li><a href="#MarshalPKCS1PrivateKey">func MarshalPKCS1PrivateKey(key *rsa.PrivateKey) []byte</a></li>
<li><a href="#MarshalPKIXPublicKey">func MarshalPKIXPublicKey(pub interface{}) ([]byte, error)</a></li>
<li><a href="#ParseCRL">func ParseCRL(crlBytes []byte) (*pkix.CertificateList, error)</a></li>
<li><a href="#ParseCertificates">func ParseCertificates(asn1Data []byte) ([]*Certificate, error)</a></li>
<li><a href="#ParseDERCRL">func ParseDERCRL(derBytes []byte) (*pkix.CertificateList, error)</a></li>
<li><a href="#ParseECPrivateKey">func ParseECPrivateKey(der []byte) (*ecdsa.PrivateKey, error)</a></li>
<li><a href="#ParsePKCS1PrivateKey">func ParsePKCS1PrivateKey(der []byte) (*rsa.PrivateKey, error)</a></li>
<li><a href="#ParsePKCS8PrivateKey">func ParsePKCS8PrivateKey(der []byte) (key interface{}, err error)</a></li>
<li><a href="#ParsePKIXPublicKey">func ParsePKIXPublicKey(derBytes []byte) (pub interface{}, err error)</a></li>
<li><a href="#CertPool">type CertPool</a></li>
<li> <a href="#NewCertPool">func NewCertPool() *CertPool</a>
</li>
<li> <a href="#SystemCertPool">func SystemCertPool() (*CertPool, error)</a>
</li>
<li> <a href="#CertPool.AddCert">func (s *CertPool) AddCert(cert *Certificate)</a>
</li>
<li> <a href="#CertPool.AppendCertsFromPEM">func (s *CertPool) AppendCertsFromPEM(pemCerts []byte) (ok bool)</a>
</li>
<li> <a href="#CertPool.Subjects">func (s *CertPool) Subjects() [][]byte</a>
</li>
<li><a href="#Certificate">type Certificate</a></li>
<li> <a href="#ParseCertificate">func ParseCertificate(asn1Data []byte) (*Certificate, error)</a>
</li>
<li> <a href="#Certificate.CheckCRLSignature">func (c *Certificate) CheckCRLSignature(crl *pkix.CertificateList) error</a>
</li>
<li> <a href="#Certificate.CheckSignature">func (c *Certificate) CheckSignature(algo SignatureAlgorithm, signed, signature []byte) error</a>
</li>
<li> <a href="#Certificate.CheckSignatureFrom">func (c *Certificate) CheckSignatureFrom(parent *Certificate) error</a>
</li>
<li> <a href="#Certificate.CreateCRL">func (c *Certificate) CreateCRL(rand io.Reader, priv interface{}, revokedCerts []pkix.RevokedCertificate, now, expiry time.Time) (crlBytes []byte, err error)</a>
</li>
<li> <a href="#Certificate.Equal">func (c *Certificate) Equal(other *Certificate) bool</a>
</li>
<li> <a href="#Certificate.Verify">func (c *Certificate) Verify(opts VerifyOptions) (chains [][]*Certificate, err error)</a>
</li>
<li> <a href="#Certificate.VerifyHostname">func (c *Certificate) VerifyHostname(h string) error</a>
</li>
<li><a href="#CertificateInvalidError">type CertificateInvalidError</a></li>
<li> <a href="#CertificateInvalidError.Error">func (e CertificateInvalidError) Error() string</a>
</li>
<li><a href="#CertificateRequest">type CertificateRequest</a></li>
<li> <a href="#ParseCertificateRequest">func ParseCertificateRequest(asn1Data []byte) (*CertificateRequest, error)</a>
</li>
<li> <a href="#CertificateRequest.CheckSignature">func (c *CertificateRequest) CheckSignature() error</a>
</li>
<li><a href="#ConstraintViolationError">type ConstraintViolationError</a></li>
<li> <a href="#ConstraintViolationError.Error">func (ConstraintViolationError) Error() string</a>
</li>
<li><a href="#ExtKeyUsage">type ExtKeyUsage</a></li>
<li><a href="#HostnameError">type HostnameError</a></li>
<li> <a href="#HostnameError.Error">func (h HostnameError) Error() string</a>
</li>
<li><a href="#InsecureAlgorithmError">type InsecureAlgorithmError</a></li>
<li> <a href="#InsecureAlgorithmError.Error">func (e InsecureAlgorithmError) Error() string</a>
</li>
<li><a href="#InvalidReason">type InvalidReason</a></li>
<li><a href="#KeyUsage">type KeyUsage</a></li>
<li><a href="#PEMCipher">type PEMCipher</a></li>
<li><a href="#PublicKeyAlgorithm">type PublicKeyAlgorithm</a></li>
<li><a href="#SignatureAlgorithm">type SignatureAlgorithm</a></li>
<li> <a href="#SignatureAlgorithm.String">func (algo SignatureAlgorithm) String() string</a>
</li>
<li><a href="#SystemRootsError">type SystemRootsError</a></li>
<li> <a href="#SystemRootsError.Error">func (se SystemRootsError) Error() string</a>
</li>
<li><a href="#UnhandledCriticalExtension">type UnhandledCriticalExtension</a></li>
<li> <a href="#UnhandledCriticalExtension.Error">func (h UnhandledCriticalExtension) Error() string</a>
</li>
<li><a href="#UnknownAuthorityError">type UnknownAuthorityError</a></li>
<li> <a href="#UnknownAuthorityError.Error">func (e UnknownAuthorityError) Error() string</a>
</li>
<li><a href="#VerifyOptions">type VerifyOptions</a></li>
</ul> <div id="pkg-examples"> <h3>Examples</h3> <dl> <dd><a class="exampleLink" href="#example_Certificate_Verify">Certificate.Verify</a></dd> <dd><a class="exampleLink" href="#example_ParsePKIXPublicKey">ParsePKIXPublicKey</a></dd> </dl> </div> <h3>Package files</h3> <p>  <a href="https://golang.org/src/crypto/x509/cert_pool.go" target="_blank">cert_pool.go</a> <a href="https://golang.org/src/crypto/x509/pem_decrypt.go" target="_blank">pem_decrypt.go</a> <a href="https://golang.org/src/crypto/x509/pkcs1.go" target="_blank">pkcs1.go</a> <a href="https://golang.org/src/crypto/x509/pkcs8.go" target="_blank">pkcs8.go</a> <a href="https://golang.org/src/crypto/x509/root.go" target="_blank">root.go</a> <a href="https://golang.org/src/crypto/x509/root_linux.go" target="_blank">root_linux.go</a> <a href="https://golang.org/src/crypto/x509/root_unix.go" target="_blank">root_unix.go</a> <a href="https://golang.org/src/crypto/x509/sec1.go" target="_blank">sec1.go</a> <a href="https://golang.org/src/crypto/x509/verify.go" target="_blank">verify.go</a> <a href="https://golang.org/src/crypto/x509/x509.go" target="_blank">x509.go</a>  </p>     <h2 id="pkg-variables">Variables</h2> <p> ErrUnsupportedAlgorithm results from attempting to perform an operation that involves algorithms that are not currently implemented. </p> <pre data-language="go">var ErrUnsupportedAlgorithm = errors.New("x509: cannot verify signature: algorithm unimplemented")</pre> <p> IncorrectPasswordError is returned when an incorrect password is detected. </p> <pre data-language="go">var IncorrectPasswordError = errors.New("x509: decryption password incorrect")</pre> <h2 id="CreateCertificate">func CreateCertificate<a href="https://golang.org/src/crypto/x509/x509.go?s=56205:56322#L1744" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func CreateCertificate(rand io.Reader, template, parent *Certificate, pub, priv interface{}) (cert []byte, err error)</pre> <p> CreateCertificate creates a new certificate based on a template. The following members of template are used: AuthorityKeyId, BasicConstraintsValid, DNSNames, ExcludedDNSDomains, ExtKeyUsage, IsCA, KeyUsage, MaxPathLen, MaxPathLenZero, NotAfter, NotBefore, PermittedDNSDomains, PermittedDNSDomainsCritical, SerialNumber, SignatureAlgorithm, Subject, SubjectKeyId, and UnknownExtKeyUsage. </p> <p> The certificate is signed by parent. If parent is equal to template then the certificate is self-signed. The parameter pub is the public key of the signee and priv is the private key of the signer. </p> <p> The returned slice is the certificate in DER encoding. </p> <p> All keys types that are implemented via crypto.Signer are supported (This includes *rsa.PublicKey and *ecdsa.PublicKey.) </p> <p> The AuthorityKeyId will be taken from the SubjectKeyId of parent, if any, unless the resulting certificate is self-signed. Otherwise the value from template will be used. </p> <h2 id="CreateCertificateRequest">func CreateCertificateRequest<a href="https://golang.org/src/crypto/x509/x509.go?s=65922:66039#L2059" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func CreateCertificateRequest(rand io.Reader, template *CertificateRequest, priv interface{}) (csr []byte, err error)</pre> <p> CreateCertificateRequest creates a new certificate request based on a template. The following members of template are used: Attributes, DNSNames, EmailAddresses, ExtraExtensions, IPAddresses, SignatureAlgorithm, and Subject. The private key is the private key of the signer. </p> <p> The returned slice is the certificate request in DER encoding. </p> <p> All keys types that are implemented via crypto.Signer are supported (This includes *rsa.PublicKey and *ecdsa.PublicKey.) </p> <h2 id="DecryptPEMBlock">func DecryptPEMBlock<a href="https://golang.org/src/crypto/x509/pem_decrypt.go?s=3143:3210#L105" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func DecryptPEMBlock(b *pem.Block, password []byte) ([]byte, error)</pre> <p> DecryptPEMBlock takes a password encrypted PEM block and the password used to encrypt it and returns a slice of decrypted DER encoded bytes. It inspects the DEK-Info header to determine the algorithm used for decryption. If no DEK-Info header is present, an error is returned. If an incorrect password is detected an IncorrectPasswordError is returned. Because of deficiencies in the encrypted-PEM format, it's not always possible to detect an incorrect password. In these cases no error will be returned but the decrypted DER bytes will be random noise. </p> <h2 id="EncryptPEMBlock">func EncryptPEMBlock<a href="https://golang.org/src/crypto/x509/pem_decrypt.go?s=5072:5184#L173" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func EncryptPEMBlock(rand io.Reader, blockType string, data, password []byte, alg PEMCipher) (*pem.Block, error)</pre> <p> EncryptPEMBlock returns a PEM block of the specified type holding the given DER-encoded data encrypted with the specified algorithm and password. </p> <h2 id="IsEncryptedPEMBlock">func IsEncryptedPEMBlock<a href="https://golang.org/src/crypto/x509/pem_decrypt.go?s=2314:2357#L89" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func IsEncryptedPEMBlock(b *pem.Block) bool</pre> <p> IsEncryptedPEMBlock returns if the PEM block is password encrypted. </p> <h2 id="MarshalECPrivateKey">func MarshalECPrivateKey<a href="https://golang.org/src/crypto/x509/sec1.go?s=1002:1065#L27" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func MarshalECPrivateKey(key *ecdsa.PrivateKey) ([]byte, error)</pre> <p> MarshalECPrivateKey marshals an EC private key into ASN.1, DER format. </p> <h2 id="MarshalPKCS1PrivateKey">func MarshalPKCS1PrivateKey<a href="https://golang.org/src/crypto/x509/pkcs1.go?s=2239:2294#L82" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func MarshalPKCS1PrivateKey(key *rsa.PrivateKey) []byte</pre> <p> MarshalPKCS1PrivateKey converts a private key to ASN.1 DER encoded form. </p> <h2 id="MarshalPKIXPublicKey">func MarshalPKIXPublicKey<a href="https://golang.org/src/crypto/x509/x509.go?s=2926:2984#L88" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func MarshalPKIXPublicKey(pub interface{}) ([]byte, error)</pre> <p> MarshalPKIXPublicKey serialises a public key to DER-encoded PKIX format. </p> <h2 id="ParseCRL">func ParseCRL<a href="https://golang.org/src/crypto/x509/x509.go?s=58871:58932#L1841" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func ParseCRL(crlBytes []byte) (*pkix.CertificateList, error)</pre> <p> ParseCRL parses a CRL from the given bytes. It's often the case that PEM encoded CRLs will appear where they should be DER encoded, so this function will transparently handle PEM encoding as long as there isn't any leading garbage. </p> <h2 id="ParseCertificates">func ParseCertificates<a href="https://golang.org/src/crypto/x509/x509.go?s=44925:44988#L1364" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func ParseCertificates(asn1Data []byte) ([]*Certificate, error)</pre> <p> ParseCertificates parses one or more certificates from the given ASN.1 DER data. The certificates must be concatenated with no intermediate padding. </p> <h2 id="ParseDERCRL">func ParseDERCRL<a href="https://golang.org/src/crypto/x509/x509.go?s=59189:59253#L1852" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func ParseDERCRL(derBytes []byte) (*pkix.CertificateList, error)</pre> <p> ParseDERCRL parses a DER encoded CRL from the given bytes. </p> <h2 id="ParseECPrivateKey">func ParseECPrivateKey<a href="https://golang.org/src/crypto/x509/sec1.go?s=825:886#L22" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func ParseECPrivateKey(der []byte) (*ecdsa.PrivateKey, error)</pre> <p> ParseECPrivateKey parses an ASN.1 Elliptic Curve Private Key Structure. </p> <h2 id="ParsePKCS1PrivateKey">func ParsePKCS1PrivateKey<a href="https://golang.org/src/crypto/x509/pkcs1.go?s=1067:1129#L35" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func ParsePKCS1PrivateKey(der []byte) (*rsa.PrivateKey, error)</pre> <p> ParsePKCS1PrivateKey returns an RSA private key from its ASN.1 PKCS#1 DER encoded form. </p> <h2 id="ParsePKCS8PrivateKey">func ParsePKCS8PrivateKey<a href="https://golang.org/src/crypto/x509/pkcs8.go?s=580:646#L16" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func ParsePKCS8PrivateKey(der []byte) (key interface{}, err error)</pre> <p> ParsePKCS8PrivateKey parses an unencrypted, PKCS#8 private key. See RFC 5208. </p> <h2 id="ParsePKIXPublicKey">func ParsePKIXPublicKey<a href="https://golang.org/src/crypto/x509/x509.go?s=1224:1293#L39" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">func ParsePKIXPublicKey(derBytes []byte) (pub interface{}, err error)</pre> <p> ParsePKIXPublicKey parses a DER encoded public key. These values are typically found in PEM blocks with "BEGIN PUBLIC KEY". </p> <p> Supported key types include RSA, DSA, and ECDSA. Unknown key types result in an error. </p> <p> On success, pub will be of type *rsa.PublicKey, *dsa.PublicKey, or *ecdsa.PublicKey. </p>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"crypto/dsa"
	"crypto/ecdsa"
	"crypto/rsa"
	"crypto/x509"
	"encoding/pem"
	"fmt"
)

func main() {
	const pubPEM = `
-----BEGIN PUBLIC KEY-----
MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAlRuRnThUjU8/prwYxbty
WPT9pURI3lbsKMiB6Fn/VHOKE13p4D8xgOCADpdRagdT6n4etr9atzDKUSvpMtR3
CP5noNc97WiNCggBjVWhs7szEe8ugyqF23XwpHQ6uV1LKH50m92MbOWfCtjU9p/x
qhNpQQ1AZhqNy5Gevap5k8XzRmjSldNAFZMY7Yv3Gi+nyCwGwpVtBUwhuLzgNFK/
yDtw2WcWmUU7NuC8Q6MWvPebxVtCfVp/iQU6q60yyt6aGOBkhAX0LpKAEhKidixY
nP9PNVBvxgu3XZ4P36gZV6+ummKdBVnc3NqwBLu5+CcdRdusmHPHd5pHf4/38Z3/
6qU2a/fPvWzceVTEgZ47QjFMTCTmCwNt29cvi7zZeQzjtwQgn4ipN9NibRH/Ax/q
TbIzHfrJ1xa2RteWSdFjwtxi9C20HUkjXSeI4YlzQMH0fPX6KCE7aVePTOnB69I/
a9/q96DiXZajwlpq3wFctrs1oXqBp5DVrCIj8hU2wNgB7LtQ1mCtsYz//heai0K9
PhE4X6hiE0YmeAZjR0uHl8M/5aW9xCoJ72+12kKpWAa0SFRWLy6FejNYCYpkupVJ
yecLk/4L1W0l6jQQZnWErXZYe0PNFcmwGXy1Rep83kfBRNKRy5tvocalLlwXLdUk
AIU+2GKjyT3iMuzZxxFxPFMCAwEAAQ==
-----END PUBLIC KEY-----`

	block, _ := pem.Decode([]byte(pubPEM))
	if block == nil {
		panic("failed to parse PEM block containing the public key")
	}

	pub, err := x509.ParsePKIXPublicKey(block.Bytes)
	if err != nil {
		panic("failed to parse DER encoded public key: " + err.Error())
	}

	switch pub := pub.(type) {
	case *rsa.PublicKey:
		fmt.Println("pub is of type RSA:", pub)
	case *dsa.PublicKey:
		fmt.Println("pub is of type DSA:", pub)
	case *ecdsa.PublicKey:
		fmt.Println("pub is of type ECDSA:", pub)
	default:
		panic("unknown type of public key")
	}
}
</pre>   <h2 id="CertPool">type CertPool<a href="https://golang.org/src/crypto/x509/cert_pool.go?s=261:382#L4" class="source" target="_blank">Source</a>  </h2> <p> CertPool is a set of certificates. </p> <pre data-language="go">type CertPool struct {
        // contains filtered or unexported fields
}</pre> <h3 id="NewCertPool">func NewCertPool<a href="https://golang.org/src/crypto/x509/cert_pool.go?s=430:458#L11" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func NewCertPool() *CertPool</pre> <p> NewCertPool returns a new, empty CertPool. </p> <h3 id="SystemCertPool">func SystemCertPool<a href="https://golang.org/src/crypto/x509/cert_pool.go?s=730:770#L22" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func SystemCertPool() (*CertPool, error)</pre> <p> SystemCertPool returns a copy of the system cert pool. </p> <p> Any mutations to the returned pool are not written to disk and do not affect any other pool. </p> <h3 id="CertPool.AddCert">func (*CertPool) AddCert<a href="https://golang.org/src/crypto/x509/cert_pool.go?s=1993:2038#L75" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (s *CertPool) AddCert(cert *Certificate)</pre> <p> AddCert adds a certificate to a pool. </p> <h3 id="CertPool.AppendCertsFromPEM">func (*CertPool) AppendCertsFromPEM<a href="https://golang.org/src/crypto/x509/cert_pool.go?s=2791:2855#L102" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (s *CertPool) AppendCertsFromPEM(pemCerts []byte) (ok bool)</pre> <p> AppendCertsFromPEM attempts to parse a series of PEM encoded certificates. It appends any certificates found to s and reports whether any certificates were successfully parsed. </p> <p> On many Linux systems, /etc/ssl/cert.pem will contain the system wide set of root CAs in a format suitable for this function. </p> <h3 id="CertPool.Subjects">func (*CertPool) Subjects<a href="https://golang.org/src/crypto/x509/cert_pool.go?s=3282:3320#L127" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (s *CertPool) Subjects() [][]byte</pre> <p> Subjects returns a list of the DER-encoded subjects of all of the certificates in the pool. </p> <h2 id="Certificate">type Certificate<a href="https://golang.org/src/crypto/x509/x509.go?s=19833:23432#L613" class="source" target="_blank">Source</a>  </h2> <p> A Certificate represents an X.509 certificate. </p> <pre data-language="go">type Certificate struct {
        Raw                     []byte // Complete ASN.1 DER content (certificate, signature algorithm and signature).
        RawTBSCertificate       []byte // Certificate part of raw ASN.1 DER content.
        RawSubjectPublicKeyInfo []byte // DER encoded SubjectPublicKeyInfo.
        RawSubject              []byte // DER encoded Subject
        RawIssuer               []byte // DER encoded Issuer

        Signature          []byte
        SignatureAlgorithm SignatureAlgorithm

        PublicKeyAlgorithm PublicKeyAlgorithm
        PublicKey          interface{}

        Version             int
        SerialNumber        *big.Int
        Issuer              pkix.Name
        Subject             pkix.Name
        NotBefore, NotAfter time.Time // Validity bounds.
        KeyUsage            KeyUsage

        // Extensions contains raw X.509 extensions. When parsing certificates,
        // this can be used to extract non-critical extensions that are not
        // parsed by this package. When marshaling certificates, the Extensions
        // field is ignored, see ExtraExtensions.
        Extensions []pkix.Extension

        // ExtraExtensions contains extensions to be copied, raw, into any
        // marshaled certificates. Values override any extensions that would
        // otherwise be produced based on the other fields. The ExtraExtensions
        // field is not populated when parsing certificates, see Extensions.
        ExtraExtensions []pkix.Extension

        // UnhandledCriticalExtensions contains a list of extension IDs that
        // were not (fully) processed when parsing. Verify will fail if this
        // slice is non-empty, unless verification is delegated to an OS
        // library which understands all the critical extensions.
        //
        // Users can access these extensions using Extensions and can remove
        // elements from this slice if they believe that they have been
        // handled.
        UnhandledCriticalExtensions []asn1.ObjectIdentifier

        ExtKeyUsage        []ExtKeyUsage           // Sequence of extended key usages.
        UnknownExtKeyUsage []asn1.ObjectIdentifier // Encountered extended key usages unknown to this package.

        // BasicConstraintsValid indicates whether IsCA, MaxPathLen,
        // and MaxPathLenZero are valid.
        BasicConstraintsValid bool
        IsCA                  bool

        // MaxPathLen and MaxPathLenZero indicate the presence and
        // value of the BasicConstraints' "pathLenConstraint".
        //
        // When parsing a certificate, a positive non-zero MaxPathLen
        // means that the field was specified, -1 means it was unset,
        // and MaxPathLenZero being true mean that the field was
        // explicitly set to zero. The case of MaxPathLen==0 with MaxPathLenZero==false
        // should be treated equivalent to -1 (unset).
        //
        // When generating a certificate, an unset pathLenConstraint
        // can be requested with either MaxPathLen == -1 or using the
        // zero value for both MaxPathLen and MaxPathLenZero.
        MaxPathLen int
        // MaxPathLenZero indicates that BasicConstraintsValid==true
        // and MaxPathLen==0 should be interpreted as an actual
        // maximum path length of zero. Otherwise, that combination is
        // interpreted as MaxPathLen not being set.
        MaxPathLenZero bool

        SubjectKeyId   []byte
        AuthorityKeyId []byte

        // RFC 5280, 4.2.2.1 (Authority Information Access)
        OCSPServer            []string
        IssuingCertificateURL []string

        // Subject Alternate Name values
        DNSNames       []string
        EmailAddresses []string
        IPAddresses    []net.IP

        // Name constraints
        PermittedDNSDomainsCritical bool // if true then the name constraints are marked critical.
        PermittedDNSDomains         []string
        ExcludedDNSDomains          []string

        // CRL Distribution Points
        CRLDistributionPoints []string

        PolicyIdentifiers []asn1.ObjectIdentifier
}</pre> <h3 id="ParseCertificate">func ParseCertificate<a href="https://golang.org/src/crypto/x509/x509.go?s=44489:44549#L1349" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func ParseCertificate(asn1Data []byte) (*Certificate, error)</pre> <p> ParseCertificate parses a single certificate from the given ASN.1 DER data. </p> <h3 id="Certificate.CheckCRLSignature">func (*Certificate) CheckCRLSignature<a href="https://golang.org/src/crypto/x509/x509.go?s=30282:30354#L884" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *Certificate) CheckCRLSignature(crl *pkix.CertificateList) error</pre> <p> CheckCRLSignature checks that the signature in crl is from c. </p> <h3 id="Certificate.CheckSignature">func (*Certificate) CheckSignature<a href="https://golang.org/src/crypto/x509/x509.go?s=27921:28014#L812" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *Certificate) CheckSignature(algo SignatureAlgorithm, signed, signature []byte) error</pre> <p> CheckSignature verifies that signature is a valid signature over signed from c's public key. </p> <h3 id="Certificate.CheckSignatureFrom">func (*Certificate) CheckSignatureFrom<a href="https://golang.org/src/crypto/x509/x509.go?s=26859:26926#L784" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *Certificate) CheckSignatureFrom(parent *Certificate) error</pre> <p> CheckSignatureFrom verifies that the signature on c is a valid signature from parent. </p> <h3 id="Certificate.CreateCRL">func (*Certificate) CreateCRL<a href="https://golang.org/src/crypto/x509/x509.go?s=59618:59775#L1864" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *Certificate) CreateCRL(rand io.Reader, priv interface{}, revokedCerts []pkix.RevokedCertificate, now, expiry time.Time) (crlBytes []byte, err error)</pre> <p> CreateCRL returns a DER encoded CRL, signed by this Certificate, that contains the given list of revoked certificates. </p> <h3 id="Certificate.Equal">func (*Certificate) Equal<a href="https://golang.org/src/crypto/x509/x509.go?s=24271:24323#L725" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *Certificate) Equal(other *Certificate) bool</pre> <h3 id="Certificate.Verify">func (*Certificate) Verify<a href="https://golang.org/src/crypto/x509/verify.go?s=8677:8762#L263" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *Certificate) Verify(opts VerifyOptions) (chains [][]*Certificate, err error)</pre> <p> Verify attempts to verify c by building one or more chains from c to a certificate in opts.Roots, using certificates in opts.Intermediates if needed. If successful, it returns one or more chains where the first element of the chain is c and the last element is from opts.Roots. </p> <p> If opts.Roots is nil and system roots are unavailable the returned error will be of type SystemRootsError. </p> <p> WARNING: this doesn't do any revocation checking. </p>    <h4> <span class="text">Example</span>
</h4> <pre class="play" data-language="go">package main

import (
	"crypto/x509"
	"encoding/pem"
)

func main() {
	// Verifying with a custom list of root certificates.

	const rootPEM = `
-----BEGIN CERTIFICATE-----
MIIEBDCCAuygAwIBAgIDAjppMA0GCSqGSIb3DQEBBQUAMEIxCzAJBgNVBAYTAlVT
MRYwFAYDVQQKEw1HZW9UcnVzdCBJbmMuMRswGQYDVQQDExJHZW9UcnVzdCBHbG9i
YWwgQ0EwHhcNMTMwNDA1MTUxNTU1WhcNMTUwNDA0MTUxNTU1WjBJMQswCQYDVQQG
EwJVUzETMBEGA1UEChMKR29vZ2xlIEluYzElMCMGA1UEAxMcR29vZ2xlIEludGVy
bmV0IEF1dGhvcml0eSBHMjCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEB
AJwqBHdc2FCROgajguDYUEi8iT/xGXAaiEZ+4I/F8YnOIe5a/mENtzJEiaB0C1NP
VaTOgmKV7utZX8bhBYASxF6UP7xbSDj0U/ck5vuR6RXEz/RTDfRK/J9U3n2+oGtv
h8DQUB8oMANA2ghzUWx//zo8pzcGjr1LEQTrfSTe5vn8MXH7lNVg8y5Kr0LSy+rE
ahqyzFPdFUuLH8gZYR/Nnag+YyuENWllhMgZxUYi+FOVvuOAShDGKuy6lyARxzmZ
EASg8GF6lSWMTlJ14rbtCMoU/M4iarNOz0YDl5cDfsCx3nuvRTPPuj5xt970JSXC
DTWJnZ37DhF5iR43xa+OcmkCAwEAAaOB+zCB+DAfBgNVHSMEGDAWgBTAephojYn7
qwVkDBF9qn1luMrMTjAdBgNVHQ4EFgQUSt0GFhu89mi1dvWBtrtiGrpagS8wEgYD
VR0TAQH/BAgwBgEB/wIBADAOBgNVHQ8BAf8EBAMCAQYwOgYDVR0fBDMwMTAvoC2g
K4YpaHR0cDovL2NybC5nZW90cnVzdC5jb20vY3Jscy9ndGdsb2JhbC5jcmwwPQYI
KwYBBQUHAQEEMTAvMC0GCCsGAQUFBzABhiFodHRwOi8vZ3RnbG9iYWwtb2NzcC5n
ZW90cnVzdC5jb20wFwYDVR0gBBAwDjAMBgorBgEEAdZ5AgUBMA0GCSqGSIb3DQEB
BQUAA4IBAQA21waAESetKhSbOHezI6B1WLuxfoNCunLaHtiONgaX4PCVOzf9G0JY
/iLIa704XtE7JW4S615ndkZAkNoUyHgN7ZVm2o6Gb4ChulYylYbc3GrKBIxbf/a/
zG+FA1jDaFETzf3I93k9mTXwVqO94FntT0QJo544evZG0R0SnU++0ED8Vf4GXjza
HFa9llF7b1cq26KqltyMdMKVvvBulRP/F/A8rLIQjcxz++iPAsbw+zOzlTvjwsto
WHPbqCRiOwY1nQ2pM714A5AuTHhdUDqB1O6gyHA43LL5Z/qHQF1hwFGPa4NrzQU6
yuGnBXj8ytqU0CwIPX4WecigUCAkVDNx
-----END CERTIFICATE-----`

	const certPEM = `
-----BEGIN CERTIFICATE-----
MIIDujCCAqKgAwIBAgIIE31FZVaPXTUwDQYJKoZIhvcNAQEFBQAwSTELMAkGA1UE
BhMCVVMxEzARBgNVBAoTCkdvb2dsZSBJbmMxJTAjBgNVBAMTHEdvb2dsZSBJbnRl
cm5ldCBBdXRob3JpdHkgRzIwHhcNMTQwMTI5MTMyNzQzWhcNMTQwNTI5MDAwMDAw
WjBpMQswCQYDVQQGEwJVUzETMBEGA1UECAwKQ2FsaWZvcm5pYTEWMBQGA1UEBwwN
TW91bnRhaW4gVmlldzETMBEGA1UECgwKR29vZ2xlIEluYzEYMBYGA1UEAwwPbWFp
bC5nb29nbGUuY29tMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEfRrObuSW5T7q
5CnSEqefEmtH4CCv6+5EckuriNr1CjfVvqzwfAhopXkLrq45EQm8vkmf7W96XJhC
7ZM0dYi1/qOCAU8wggFLMB0GA1UdJQQWMBQGCCsGAQUFBwMBBggrBgEFBQcDAjAa
BgNVHREEEzARgg9tYWlsLmdvb2dsZS5jb20wCwYDVR0PBAQDAgeAMGgGCCsGAQUF
BwEBBFwwWjArBggrBgEFBQcwAoYfaHR0cDovL3BraS5nb29nbGUuY29tL0dJQUcy
LmNydDArBggrBgEFBQcwAYYfaHR0cDovL2NsaWVudHMxLmdvb2dsZS5jb20vb2Nz
cDAdBgNVHQ4EFgQUiJxtimAuTfwb+aUtBn5UYKreKvMwDAYDVR0TAQH/BAIwADAf
BgNVHSMEGDAWgBRK3QYWG7z2aLV29YG2u2IaulqBLzAXBgNVHSAEEDAOMAwGCisG
AQQB1nkCBQEwMAYDVR0fBCkwJzAloCOgIYYfaHR0cDovL3BraS5nb29nbGUuY29t
L0dJQUcyLmNybDANBgkqhkiG9w0BAQUFAAOCAQEAH6RYHxHdcGpMpFE3oxDoFnP+
gtuBCHan2yE2GRbJ2Cw8Lw0MmuKqHlf9RSeYfd3BXeKkj1qO6TVKwCh+0HdZk283
TZZyzmEOyclm3UGFYe82P/iDFt+CeQ3NpmBg+GoaVCuWAARJN/KfglbLyyYygcQq
0SgeDh8dRKUiaW3HQSoYvTvdTuqzwK4CXsr3b5/dAOY8uMuG/IAR3FgwTbZ1dtoW
RvOTa8hYiU6A475WuZKyEHcwnGYe57u2I2KbMgcKjPniocj4QzgYsVAVKW3IwaOh
yE+vPxsiUkvQHdO2fojCkY8jg70jxM+gu59tPDNbw3Uh/2Ij310FgTHsnGQMyA==
-----END CERTIFICATE-----`

	// First, create the set of root certificates. For this example we only
	// have one. It's also possible to omit this in order to use the
	// default root set of the current operating system.
	roots := x509.NewCertPool()
	ok := roots.AppendCertsFromPEM([]byte(rootPEM))
	if !ok {
		panic("failed to parse root certificate")
	}

	block, _ := pem.Decode([]byte(certPEM))
	if block == nil {
		panic("failed to parse certificate PEM")
	}
	cert, err := x509.ParseCertificate(block.Bytes)
	if err != nil {
		panic("failed to parse certificate: " + err.Error())
	}

	opts := x509.VerifyOptions{
		DNSName: "mail.google.com",
		Roots:   roots,
	}

	if _, err := cert.Verify(opts); err != nil {
		panic("failed to verify certificate: " + err.Error())
	}
}
</pre>   <h3 id="Certificate.VerifyHostname">func (*Certificate) VerifyHostname<a href="https://golang.org/src/crypto/x509/verify.go?s=13550:13602#L462" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *Certificate) VerifyHostname(h string) error</pre> <p> VerifyHostname returns nil if c is a valid certificate for the named host. Otherwise it returns an error describing the mismatch. </p> <h2 id="CertificateInvalidError">type CertificateInvalidError<a href="https://golang.org/src/crypto/x509/verify.go?s=1273:1355#L34" class="source" target="_blank">Source</a>  </h2> <p> CertificateInvalidError results when an odd error occurs. Users of this library probably want to handle all these errors uniformly. </p> <pre data-language="go">type CertificateInvalidError struct {
        Cert   *Certificate
        Reason InvalidReason
}</pre> <h3 id="CertificateInvalidError.Error">func (CertificateInvalidError) Error<a href="https://golang.org/src/crypto/x509/verify.go?s=1357:1404#L39" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (e CertificateInvalidError) Error() string</pre> <h2 id="CertificateRequest">type CertificateRequest<a href="https://golang.org/src/crypto/x509/x509.go?s=61369:62682#L1925" class="source" target="_blank">Source</a>  </h2> <p> CertificateRequest represents a PKCS #10, certificate signature request. </p> <pre data-language="go">type CertificateRequest struct {
        Raw                      []byte // Complete ASN.1 DER content (CSR, signature algorithm and signature).
        RawTBSCertificateRequest []byte // Certificate request info part of raw ASN.1 DER content.
        RawSubjectPublicKeyInfo  []byte // DER encoded SubjectPublicKeyInfo.
        RawSubject               []byte // DER encoded Subject.

        Version            int
        Signature          []byte
        SignatureAlgorithm SignatureAlgorithm

        PublicKeyAlgorithm PublicKeyAlgorithm
        PublicKey          interface{}

        Subject pkix.Name

        // Attributes is the dried husk of a bug and shouldn't be used.
        Attributes []pkix.AttributeTypeAndValueSET

        // Extensions contains raw X.509 extensions. When parsing CSRs, this
        // can be used to extract extensions that are not parsed by this
        // package.
        Extensions []pkix.Extension

        // ExtraExtensions contains extensions to be copied, raw, into any
        // marshaled CSR. Values override any extensions that would otherwise
        // be produced based on the other fields but are overridden by any
        // extensions specified in Attributes.
        //
        // The ExtraExtensions field is not populated when parsing CSRs, see
        // Extensions.
        ExtraExtensions []pkix.Extension

        // Subject Alternate Name values.
        DNSNames       []string
        EmailAddresses []string
        IPAddresses    []net.IP
}</pre> <h3 id="ParseCertificateRequest">func ParseCertificateRequest<a href="https://golang.org/src/crypto/x509/x509.go?s=69755:69829#L2208" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func ParseCertificateRequest(asn1Data []byte) (*CertificateRequest, error)</pre> <p> ParseCertificateRequest parses a single certificate request from the given ASN.1 DER data. </p> <h3 id="CertificateRequest.CheckSignature">func (*CertificateRequest) CheckSignature<a href="https://golang.org/src/crypto/x509/x509.go?s=71516:71567#L2269" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (c *CertificateRequest) CheckSignature() error</pre> <p> CheckSignature reports whether the signature on c is valid. </p> <h2 id="ConstraintViolationError">type ConstraintViolationError<a href="https://golang.org/src/crypto/x509/x509.go?s=24088:24126#L719" class="source" target="_blank">Source</a>  </h2> <p> ConstraintViolationError results when a requested usage is not permitted by a certificate. For example: checking a signature when the public key isn't a certificate signing key. </p> <pre data-language="go">type ConstraintViolationError struct{}</pre> <h3 id="ConstraintViolationError.Error">func (ConstraintViolationError) Error<a href="https://golang.org/src/crypto/x509/x509.go?s=24128:24174#L721" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (ConstraintViolationError) Error() string</pre> <h2 id="ExtKeyUsage">type ExtKeyUsage<a href="https://golang.org/src/crypto/x509/x509.go?s=18153:18173#L558" class="source" target="_blank">Source</a>  </h2> <p> ExtKeyUsage represents an extended set of actions that are valid for a given key. Each of the ExtKeyUsage* constants define a unique action. </p> <pre data-language="go">type ExtKeyUsage int</pre> <pre data-language="go">const (
        ExtKeyUsageAny ExtKeyUsage = iota
        ExtKeyUsageServerAuth
        ExtKeyUsageClientAuth
        ExtKeyUsageCodeSigning
        ExtKeyUsageEmailProtection
        ExtKeyUsageIPSECEndSystem
        ExtKeyUsageIPSECTunnel
        ExtKeyUsageIPSECUser
        ExtKeyUsageTimeStamping
        ExtKeyUsageOCSPSigning
        ExtKeyUsageMicrosoftServerGatedCrypto
        ExtKeyUsageNetscapeServerGatedCrypto
)</pre> <h2 id="HostnameError">type HostnameError<a href="https://golang.org/src/crypto/x509/verify.go?s=2143:2218#L59" class="source" target="_blank">Source</a>  </h2> <p> HostnameError results when the set of authorized names doesn't match the requested name. </p> <pre data-language="go">type HostnameError struct {
        Certificate *Certificate
        Host        string
}</pre> <h3 id="HostnameError.Error">func (HostnameError) Error<a href="https://golang.org/src/crypto/x509/verify.go?s=2220:2257#L64" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (h HostnameError) Error() string</pre> <h2 id="InsecureAlgorithmError">type InsecureAlgorithmError<a href="https://golang.org/src/crypto/x509/x509.go?s=23702:23748#L710" class="source" target="_blank">Source</a>  </h2> <p> An InsecureAlgorithmError </p> <pre data-language="go">type InsecureAlgorithmError SignatureAlgorithm</pre> <h3 id="InsecureAlgorithmError.Error">func (InsecureAlgorithmError) Error<a href="https://golang.org/src/crypto/x509/x509.go?s=23750:23796#L712" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (e InsecureAlgorithmError) Error() string</pre> <h2 id="InvalidReason">type InvalidReason<a href="https://golang.org/src/crypto/x509/verify.go?s=265:287#L8" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">type InvalidReason int</pre> <pre data-language="go">const (
        // NotAuthorizedToSign results when a certificate is signed by another
        // which isn't marked as a CA certificate.
        NotAuthorizedToSign InvalidReason = iota
        // Expired results when a certificate has expired, based on the time
        // given in the VerifyOptions.
        Expired
        // CANotAuthorizedForThisName results when an intermediate or root
        // certificate has a name constraint which doesn't include the name
        // being checked.
        CANotAuthorizedForThisName
        // TooManyIntermediates results when a path length constraint is
        // violated.
        TooManyIntermediates
        // IncompatibleUsage results when the certificate's key usage indicates
        // that it may only be used for a different purpose.
        IncompatibleUsage
        // NameMismatch results when the subject name of a parent certificate
        // does not match the issuer name in the child.
        NameMismatch
)</pre> <h2 id="KeyUsage">type KeyUsage<a href="https://golang.org/src/crypto/x509/x509.go?s=16066:16083#L515" class="source" target="_blank">Source</a>  </h2> <p> KeyUsage represents the set of actions that are valid for a given key. It's a bitmap of the KeyUsage* constants. </p> <pre data-language="go">type KeyUsage int</pre> <pre data-language="go">const (
        KeyUsageDigitalSignature KeyUsage = 1 &lt;&lt; iota
        KeyUsageContentCommitment
        KeyUsageKeyEncipherment
        KeyUsageDataEncipherment
        KeyUsageKeyAgreement
        KeyUsageCertSign
        KeyUsageCRLSign
        KeyUsageEncipherOnly
        KeyUsageDecipherOnly
)</pre> <h2 id="PEMCipher">type PEMCipher<a href="https://golang.org/src/crypto/x509/pem_decrypt.go?s=472:490#L13" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">type PEMCipher int</pre> <p> Possible values for the EncryptPEMBlock encryption algorithm. </p> <pre data-language="go">const (
        PEMCipherDES PEMCipher
        PEMCipher3DES
        PEMCipherAES128
        PEMCipherAES192
        PEMCipherAES256
)</pre> <h2 id="PublicKeyAlgorithm">type PublicKeyAlgorithm<a href="https://golang.org/src/crypto/x509/x509.go?s=5753:5780#L212" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">type PublicKeyAlgorithm int</pre> <pre data-language="go">const (
        UnknownPublicKeyAlgorithm PublicKeyAlgorithm = iota
        RSA
        DSA
        ECDSA
)</pre> <h2 id="SignatureAlgorithm">type SignatureAlgorithm<a href="https://golang.org/src/crypto/x509/x509.go?s=4575:4602#L157" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">type SignatureAlgorithm int</pre> <pre data-language="go">const (
        UnknownSignatureAlgorithm SignatureAlgorithm = iota
        MD2WithRSA
        MD5WithRSA
        SHA1WithRSA
        SHA256WithRSA
        SHA384WithRSA
        SHA512WithRSA
        DSAWithSHA1
        DSAWithSHA256
        ECDSAWithSHA1
        ECDSAWithSHA256
        ECDSAWithSHA384
        ECDSAWithSHA512
        SHA256WithRSAPSS
        SHA384WithRSAPSS
        SHA512WithRSAPSS
)</pre> <h3 id="SignatureAlgorithm.String">func (SignatureAlgorithm) String<a href="https://golang.org/src/crypto/x509/x509.go?s=5598:5644#L205" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (algo SignatureAlgorithm) String() string</pre> <h2 id="SystemRootsError">type SystemRootsError<a href="https://golang.org/src/crypto/x509/verify.go?s=3914:3957#L121" class="source" target="_blank">Source</a>  </h2> <p> SystemRootsError results when we fail to load the system root certificates. </p> <pre data-language="go">type SystemRootsError struct {
        Err error
}</pre> <h3 id="SystemRootsError.Error">func (SystemRootsError) Error<a href="https://golang.org/src/crypto/x509/verify.go?s=3959:4000#L125" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (se SystemRootsError) Error() string</pre> <h2 id="UnhandledCriticalExtension">type UnhandledCriticalExtension<a href="https://golang.org/src/crypto/x509/x509.go?s=30506:30546#L889" class="source" target="_blank">Source</a>  </h2> <pre data-language="go">type UnhandledCriticalExtension struct{}</pre> <h3 id="UnhandledCriticalExtension.Error">func (UnhandledCriticalExtension) Error<a href="https://golang.org/src/crypto/x509/x509.go?s=30548:30598#L891" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (h UnhandledCriticalExtension) Error() string</pre> <h2 id="UnknownAuthorityError">type UnknownAuthorityError<a href="https://golang.org/src/crypto/x509/verify.go?s=3011:3315#L94" class="source" target="_blank">Source</a>  </h2> <p> UnknownAuthorityError results when the certificate issuer is unknown </p> <pre data-language="go">type UnknownAuthorityError struct {
        Cert *Certificate
        // contains filtered or unexported fields
}</pre> <h3 id="UnknownAuthorityError.Error">func (UnknownAuthorityError) Error<a href="https://golang.org/src/crypto/x509/verify.go?s=3317:3362#L104" class="source" target="_blank">Source</a>  </h3> <pre data-language="go">func (e UnknownAuthorityError) Error() string</pre> <h2 id="VerifyOptions">type VerifyOptions<a href="https://golang.org/src/crypto/x509/verify.go?s=4526:5038#L139" class="source" target="_blank">Source</a>  </h2> <p> VerifyOptions contains parameters for Certificate.Verify. It's a structure because other PKIX verification APIs have ended up needing many options. </p> <pre data-language="go">type VerifyOptions struct {
        DNSName       string
        Intermediates *CertPool
        Roots         *CertPool // if nil, the system roots are used
        CurrentTime   time.Time // if zero, the current time is used
        // KeyUsage specifies which Extended Key Usage values are acceptable.
        // An empty list means ExtKeyUsageServerAuth. Key usage is considered a
        // constraint down the chain which mirrors Windows CryptoAPI behavior,
        // but not the spec. To accept any key usage, include ExtKeyUsageAny.
        KeyUsages []ExtKeyUsage
}</pre> <h2 id="pkg-subdirectories">Subdirectories</h2> <div class="pkg-dir"> <table> <tr> <th class="pkg-name">Name</th> <th class="pkg-synopsis">Synopsis</th> </tr> <tr> <td colspan="2"><a href="../">..</a></td> </tr> <tr> <td class="pkg-name"> <a href="pkix/">pkix</a> </td> <td class="pkg-synopsis"> Package pkix contains shared, low level structures used for ASN.1 parsing and serialization of X.509 certificates, CRL and OCSP. </td> </tr> </table> </div>
<div class="_attribution">
  <p class="_attribution-p">
    © Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>
    <a href="https://golang.org/pkg/crypto/x509/" class="_attribution-link" target="_blank">https://golang.org/pkg/crypto/x509/</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
