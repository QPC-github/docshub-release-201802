
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Date - Elixir 1.6 - W3cubDocs</title>
  
  <meta name="description" content=" A Date struct and functions. ">
  <meta name="keywords" content="date, summary, types, functions, -, elixir, elixir~1.6">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/elixir~1.6/date/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-e0f881b0fce8cbe96f33dadc355b7159d5d2912911231446d60eb8f9caffa802.css">
  <script type="text/javascript" src="/assets/application-8fc46316434047265cd383f02b8e7f434ed7dec4a59f920dd633deef8d488d1b.js"></script>
  <script src="/json/elixir~1.6.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/elixir~1.6/" class="_nav-link" title="" style="margin-left:0;">Elixir 1.6</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _elixir">
				
<h1>  Date  </h1>  <p>A Date struct and functions.</p> <p>The Date struct contains the fields year, month, day and calendar. New dates can be built with the <a href="#new/3"><code class="inline">new/3</code></a> function or using the <code class="inline">~D</code> sigil:</p> <pre data-language="elixir"><code class="iex elixir">iex&gt; ~D[2000-01-01]
~D[2000-01-01]</code></pre> <p>Both <a href="#new/3"><code class="inline">new/3</code></a> and sigil return a struct where the date fields can be accessed directly:</p> <pre data-language="elixir"><code class="iex elixir">iex&gt; date = ~D[2000-01-01]
iex&gt; date.year
2000
iex&gt; date.month
1</code></pre> <p>The functions on this module work with the <a href="../date/#content"><code class="inline">Date</code></a> struct as well as any struct that contains the same fields as the <a href="../date/#content"><code class="inline">Date</code></a> struct, such as <a href="../naivedatetime/"><code class="inline">NaiveDateTime</code></a> and <a href="../datetime/"><code class="inline">DateTime</code></a>. Such functions expect <a href="../calendar/#t:date/0"><code class="inline">Calendar.date/0</code></a> in their typespecs (instead of <a href="#t:t/0"><code class="inline">t/0</code></a>).</p> <p>Developers should avoid creating the Date structs directly and instead rely on the functions provided by this module as well as the ones in 3rd party calendar libraries.</p> <h2 id="module-comparing-dates" class="section-heading">  Comparing dates </h2> <p>Comparisons in Elixir using <code class="inline">==</code>, <code class="inline">&gt;</code>, <code class="inline">&lt;</code> and similar are structural and based on the <a href="../date/#content"><code class="inline">Date</code></a> struct fields. For proper comparison between dates, use the <a href="#compare/2"><code class="inline">compare/2</code></a> function.</p> <h2 id="module-using-epochs" class="section-heading">  Using epochs </h2> <p>The <a href="#add/2"><code class="inline">add/2</code></a> and <a href="#diff/2"><code class="inline">diff/2</code></a> functions can be used for computing dates or retrieving the number of days between instants. For example, if there is an interest in computing the number of days from the Unix epoch (1970-01-01):</p> <pre data-language="elixir"><code class="iex elixir">iex&gt; Date.diff(~D[2010-04-17], ~D[1970-01-01])
14716

iex&gt; Date.add(~D[1970-01-01], 14716)
~D[2010-04-17]</code></pre> <p>Those functions are optimized to deal with common epochs, such as the Unix Epoch above or the Gregorian Epoch (0000-01-01).</p>   <h1 class="section-heading" id="summary">  Summary </h1> <h2> Types </h2>
<dl class="summary-types summary">   <dt class="summary-signature"> <a href="#t:t/0">t()</a> </dt>  </dl> <h2> Functions </h2>
<dl class="summary-functions summary">   <dt class="summary-signature"> <a href="#add/2">add(date, days)</a> </dt> <dd class="summary-synopsis">
<p>Adds the number of days to the given <code class="inline">date</code></p> </dd>   <dt class="summary-signature"> <a href="#compare/2">compare(date1, date2)</a> </dt> <dd class="summary-synopsis">
<p>Compares two date structs</p> </dd>   <dt class="summary-signature"> <a href="#convert/2">convert(date, calendar)</a> </dt> <dd class="summary-synopsis">
<p>Converts the given <code class="inline">date</code> from its calendar to the given <code class="inline">calendar</code></p> </dd>   <dt class="summary-signature"> <a href="#convert!/2">convert!(date, calendar)</a> </dt> <dd class="summary-synopsis">
<p>Similar to <a href="../date/#convert/2"><code class="inline">Date.convert/2</code></a>, but raises an <a href="../argumenterror/"><code class="inline">ArgumentError</code></a> if the conversion between the two calendars is not possible</p> </dd>   <dt class="summary-signature"> <a href="#day_of_week/1">day_of_week(date)</a> </dt> <dd class="summary-synopsis">
<p>Calculates the day of the week of a given <code class="inline">date</code></p> </dd>   <dt class="summary-signature"> <a href="#days_in_month/1">days_in_month(date)</a> </dt> <dd class="summary-synopsis">
<p>Returns the number of days in the given <code class="inline">date</code> month</p> </dd>   <dt class="summary-signature"> <a href="#diff/2">diff(date1, date2)</a> </dt> <dd class="summary-synopsis">
<p>Calculates the difference between two dates, in a full number of days</p> </dd>   <dt class="summary-signature"> <a href="#from_erl/2">from_erl(tuple, calendar \\ Calendar.ISO)</a> </dt> <dd class="summary-synopsis">
<p>Converts an Erlang date tuple to a <a href="../date/#content"><code class="inline">Date</code></a> struct</p> </dd>   <dt class="summary-signature"> <a href="#from_erl!/2">from_erl!(tuple, calendar \\ Calendar.ISO)</a> </dt> <dd class="summary-synopsis">
<p>Converts an Erlang date tuple but raises for invalid dates</p> </dd>   <dt class="summary-signature"> <a href="#from_iso8601/2">from_iso8601(string, calendar \\ Calendar.ISO)</a> </dt> <dd class="summary-synopsis">
<p>Parses the extended “Dates” format described by <a href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank">ISO 8601:2004</a></p> </dd>   <dt class="summary-signature"> <a href="#from_iso8601!/2">from_iso8601!(string, calendar \\ Calendar.ISO)</a> </dt> <dd class="summary-synopsis">
<p>Parses the extended “Dates” format described by <a href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank">ISO 8601:2004</a></p> </dd>   <dt class="summary-signature"> <a href="#leap_year?/1">leap_year?(date)</a> </dt> <dd class="summary-synopsis">
<p>Returns true if the year in the given <code class="inline">date</code> is a leap year</p> </dd>   <dt class="summary-signature"> <a href="#new/4">new(year, month, day, calendar \\ Calendar.ISO)</a> </dt> <dd class="summary-synopsis">
<p>Builds a new ISO date</p> </dd>   <dt class="summary-signature"> <a href="#range/2">range(first, last)</a> </dt> <dd class="summary-synopsis">
<p>Returns a range of dates</p> </dd>   <dt class="summary-signature"> <a href="#to_erl/1">to_erl(date)</a> </dt> <dd class="summary-synopsis">
<p>Converts the given <code class="inline">date</code> to an Erlang date tuple</p> </dd>   <dt class="summary-signature"> <a href="#to_iso8601/2">to_iso8601(date, format \\ :extended)</a> </dt> <dd class="summary-synopsis">
<p>Converts the given <code class="inline">date</code> to <a href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank">ISO 8601:2004</a></p> </dd>   <dt class="summary-signature"> <a href="#to_string/1">to_string(date)</a> </dt> <dd class="summary-synopsis">
<p>Converts the given date to a string according to its calendar</p> </dd>   <dt class="summary-signature"> <a href="#utc_today/1">utc_today(calendar \\ Calendar.ISO)</a> </dt> <dd class="summary-synopsis">
<p>Returns the current date in UTC</p> </dd>  </dl>   <h1 class="section-heading" id="types">  Types </h1>   <h3 class="detail-header type" id="t:t/0">  <span class="signature">t()</span>     </h3>
<pre data-language="elixir">t() :: %Date{calendar: <a href="../calendar/#t:calendar/0">Calendar.calendar</a>(), day: <a href="../calendar/#t:day/0">Calendar.day</a>(), month: <a href="../calendar/#t:month/0">Calendar.month</a>(), year: <a href="../calendar/#t:year/0">Calendar.year</a>()}</pre>       <h1 class="section-heading" id="functions">  Functions </h1>  <h3 class="detail-header function" id="add/2">  <span class="signature">add(date, days)</span>     </h3>
<pre data-language="elixir">add(<a href="../calendar/#t:date/0">Calendar.date</a>(), integer()) :: <a href="#t:t/0">t</a>()</pre>  <p>Adds the number of days to the given <code class="inline">date</code>.</p> <p>The days are counted as Gregorian days. The date is returned in the same calendar as it was given in.</p> <h4 id="add/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Date.add(~D[2000-01-03], -2)
~D[2000-01-01]
iex&gt; Date.add(~D[2000-01-01], 2)
~D[2000-01-03]

iex&gt; Date.add(~N[2000-01-01 09:00:00], 2)
~D[2000-01-03]</code></pre>    <h3 class="detail-header function" id="compare/2">  <span class="signature">compare(date1, date2)</span>     </h3>
<pre data-language="elixir">compare(<a href="../calendar/#t:date/0">Calendar.date</a>(), <a href="../calendar/#t:date/0">Calendar.date</a>()) :: :lt | :eq | :gt</pre>  <p>Compares two date structs.</p> <p>Returns <code class="inline">:gt</code> if first date is later than the second and <code class="inline">:lt</code> for vice versa. If the two dates are equal <code class="inline">:eq</code> is returned.</p> <h4 id="compare/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Date.compare(~D[2016-04-16], ~D[2016-04-28])
:lt</code></pre> <p>This function can also be used to compare across more complex calendar types by considering only the date fields:</p> <pre data-language="elixir"><code class="iex elixir">iex&gt; Date.compare(~D[2016-04-16], ~N[2016-04-28 01:23:45])
:lt
iex&gt; Date.compare(~D[2016-04-16], ~N[2016-04-16 01:23:45])
:eq
iex&gt; Date.compare(~N[2016-04-16 12:34:56], ~N[2016-04-16 01:23:45])
:eq</code></pre>    <h3 class="detail-header function" id="convert/2">  <span class="signature">convert(date, calendar)</span>     </h3>
<pre data-language="elixir">convert(<a href="../calendar/#t:date/0">Calendar.date</a>(), <a href="../calendar/#t:calendar/0">Calendar.calendar</a>()) ::
  {:ok, <a href="#t:t/0">t</a>()} |
  {:error, :incompatible_calendars}</pre>  <p>Converts the given <code class="inline">date</code> from its calendar to the given <code class="inline">calendar</code>.</p> <p>Returns <code class="inline">{:ok, date}</code> if the calendars are compatible, or <code class="inline">{:error, :incompatible_calendars}</code> if they are not.</p> <p>See also <a href="../calendar/#compatible_calendars?/2"><code class="inline">Calendar.compatible_calendars?/2</code></a>.</p> <h4 id="convert/2-examples" class="section-heading">  Examples </h4> <p>Imagine someone implements <code class="inline">Calendar.Holocene</code>, a calendar based on the Gregorian calendar that adds exactly 10,000 years to the current Gregorian year:</p> <pre data-language="elixir"><code class="iex elixir">iex&gt; Date.convert(~D[2000-01-01], Calendar.Holocene)
{:ok, %Date{calendar: Calendar.Holocene, year: 12000, month: 1, day: 1}}</code></pre>    <h3 class="detail-header function" id="convert!/2">  <span class="signature">convert!(date, calendar)</span>     </h3>
<pre data-language="elixir">convert!(<a href="../calendar/#t:date/0">Calendar.date</a>(), <a href="../calendar/#t:calendar/0">Calendar.calendar</a>()) :: <a href="#t:t/0">t</a>()</pre>  <p>Similar to <a href="../date/#convert/2"><code class="inline">Date.convert/2</code></a>, but raises an <a href="../argumenterror/"><code class="inline">ArgumentError</code></a> if the conversion between the two calendars is not possible.</p> <h4 id="convert!/2-examples" class="section-heading">  Examples </h4> <p>Imagine someone implements <code class="inline">Calendar.Holocene</code>, a calendar based on the Gregorian calendar that adds exactly 10,000 years to the current Gregorian year:</p> <pre data-language="elixir"><code class="iex elixir">iex&gt; Date.convert!(~D[2000-01-01], Calendar.Holocene)
%Date{calendar: Calendar.Holocene, year: 12000, month: 1, day: 1}</code></pre>    <h3 class="detail-header function" id="day_of_week/1">  <span class="signature">day_of_week(date)</span>     </h3>
<pre data-language="elixir">day_of_week(<a href="../calendar/#t:date/0">Calendar.date</a>()) :: non_neg_integer()</pre>  <p>Calculates the day of the week of a given <code class="inline">date</code>.</p> <p>Returns the day of the week as an integer. For the ISO 8601 calendar (the default), it is an integer from 1 to 7, where 1 is Monday and 7 is Sunday.</p> <h4 id="day_of_week/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Date.day_of_week(~D[2016-10-31])
1
iex&gt; Date.day_of_week(~D[2016-11-01])
2
iex&gt; Date.day_of_week(~N[2016-11-01 01:23:45])
2</code></pre>    <h3 class="detail-header function" id="days_in_month/1">  <span class="signature">days_in_month(date)</span>     </h3>
<pre data-language="elixir">days_in_month(<a href="../calendar/#t:date/0">Calendar.date</a>()) :: <a href="../calendar/#t:day/0">Calendar.day</a>()</pre>  <p>Returns the number of days in the given <code class="inline">date</code> month.</p> <h4 id="days_in_month/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Date.days_in_month(~D[1900-01-13])
31
iex&gt; Date.days_in_month(~D[1900-02-09])
28
iex&gt; Date.days_in_month(~N[2000-02-20 01:23:45])
29</code></pre>    <h3 class="detail-header function" id="diff/2">  <span class="signature">diff(date1, date2)</span>     </h3>
<pre data-language="elixir">diff(<a href="../calendar/#t:date/0">Calendar.date</a>(), <a href="../calendar/#t:date/0">Calendar.date</a>()) :: integer()</pre>  <p>Calculates the difference between two dates, in a full number of days.</p> <p>It returns the number of Gregorian days between the dates. Only <a href="../date/#content"><code class="inline">Date</code></a> structs that follow the same or compatible calendars can be compared this way. If two calendars are not compatible, it will raise.</p> <h4 id="diff/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Date.diff(~D[2000-01-03], ~D[2000-01-01])
2
iex&gt; Date.diff(~D[2000-01-01], ~D[2000-01-03])
-2

iex&gt; Date.diff(~D[2000-01-01], ~N[2000-01-03 09:00:00])
-2</code></pre>     <h3 class="detail-header function" id="from_erl/2">  <span class="signature">from_erl(tuple, calendar \\ Calendar.ISO)</span>     </h3>
<pre data-language="elixir">from_erl(:calendar.date(), <a href="../calendar/#t:calendar/0">Calendar.calendar</a>()) ::
  {:ok, <a href="#t:t/0">t</a>()} |
  {:error, atom()}</pre>  <p>Converts an Erlang date tuple to a <a href="../date/#content"><code class="inline">Date</code></a> struct.</p> <p>Only supports converting dates which are in the ISO calendar, or other calendars in which the days also start at midnight. Attempting to convert dates from other calendars will return an error tuple.</p> <h4 id="from_erl/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Date.from_erl({2000, 1, 1})
{:ok, ~D[2000-01-01]}
iex&gt; Date.from_erl({2000, 13, 1})
{:error, :invalid_date}</code></pre>     <h3 class="detail-header function" id="from_erl!/2">  <span class="signature">from_erl!(tuple, calendar \\ Calendar.ISO)</span>     </h3>
<pre data-language="elixir">from_erl!(:calendar.date(), <a href="../calendar/#t:calendar/0">Calendar.calendar</a>()) :: <a href="#t:t/0">t</a>()</pre>  <p>Converts an Erlang date tuple but raises for invalid dates.</p> <h4 id="from_erl!/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Date.from_erl!({2000, 1, 1})
~D[2000-01-01]
iex&gt; Date.from_erl!({2000, 13, 1})
** (ArgumentError) cannot convert {2000, 13, 1} to date, reason: :invalid_date</code></pre>     <h3 class="detail-header function" id="from_iso8601/2">  <span class="signature">from_iso8601(string, calendar \\ Calendar.ISO)</span>     </h3>
<pre data-language="elixir">from_iso8601(<a href="../string/#t:t/0">String.t</a>(), <a href="../calendar/#t:calendar/0">Calendar.calendar</a>()) ::
  {:ok, <a href="#t:t/0">t</a>()} |
  {:error, atom()}</pre>  <p>Parses the extended “Dates” format described by <a href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank">ISO 8601:2004</a>.</p> <h4 id="from_iso8601/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Date.from_iso8601("2015-01-23")
{:ok, ~D[2015-01-23]}

iex&gt; Date.from_iso8601("2015:01:23")
{:error, :invalid_format}

iex&gt; Date.from_iso8601("2015-01-32")
{:error, :invalid_date}</code></pre>     <h3 class="detail-header function" id="from_iso8601!/2">  <span class="signature">from_iso8601!(string, calendar \\ Calendar.ISO)</span>     </h3>
<pre data-language="elixir">from_iso8601!(<a href="../string/#t:t/0">String.t</a>(), <a href="../calendar/#t:calendar/0">Calendar.calendar</a>()) :: <a href="#t:t/0">t</a>()</pre>  <p>Parses the extended “Dates” format described by <a href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank">ISO 8601:2004</a>.</p> <p>Raises if the format is invalid.</p> <h4 id="from_iso8601!/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Date.from_iso8601!("2015-01-23")
~D[2015-01-23]
iex&gt; Date.from_iso8601!("2015:01:23")
** (ArgumentError) cannot parse "2015:01:23" as date, reason: :invalid_format</code></pre>    <h3 class="detail-header function" id="leap_year?/1">  <span class="signature">leap_year?(date)</span>     </h3>
<pre data-language="elixir">leap_year?(<a href="../calendar/#t:date/0">Calendar.date</a>()) :: boolean()</pre>  <p>Returns true if the year in the given <code class="inline">date</code> is a leap year.</p> <h4 id="leap_year?/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Date.leap_year?(~D[2000-01-01])
true
iex&gt; Date.leap_year?(~D[2001-01-01])
false
iex&gt; Date.leap_year?(~D[2004-01-01])
true
iex&gt; Date.leap_year?(~D[1900-01-01])
false
iex&gt; Date.leap_year?(~N[2004-01-01 01:23:45])
true</code></pre>     <h3 class="detail-header function" id="new/4">  <span class="signature">new(year, month, day, calendar \\ Calendar.ISO)</span>     </h3>
<pre data-language="elixir">new(<a href="../calendar/#t:year/0">Calendar.year</a>(), <a href="../calendar/#t:month/0">Calendar.month</a>(), <a href="../calendar/#t:day/0">Calendar.day</a>(), <a href="../calendar/#t:calendar/0">Calendar.calendar</a>()) ::
  {:ok, <a href="#t:t/0">t</a>()} |
  {:error, atom()}</pre>  <p>Builds a new ISO date.</p> <p>Expects all values to be integers. Returns <code class="inline">{:ok, date}</code> if each entry fits its appropriate range, returns <code class="inline">{:error, reason}</code> otherwise.</p> <h4 id="new/4-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Date.new(2000, 1, 1)
{:ok, ~D[2000-01-01]}
iex&gt; Date.new(2000, 13, 1)
{:error, :invalid_date}
iex&gt; Date.new(2000, 2, 29)
{:ok, ~D[2000-02-29]}

iex&gt; Date.new(2000, 2, 30)
{:error, :invalid_date}
iex&gt; Date.new(2001, 2, 29)
{:error, :invalid_date}</code></pre>    <h3 class="detail-header function" id="range/2">  <span class="signature">range(first, last)</span>     </h3>
<pre data-language="elixir">range(<a href="../date/#t:t/0">Date.t</a>(), <a href="../date/#t:t/0">Date.t</a>()) :: <a href="../date.range/#t:t/0">Date.Range.t</a>()</pre>  <p>Returns a range of dates.</p> <p>A range of dates represents a discrete number of dates where the first and last values are dates with matching calendars.</p> <p>Ranges of dates can be either increasing (<code class="inline">first &lt;= last</code>) or decreasing (<code class="inline">first &gt; last</code>). They are also always inclusive.</p> <h4 id="range/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Date.range(~D[1999-01-01], ~D[2000-01-01])
#DateRange&lt;~D[1999-01-01], ~D[2000-01-01]&gt;</code></pre> <p>A range of dates implements the <a href="../enumerable/"><code class="inline">Enumerable</code></a> protocol, which means functions in the <a href="../enum/"><code class="inline">Enum</code></a> module can be used to work with ranges:</p> <pre data-language="elixir"><code class="iex elixir">iex&gt; range = Date.range(~D[2001-01-01], ~D[2002-01-01])
iex&gt; Enum.count(range)
366
iex&gt; Enum.member?(range, ~D[2001-02-01])
true
iex&gt; Enum.reduce(range, 0, fn _date, acc -&gt; acc - 1 end)
-366</code></pre>    <h3 class="detail-header function" id="to_erl/1">  <span class="signature">to_erl(date)</span>     </h3>
<pre data-language="elixir">to_erl(<a href="../calendar/#t:date/0">Calendar.date</a>()) :: :calendar.date()</pre>  <p>Converts the given <code class="inline">date</code> to an Erlang date tuple.</p> <p>Only supports converting dates which are in the ISO calendar, or other calendars in which the days also start at midnight. Attempting to convert dates from other calendars will raise.</p> <h4 id="to_erl/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Date.to_erl(~D[2000-01-01])
{2000, 1, 1}

iex&gt; Date.to_erl(~N[2000-01-01 00:00:00])
{2000, 1, 1}</code></pre>     <h3 class="detail-header function" id="to_iso8601/2">  <span class="signature">to_iso8601(date, format \\ :extended)</span>     </h3>
<pre data-language="elixir">to_iso8601(<a href="../calendar/#t:date/0">Calendar.date</a>(), :extended | :basic) :: <a href="../string/#t:t/0">String.t</a>()</pre>  <p>Converts the given <code class="inline">date</code> to <a href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank">ISO 8601:2004</a>.</p> <p>By default, <a href="../date/#to_iso8601/2"><code class="inline">Date.to_iso8601/2</code></a> returns dates formatted in the “extended” format, for human readability. It also supports the “basic” format through passing the <code class="inline">:basic</code> option.</p> <p>Only supports converting dates which are in the ISO calendar, or other calendars in which the days also start at midnight. Attempting to convert dates from other calendars will raise an <a href="../argumenterror/"><code class="inline">ArgumentError</code></a>.</p> <h3 id="to_iso8601/2-examples" class="section-heading">  Examples </h3> <pre data-language="elixir"><code class="iex elixir">iex&gt; Date.to_iso8601(~D[2000-02-28])
"2000-02-28"

iex&gt; Date.to_iso8601(~D[2000-02-28], :basic)
"20000228"

iex&gt; Date.to_iso8601(~N[2000-02-28 00:00:00])
"2000-02-28"</code></pre>    <h3 class="detail-header function" id="to_string/1">  <span class="signature">to_string(date)</span>     </h3>
<pre data-language="elixir">to_string(<a href="../calendar/#t:date/0">Calendar.date</a>()) :: <a href="../string/#t:t/0">String.t</a>()</pre>  <p>Converts the given date to a string according to its calendar.</p> <h3 id="to_string/1-examples" class="section-heading">  Examples </h3> <pre data-language="elixir"><code class="iex elixir">iex&gt; Date.to_string(~D[2000-02-28])
"2000-02-28"
iex&gt; Date.to_string(~N[2000-02-28 01:23:45])
"2000-02-28"</code></pre>     <h3 class="detail-header function" id="utc_today/1">  <span class="signature">utc_today(calendar \\ Calendar.ISO)</span>     </h3>
<pre data-language="elixir">utc_today(<a href="../calendar/#t:calendar/0">Calendar.calendar</a>()) :: <a href="#t:t/0">t</a>()</pre>  <p>Returns the current date in UTC.</p> <h4 id="utc_today/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; date = Date.utc_today()
iex&gt; date.year &gt;= 2016
true</code></pre>
<div class="_attribution">
  <p class="_attribution-p">
    © 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://hexdocs.pm/elixir/1.6.0/Date.html" class="_attribution-link" target="_blank">https://hexdocs.pm/elixir/1.6.0/Date.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
