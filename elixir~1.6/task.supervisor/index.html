
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Task.Supervisor - Elixir 1.6 - W3cubDocs</title>
  
  <meta name="description" content=" A task supervisor. ">
  <meta name="keywords" content="task, supervisor, summary, types, functions, -, elixir, elixir~1.6">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/elixir~1.6/task.supervisor/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-e0f881b0fce8cbe96f33dadc355b7159d5d2912911231446d60eb8f9caffa802.css">
  <script type="text/javascript" src="/assets/application-8fc46316434047265cd383f02b8e7f434ed7dec4a59f920dd633deef8d488d1b.js"></script>
  <script src="/json/elixir~1.6.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/elixir~1.6/" class="_nav-link" title="" style="margin-left:0;">Elixir 1.6</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _elixir">
				
<h1>  Task.Supervisor  </h1>  <p>A task supervisor.</p> <p>This module defines a supervisor which can be used to dynamically supervise tasks.</p> <p><a href="#start_link/1"><code class="inline">start_link/1</code></a> can be used to start the supervisor. See the <a href="../task/"><code class="inline">Task</code></a> module for more examples.</p> <h2 id="module-name-registration" class="section-heading">  Name registration </h2> <p>A <a href="../task.supervisor/#content"><code class="inline">Task.Supervisor</code></a> is bound to the same name registration rules as a <a href="../genserver/"><code class="inline">GenServer</code></a>. Read more about them in the <a href="../genserver/"><code class="inline">GenServer</code></a> docs.</p>   <h1 class="section-heading" id="summary">  Summary </h1> <h2> Types </h2>
<dl class="summary-types summary">   <dt class="summary-signature"> <a href="#t:option/0">option()</a> </dt> <dd class="summary-synopsis">
<p>Option values used by <code class="inline">start_link</code></p> </dd>  </dl> <h2> Functions </h2>
<dl class="summary-functions summary">   <dt class="summary-signature"> <a href="#async/3">async(supervisor, fun, options \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Starts a task that can be awaited on</p> </dd>   <dt class="summary-signature"> <a href="#async/5">async(supervisor, module, fun, args, options \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Starts a task that can be awaited on</p> </dd>   <dt class="summary-signature"> <a href="#async_nolink/3">async_nolink(supervisor, fun, options \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Starts a task that can be awaited on</p> </dd>   <dt class="summary-signature"> <a href="#async_nolink/5">async_nolink(supervisor, module, fun, args, options \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Starts a task that can be awaited on</p> </dd>   <dt class="summary-signature"> <a href="#async_stream/4">async_stream(supervisor, enumerable, fun, options \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Returns a stream that runs the given function <code class="inline">fun</code> concurrently on each item in <code class="inline">enumerable</code></p> </dd>   <dt class="summary-signature"> <a href="#async_stream/6">async_stream(supervisor, enumerable, module, function, args, options \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Returns a stream that runs the given <code class="inline">module</code>, <code class="inline">function</code>, and <code class="inline">args</code> concurrently on each item in <code class="inline">enumerable</code></p> </dd>   <dt class="summary-signature"> <a href="#async_stream_nolink/4">async_stream_nolink(supervisor, enumerable, fun, options \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Returns a stream that runs the given <code class="inline">function</code> concurrently on each item in <code class="inline">enumerable</code></p> </dd>   <dt class="summary-signature"> <a href="#async_stream_nolink/6">async_stream_nolink(supervisor, enumerable, module, function, args, options \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Returns a stream that runs the given <code class="inline">module</code>, <code class="inline">function</code>, and <code class="inline">args</code> concurrently on each item in <code class="inline">enumerable</code></p> </dd>   <dt class="summary-signature"> <a href="#children/1">children(supervisor)</a> </dt> <dd class="summary-synopsis">
<p>Returns all children PIDs</p> </dd>   <dt class="summary-signature"> <a href="#start_child/3">start_child(supervisor, fun, options \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Starts a task as a child of the given <code class="inline">supervisor</code></p> </dd>   <dt class="summary-signature"> <a href="#start_child/5">start_child(supervisor, module, fun, args, options \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Starts a task as a child of the given <code class="inline">supervisor</code></p> </dd>   <dt class="summary-signature"> <a href="#start_link/1">start_link(options \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Starts a new supervisor</p> </dd>   <dt class="summary-signature"> <a href="#terminate_child/2">terminate_child(supervisor, pid)</a> </dt> <dd class="summary-synopsis">
<p>Terminates the child with the given <code class="inline">pid</code></p> </dd>  </dl>   <h1 class="section-heading" id="types">  Types </h1>   <h3 class="detail-header type" id="t:option/0">  <span class="signature">option()</span>     </h3>
<pre data-language="elixir"><a href="#t:option/0">option</a>() ::
  <a href="../supervisor/#t:option/0">Supervisor.option</a>() |
  {:restart, :supervisor.restart()} |
  {:shutdown, :supervisor.shutdown()}</pre>  <p>Option values used by <code class="inline">start_link</code></p>      <h1 class="section-heading" id="functions">  Functions </h1>   <h3 class="detail-header function" id="async/3">  <span class="signature">async(supervisor, fun, options \\ [])</span>     </h3>
<pre data-language="elixir">async(<a href="../supervisor/#t:supervisor/0">Supervisor.supervisor</a>(), (() -&gt; any()), <a href="../keyword/#t:t/0">Keyword.t</a>()) :: <a href="../task/#t:t/0">Task.t</a>()</pre>  <p>Starts a task that can be awaited on.</p> <p>The <code class="inline">supervisor</code> must be a reference as defined in <a href="../task.supervisor/#content"><code class="inline">Task.Supervisor</code></a>. The task will still be linked to the caller, see <a href="../task/#async/3"><code class="inline">Task.async/3</code></a> for more information and <a href="#async_nolink/2"><code class="inline">async_nolink/2</code></a> for a non-linked variant.</p> <h4 id="async/3-options" class="section-heading">  Options </h4> <ul> <li>
<code class="inline">:shutdown</code> - <code class="inline">:brutal_kill</code> if the tasks must be killed directly on shutdown or an integer indicating the timeout value, defaults to 5000 milliseconds. </li> </ul>     <h3 class="detail-header function" id="async/5">  <span class="signature">async(supervisor, module, fun, args, options \\ [])</span>     </h3>
<pre data-language="elixir">async(<a href="../supervisor/#t:supervisor/0">Supervisor.supervisor</a>(), module(), atom(), [term()], <a href="../keyword/#t:t/0">Keyword.t</a>()) :: <a href="../task/#t:t/0">Task.t</a>()</pre>  <p>Starts a task that can be awaited on.</p> <p>The <code class="inline">supervisor</code> must be a reference as defined in <a href="../task.supervisor/#content"><code class="inline">Task.Supervisor</code></a>. The task will still be linked to the caller, see <a href="../task/#async/3"><code class="inline">Task.async/3</code></a> for more information and <a href="#async_nolink/2"><code class="inline">async_nolink/2</code></a> for a non-linked variant.</p> <h4 id="async/5-options" class="section-heading">  Options </h4> <ul> <li>
<code class="inline">:shutdown</code> - <code class="inline">:brutal_kill</code> if the tasks must be killed directly on shutdown or an integer indicating the timeout value, defaults to 5000 milliseconds. </li> </ul>     <h3 class="detail-header function" id="async_nolink/3">  <span class="signature">async_nolink(supervisor, fun, options \\ [])</span>     </h3>
<pre data-language="elixir">async_nolink(<a href="../supervisor/#t:supervisor/0">Supervisor.supervisor</a>(), (() -&gt; any()), <a href="../keyword/#t:t/0">Keyword.t</a>()) :: <a href="../task/#t:t/0">Task.t</a>()</pre>  <p>Starts a task that can be awaited on.</p> <p>The <code class="inline">supervisor</code> must be a reference as defined in <a href="../task.supervisor/#content"><code class="inline">Task.Supervisor</code></a>. The task won’t be linked to the caller, see <a href="../task/#async/3"><code class="inline">Task.async/3</code></a> for more information.</p> <h4 id="async_nolink/3-options" class="section-heading">  Options </h4> <ul> <li>
<code class="inline">:shutdown</code> - <code class="inline">:brutal_kill</code> if the tasks must be killed directly on shutdown or an integer indicating the timeout value, defaults to 5000 milliseconds. </li> </ul> <h4 id="async_nolink/3-compatibility-with-otp-behaviours" class="section-heading">  Compatibility with OTP behaviours </h4> <p>If you create a task using <code class="inline">async_nolink</code> inside an OTP behaviour like <a href="../genserver/"><code class="inline">GenServer</code></a>, you should match on the message coming from the task inside your <a href="../genserver/#c:handle_info/2"><code class="inline">GenServer.handle_info/2</code></a> callback.</p> <p>The reply sent by the task will be in the format <code class="inline">{ref, result}</code>, where <code class="inline">ref</code> is the monitor reference held by the task struct and <code class="inline">result</code> is the return value of the task function.</p> <p>Keep in mind that, regardless of how the task created with <code class="inline">async_nolink</code> terminates, the caller’s process will always receive a <code class="inline">:DOWN</code> message with the same <code class="inline">ref</code> value that is held by the task struct. If the task terminates normally, the reason in the <code class="inline">:DOWN</code> message will be <code class="inline">:normal</code>.</p>     <h3 class="detail-header function" id="async_nolink/5">  <span class="signature">async_nolink(supervisor, module, fun, args, options \\ [])</span>     </h3>
<pre data-language="elixir">async_nolink(<a href="../supervisor/#t:supervisor/0">Supervisor.supervisor</a>(), module(), atom(), [term()], <a href="../keyword/#t:t/0">Keyword.t</a>()) :: <a href="../task/#t:t/0">Task.t</a>()</pre>  <p>Starts a task that can be awaited on.</p> <p>The <code class="inline">supervisor</code> must be a reference as defined in <a href="../task.supervisor/#content"><code class="inline">Task.Supervisor</code></a>. The task won’t be linked to the caller, see <a href="../task/#async/3"><code class="inline">Task.async/3</code></a> for more information.</p> <p>Note this function requires the task supervisor to have <code class="inline">:temporary</code> as the <code class="inline">:restart</code> option (the default), as <a href="#async_nolink/4"><code class="inline">async_nolink/4</code></a> keeps a direct reference to the task which is lost if the task is restarted.</p>     <h3 class="detail-header function" id="async_stream/4">  <span class="signature">async_stream(supervisor, enumerable, fun, options \\ [])</span>     </h3>
<pre data-language="elixir">async_stream(<a href="../supervisor/#t:supervisor/0">Supervisor.supervisor</a>(), <a href="../enumerable/#t:t/0">Enumerable.t</a>(), (term() -&gt; term()), keyword()) :: <a href="../enumerable/#t:t/0">Enumerable.t</a>()</pre>  <p>Returns a stream that runs the given function <code class="inline">fun</code> concurrently on each item in <code class="inline">enumerable</code>.</p> <p>Each item in <code class="inline">enumerable</code> is passed as argument to the given function <code class="inline">fun</code> and processed by its own task. The tasks will be spawned under the given <code class="inline">supervisor</code> and linked to the current process, similarly to <a href="#async/2"><code class="inline">async/2</code></a>.</p> <p>See <a href="#async_stream/6"><code class="inline">async_stream/6</code></a> for discussion, options, and examples.</p>     <h3 class="detail-header function" id="async_stream/6">  <span class="signature">async_stream(supervisor, enumerable, module, function, args, options \\ [])</span>     </h3>
<pre data-language="elixir">async_stream(<a href="../supervisor/#t:supervisor/0">Supervisor.supervisor</a>(), <a href="../enumerable/#t:t/0">Enumerable.t</a>(), module(), atom(), [term()], keyword()) :: <a href="../enumerable/#t:t/0">Enumerable.t</a>()</pre>  <p>Returns a stream that runs the given <code class="inline">module</code>, <code class="inline">function</code>, and <code class="inline">args</code> concurrently on each item in <code class="inline">enumerable</code>.</p> <p>Each item will be prepended to the given <code class="inline">args</code> and processed by its own task. The tasks will be spawned under the given <code class="inline">supervisor</code> and linked to the current process, similarly to <a href="#async/4"><code class="inline">async/4</code></a>.</p> <p>When streamed, each task will emit <code class="inline">{:ok, value}</code> upon successful completion or <code class="inline">{:exit, reason}</code> if the caller is trapping exits. Results are emitted in the same order as the original <code class="inline">enumerable</code>.</p> <p>The level of concurrency can be controlled via the <code class="inline">:max_concurrency</code> option and defaults to <a href="../system/#schedulers_online/0"><code class="inline">System.schedulers_online/0</code></a>. A timeout can also be given as an option representing the maximum amount of time to wait without a task reply.</p> <p>Finally, if you find yourself trapping exits to handle exits inside the async stream, consider using <a href="#async_stream_nolink/6"><code class="inline">async_stream_nolink/6</code></a> to start tasks that are not linked to the current process.</p> <h4 id="async_stream/6-options" class="section-heading">  Options </h4> <ul> <li>
<code class="inline">:max_concurrency</code> - sets the maximum number of tasks to run at the same time. Defaults to <a href="../system/#schedulers_online/0"><code class="inline">System.schedulers_online/0</code></a>. </li> <li>
<code class="inline">:ordered</code> - whether the results should be returned in the same order as the input stream. This option is useful when you have large streams and don’t want to buffer results before they are delivered. Defaults to <code class="inline">true</code>. </li> <li>
<code class="inline">:timeout</code> - the maximum amount of time to wait (in milliseconds) without receiving a task reply (across all running tasks). Defaults to <code class="inline">5000</code>. </li> <li>
<p><code class="inline">:on_timeout</code> - what do to when a task times out. The possible values are:</p> <ul> <li>
<code class="inline">:exit</code> (default) - the process that spawned the tasks exits. </li> <li>
<code class="inline">:kill_task</code> - the task that timed out is killed. The value emitted for that task is <code class="inline">{:exit, :timeout}</code>. </li> </ul> </li> <li>
<code class="inline">:shutdown</code> - <code class="inline">:brutal_kill</code> if the tasks must be killed directly on shutdown or an integer indicating the timeout value, defaults to 5000 milliseconds. </li> </ul> <h4 id="async_stream/6-examples" class="section-heading">  Examples </h4> <p>Let’s build a stream and then enumerate it:</p> <pre data-language="elixir"><code class="elixir">stream = Task.Supervisor.async_stream(MySupervisor, collection, Mod, :expensive_fun, [])
Enum.to_list(stream)</code></pre>     <h3 class="detail-header function" id="async_stream_nolink/4">  <span class="signature">async_stream_nolink(supervisor, enumerable, fun, options \\ [])</span>     </h3>
<pre data-language="elixir">async_stream_nolink(<a href="../supervisor/#t:supervisor/0">Supervisor.supervisor</a>(), <a href="../enumerable/#t:t/0">Enumerable.t</a>(), (term() -&gt; term()), keyword()) :: <a href="../enumerable/#t:t/0">Enumerable.t</a>()</pre>  <p>Returns a stream that runs the given <code class="inline">function</code> concurrently on each item in <code class="inline">enumerable</code>.</p> <p>Each item in <code class="inline">enumerable</code> is passed as argument to the given function <code class="inline">fun</code> and processed by its own task. The tasks will be spawned under the given <code class="inline">supervisor</code> and will not be linked to the current process, similarly to <a href="#async_nolink/2"><code class="inline">async_nolink/2</code></a>.</p> <p>See <a href="#async_stream/6"><code class="inline">async_stream/6</code></a> for discussion and examples.</p>     <h3 class="detail-header function" id="async_stream_nolink/6">  <span class="signature">async_stream_nolink(supervisor, enumerable, module, function, args, options \\ [])</span>     </h3>
<pre data-language="elixir">async_stream_nolink(<a href="../supervisor/#t:supervisor/0">Supervisor.supervisor</a>(), <a href="../enumerable/#t:t/0">Enumerable.t</a>(), module(), atom(), [term()], keyword()) :: <a href="../enumerable/#t:t/0">Enumerable.t</a>()</pre>  <p>Returns a stream that runs the given <code class="inline">module</code>, <code class="inline">function</code>, and <code class="inline">args</code> concurrently on each item in <code class="inline">enumerable</code>.</p> <p>Each item in <code class="inline">enumerable</code> will be prepended to the given <code class="inline">args</code> and processed by its own task. The tasks will be spawned under the given <code class="inline">supervisor</code> and will not be linked to the current process, similarly to <a href="#async_nolink/4"><code class="inline">async_nolink/4</code></a>.</p> <p>See <a href="#async_stream/6"><code class="inline">async_stream/6</code></a> for discussion, options, and examples.</p>    <h3 class="detail-header function" id="children/1">  <span class="signature">children(supervisor)</span>     </h3>
<pre data-language="elixir">children(<a href="../supervisor/#t:supervisor/0">Supervisor.supervisor</a>()) :: [pid()]</pre>  <p>Returns all children PIDs.</p>     <h3 class="detail-header function" id="start_child/3">  <span class="signature">start_child(supervisor, fun, options \\ [])</span>  </h3>  <p>Starts a task as a child of the given <code class="inline">supervisor</code>.</p> <p>Note that the spawned process is not linked to the caller, but only to the supervisor. This command is useful in case the task needs to perform side-effects (like I/O) and does not need to report back to the caller.</p> <h4 id="start_child/3-options" class="section-heading">  Options </h4> <ul> <li>
<p><code class="inline">:restart</code> - the restart strategy, may be <code class="inline">:temporary</code> (the default), <code class="inline">:transient</code> or <code class="inline">:permanent</code>. <code class="inline">:temporary</code> means the task is never restarted, <code class="inline">:transient</code> means it is restarted if the exit is not <code class="inline">:normal</code>, <code class="inline">:shutdown</code> or <code class="inline">{:shutdown, reason}</code>. A <code class="inline">:permanent</code> restart strategy means it is always restarted. It defaults to <code class="inline">:temporary</code>.</p> </li> <li>
<p><code class="inline">:shutdown</code> - <code class="inline">:brutal_kill</code> if the tasks must be killed directly on shutdown or an integer indicating the timeout value, defaults to 5000 milliseconds.</p> </li> </ul>     <h3 class="detail-header function" id="start_child/5">  <span class="signature">start_child(supervisor, module, fun, args, options \\ [])</span>  </h3>  <p>Starts a task as a child of the given <code class="inline">supervisor</code>.</p> <p>Similar to <a href="#start_child/2"><code class="inline">start_child/2</code></a> except the task is specified by the given <code class="inline">module</code>, <code class="inline">fun</code> and <code class="inline">args</code>.</p>     <h3 class="detail-header function" id="start_link/1">  <span class="signature">start_link(options \\ [])</span>     </h3>
<pre data-language="elixir">start_link([<a href="#t:option/0">option</a>()]) :: <a href="../supervisor/#t:on_start/0">Supervisor.on_start</a>()</pre>  <p>Starts a new supervisor.</p> <p>The supported options are:</p> <ul> <li>
<p><code class="inline">:name</code> - used to register a supervisor name, the supported values are described under the <code class="inline">Name Registration</code> section in the <a href="../genserver/"><code class="inline">GenServer</code></a> module docs;</p> </li> <li>
<p><code class="inline">:max_restarts</code>, <code class="inline">:max_seconds</code> and <code class="inline">:max_children</code> - as specified in <a href="../dynamicsupervisor/"><code class="inline">DynamicSupervisor</code></a>;</p> </li> </ul> <p>This function could also receive <code class="inline">:restart</code> and <code class="inline">:shutdown</code> as options but those two options have been deprecated and it is now preferred to give them directly to <code class="inline">start_child</code> and <code class="inline">async</code> when supported.</p>    <h3 class="detail-header function" id="terminate_child/2">  <span class="signature">terminate_child(supervisor, pid)</span>     </h3>
<pre data-language="elixir">terminate_child(<a href="../supervisor/#t:supervisor/0">Supervisor.supervisor</a>(), pid()) ::
  :ok |
  {:error, :not_found}</pre>  <p>Terminates the child with the given <code class="inline">pid</code>.</p>
<div class="_attribution">
  <p class="_attribution-p">
    © 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://hexdocs.pm/elixir/1.6.0/Task.Supervisor.html" class="_attribution-link" target="_blank">https://hexdocs.pm/elixir/1.6.0/Task.Supervisor.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
