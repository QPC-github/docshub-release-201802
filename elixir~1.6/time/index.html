
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Time - Elixir 1.6 - W3cubDocs</title>
  
  <meta name="description" content=" A Time struct and functions. ">
  <meta name="keywords" content="time, summary, types, functions, -, elixir, elixir~1.6">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/elixir~1.6/time/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-e0f881b0fce8cbe96f33dadc355b7159d5d2912911231446d60eb8f9caffa802.css">
  <script type="text/javascript" src="/assets/application-8fc46316434047265cd383f02b8e7f434ed7dec4a59f920dd633deef8d488d1b.js"></script>
  <script src="/json/elixir~1.6.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/elixir~1.6/" class="_nav-link" title="" style="margin-left:0;">Elixir 1.6</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _elixir">
				
<h1>  Time  </h1>  <p>A Time struct and functions.</p> <p>The Time struct contains the fields hour, minute, second and microseconds. New times can be built with the <a href="#new/4"><code class="inline">new/4</code></a> function or using the <code class="inline">~T</code> sigil:</p> <pre data-language="elixir"><code class="iex elixir">iex&gt; ~T[23:00:07.001]
~T[23:00:07.001]</code></pre> <p>Both <a href="#new/4"><code class="inline">new/4</code></a> and sigil return a struct where the time fields can be accessed directly:</p> <pre data-language="elixir"><code class="iex elixir">iex&gt; time = ~T[23:00:07.001]
iex&gt; time.hour
23
iex&gt; time.microsecond
{1000, 3}</code></pre> <p>The functions on this module work with the <a href="../time/#content"><code class="inline">Time</code></a> struct as well as any struct that contains the same fields as the <a href="../time/#content"><code class="inline">Time</code></a> struct, such as <a href="../naivedatetime/"><code class="inline">NaiveDateTime</code></a> and <a href="../datetime/"><code class="inline">DateTime</code></a>. Such functions expect <a href="../calendar/#t:time/0"><code class="inline">Calendar.time/0</code></a> in their typespecs (instead of <a href="#t:t/0"><code class="inline">t/0</code></a>).</p> <p>Developers should avoid creating the Time structs directly and instead rely on the functions provided by this module as well as the ones in 3rd party calendar libraries.</p> <h2 id="module-comparing-times" class="section-heading">  Comparing times </h2> <p>Comparisons in Elixir using <code class="inline">==</code>, <code class="inline">&gt;</code>, <code class="inline">&lt;</code> and similar are structural and based on the <a href="../time/#content"><code class="inline">Time</code></a> struct fields. For proper comparison between times, use the <a href="#compare/2"><code class="inline">compare/2</code></a> function.</p>   <h1 class="section-heading" id="summary">  Summary </h1> <h2> Types </h2>
<dl class="summary-types summary">   <dt class="summary-signature"> <a href="#t:t/0">t()</a> </dt>  </dl> <h2> Functions </h2>
<dl class="summary-functions summary">   <dt class="summary-signature"> <a href="#add/3">add(time, number, unit \\ :second)</a> </dt> <dd class="summary-synopsis">
<p>Adds the <code class="inline">number</code> of <code class="inline">unit</code>s to the given <code class="inline">time</code></p> </dd>   <dt class="summary-signature"> <a href="#compare/2">compare(time1, time2)</a> </dt> <dd class="summary-synopsis">
<p>Compares two time structs</p> </dd>   <dt class="summary-signature"> <a href="#convert/2">convert(time, calendar)</a> </dt> <dd class="summary-synopsis">
<p>Converts given <code class="inline">time</code> to a different calendar</p> </dd>   <dt class="summary-signature"> <a href="#convert!/2">convert!(time, calendar)</a> </dt> <dd class="summary-synopsis">
<p>Similar to <a href="../time/#convert/2"><code class="inline">Time.convert/2</code></a>, but raises an <a href="../argumenterror/"><code class="inline">ArgumentError</code></a> if the conversion between the two calendars is not possible</p> </dd>   <dt class="summary-signature"> <a href="#diff/3">diff(time1, time2, unit \\ :second)</a> </dt> <dd class="summary-synopsis">
<p>Returns the difference between two times, considering only the hour, minute second and microsecond</p> </dd>   <dt class="summary-signature"> <a href="#from_erl/3">from_erl(tuple, microsecond \\ {0, 0}, calendar \\ Calendar.ISO)</a> </dt> <dd class="summary-synopsis">
<p>Converts an Erlang time tuple to a <a href="../time/#content"><code class="inline">Time</code></a> struct</p> </dd>   <dt class="summary-signature"> <a href="#from_erl!/3">from_erl!(tuple, microsecond \\ {0, 0}, calendar \\ Calendar.ISO)</a> </dt> <dd class="summary-synopsis">
<p>Converts an Erlang time tuple to a <a href="../time/#content"><code class="inline">Time</code></a> struct</p> </dd>   <dt class="summary-signature"> <a href="#from_iso8601/2">from_iso8601(string, calendar \\ Calendar.ISO)</a> </dt> <dd class="summary-synopsis">
<p>Parses the extended “Local time” format described by <a href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank">ISO 8601:2004</a></p> </dd>   <dt class="summary-signature"> <a href="#from_iso8601!/2">from_iso8601!(string, calendar \\ Calendar.ISO)</a> </dt> <dd class="summary-synopsis">
<p>Parses the extended “Local time” format described by <a href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank">ISO 8601:2004</a></p> </dd>   <dt class="summary-signature"> <a href="#new/5">new(hour, minute, second, microsecond \\ {0, 0}, calendar \\ Calendar.ISO)</a> </dt> <dd class="summary-synopsis">
<p>Builds a new time</p> </dd>   <dt class="summary-signature"> <a href="#to_erl/1">to_erl(time)</a> </dt> <dd class="summary-synopsis">
<p>Converts given <code class="inline">time</code> to an Erlang time tuple</p> </dd>   <dt class="summary-signature"> <a href="#to_iso8601/2">to_iso8601(time, format \\ :extended)</a> </dt> <dd class="summary-synopsis">
<p>Converts the given time to <a href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank">ISO 8601:2004</a></p> </dd>   <dt class="summary-signature"> <a href="#to_string/1">to_string(time)</a> </dt> <dd class="summary-synopsis">
<p>Converts the given <code class="inline">time</code> to a string</p> </dd>   <dt class="summary-signature"> <a href="#truncate/2">truncate(time, precision)</a> </dt> <dd class="summary-synopsis">
<p>Returns the given time with the microsecond field truncated to the given precision (<code class="inline">:microsecond</code>, <code class="inline">millisecond</code> or <code class="inline">:second</code>)</p> </dd>   <dt class="summary-signature"> <a href="#utc_now/1">utc_now(calendar \\ Calendar.ISO)</a> </dt> <dd class="summary-synopsis">
<p>Returns the current time in UTC</p> </dd>  </dl>   <h1 class="section-heading" id="types">  Types </h1>   <h3 class="detail-header type" id="t:t/0">  <span class="signature">t()</span>     </h3>
<pre data-language="elixir">t() :: %Time{calendar: <a href="../calendar/#t:calendar/0">Calendar.calendar</a>(), hour: <a href="../calendar/#t:hour/0">Calendar.hour</a>(), microsecond: <a href="../calendar/#t:microsecond/0">Calendar.microsecond</a>(), minute: <a href="../calendar/#t:minute/0">Calendar.minute</a>(), second: <a href="../calendar/#t:second/0">Calendar.second</a>()}</pre>       <h1 class="section-heading" id="functions">  Functions </h1>   <h3 class="detail-header function" id="add/3">  <span class="signature">add(time, number, unit \\ :second)</span>     </h3>
<pre data-language="elixir">add(<a href="../calendar/#t:time/0">Calendar.time</a>(), integer(), <a href="../system/#t:time_unit/0">System.time_unit</a>()) :: <a href="#t:t/0">t</a>()</pre>  <p>Adds the <code class="inline">number</code> of <code class="inline">unit</code>s to the given <code class="inline">time</code>.</p> <p>This function accepts the <code class="inline">number</code> measured according to <a href="../calendar.iso/"><code class="inline">Calendar.ISO</code></a>. The time is returned in the same calendar as it was given in.</p> <p>Note the result value represents the time of day, meaning that it is cyclic, for instance, it will never go over 24 hours for the ISO calendar.</p> <h4 id="add/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Time.add(~T[10:00:00], 27000)
~T[17:30:00.000000]
iex&gt; Time.add(~T[11:00:00.005], 2400)
~T[11:40:00.005000]
iex&gt; Time.add(~T[00:00:00], 86399999, :millisecond)
~T[23:59:59.999000]
iex&gt; Time.add(~T[17:10:05], 86400)
~T[17:10:05.000000]
iex&gt; Time.add(~T[23:00:00], -60)
~T[22:59:00.000000]</code></pre>    <h3 class="detail-header function" id="compare/2">  <span class="signature">compare(time1, time2)</span>     </h3>
<pre data-language="elixir">compare(<a href="../calendar/#t:time/0">Calendar.time</a>(), <a href="../calendar/#t:time/0">Calendar.time</a>()) :: :lt | :eq | :gt</pre>  <p>Compares two time structs.</p> <p>Returns <code class="inline">:gt</code> if first time is later than the second and <code class="inline">:lt</code> for vice versa. If the two times are equal <code class="inline">:eq</code> is returned.</p> <h4 id="compare/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Time.compare(~T[16:04:16], ~T[16:04:28])
:lt
iex&gt; Time.compare(~T[16:04:16], ~T[16:04:16])
:eq
iex&gt; Time.compare(~T[16:04:16.01], ~T[16:04:16.001])
:gt</code></pre> <p>This function can also be used to compare across more complex calendar types by considering only the time fields:</p> <pre data-language="elixir"><code class="iex elixir">iex&gt; Time.compare(~N[1900-01-01 16:04:16], ~N[2015-01-01 16:04:16])
:eq
iex&gt; Time.compare(~N[2015-01-01 16:04:16], ~N[2015-01-01 16:04:28])
:lt
iex&gt; Time.compare(~N[2015-01-01 16:04:16.01], ~N[2000-01-01 16:04:16.001])
:gt</code></pre>    <h3 class="detail-header function" id="convert/2">  <span class="signature">convert(time, calendar)</span>     </h3>
<pre data-language="elixir">convert(<a href="../calendar/#t:time/0">Calendar.time</a>(), <a href="../calendar/#t:calendar/0">Calendar.calendar</a>()) ::
  {:ok, <a href="#t:t/0">t</a>()} |
  {:error, atom()}</pre>  <p>Converts given <code class="inline">time</code> to a different calendar.</p> <p>Returns <code class="inline">{:ok, time}</code> if the conversion was successful, or <code class="inline">{:error, reason}</code> if it was not, for some reason.</p> <h4 id="convert/2-examples" class="section-heading">  Examples </h4> <p>Imagine someone implements <code class="inline">Calendar.Holocene</code>, a calendar based on the Gregorian calendar that adds exactly 10,000 years to the current Gregorian year:</p> <pre data-language="elixir"><code class="iex elixir">iex&gt; Time.convert(~T[13:30:15], Calendar.Holocene)
{:ok, %Time{calendar: Calendar.Holocene, hour: 13, minute: 30, second: 15, microsecond: {0, 0}}}</code></pre>    <h3 class="detail-header function" id="convert!/2">  <span class="signature">convert!(time, calendar)</span>     </h3>
<pre data-language="elixir">convert!(<a href="../calendar/#t:time/0">Calendar.time</a>(), <a href="../calendar/#t:calendar/0">Calendar.calendar</a>()) :: <a href="#t:t/0">t</a>()</pre>  <p>Similar to <a href="../time/#convert/2"><code class="inline">Time.convert/2</code></a>, but raises an <a href="../argumenterror/"><code class="inline">ArgumentError</code></a> if the conversion between the two calendars is not possible.</p> <h4 id="convert!/2-examples" class="section-heading">  Examples </h4> <p>Imagine someone implements <code class="inline">Calendar.Holocene</code>, a calendar based on the Gregorian calendar that adds exactly 10,000 years to the current Gregorian year:</p> <pre data-language="elixir"><code class="iex elixir">iex&gt; Time.convert!(~T[13:30:15], Calendar.Holocene)
%Time{calendar: Calendar.Holocene, hour: 13, minute: 30, second: 15, microsecond: {0, 0}}</code></pre>     <h3 class="detail-header function" id="diff/3">  <span class="signature">diff(time1, time2, unit \\ :second)</span>     </h3>
<pre data-language="elixir">diff(<a href="../calendar/#t:time/0">Calendar.time</a>(), <a href="../calendar/#t:time/0">Calendar.time</a>(), <a href="../system/#t:time_unit/0">System.time_unit</a>()) :: integer()</pre>  <p>Returns the difference between two times, considering only the hour, minute second and microsecond.</p> <p>As with the <a href="#compare/2"><code class="inline">compare/2</code></a> function both <a href="../time/#content"><code class="inline">Time</code></a> structs and other structures containing time can be used. If for instance a <a href="../naivedatetime/"><code class="inline">NaiveDateTime</code></a> or <a href="../datetime/"><code class="inline">DateTime</code></a> is passed, only the hour, month, second, and microsecond is considered. Any additional information about a date or time zone is ignored when calculating the difference.</p> <p>The answer can be returned in any <code class="inline">unit</code> available from <a href="../system/#t:time_unit/0"><code class="inline">System.time_unit/0</code></a>. If the first unit is smaller than the second, a negative number is returned.</p> <p>This function returns the difference in seconds where seconds are measured according to <a href="../calendar.iso/"><code class="inline">Calendar.ISO</code></a>.</p> <h4 id="diff/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Time.diff(~T[00:29:12], ~T[00:29:10])
2

# When passing a [`NaiveDateTime`](NaiveDateTime.html) the date part is ignored.
iex&gt; Time.diff(~N[2017-01-01 00:29:12], ~T[00:29:10])
2

# Two [`NaiveDateTime`](NaiveDateTime.html) structs could have big differences in the date
# but only the time part is considered.
iex&gt; Time.diff(~N[2017-01-01 00:29:12], (~N[1900-02-03 00:29:10]))
2

iex&gt; Time.diff(~T[00:29:12], ~T[00:29:10], :microsecond)
2_000_000
iex&gt; Time.diff(~T[00:29:10], ~T[00:29:12], :microsecond)
-2_000_000</code></pre>      <h3 class="detail-header function" id="from_erl/3">  <span class="signature">from_erl(tuple, microsecond \\ {0, 0}, calendar \\ Calendar.ISO)</span>     </h3>
<pre data-language="elixir">from_erl(:calendar.time(), <a href="../calendar/#t:microsecond/0">Calendar.microsecond</a>(), <a href="../calendar/#t:calendar/0">Calendar.calendar</a>()) ::
  {:ok, <a href="#t:t/0">t</a>()} |
  {:error, atom()}</pre>  <p>Converts an Erlang time tuple to a <a href="../time/#content"><code class="inline">Time</code></a> struct.</p> <h4 id="from_erl/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Time.from_erl({23, 30, 15}, {5000, 3})
{:ok, ~T[23:30:15.005]}
iex&gt; Time.from_erl({24, 30, 15})
{:error, :invalid_time}</code></pre>      <h3 class="detail-header function" id="from_erl!/3">  <span class="signature">from_erl!(tuple, microsecond \\ {0, 0}, calendar \\ Calendar.ISO)</span>     </h3>
<pre data-language="elixir">from_erl!(:calendar.time(), <a href="../calendar/#t:microsecond/0">Calendar.microsecond</a>(), <a href="../calendar/#t:calendar/0">Calendar.calendar</a>()) :: <a href="#t:t/0">t</a>()</pre>  <p>Converts an Erlang time tuple to a <a href="../time/#content"><code class="inline">Time</code></a> struct.</p> <h4 id="from_erl!/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Time.from_erl!({23, 30, 15})
~T[23:30:15]
iex&gt; Time.from_erl!({23, 30, 15}, {5000, 3})
~T[23:30:15.005]
iex&gt; Time.from_erl!({24, 30, 15})
** (ArgumentError) cannot convert {24, 30, 15} to time, reason: :invalid_time</code></pre>     <h3 class="detail-header function" id="from_iso8601/2">  <span class="signature">from_iso8601(string, calendar \\ Calendar.ISO)</span>     </h3>
<pre data-language="elixir">from_iso8601(<a href="../string/#t:t/0">String.t</a>(), <a href="../calendar/#t:calendar/0">Calendar.calendar</a>()) ::
  {:ok, <a href="#t:t/0">t</a>()} |
  {:error, atom()}</pre>  <p>Parses the extended “Local time” format described by <a href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank">ISO 8601:2004</a>.</p> <p>Timezone offset may be included in the string but they will be simply discarded as such information is not included in times.</p> <p>As specified in the standard, the separator “T” may be omitted if desired as there is no ambiguity within this function.</p> <p>Time representations with reduced accuracy are not supported.</p> <p>Note that while ISO 8601 allows times to specify 24:00:00 as the zero hour of the next day, this notation is not supported by Elixir.</p> <h4 id="from_iso8601/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Time.from_iso8601("23:50:07")
{:ok, ~T[23:50:07]}
iex&gt; Time.from_iso8601("23:50:07Z")
{:ok, ~T[23:50:07]}
iex&gt; Time.from_iso8601("T23:50:07Z")
{:ok, ~T[23:50:07]}

iex&gt; Time.from_iso8601("23:50:07,0123456")
{:ok, ~T[23:50:07.012345]}
iex&gt; Time.from_iso8601("23:50:07.0123456")
{:ok, ~T[23:50:07.012345]}
iex&gt; Time.from_iso8601("23:50:07.123Z")
{:ok, ~T[23:50:07.123]}

iex&gt; Time.from_iso8601("2015:01:23 23-50-07")
{:error, :invalid_format}
iex&gt; Time.from_iso8601("23:50:07A")
{:error, :invalid_format}
iex&gt; Time.from_iso8601("23:50:07.")
{:error, :invalid_format}
iex&gt; Time.from_iso8601("23:50:61")
{:error, :invalid_time}</code></pre>     <h3 class="detail-header function" id="from_iso8601!/2">  <span class="signature">from_iso8601!(string, calendar \\ Calendar.ISO)</span>     </h3>
<pre data-language="elixir">from_iso8601!(<a href="../string/#t:t/0">String.t</a>(), <a href="../calendar/#t:calendar/0">Calendar.calendar</a>()) :: <a href="#t:t/0">t</a>()</pre>  <p>Parses the extended “Local time” format described by <a href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank">ISO 8601:2004</a>.</p> <p>Raises if the format is invalid.</p> <h4 id="from_iso8601!/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Time.from_iso8601!("23:50:07,123Z")
~T[23:50:07.123]
iex&gt; Time.from_iso8601!("23:50:07.123Z")
~T[23:50:07.123]
iex&gt; Time.from_iso8601!("2015:01:23 23-50-07")
** (ArgumentError) cannot parse "2015:01:23 23-50-07" as time, reason: :invalid_format</code></pre>      <h3 class="detail-header function" id="new/5">  <span class="signature">new(hour, minute, second, microsecond \\ {0, 0}, calendar \\ Calendar.ISO)</span>     </h3>
<pre data-language="elixir">new(<a href="../calendar/#t:hour/0">Calendar.hour</a>(), <a href="../calendar/#t:minute/0">Calendar.minute</a>(), <a href="../calendar/#t:second/0">Calendar.second</a>(), <a href="../calendar/#t:microsecond/0">Calendar.microsecond</a>() | integer(), <a href="../calendar/#t:calendar/0">Calendar.calendar</a>()) ::
  {:ok, <a href="#t:t/0">t</a>()} |
  {:error, atom()}</pre>  <p>Builds a new time.</p> <p>Expects all values to be integers. Returns <code class="inline">{:ok, time}</code> if each entry fits its appropriate range, returns <code class="inline">{:error, reason}</code> otherwise.</p> <p>Note a time may have 60 seconds in case of leap seconds. Microseconds can also be given with a precision, which must be an integer between 0 and 6.</p> <h4 id="new/5-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Time.new(0, 0, 0, 0)
{:ok, ~T[00:00:00.000000]}
iex&gt; Time.new(23, 59, 59, 999_999)
{:ok, ~T[23:59:59.999999]}
iex&gt; Time.new(23, 59, 60, 999_999)
{:ok, ~T[23:59:60.999999]}

# Time with microseconds and their precision
iex&gt; Time.new(23, 59, 60, {10_000, 2})
{:ok, ~T[23:59:60.01]}

iex&gt; Time.new(24, 59, 59, 999_999)
{:error, :invalid_time}
iex&gt; Time.new(23, 60, 59, 999_999)
{:error, :invalid_time}
iex&gt; Time.new(23, 59, 61, 999_999)
{:error, :invalid_time}
iex&gt; Time.new(23, 59, 59, 1_000_000)
{:error, :invalid_time}

# Invalid precision
Time.new(23, 59, 59, {999_999, 10})
{:error, :invalid_time}</code></pre>    <h3 class="detail-header function" id="to_erl/1">  <span class="signature">to_erl(time)</span>     </h3>
<pre data-language="elixir">to_erl(<a href="../calendar/#t:time/0">Calendar.time</a>()) :: :calendar.time()</pre>  <p>Converts given <code class="inline">time</code> to an Erlang time tuple.</p> <p>WARNING: Loss of precision may occur, as Erlang time tuples only contain hours/minutes/seconds.</p> <h4 id="to_erl/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Time.to_erl(~T[23:30:15.999])
{23, 30, 15}

iex&gt; Time.to_erl(~N[2010-04-17 23:30:15.999])
{23, 30, 15}</code></pre>     <h3 class="detail-header function" id="to_iso8601/2">  <span class="signature">to_iso8601(time, format \\ :extended)</span>     </h3>
<pre data-language="elixir">to_iso8601(<a href="../calendar/#t:time/0">Calendar.time</a>(), :extended | :basic) :: <a href="../string/#t:t/0">String.t</a>()</pre>  <p>Converts the given time to <a href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank">ISO 8601:2004</a>.</p> <p>By default, <a href="../time/#to_iso8601/2"><code class="inline">Time.to_iso8601/2</code></a> returns times formatted in the “extended” format, for human readability. It also supports the “basic” format through passing the <code class="inline">:basic</code> option.</p> <h3 id="to_iso8601/2-examples" class="section-heading">  Examples </h3> <pre data-language="elixir"><code class="iex elixir">iex&gt; Time.to_iso8601(~T[23:00:13])
"23:00:13"

iex&gt; Time.to_iso8601(~T[23:00:13.001])
"23:00:13.001"

iex&gt; Time.to_iso8601(~T[23:00:13.001], :basic)
"230013.001"

iex&gt; Time.to_iso8601(~N[2010-04-17 23:00:13])
"23:00:13"</code></pre>    <h3 class="detail-header function" id="to_string/1">  <span class="signature">to_string(time)</span>     </h3>
<pre data-language="elixir">to_string(<a href="../calendar/#t:time/0">Calendar.time</a>()) :: <a href="../string/#t:t/0">String.t</a>()</pre>  <p>Converts the given <code class="inline">time</code> to a string.</p> <h3 id="to_string/1-examples" class="section-heading">  Examples </h3> <pre data-language="elixir"><code class="iex elixir">iex&gt; Time.to_string(~T[23:00:00])
"23:00:00"
iex&gt; Time.to_string(~T[23:00:00.001])
"23:00:00.001"
iex&gt; Time.to_string(~T[23:00:00.123456])
"23:00:00.123456"

iex&gt; Time.to_string(~N[2015-01-01 23:00:00.001])
"23:00:00.001"
iex&gt; Time.to_string(~N[2015-01-01 23:00:00.123456])
"23:00:00.123456"</code></pre>    <h3 class="detail-header function" id="truncate/2">  <span class="signature">truncate(time, precision)</span>     </h3>
<pre data-language="elixir">truncate(<a href="#t:t/0">t</a>(), :microsecond | :millisecond | :second) :: <a href="#t:t/0">t</a>()</pre>  <p>Returns the given time with the microsecond field truncated to the given precision (<code class="inline">:microsecond</code>, <code class="inline">millisecond</code> or <code class="inline">:second</code>).</p> <h4 id="truncate/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Time.truncate(~T[01:01:01.123456], :microsecond)
~T[01:01:01.123456]

iex&gt; Time.truncate(~T[01:01:01.123456], :millisecond)
~T[01:01:01.123]

iex&gt; Time.truncate(~T[01:01:01.123456], :second)
~T[01:01:01]</code></pre>     <h3 class="detail-header function" id="utc_now/1">  <span class="signature">utc_now(calendar \\ Calendar.ISO)</span>     </h3>
<pre data-language="elixir">utc_now(<a href="../calendar/#t:calendar/0">Calendar.calendar</a>()) :: <a href="#t:t/0">t</a>()</pre>  <p>Returns the current time in UTC.</p> <h4 id="utc_now/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; time = Time.utc_now()
iex&gt; time.hour &gt;= 0
true</code></pre>
<div class="_attribution">
  <p class="_attribution-p">
    © 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://hexdocs.pm/elixir/1.6.0/Time.html" class="_attribution-link" target="_blank">https://hexdocs.pm/elixir/1.6.0/Time.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
