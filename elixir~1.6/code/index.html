
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Code - Elixir 1.6 - W3cubDocs</title>
  
  <meta name="description" content=" Utilities for managing code compilation, code evaluation, and code loading. ">
  <meta name="keywords" content="code, summary, functions, -, elixir, elixir~1.6">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/elixir~1.6/code/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-e0f881b0fce8cbe96f33dadc355b7159d5d2912911231446d60eb8f9caffa802.css">
  <script type="text/javascript" src="/assets/application-8fc46316434047265cd383f02b8e7f434ed7dec4a59f920dd633deef8d488d1b.js"></script>
  <script src="/json/elixir~1.6.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/elixir~1.6/" class="_nav-link" title="" style="margin-left:0;">Elixir 1.6</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _elixir">
				
<h1>  Code  </h1>  <p>Utilities for managing code compilation, code evaluation, and code loading.</p> <p>This module complements Erlang’s <a href="http://www.erlang.org/doc/man/code.html" target="_blank"><code class="inline">:code</code> module</a> to add behaviour which is specific to Elixir. Almost all of the functions in this module have global side effects on the behaviour of Elixir.</p>   <h1 class="section-heading" id="summary">  Summary </h1> <h2> Functions </h2>
<dl class="summary-functions summary">   <dt class="summary-signature"> <a href="#append_path/1">append_path(path)</a> </dt> <dd class="summary-synopsis">
<p>Appends a path to the end of the Erlang VM code path list</p> </dd>   <dt class="summary-signature"> <a href="#available_compiler_options/0">available_compiler_options()</a> </dt> <dd class="summary-synopsis">
<p>Returns a list with the available compiler options</p> </dd>   <dt class="summary-signature"> <a href="#compile_quoted/2">compile_quoted(quoted, file \\ "nofile")</a> </dt> <dd class="summary-synopsis">
<p>Compiles the quoted expression</p> </dd>   <dt class="summary-signature"> <a href="#compile_string/2">compile_string(string, file \\ "nofile")</a> </dt> <dd class="summary-synopsis">
<p>Compiles the given string</p> </dd>   <dt class="summary-signature"> <a href="#compiler_options/0">compiler_options()</a> </dt> <dd class="summary-synopsis">
<p>Gets the compilation options from the code server</p> </dd>   <dt class="summary-signature"> <a href="#compiler_options/1">compiler_options(opts)</a> </dt> <dd class="summary-synopsis">
<p>Sets compilation options</p> </dd>   <dt class="summary-signature"> <a href="#delete_path/1">delete_path(path)</a> </dt> <dd class="summary-synopsis">
<p>Deletes a path from the Erlang VM code path list. This is the list of directories the Erlang VM uses for finding module code</p> </dd>   <dt class="summary-signature"> <a href="#ensure_compiled/1">ensure_compiled(module)</a> </dt> <dd class="summary-synopsis">
<p>Ensures the given module is compiled and loaded</p> </dd>   <dt class="summary-signature"> <a href="#ensure_compiled?/1">ensure_compiled?(module)</a> </dt> <dd class="summary-synopsis">
<p>Ensures the given module is compiled and loaded</p> </dd>   <dt class="summary-signature"> <a href="#ensure_loaded/1">ensure_loaded(module)</a> </dt> <dd class="summary-synopsis">
<p>Ensures the given module is loaded</p> </dd>   <dt class="summary-signature"> <a href="#ensure_loaded?/1">ensure_loaded?(module)</a> </dt> <dd class="summary-synopsis">
<p>Ensures the given module is loaded</p> </dd>   <dt class="summary-signature"> <a href="#eval_file/2">eval_file(file, relative_to \\ nil)</a> </dt> <dd class="summary-synopsis">
<p>Evals the given file</p> </dd>   <dt class="summary-signature"> <a href="#eval_quoted/3">eval_quoted(quoted, binding \\ [], opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Evaluates the quoted contents</p> </dd>   <dt class="summary-signature"> <a href="#eval_string/3">eval_string(string, binding \\ [], opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Evaluates the contents given by <code class="inline">string</code></p> </dd>   <dt class="summary-signature"> <a href="#format_file!/2">format_file!(file, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Formats a file</p> </dd>   <dt class="summary-signature"> <a href="#format_string!/2">format_string!(string, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Formats the given code <code class="inline">string</code></p> </dd>   <dt class="summary-signature"> <a href="#get_docs/2">get_docs(module, kind)</a> </dt> <dd class="summary-synopsis">
<p>Returns the docs for the given module</p> </dd>   <dt class="summary-signature"> <a href="#load_file/2">load_file(file, relative_to \\ nil)</a> </dt> <dd class="summary-synopsis">
<p>Loads the given file</p> </dd>   <dt class="summary-signature"> <a href="#loaded_files/0">loaded_files()</a> </dt> <dd class="summary-synopsis">
<p>Lists all loaded files</p> </dd>   <dt class="summary-signature"> <a href="#prepend_path/1">prepend_path(path)</a> </dt> <dd class="summary-synopsis">
<p>Prepends a path to the beginning of the Erlang VM code path list</p> </dd>   <dt class="summary-signature"> <a href="#require_file/2">require_file(file, relative_to \\ nil)</a> </dt> <dd class="summary-synopsis">
<p>Requires the given <code class="inline">file</code></p> </dd>   <dt class="summary-signature"> <a href="#string_to_quoted/2">string_to_quoted(string, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Converts the given string to its quoted form</p> </dd>   <dt class="summary-signature"> <a href="#string_to_quoted!/2">string_to_quoted!(string, opts \\ [])</a> </dt> <dd class="summary-synopsis">
<p>Converts the given string to its quoted form</p> </dd>   <dt class="summary-signature"> <a href="#unload_files/1">unload_files(files)</a> </dt> <dd class="summary-synopsis">
<p>Removes files from the loaded files list</p> </dd>  </dl>   <h1 class="section-heading" id="functions">  Functions </h1>  <h3 class="detail-header function" id="append_path/1">  <span class="signature">append_path(path)</span>     </h3>
<pre data-language="elixir">append_path(<a href="../path/#t:t/0">Path.t</a>()) :: true | {:error, :bad_directory}</pre>  <p>Appends a path to the end of the Erlang VM code path list.</p> <p>This is the list of directories the Erlang VM uses for finding module code.</p> <p>The path is expanded with <a href="../path/#expand/1"><code class="inline">Path.expand/1</code></a> before being appended. If this path does not exist, an error is returned.</p> <h4 id="append_path/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="elixir">Code.append_path(".")
#=&gt; true

Code.append_path("/does_not_exist")
#=&gt; {:error, :bad_directory}</code></pre>    <h3 class="detail-header function" id="available_compiler_options/0">  <span class="signature">available_compiler_options()</span>     </h3>
<pre data-language="elixir">available_compiler_options() :: [atom()]</pre>  <p>Returns a list with the available compiler options.</p> <p>See <a href="#compiler_options/1"><code class="inline">compiler_options/1</code></a> for more info.</p> <h4 id="available_compiler_options/0-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Code.available_compiler_options
[:docs, :debug_info, :ignore_module_conflict, :relative_paths, :warnings_as_errors]</code></pre>     <h3 class="detail-header function" id="compile_quoted/2">  <span class="signature">compile_quoted(quoted, file \\ "nofile")</span>     </h3>
<pre data-language="elixir">compile_quoted(<a href="../macro/#t:t/0">Macro.t</a>(), binary()) :: [{module(), binary()}]</pre>  <p>Compiles the quoted expression.</p> <p>Returns a list of tuples where the first element is the module name and the second one is its bytecode (as a binary). A <code class="inline">file</code> can be given as second argument which will be used for reporting warnings and errors.</p>     <h3 class="detail-header function" id="compile_string/2">  <span class="signature">compile_string(string, file \\ "nofile")</span>     </h3>
<pre data-language="elixir">compile_string(<a href="../list.chars/#t:t/0">List.Chars.t</a>(), binary()) :: [{module(), binary()}]</pre>  <p>Compiles the given string.</p> <p>Returns a list of tuples where the first element is the module name and the second one is its bytecode (as a binary). A <code class="inline">file</code> can be given as second argument which will be used for reporting warnings and errors.</p> <p>For compiling many files at once, check <a href="../kernel.parallelcompiler/#compile/2"><code class="inline">Kernel.ParallelCompiler.compile/2</code></a>.</p>    <h3 class="detail-header function" id="compiler_options/0">  <span class="signature">compiler_options()</span>     </h3>
<pre data-language="elixir">compiler_options() :: %{optional(atom()) =&gt; boolean()}</pre>  <p>Gets the compilation options from the code server.</p> <p>Check <a href="#compiler_options/1"><code class="inline">compiler_options/1</code></a> for more information.</p> <h4 id="compiler_options/0-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="elixir">Code.compiler_options()
#=&gt; %{debug_info: true, docs: true,
#=&gt;   warnings_as_errors: false, ignore_module_conflict: false}</code></pre>    <h3 class="detail-header function" id="compiler_options/1">  <span class="signature">compiler_options(opts)</span>     </h3>
<pre data-language="elixir">compiler_options(<a href="../enumerable/#t:t/0">Enumerable.t</a>()) :: %{optional(atom()) =&gt; boolean()}</pre>  <p>Sets compilation options.</p> <p>These options are global since they are stored by Elixir’s Code Server.</p> <p>Available options are:</p> <ul> <li>
<p><code class="inline">:docs</code> - when <code class="inline">true</code>, retain documentation in the compiled module. Defaults to <code class="inline">true</code>.</p> </li> <li>
<p><code class="inline">:debug_info</code> - when <code class="inline">true</code>, retain debug information in the compiled module. This allows a developer to reconstruct the original source code. Defaults to <code class="inline">false</code>.</p> </li> <li>
<p><code class="inline">:ignore_module_conflict</code> - when <code class="inline">true</code>, override modules that were already defined without raising errors. Defaults to <code class="inline">false</code>.</p> </li> <li>
<p><code class="inline">:relative_paths</code> - when <code class="inline">true</code>, use relative paths in quoted nodes, warnings and errors generated by the compiler. Note disabling this option won’t affect runtime warnings and errors. Defaults to <code class="inline">true</code>.</p> </li> <li>
<p><code class="inline">:warnings_as_errors</code> - causes compilation to fail when warnings are generated. Defaults to <code class="inline">false</code>.</p> </li> </ul> <p>It returns the new map of compiler options.</p> <h4 id="compiler_options/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="elixir">Code.compiler_options(debug_info: true)
#=&gt; %{debug_info: true, docs: true,
#=&gt;   warnings_as_errors: false, ignore_module_conflict: false}</code></pre>    <h3 class="detail-header function" id="delete_path/1">  <span class="signature">delete_path(path)</span>     </h3>
<pre data-language="elixir">delete_path(<a href="../path/#t:t/0">Path.t</a>()) :: boolean()</pre>  <p>Deletes a path from the Erlang VM code path list. This is the list of directories the Erlang VM uses for finding module code.</p> <p>The path is expanded with <a href="../path/#expand/1"><code class="inline">Path.expand/1</code></a> before being deleted. If the path does not exist, this function returns <code class="inline">false</code>.</p> <h4 id="delete_path/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="elixir">Code.prepend_path(".")
Code.delete_path(".")
#=&gt; true

Code.delete_path("/does_not_exist")
#=&gt; false</code></pre>    <h3 class="detail-header function" id="ensure_compiled/1">  <span class="signature">ensure_compiled(module)</span>     </h3>
<pre data-language="elixir">ensure_compiled(module()) ::
  {:module, module()} |
  {:error, :embedded | :badfile | :nofile | :on_load_failure}</pre>  <p>Ensures the given module is compiled and loaded.</p> <p>If the module is already loaded, it works as no-op. If the module was not loaded yet, it checks if it needs to be compiled first and then tries to load it.</p> <p>If it succeeds in loading the module, it returns <code class="inline">{:module, module}</code>. If not, returns <code class="inline">{:error, reason}</code> with the error reason.</p> <p>Check <a href="#ensure_loaded/1"><code class="inline">ensure_loaded/1</code></a> for more information on module loading and when to use <a href="#ensure_loaded/1"><code class="inline">ensure_loaded/1</code></a> or <a href="#ensure_compiled/1"><code class="inline">ensure_compiled/1</code></a>.</p>    <h3 class="detail-header function" id="ensure_compiled?/1">  <span class="signature">ensure_compiled?(module)</span>     </h3>
<pre data-language="elixir">ensure_compiled?(module()) :: boolean()</pre>  <p>Ensures the given module is compiled and loaded.</p> <p>Similar to <a href="#ensure_compiled/1"><code class="inline">ensure_compiled/1</code></a>, but returns <code class="inline">true</code> if the module is already loaded or was successfully loaded and compiled. Returns <code class="inline">false</code> otherwise.</p>    <h3 class="detail-header function" id="ensure_loaded/1">  <span class="signature">ensure_loaded(module)</span>     </h3>
<pre data-language="elixir">ensure_loaded(module()) ::
  {:module, module()} |
  {:error, :embedded | :badfile | :nofile | :on_load_failure}</pre>  <p>Ensures the given module is loaded.</p> <p>If the module is already loaded, this works as no-op. If the module was not yet loaded, it tries to load it.</p> <p>If it succeeds in loading the module, it returns <code class="inline">{:module, module}</code>. If not, returns <code class="inline">{:error, reason}</code> with the error reason.</p> <h4 id="ensure_loaded/1-code-loading-on-the-erlang-vm" class="section-heading">  Code loading on the Erlang VM </h4> <p>Erlang has two modes to load code: interactive and embedded.</p> <p>By default, the Erlang VM runs in interactive mode, where modules are loaded as needed. In embedded mode the opposite happens, as all modules need to be loaded upfront or explicitly.</p> <p>Therefore, this function is used to check if a module is loaded before using it and allows one to react accordingly. For example, the <a href="../uri/"><code class="inline">URI</code></a> module uses this function to check if a specific parser exists for a given URI scheme.</p> <h4 id="ensure_loaded/1-ensure_compiled-1" class="section-heading">  <a href="#ensure_compiled/1"><code class="inline">ensure_compiled/1</code></a> </h4> <p>Elixir also contains an <a href="#ensure_compiled/1"><code class="inline">ensure_compiled/1</code></a> function that is a superset of <a href="#ensure_loaded/1"><code class="inline">ensure_loaded/1</code></a>.</p> <p>Since Elixir’s compilation happens in parallel, in some situations you may need to use a module that was not yet compiled, therefore it can’t even be loaded.</p> <p>When invoked, <a href="#ensure_compiled/1"><code class="inline">ensure_compiled/1</code></a> halts the compilation of the caller until the module given to <a href="#ensure_compiled/1"><code class="inline">ensure_compiled/1</code></a> becomes available or all files for the current project have been compiled. If compilation finishes and the module is not available, an error tuple is returned.</p> <p><a href="#ensure_compiled/1"><code class="inline">ensure_compiled/1</code></a> does not apply to dependencies, as dependencies must be compiled upfront.</p> <p>In most cases, <a href="#ensure_loaded/1"><code class="inline">ensure_loaded/1</code></a> is enough. <a href="#ensure_compiled/1"><code class="inline">ensure_compiled/1</code></a> must be used in rare cases, usually involving macros that need to invoke a module for callback information.</p> <h4 id="ensure_loaded/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Code.ensure_loaded(Atom)
{:module, Atom}

iex&gt; Code.ensure_loaded(DoesNotExist)
{:error, :nofile}</code></pre>    <h3 class="detail-header function" id="ensure_loaded?/1">  <span class="signature">ensure_loaded?(module)</span>     </h3>
<pre data-language="elixir">ensure_loaded?(module()) :: boolean()</pre>  <p>Ensures the given module is loaded.</p> <p>Similar to <a href="#ensure_loaded/1"><code class="inline">ensure_loaded/1</code></a>, but returns <code class="inline">true</code> if the module is already loaded or was successfully loaded. Returns <code class="inline">false</code> otherwise.</p> <h4 id="ensure_loaded?/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Code.ensure_loaded?(Atom)
true</code></pre>     <h3 class="detail-header function" id="eval_file/2">  <span class="signature">eval_file(file, relative_to \\ nil)</span>     </h3>
<pre data-language="elixir">eval_file(binary(), nil | binary()) :: {term(), binding :: list()}</pre>  <p>Evals the given file.</p> <p>Accepts <code class="inline">relative_to</code> as an argument to tell where the file is located.</p> <p>While <a href="#load_file/2"><code class="inline">load_file/2</code></a> loads a file and returns the loaded modules and their byte code, <a href="#eval_file/2"><code class="inline">eval_file/2</code></a> simply evaluates the file contents and returns the evaluation result and its bindings (exactly the same return value as <a href="#eval_string/3"><code class="inline">eval_string/3</code></a>).</p>      <h3 class="detail-header function" id="eval_quoted/3">  <span class="signature">eval_quoted(quoted, binding \\ [], opts \\ [])</span>     </h3>
<pre data-language="elixir">eval_quoted(<a href="../macro/#t:t/0">Macro.t</a>(), list(), <a href="../macro.env/#t:t/0">Macro.Env.t</a>() | keyword()) :: {term(), binding :: list()}</pre>  <p>Evaluates the quoted contents.</p> <p><strong>Warning</strong>: Calling this function inside a macro is considered bad practice as it will attempt to evaluate runtime values at compile time. Macro arguments are typically transformed by unquoting them into the returned quoted expressions (instead of evaluated).</p> <p>See <a href="#eval_string/3"><code class="inline">eval_string/3</code></a> for a description of bindings and options.</p> <h4 id="eval_quoted/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; contents = quote(do: var!(a) + var!(b))
iex&gt; Code.eval_quoted(contents, [a: 1, b: 2], file: __ENV__.file, line: __ENV__.line)
{3, [a: 1, b: 2]}</code></pre> <p>For convenience, you can pass <code class="inline">__ENV__/0</code> as the <code class="inline">opts</code> argument and all options will be automatically extracted from the current environment:</p> <pre data-language="elixir"><code class="iex elixir">iex&gt; contents = quote(do: var!(a) + var!(b))
iex&gt; Code.eval_quoted(contents, [a: 1, b: 2], __ENV__)
{3, [a: 1, b: 2]}</code></pre>      <h3 class="detail-header function" id="eval_string/3">  <span class="signature">eval_string(string, binding \\ [], opts \\ [])</span>     </h3>
<pre data-language="elixir">eval_string(<a href="../list.chars/#t:t/0">List.Chars.t</a>(), list(), <a href="../macro.env/#t:t/0">Macro.Env.t</a>() | keyword()) :: {term(), binding :: list()}</pre>  <p>Evaluates the contents given by <code class="inline">string</code>.</p> <p>The <code class="inline">binding</code> argument is a keyword list of variable bindings. The <code class="inline">opts</code> argument is a keyword list of environment options.</p> <p><strong>Warning</strong>: <code class="inline">string</code> can be any Elixir code and will be executed with the same privileges as the Erlang VM: this means that such code could compromise the machine (for example by executing system commands). Don’t use <a href="#eval_string/3"><code class="inline">eval_string/3</code></a> with untrusted input (such as strings coming from the network).</p> <h4 id="eval_string/3-options" class="section-heading">  Options </h4> <p>Options can be:</p> <ul> <li>
<p><code class="inline">:file</code> - the file to be considered in the evaluation</p> </li> <li>
<p><code class="inline">:line</code> - the line on which the script starts</p> </li> </ul> <p>Additionally, the following scope values can be configured:</p> <ul> <li>
<p><code class="inline">:aliases</code> - a list of tuples with the alias and its target</p> </li> <li>
<p><code class="inline">:requires</code> - a list of modules required</p> </li> <li>
<p><code class="inline">:functions</code> - a list of tuples where the first element is a module and the second a list of imported function names and arity; the list of function names and arity must be sorted</p> </li> <li>
<p><code class="inline">:macros</code> - a list of tuples where the first element is a module and the second a list of imported macro names and arity; the list of function names and arity must be sorted</p> </li> </ul> <p>Notice that setting any of the values above overrides Elixir’s default values. For example, setting <code class="inline">:requires</code> to <code class="inline">[]</code> will no longer automatically require the <a href="../kernel/"><code class="inline">Kernel</code></a> module. In the same way setting <code class="inline">:macros</code> will no longer auto-import <a href="../kernel/"><code class="inline">Kernel</code></a> macros like <a href="../kernel/#if/2"><code class="inline">Kernel.if/2</code></a>, <a href="../kernel.specialforms/#case/2"><code class="inline">Kernel.SpecialForms.case/2</code></a>, and so on.</p> <p>Returns a tuple of the form <code class="inline">{value, binding}</code>, where <code class="inline">value</code> is the value returned from evaluating <code class="inline">string</code>. If an error occurs while evaluating <code class="inline">string</code> an exception will be raised.</p> <p><code class="inline">binding</code> is a keyword list with the value of all variable bindings after evaluating <code class="inline">string</code>. The binding key is usually an atom, but it may be a tuple for variables defined in a different context.</p> <h4 id="eval_string/3-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="iex elixir">iex&gt; Code.eval_string("a + b", [a: 1, b: 2], file: __ENV__.file, line: __ENV__.line)
{3, [a: 1, b: 2]}

iex&gt; Code.eval_string("c = a + b", [a: 1, b: 2], __ENV__)
{3, [a: 1, b: 2, c: 3]}

iex&gt; Code.eval_string("a = a + b", [a: 1, b: 2])
{3, [a: 3, b: 2]}</code></pre> <p>For convenience, you can pass <code class="inline">__ENV__/0</code> as the <code class="inline">opts</code> argument and all imports, requires and aliases defined in the current environment will be automatically carried over:</p> <pre data-language="elixir"><code class="iex elixir">iex&gt; Code.eval_string("a + b", [a: 1, b: 2], __ENV__)
{3, [a: 1, b: 2]}</code></pre>     <h3 class="detail-header function" id="format_file!/2">  <span class="signature">format_file!(file, opts \\ [])</span>     </h3>
<pre data-language="elixir">format_file!(binary(), keyword()) :: iodata()</pre>  <p>Formats a file.</p> <p>See <a href="#format_string!/2"><code class="inline">format_string!/2</code></a> for more information on code formatting and available options.</p>     <h3 class="detail-header function" id="format_string!/2">  <span class="signature">format_string!(string, opts \\ [])</span>     </h3>
<pre data-language="elixir">format_string!(binary(), keyword()) :: iodata()</pre>  <p>Formats the given code <code class="inline">string</code>.</p> <p>The formatter receives a string representing Elixir code and returns iodata representing the formatted code according to pre-defined rules.</p> <h4 id="format_string!/2-options" class="section-heading">  Options </h4> <ul> <li>
<p><code class="inline">:file</code> - the file which contains the string, used for error reporting</p> </li> <li>
<p><code class="inline">:line</code> - the line the string starts, used for error reporting</p> </li> <li>
<p><code class="inline">:line_length</code> - the line length to aim for when formatting the document. Defaults to 98.</p> </li> <li>
<p><code class="inline">:locals_without_parens</code> - a keyword list of name and arity pairs that should be kept without parens whenever possible. The arity may be the atom <code class="inline">:*</code>, which implies all arities of that name. The formatter already includes a list of functions and this option augments this list.</p> </li> <li>
<p><code class="inline">:rename_deprecated_at</code> - rename all known deprecated functions at the given version to their non-deprecated equivalent. It expects a valid <a href="../version/"><code class="inline">Version</code></a> which is usually the minimum Elixir version supported by the project.</p> </li> </ul> <h4 id="format_string!/2-design-principles" class="section-heading">  Design principles </h4> <p>The formatter was designed under three principles.</p> <p>First, the formatter never changes the semantics of the code by default. This means the input AST and the output AST are equivalent. Optional behaviour, such as <code class="inline">:rename_deprecated_at</code>, is allowed to break this guarantee.</p> <p>The second principle is to provide as little configuration as possible. This eases the formatter adoption by removing contention points while making sure a single style is followed consistently by the community as a whole.</p> <p>The formatter does not hard code names. The formatter will not behave specially because a function is named <code class="inline">defmodule</code>, <code class="inline">def</code>, etc. This principle mirrors Elixir’s goal of being an extensible language where developers can extend the language with new constructs as if they were part of the language. When it is absolutely necessary to change behaviour based on the name, this behaviour should be configurable, such as the <code class="inline">:locals_without_parens</code> option.</p> <h4 id="format_string!/2-keeping-user-s-formatting" class="section-heading">  Keeping user’s formatting </h4> <p>The formatter respects the input format in some cases. Those are listed below:</p> <ul> <li>
<p>Insignificant digits in numbers are kept as is. The formatter however always inserts underscores for decimal numbers with more than 5 digits and converts hexadecimal digits to uppercase</p> </li> <li>
<p>Strings, charlists, atoms and sigils are kept as is. No character is automatically escaped or unescaped. The choice of delimiter is also respected from the input</p> </li> <li>
<p>Newlines inside blocks are kept as in the input except for: 1) expressions that take multiple lines will always have an empty line before and after and 2) empty lines are always squeezed together into a single empty line</p> </li> <li>
<p>The choice between <code class="inline">:do</code> keyword and <code class="inline">do/end</code> blocks is left to the user</p> </li> <li>
<p>Lists, tuples, bitstrings, maps, structs and function calls will be broken into multiple lines if they are followed by a newline in the opening bracket and preceded by a new line in the closing bracket</p> </li> <li>
<p>Pipeline operators, like <code class="inline">|&gt;</code> and others with the same precedence, will span multiple lines if they spanned multiple lines in the input</p> </li> </ul> <p>The behaviours above are not guaranteed. We may remove or add new rules in the future. The goal of documenting them is to provide better understanding on what to expect from the formatter.</p> <h4 id="format_string!/2-adjusting-formatted-output" class="section-heading">  Adjusting formatted output </h4> <p>The formatter attempts to the fit the most it can on a single line. When the code does not fit a single line, the formatter introduces line breaks in the code.</p> <p>In some rare situations, this may lead to undesired formatting. For example, the code below:</p> <pre data-language="elixir"><code class="elixir">"this is a very long string ... #{inspect(some_value)}"</code></pre> <p>may be formatted as:</p> <pre data-language="elixir"><code class="elixir">"this is a very long string ... #{
  inspect(some_value)
}"</code></pre> <p>This happens because the only place the formatter can introduce a new line without changing the code semantics is in the interpolation. In those scenarios, we recommend developers to directly adjust the code. Here we can use the binary concatenation operator <code class="inline">&lt;&gt;</code>:</p> <pre data-language="elixir"><code class="elixir">"this is a very long string " &lt;&gt;
  "... #{inspect(some_value)}"</code></pre> <p>The string concatenation makes the code fit on a single line and also gives more options to the formatter.</p> <p>A similar example is when the formatter breaks a function definition over multiple clauses:</p> <pre data-language="elixir"><code class="elixir">def my_function(
  %User{name: name, age: age, ...},
  arg1,
  arg2
) do</code></pre> <p>While the code above is completely valid, you may prefer to match on the struct variables inside the function body in order to keep the definition on a single line:</p> <pre data-language="elixir"><code class="elixir">def my_function(%User{} = user, arg1, arg2) do
  %{name: name, age: age, ...} = user</code></pre> <p>Since the formatter cannot change the semantics of your code, sometimes it is necessary to tweak the code to get optimal formatting.</p> <h3 id="format_string!/2-multi-line-lists-maps-tuples-etc" class="section-heading">  Multi-line lists, maps, tuples, etc </h3> <p>You can force lists, tuples, bitstrings, maps, structs and function calls to have one entry per line by adding a newline after the opening bracket and a new line before the closing bracket lines. For example:</p> <pre data-language="elixir"><code class="elixir">[
  foo,
  bar
]</code></pre> <p>If there are no newlines around the brackets, then the formatter will try to fit everything on a single line, such that the snippet below</p> <pre data-language="elixir"><code class="elixir">[foo,
 bar]</code></pre> <p>will be formatted as</p> <pre data-language="elixir"><code class="elixir">[foo, bar]</code></pre> <p>You can also force keywords to be rendered on multiple lines by having each entry on its own line:</p> <pre data-language="elixir"><code class="elixir">defstruct name: nil,
          age: 0</code></pre> <p>The code above will be kept with one keyword entry per line by the formatter. To avoid that, just keep everything on a single line.</p> <h3 id="format_string!/2-parens-and-no-parens-in-function-calls" class="section-heading">  Parens and no parens in function calls </h3> <p>Elixir has two syntaxes for function calls. With parens and no parens. By default, Elixir will add parens to all calls except for:</p> <ol> <li>calls that have do/end blocks </li> <li>local calls without parens where the name and arity of the local call is also listed under <code class="inline">:locals_without_parens</code> </li> </ol> <p>The choice of parens and no parens also affects indentation. When a function call with parens doesn’t fit on the same line, the formatter introduces a newline around parens and indents the arguments with two spaces:</p> <pre data-language="elixir"><code class="elixir">some_call(
  arg1,
  arg2,
  arg3
)</code></pre> <p>On the other hand, function calls without parens are always indented by the function call length itself, like this:</p> <pre data-language="elixir"><code class="elixir">some_call arg1,
          arg2,
          arg3</code></pre> <p>If the last argument is a data structure, such as maps and lists, and the beginning of the data structure fits on the same line as the function call, then no indentation happens, this allows code like this:</p> <pre data-language="elixir"><code class="elixir">Enum.reduce(some_collection, initial_value, fn element, acc -&gt;
  # code
end)

some_funtion_without_parens %{
  foo: :bar,
  baz: :bat
}</code></pre> <h4 id="format_string!/2-code-comments" class="section-heading">  Code comments </h4> <p>The formatter also handles code comments in a way to guarantee a space is always added between the beginning of the comment (#) and the next character.</p> <p>The formatter also extracts all trailing comments to their previous line. For example, the code below</p> <pre data-language="elixir"><code class="elixir">hello # world</code></pre> <p>will be rewritten to</p> <pre data-language="elixir"><code class="elixir"># world
hello</code></pre> <p>Because code comments are handled apart from the code representation (AST), there are some situations where code comments are seen as ambiguous by the code formatter. For example, the comment in the anonymous function below</p> <pre data-language="elixir"><code class="elixir">fn
  arg1 -&gt;
    body1
    # comment

  arg2 -&gt;
    body2
end</code></pre> <p>and in this one</p> <pre data-language="elixir"><code class="elixir">fn
  arg1 -&gt;
    body1

  # comment
  arg2 -&gt;
    body2
end</code></pre> <p>are considered equivalent (the nesting is discarded alongside most of user formatting). In such cases, the code formatter will always format to the latter.</p>    <h3 class="detail-header function" id="get_docs/2">  <span class="signature">get_docs(module, kind)</span>         </h3>
<pre data-language="elixir">get_docs(module(), :all) :: keyword() | nil</pre>
<pre data-language="elixir">get_docs(module(), :type_docs) ::
  [{type, line, kind, doc}] |
  nil when type: {atom(), arity()}, line: pos_integer(), kind: atom(), doc: nil | false | binary()</pre>
<pre data-language="elixir">get_docs(module(), :callback_docs) ::
  [{callback, line, kind, doc}] |
  nil when callback: {atom(), arity()}, line: pos_integer(), kind: atom(), doc: nil | false | binary()</pre>
<pre data-language="elixir">get_docs(module(), :docs) ::
  [{function, line, kind, list(), doc}] |
  nil when function: {atom(), arity()}, line: pos_integer(), kind: atom(), doc: nil | false | binary()</pre>
<pre data-language="elixir">get_docs(module(), :moduledoc) ::
  {line :: pos_integer(), doc :: false | binary()} |
  nil</pre>  <p>Returns the docs for the given module.</p> <p>When given a module name, it finds its BEAM code and reads the docs from it.</p> <p>When given a path to a <code class="inline">.beam</code> file, it will load the docs directly from that file.</p> <p>The return value depends on the <code class="inline">kind</code> value:</p> <ul> <li>
<p><code class="inline">:moduledoc</code> - tuple <code class="inline">{line, doc}</code> where <code class="inline">line</code> is the line on which the module definition starts and <code class="inline">doc</code> is the string attached to the module using the <code class="inline">@moduledoc</code> attribute, <code class="inline">false</code> if <code class="inline">@moduledoc false</code> was used, or <code class="inline">nil</code> if no <code class="inline">@moduledoc</code> was used.</p> </li> <li>
<p><code class="inline">:docs</code> - list of all docstrings attached to functions and macros using the <code class="inline">@doc</code> attribute. Each tuple has the form <code class="inline">{{name, arity}, line, kind, arguments, doc}</code>. <code class="inline">doc</code> can be either a string, <code class="inline">false</code> if <code class="inline">@doc false</code> was used, or <code class="inline">nil</code> if no doc was used.</p> </li> <li>
<p><code class="inline">:callback_docs</code> - list of all docstrings attached to <code class="inline">@callbacks</code> using the <code class="inline">@doc</code> attribute. Each tuple has the form <code class="inline">{{name, arity}, line, kind, doc}</code>. <code class="inline">doc</code> can be either a string or <code class="inline">nil</code> if no <code class="inline">@doc</code> was set.</p> </li> <li>
<p><code class="inline">:type_docs</code> - list of all docstrings attached to <code class="inline">@type</code> callbacks using the <code class="inline">@typedoc</code> attribute. Each tuple has the form <code class="inline">{{name, arity}, line, kind, doc}</code>. <code class="inline">doc</code> can be either a string or <code class="inline">nil</code> if no <code class="inline">@typedoc</code> was used.</p> </li> <li>
<p><code class="inline">:all</code> - a keyword list with <code class="inline">:docs</code>, <code class="inline">:moduledoc</code>, <code class="inline">:callback_docs</code>, and <code class="inline">:type_docs</code>.</p> </li> </ul> <p>If the module cannot be found, it returns <code class="inline">nil</code>.</p> <h4 id="get_docs/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="elixir"># Module documentation of an existing module
iex&gt; {_line, text} = Code.get_docs(Atom, :moduledoc)
iex&gt; text |&gt; String.split("\n") |&gt; Enum.at(0)
"Convenience functions for working with atoms."

# A module that doesn't exist
iex&gt; Code.get_docs(ModuleNotGood, :all)
nil</code></pre>     <h3 class="detail-header function" id="load_file/2">  <span class="signature">load_file(file, relative_to \\ nil)</span>     </h3>
<pre data-language="elixir">load_file(binary(), nil | binary()) :: [{module(), binary()}]</pre>  <p>Loads the given file.</p> <p>Accepts <code class="inline">relative_to</code> as an argument to tell where the file is located. If the file was already required/loaded, loads it again.</p> <p>It returns a list of tuples <code class="inline">{ModuleName, bytecode}</code>, one tuple for each module defined in the file.</p> <p>Notice that if <a href="#load_file/2"><code class="inline">load_file/2</code></a> is invoked by different processes concurrently, the target file will be loaded concurrently many times. Check <a href="#require_file/2"><code class="inline">require_file/2</code></a> if you don’t want a file to be loaded concurrently.</p> <h4 id="load_file/2-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="elixir">modules = Code.load_file("eex_test.exs", "../eex/test")
List.first(modules)
#=&gt; {EExTest.Compiled, &lt;&lt;70, 79, 82, 49, ...&gt;&gt;}</code></pre>    <h3 class="detail-header function" id="loaded_files/0">  <span class="signature">loaded_files()</span>     </h3>
<pre data-language="elixir">loaded_files() :: [binary()]</pre>  <p>Lists all loaded files.</p> <h4 id="loaded_files/0-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="elixir">Code.require_file("../eex/test/eex_test.exs")
List.first(Code.loaded_files()) =~ "eex_test.exs"
#=&gt; true</code></pre>    <h3 class="detail-header function" id="prepend_path/1">  <span class="signature">prepend_path(path)</span>     </h3>
<pre data-language="elixir">prepend_path(<a href="../path/#t:t/0">Path.t</a>()) :: true | {:error, :bad_directory}</pre>  <p>Prepends a path to the beginning of the Erlang VM code path list.</p> <p>This is the list of directories the Erlang VM uses for finding module code.</p> <p>The path is expanded with <a href="../path/#expand/1"><code class="inline">Path.expand/1</code></a> before being prepended. If this path does not exist, an error is returned.</p> <h4 id="prepend_path/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="elixir">Code.prepend_path(".")
#=&gt; true

Code.prepend_path("/does_not_exist")
#=&gt; {:error, :bad_directory}</code></pre>     <h3 class="detail-header function" id="require_file/2">  <span class="signature">require_file(file, relative_to \\ nil)</span>     </h3>
<pre data-language="elixir">require_file(binary(), nil | binary()) :: [{module(), binary()}] | nil</pre>  <p>Requires the given <code class="inline">file</code>.</p> <p>Accepts <code class="inline">relative_to</code> as an argument to tell where the file is located. The return value is the same as that of <a href="#load_file/2"><code class="inline">load_file/2</code></a>. If the file was already required or loaded, <a href="#require_file/2"><code class="inline">require_file/2</code></a> doesn’t do anything and returns <code class="inline">nil</code>.</p> <p>Notice that if <a href="#require_file/2"><code class="inline">require_file/2</code></a> is invoked by different processes concurrently, the first process to invoke <a href="#require_file/2"><code class="inline">require_file/2</code></a> acquires a lock and the remaining ones will block until the file is available. This means that if <a href="#require_file/2"><code class="inline">require_file/2</code></a> is called more than one times with a given file, that file will be loaded only once. The first process to call <a href="#require_file/2"><code class="inline">require_file/2</code></a> will get the list of loaded modules, others will get <code class="inline">nil</code>.</p> <p>Check <a href="#load_file/2"><code class="inline">load_file/2</code></a> if you want to load a file multiple times. See also <a href="#unload_files/1"><code class="inline">unload_files/1</code></a>.</p> <h4 id="require_file/2-examples" class="section-heading">  Examples </h4> <p>If the code is already loaded, it returns <code class="inline">nil</code>:</p> <pre data-language="elixir"><code class="elixir">Code.require_file("eex_test.exs", "../eex/test")
#=&gt; nil</code></pre> <p>If the code is not loaded yet, it returns the same as <a href="#load_file/2"><code class="inline">load_file/2</code></a>:</p> <pre data-language="elixir"><code class="elixir">modules = Code.require_file("eex_test.exs", "../eex/test")
List.first(modules)
#=&gt; {EExTest.Compiled, &lt;&lt;70, 79, 82, 49, ...&gt;&gt;}</code></pre>     <h3 class="detail-header function" id="string_to_quoted/2">  <span class="signature">string_to_quoted(string, opts \\ [])</span>     </h3>
<pre data-language="elixir">string_to_quoted(<a href="../list.chars/#t:t/0">List.Chars.t</a>(), keyword()) ::
  {:ok, <a href="../macro/#t:t/0">Macro.t</a>()} |
  {:error, {line :: pos_integer(), term(), term()}}</pre>  <p>Converts the given string to its quoted form.</p> <p>Returns <code class="inline">{:ok, quoted_form}</code> if it succeeds, <code class="inline">{:error, {line, error, token}}</code> otherwise.</p> <h4 id="string_to_quoted/2-options" class="section-heading">  Options </h4> <ul> <li>
<p><code class="inline">:file</code> - the filename to be reported in case of parsing errors. Defaults to “nofile”.</p> </li> <li>
<p><code class="inline">:line</code> - the starting line of the string being parsed. Defaults to 1.</p> </li> <li>
<p><code class="inline">:columns</code> - when <code class="inline">true</code>, attach a <code class="inline">:column</code> key to the quoted metadata. Defaults to <code class="inline">false</code>.</p> </li> <li>
<p><code class="inline">:existing_atoms_only</code> - when <code class="inline">true</code>, raises an error when non-existing atoms are found by the tokenizer. Defaults to <code class="inline">false</code>.</p> </li> </ul> <h4 id="string_to_quoted/2-macro-to_string-2" class="section-heading">  <a href="../macro/#to_string/2"><code class="inline">Macro.to_string/2</code></a> </h4> <p>The opposite of converting a string to its quoted form is <a href="../macro/#to_string/2"><code class="inline">Macro.to_string/2</code></a>, which converts a quoted form to a string/binary representation.</p>     <h3 class="detail-header function" id="string_to_quoted!/2">  <span class="signature">string_to_quoted!(string, opts \\ [])</span>     </h3>
<pre data-language="elixir">string_to_quoted!(<a href="../list.chars/#t:t/0">List.Chars.t</a>(), keyword()) :: <a href="../macro/#t:t/0">Macro.t</a>()</pre>  <p>Converts the given string to its quoted form.</p> <p>It returns the ast if it succeeds, raises an exception otherwise. The exception is a <a href="../tokenmissingerror/"><code class="inline">TokenMissingError</code></a> in case a token is missing (usually because the expression is incomplete), <a href="../syntaxerror/"><code class="inline">SyntaxError</code></a> otherwise.</p> <p>Check <a href="#string_to_quoted/2"><code class="inline">string_to_quoted/2</code></a> for options information.</p>    <h3 class="detail-header function" id="unload_files/1">  <span class="signature">unload_files(files)</span>     </h3>
<pre data-language="elixir">unload_files([binary()]) :: :ok</pre>  <p>Removes files from the loaded files list.</p> <p>The modules defined in the file are not removed; calling this function only removes them from the list, allowing them to be required again.</p> <h4 id="unload_files/1-examples" class="section-heading">  Examples </h4> <pre data-language="elixir"><code class="elixir"># Load EEx test code, unload file, check for functions still available
Code.load_file("../eex/test/eex_test.exs")

Code.unload_files(Code.loaded_files())
function_exported?(EExTest.Compiled, :before_compile, 0)
#=&gt; true</code></pre>
<div class="_attribution">
  <p class="_attribution-p">
    © 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://hexdocs.pm/elixir/1.6.0/Code.html" class="_attribution-link" target="_blank">https://hexdocs.pm/elixir/1.6.0/Code.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
