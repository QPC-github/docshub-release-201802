
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>std.datetime.interval - D - W3cubDocs</title>
  
  <meta name="description" content="Indicates a direction in time. One example of its use is Interval&#39;s expand function which uses it to indicate whether the interval should be &hellip;">
  <meta name="keywords" content="std, datetime, interval, -, d">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/d/std_datetime_interval/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-e0f881b0fce8cbe96f33dadc355b7159d5d2912911231446d60eb8f9caffa802.css">
  <script type="text/javascript" src="/assets/application-8fc46316434047265cd383f02b8e7f434ed7dec4a59f920dd633deef8d488d1b.js"></script>
  <script src="/json/d.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/d/" class="_nav-link" title="" style="margin-left:0;">D</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _d">
				
<h1>std.datetime.interval</h1>  <dl>
<dt>License:</dt>
<dd>
<a href="http://www.boost.org/LICENSE_1_0.txt" target="_blank">Boost License 1.0</a>. </dd>
</dl> <dl>
<dt>Authors:</dt>
<dd>Jonathan M Davis </dd>
</dl> <dl>
<dt>Source</dt>
<dd> <span class="phobos_src"><a class="https" href="https://github.com/dlang/phobos/blob/master/std/datetime/interval.d" target="_blank">std/datetime/interval.d</a></span>
</dd>
</dl> <dl>
<dt class="d_decl" id="Direction">enum Direction: int</dt> <dd>
<p>Indicates a direction in time. One example of its use is <a href="#Interval"><code>Interval</code></a>'s <a href="#expand"><code>expand</code></a> function which uses it to indicate whether the interval should be expanded backwards (into the past), forwards (into the future), or both.</p> <dl>
<dt class="d_decl" id="Direction.bwd">bwd</dt> <dd>
<p>Backward.</p> </dd> <dt class="d_decl" id="Direction.fwd">fwd</dt> <dd>
<p>Forward.</p> </dd> <dt class="d_decl" id="Direction.both">both</dt> <dd>
<p>Both backward and forward.</p> </dd> </dl> </dd> <dt class="d_decl" id="PopFirst">alias PopFirst = std.typecons.Flag!"popFirst".Flag</dt> <dd>
<p>Used to indicate whether <code>popFront</code> should be called immediately upon creating a range. The idea is that for some functions used to generate a range for an interval, <code>front</code> is not necessarily a time point which would ever be generated by the range (e.g. if the range were every Sunday within an interval, but the interval started on a Monday), so there needs to be a way to deal with that. To get the first time point in the range to match what the function generates, then use <code>PopFirst.yes</code> to indicate that the range should have <code>popFront</code> called on it before the range is returned so that <code>front</code> is a time point which the function would generate. To let the first time point not match the generator function, use <code>PopFront.no</code>. </p>
<p>For instance, if the function used to generate a range of time points generated successive Easters (i.e. you're iterating over all of the Easters within the interval), the initial date probably isn't an Easter. Using <code>PopFirst.yes</code> would tell the function which returned the range that <code>popFront</code> was to be called so that front would then be an Easter - the next one generated by the function (which when iterating forward would be the Easter following the original <code>front</code>, while when iterating backward, it would be the Easter prior to the original <code>front</code>). If <code>PopFirst.no</code> were used, then <code>front</code> would remain the original time point and it would not necessarily be a time point which would be generated by the range-generating function (which in many cases is exactly what is desired - e.g. if iterating over every day starting at the beginning of the interval). <br><br> If set to <code>PopFirst.no</code>, then popFront is not called before returning the range. <br><br> Otherwise, if set to <code>PopFirst.yes</code>, then popFront is called before returning the range.</p> </dd> <dt class="d_decl" id="Interval">struct Interval(TP)</dt> <dd>
<p>Represents an interval of time. </p>
<p>An <code>Interval</code> has a starting point and an end point. The interval of time is therefore the time starting at the starting point up to, but not including, the end point. e.g. <br><br> </p>
<table>
 <tr><td>[January 5th, 2010 - March 10th, 2010)</td></tr> <tr><td>[05:00:30 - 12:00:00)</td></tr> <tr><td>[1982-01-04T08:59:00 - 2010-07-04T12:00:00)</td></tr> </table> <br><br> A range can be obtained from an <code>Interval</code>, allowing iteration over that interval, with the exact time points which are iterated over depending on the function which generates the range. <dl>
<dt class="d_decl" id="Interval.this">pure this(U)(in TP begin, in U end)<br><br>  Constraints:<br>    if (is(Unqual!TP == Unqual!U))</dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>TP <code>begin</code>
</td> <td>The time point which begins the interval.</td>
</tr> <tr>
<td>U <code>end</code>
</td> <td>The time point which ends (but is not included in) the interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if <span class="d_param"><code>end</code></span> is before <span class="d_param"><code>begin</code></span>. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1));
</pre>  </dd> <dt class="d_decl" id="Interval.this.2">pure this(D)(in TP begin, in D duration)<br><br>  Constraints:<br>    if (__traits(compiles, begin + duration))</dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>TP <code>begin</code>
</td> <td>The time point which begins the interval.</td>
</tr> <tr>
<td>D <code>duration</code>
</td> <td>The <code>duration</code> from the starting point to the end point.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the resulting <code>end</code> is before <code>begin</code>. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(Interval!Date(Date(1996, 1, 2), dur!"days"(3)) ==
       Interval!Date(Date(1996, 1, 2), Date(1996, 1, 5)));
</pre>  </dd> <dt class="d_decl" id="Interval.opAssign">pure nothrow ref Interval opAssign(ref const Interval rhs)</dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Interval <code>rhs</code>
</td> <td>The <a href="#Interval"><code>Interval</code></a> to assign to this one.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="Interval.opAssign.2">pure nothrow ref Interval opAssign(Interval rhs)</dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Interval <code>rhs</code>
</td> <td>The <a href="#Interval"><code>Interval</code></a> to assign to this one.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="Interval.begin">const pure nothrow @property TP begin()</dt> <dd>
<p>The starting point of the interval. It is included in the interval. </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).begin ==
       Date(1996, 1, 2));
</pre>  </dd> <dt class="d_decl" id="Interval.begin.2">pure @property void begin(TP timePoint)</dt> <dd>
<p>The starting point of the interval. It is included in the interval. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>TP <code>timePoint</code>
</td> <td>The time point to set <code>begin</code> to.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the resulting interval would be invalid.</dd>
</dl> </dd> <dt class="d_decl" id="Interval.end">const pure nothrow @property TP end()</dt> <dd>
<p>The <code>end</code> point of the interval. It is excluded from the interval. </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).end ==
       Date(2012, 3, 1));
</pre>  </dd> <dt class="d_decl" id="Interval.end.2">pure @property void end(TP timePoint)</dt> <dd>
<p>The <code>end</code> point of the interval. It is excluded from the interval. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>TP <code>timePoint</code>
</td> <td>The time point to set <code>end</code> to.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the resulting interval would be invalid.</dd>
</dl> </dd> <dt class="d_decl" id="Interval.length">const pure nothrow @property auto length()</dt> <dd>
<p>Returns the duration between <code>begin</code> and <code>end</code>. </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).length ==
       dur!"days"(5903));
</pre>  </dd> <dt class="d_decl" id="Interval.empty">const pure nothrow @property bool empty()</dt> <dd>
<p>Whether the interval's length is 0, that is, whether <code>begin == end</code>. </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(Interval!Date(Date(1996, 1, 2), Date(1996, 1, 2)).empty);
assert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).empty);
</pre>  </dd> <dt class="d_decl" id="Interval.contains">const pure bool contains(in TP timePoint)</dt> <dd>
<p>Whether the given time point is within this interval. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>TP <code>timePoint</code>
</td> <td>The time point to check for inclusion in this interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if this interval is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).contains(
            Date(1994, 12, 24)));

assert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).contains(
            Date(2000, 1, 5)));
assert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).contains(
            Date(2012, 3, 1)));
</pre>  </dd> <dt class="d_decl" id="Interval.contains.2">const pure bool contains(in Interval interval)</dt> <dd>
<p>Whether the given <code>interval</code> is completely within this <code>interval</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Interval <code>interval</code>
</td> <td>The <code>interval</code> to check for inclusion in this <code>interval</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if either <code>interval</code> is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).contains(
            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));

assert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).contains(
            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));

assert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).contains(
            Interval!Date(Date(1998, 2, 28), Date(2013, 5, 1))));
</pre>  </dd> <dt class="d_decl" id="Interval.contains.3">const pure bool contains(in PosInfInterval!TP interval)</dt> <dd>
<p>Whether the given <code>interval</code> is completely within this <code>interval</code>. </p>
<p>Always returns <code>false</code> (unless this <code>interval</code> is empty), because an <code>interval</code> going to positive infinity can never be contained in a finite <code>interval</code>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>PosInfInterval!TP <code>interval</code>
</td> <td>The <code>interval</code> to check for inclusion in this <code>interval</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if this <code>interval</code> is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).contains(
            PosInfInterval!Date(Date(1999, 5, 4))));
</pre>  </dd> <dt class="d_decl" id="Interval.contains.4">const pure bool contains(in NegInfInterval!TP interval)</dt> <dd>
<p>Whether the given <code>interval</code> is completely within this <code>interval</code>. </p>
<p>Always returns <code>false</code> (unless this <code>interval</code> is empty), because an <code>interval</code> beginning at negative infinity can never be contained in a finite <code>interval</code>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>NegInfInterval!TP <code>interval</code>
</td> <td>The <code>interval</code> to check for inclusion in this <code>interval</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if this <code>interval</code> is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).contains(
            NegInfInterval!Date(Date(1996, 5, 4))));
</pre>  </dd> <dt class="d_decl" id="Interval.isBefore">const pure bool isBefore(in TP timePoint)</dt> <dd>
<p>Whether this interval is before the given time point. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>TP <code>timePoint</code>
</td> <td>The time point to check whether this interval is before it.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if this interval is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isBefore(
            Date(1994, 12, 24)));

assert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isBefore(
            Date(2000, 1, 5)));

assert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isBefore(
            Date(2012, 3, 1)));
</pre>  </dd> <dt class="d_decl" id="Interval.isBefore.2">const pure bool isBefore(in Interval interval)</dt> <dd>
<p>Whether this <code>interval</code> is before the given <code>interval</code> and does not intersect with it. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Interval <code>interval</code>
</td> <td>The <code>interval</code> to check for against this <code>interval</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if either <code>interval</code> is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isBefore(
            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));

assert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isBefore(
            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));

assert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isBefore(
            Interval!Date(Date(2012, 3, 1), Date(2013, 5, 1))));
</pre>  </dd> <dt class="d_decl" id="Interval.isBefore.3">const pure bool isBefore(in PosInfInterval!TP interval)</dt> <dd>
<p>Whether this <code>interval</code> is before the given <code>interval</code> and does not intersect with it. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>PosInfInterval!TP <code>interval</code>
</td> <td>The <code>interval</code> to check for against this <code>interval</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if this <code>interval</code> is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isBefore(
            PosInfInterval!Date(Date(1999, 5, 4))));

assert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isBefore(
            PosInfInterval!Date(Date(2013, 3, 7))));
</pre>  </dd> <dt class="d_decl" id="Interval.isBefore.4">const pure bool isBefore(in NegInfInterval!TP interval)</dt> <dd>
<p>Whether this <code>interval</code> is before the given <code>interval</code> and does not intersect with it. </p>
<p>Always returns <code>false</code> (unless this <code>interval</code> is empty) because a finite <code>interval</code> can never be before an <code>interval</code> beginning at negative infinity. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>NegInfInterval!TP <code>interval</code>
</td> <td>The <code>interval</code> to check for against this <code>interval</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if this <code>interval</code> is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isBefore(
            NegInfInterval!Date(Date(1996, 5, 4))));
</pre>  </dd> <dt class="d_decl" id="Interval.isAfter">const pure bool isAfter(in TP timePoint)</dt> <dd>
<p>Whether this interval is after the given time point. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>TP <code>timePoint</code>
</td> <td>The time point to check whether this interval is after it.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if this interval is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAfter(
            Date(1994, 12, 24)));

assert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAfter(
            Date(2000, 1, 5)));

assert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAfter(
            Date(2012, 3, 1)));
</pre>  </dd> <dt class="d_decl" id="Interval.isAfter.2">const pure bool isAfter(in Interval interval)</dt> <dd>
<p>Whether this <code>interval</code> is after the given <code>interval</code> and does not intersect it. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Interval <code>interval</code>
</td> <td>The <code>interval</code> to check against this <code>interval</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if either <code>interval</code> is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAfter(
            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));

assert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAfter(
            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));

assert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAfter(
            Interval!Date(Date(1989, 3, 1), Date(1996, 1, 2))));
</pre>  </dd> <dt class="d_decl" id="Interval.isAfter.3">const pure bool isAfter(in PosInfInterval!TP interval)</dt> <dd>
<p>Whether this <code>interval</code> is after the given <code>interval</code> and does not intersect it. </p>
<p>Always returns <code>false</code> (unless this <code>interval</code> is empty) because a finite <code>interval</code> can never be after an <code>interval</code> going to positive infinity. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>PosInfInterval!TP <code>interval</code>
</td> <td>The <code>interval</code> to check against this <code>interval</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if this <code>interval</code> is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAfter(
            PosInfInterval!Date(Date(1999, 5, 4))));
</pre>  </dd> <dt class="d_decl" id="Interval.isAfter.4">const pure bool isAfter(in NegInfInterval!TP interval)</dt> <dd>
<p>Whether this <code>interval</code> is after the given <code>interval</code> and does not intersect it. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>NegInfInterval!TP <code>interval</code>
</td> <td>The <code>interval</code> to check against this <code>interval</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if this <code>interval</code> is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAfter(
            NegInfInterval!Date(Date(1996, 1, 2))));
</pre>  </dd> <dt class="d_decl" id="Interval.intersects">const pure bool intersects(in Interval interval)</dt> <dd>
<p>Whether the given <code>interval</code> overlaps this <code>interval</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Interval <code>interval</code>
</td> <td>The <code>interval</code> to check for intersection with this <code>interval</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if either <code>interval</code> is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersects(
            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));

assert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersects(
            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));

assert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersects(
            Interval!Date(Date(1989, 3, 1), Date(1996, 1, 2))));
</pre>  </dd> <dt class="d_decl" id="Interval.intersects.2">const pure bool intersects(in PosInfInterval!TP interval)</dt> <dd>
<p>Whether the given <code>interval</code> overlaps this <code>interval</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>PosInfInterval!TP <code>interval</code>
</td> <td>The <code>interval</code> to check for intersection with this <code>interval</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if this <code>interval</code> is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersects(
            PosInfInterval!Date(Date(1999, 5, 4))));

assert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersects(
            PosInfInterval!Date(Date(2012, 3, 1))));
</pre>  </dd> <dt class="d_decl" id="Interval.intersects.3">const pure bool intersects(in NegInfInterval!TP interval)</dt> <dd>
<p>Whether the given <code>interval</code> overlaps this <code>interval</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>NegInfInterval!TP <code>interval</code>
</td> <td>The <code>interval</code> to check for intersection with this <code>interval</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if this <code>interval</code> is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersects(
            NegInfInterval!Date(Date(1996, 1, 2))));

assert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersects(
            NegInfInterval!Date(Date(2000, 1, 2))));
</pre>  </dd> <dt class="d_decl" id="Interval.intersection">const Interval intersection(in Interval interval)</dt> <dd>
<p>Returns the <code>intersection</code> of two intervals </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Interval <code>interval</code>
</td> <td>The <code>interval</code> to intersect with this <code>interval</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the two intervals do not intersect or if either <code>interval</code> is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersection(
            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))) ==
       Interval!Date(Date(1996, 1 , 2), Date(2000, 8, 2)));

assert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersection(
            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))) ==
       Interval!Date(Date(1999, 1 , 12), Date(2011, 9, 17)));
</pre>  </dd> <dt class="d_decl" id="Interval.intersection.2">const Interval intersection(in PosInfInterval!TP interval)</dt> <dd>
<p>Returns the <code>intersection</code> of two intervals </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>PosInfInterval!TP <code>interval</code>
</td> <td>The <code>interval</code> to intersect with this <code>interval</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the two intervals do not intersect or if this <code>interval</code> is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersection(
            PosInfInterval!Date(Date(1990, 7, 6))) ==
       Interval!Date(Date(1996, 1 , 2), Date(2012, 3, 1)));

assert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersection(
            PosInfInterval!Date(Date(1999, 1, 12))) ==
       Interval!Date(Date(1999, 1 , 12), Date(2012, 3, 1)));
</pre>  </dd> <dt class="d_decl" id="Interval.intersection.3">const Interval intersection(in NegInfInterval!TP interval)</dt> <dd>
<p>Returns the <code>intersection</code> of two intervals </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>NegInfInterval!TP <code>interval</code>
</td> <td>The <code>interval</code> to intersect with this <code>interval</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the two intervals do not intersect or if this <code>interval</code> is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersection(
            NegInfInterval!Date(Date(1999, 7, 6))) ==
       Interval!Date(Date(1996, 1 , 2), Date(1999, 7, 6)));

assert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersection(
            NegInfInterval!Date(Date(2013, 1, 12))) ==
       Interval!Date(Date(1996, 1 , 2), Date(2012, 3, 1)));
</pre>  </dd> <dt class="d_decl" id="Interval.isAdjacent">const pure bool isAdjacent(in Interval interval)</dt> <dd>
<p>Whether the given <code>interval</code> is adjacent to this <code>interval</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Interval <code>interval</code>
</td> <td>The <code>interval</code> to check whether its adjecent to this <code>interval</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if either <code>interval</code> is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAdjacent(
            Interval!Date(Date(1990, 7, 6), Date(1996, 1, 2))));

assert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAdjacent(
            Interval!Date(Date(2012, 3, 1), Date(2013, 9, 17))));

assert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAdjacent(
            Interval!Date(Date(1989, 3, 1), Date(2012, 3, 1))));
</pre>  </dd> <dt class="d_decl" id="Interval.isAdjacent.2">const pure bool isAdjacent(in PosInfInterval!TP interval)</dt> <dd>
<p>Whether the given <code>interval</code> is adjacent to this <code>interval</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>PosInfInterval!TP <code>interval</code>
</td> <td>The <code>interval</code> to check whether its adjecent to this <code>interval</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if this <code>interval</code> is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAdjacent(
            PosInfInterval!Date(Date(1999, 5, 4))));

assert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAdjacent(
            PosInfInterval!Date(Date(2012, 3, 1))));
</pre>  </dd> <dt class="d_decl" id="Interval.isAdjacent.3">const pure bool isAdjacent(in NegInfInterval!TP interval)</dt> <dd>
<p>Whether the given <code>interval</code> is adjacent to this <code>interval</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>NegInfInterval!TP <code>interval</code>
</td> <td>The <code>interval</code> to check whether its adjecent to this <code>interval</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if this <code>interval</code> is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAdjacent(
            NegInfInterval!Date(Date(1996, 1, 2))));

assert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAdjacent(
            NegInfInterval!Date(Date(2000, 1, 2))));
</pre>  </dd> <dt class="d_decl" id="Interval.merge">const Interval merge(in Interval interval)</dt> <dd>
<p>Returns the union of two intervals </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Interval <code>interval</code>
</td> <td>The <code>interval</code> to <code>merge</code> with this <code>interval</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the two intervals do not intersect and are not adjacent or if either <code>interval</code> is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).merge(
            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))) ==
       Interval!Date(Date(1990, 7 , 6), Date(2012, 3, 1)));

assert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).merge(
            Interval!Date(Date(2012, 3, 1), Date(2013, 5, 7))) ==
       Interval!Date(Date(1996, 1 , 2), Date(2013, 5, 7)));
</pre>  </dd> <dt class="d_decl" id="Interval.merge.2">const PosInfInterval!TP merge(in PosInfInterval!TP interval)</dt> <dd>
<p>Returns the union of two intervals </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>PosInfInterval!TP <code>interval</code>
</td> <td>The <code>interval</code> to <code>merge</code> with this <code>interval</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the two intervals do not intersect and are not adjacent or if this <code>interval</code> is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).merge(
            PosInfInterval!Date(Date(1990, 7, 6))) ==
       PosInfInterval!Date(Date(1990, 7 , 6)));

assert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).merge(
            PosInfInterval!Date(Date(2012, 3, 1))) ==
       PosInfInterval!Date(Date(1996, 1 , 2)));
</pre>  </dd> <dt class="d_decl" id="Interval.merge.3">const NegInfInterval!TP merge(in NegInfInterval!TP interval)</dt> <dd>
<p>Returns the union of two intervals </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>NegInfInterval!TP <code>interval</code>
</td> <td>The <code>interval</code> to <code>merge</code> with this <code>interval</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the two intervals do not intersect and are not adjacent or if this <code>interval</code> is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).merge(
            NegInfInterval!Date(Date(1996, 1, 2))) ==
       NegInfInterval!Date(Date(2012, 3 , 1)));

assert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).merge(
            NegInfInterval!Date(Date(2013, 1, 12))) ==
       NegInfInterval!Date(Date(2013, 1 , 12)));
</pre>  </dd> <dt class="d_decl" id="Interval.span">const pure Interval span(in Interval interval)</dt> <dd>
<p>Returns an <code>interval</code> that covers from the earliest time point of two intervals up to (but not including) the latest time point of two intervals. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Interval <code>interval</code>
</td> <td>The <code>interval</code> to create a <code>span</code> together with this <code>interval</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if either <code>interval</code> is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).span(
            Interval!Date(Date(1990, 7, 6), Date(1991, 1, 8))) ==
       Interval!Date(Date(1990, 7 , 6), Date(2012, 3, 1)));

assert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).span(
            Interval!Date(Date(2012, 3, 1), Date(2013, 5, 7))) ==
       Interval!Date(Date(1996, 1 , 2), Date(2013, 5, 7)));
</pre>  </dd> <dt class="d_decl" id="Interval.span.2">const pure PosInfInterval!TP span(in PosInfInterval!TP interval)</dt> <dd>
<p>Returns an <code>interval</code> that covers from the earliest time point of two intervals up to (but not including) the latest time point of two intervals. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>PosInfInterval!TP <code>interval</code>
</td> <td>The <code>interval</code> to create a <code>span</code> together with this <code>interval</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if this <code>interval</code> is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).span(
            PosInfInterval!Date(Date(1990, 7, 6))) ==
       PosInfInterval!Date(Date(1990, 7 , 6)));

assert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).span(
            PosInfInterval!Date(Date(2050, 1, 1))) ==
       PosInfInterval!Date(Date(1996, 1 , 2)));
</pre>  </dd> <dt class="d_decl" id="Interval.span.3">const pure NegInfInterval!TP span(in NegInfInterval!TP interval)</dt> <dd>
<p>Returns an <code>interval</code> that covers from the earliest time point of two intervals up to (but not including) the latest time point of two intervals. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>NegInfInterval!TP <code>interval</code>
</td> <td>The <code>interval</code> to create a <code>span</code> together with this <code>interval</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if this <code>interval</code> is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).span(
            NegInfInterval!Date(Date(1602, 5, 21))) ==
       NegInfInterval!Date(Date(2012, 3 , 1)));

assert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).span(
            NegInfInterval!Date(Date(2013, 1, 12))) ==
       NegInfInterval!Date(Date(2013, 1 , 12)));
</pre>  </dd> <dt class="d_decl" id="Interval.shift">pure void shift(D)(D duration)<br><br>  Constraints:<br>    if (__traits(compiles, begin + duration))</dt> <dd>
<p>Shifts the interval forward or backwards in time by the given <code>duration</code> (a positive <code>duration</code> shifts the interval forward; a negative <code>duration</code> shifts it backward). Effectively, it does <code>begin += duration</code> and <code>end += duration</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>D <code>duration</code>
</td> <td>The <code>duration</code> to <code>shift</code> the interval by.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> this interval is empty or if the resulting interval would be invalid. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto interval1 = Interval!Date(Date(1996, 1, 2), Date(2012, 4, 5));
auto interval2 = Interval!Date(Date(1996, 1, 2), Date(2012, 4, 5));

interval1.shift(dur!"days"(50));
assert(interval1 == Interval!Date(Date(1996, 2, 21), Date(2012, 5, 25)));

interval2.shift(dur!"days"(-50));
assert(interval2 == Interval!Date(Date(1995, 11, 13), Date(2012, 2, 15)));
</pre>  </dd> <dt class="d_decl" id="Interval.shift.2">void shift(T)(T years, T months = 0, AllowDayOverflow allowOverflow = AllowDayOverflow.yes)<br><br>  Constraints:<br>    if (isIntegral!T)</dt> <dd>
<p>Shifts the interval forward or backwards in time by the given number of <code>years</code> and/or <code>months</code> (a positive number of <code>years</code> and <code>months</code> shifts the interval forward; a negative number shifts it backward). It adds the <code>years</code> the given <code>years</code> and <code>months</code> to both begin and end. It effectively calls <code>add!"years"()</code> and then <code>add!"months"()</code> on begin and end with the given number of <code>years</code> and <code>months</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T <code>years</code>
</td> <td>The number of <code>years</code> to <code>shift</code> the interval by.</td>
</tr> <tr>
<td>T <code>months</code>
</td> <td>The number of <code>months</code> to <code>shift</code> the interval by.</td>
</tr> <tr>
<td>AllowDayOverflow <code>allowOverflow</code>
</td> <td>Whether the days should be allowed to overflow on <code>begin</code> and <code>end</code>, causing their month to increment.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if this interval is empty or if the resulting interval would be invalid. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto interval1 = Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1));
auto interval2 = Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1));

interval1.shift(2);
assert(interval1 == Interval!Date(Date(1998, 1, 2), Date(2014, 3, 1)));

interval2.shift(-2);
assert(interval2 == Interval!Date(Date(1994, 1, 2), Date(2010, 3, 1)));
</pre>  </dd> <dt class="d_decl" id="Interval.expand">pure void expand(D)(D duration, Direction dir = Direction.both)<br><br>  Constraints:<br>    if (__traits(compiles, begin + duration))</dt> <dd>
<p>Expands the interval forwards and/or backwards in time. Effectively, it does <code>begin -= duration</code> and/or <code>end += duration</code>. Whether it expands forwards and/or backwards in time is determined by <span class="d_param"><code>dir</code></span>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>D <code>duration</code>
</td> <td>The <code>duration</code> to <code>expand</code> the interval by.</td>
</tr> <tr>
<td>Direction <code>dir</code>
</td> <td>The direction in time to <code>expand</code> the interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> this interval is empty or if the resulting interval would be invalid. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto interval1 = Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1));
auto interval2 = Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1));

interval1.expand(2);
assert(interval1 == Interval!Date(Date(1994, 1, 2), Date(2014, 3, 1)));

interval2.expand(-2);
assert(interval2 == Interval!Date(Date(1998, 1, 2), Date(2010, 3, 1)));
</pre>  </dd> <dt class="d_decl" id="Interval.expand.2">void expand(T)(T years, T months = 0, AllowDayOverflow allowOverflow = AllowDayOverflow.yes, Direction dir = Direction.both)<br><br>  Constraints:<br>    if (isIntegral!T)</dt> <dd>
<p>Expands the interval forwards and/or backwards in time. Effectively, it subtracts the given number of <code>months</code>/<code>years</code> from <code>begin</code> and adds them to <code>end</code>. Whether it expands forwards and/or backwards in time is determined by <span class="d_param"><code>dir</code></span>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T <code>years</code>
</td> <td>The number of <code>years</code> to <code>expand</code> the interval by.</td>
</tr> <tr>
<td>T <code>months</code>
</td> <td>The number of <code>months</code> to <code>expand</code> the interval by.</td>
</tr> <tr>
<td>AllowDayOverflow <code>allowOverflow</code>
</td> <td>Whether the days should be allowed to overflow on <code>begin</code> and <code>end</code>, causing their month to increment.</td>
</tr> <tr>
<td>Direction <code>dir</code>
</td> <td>The direction in time to <code>expand</code> the interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if this interval is empty or if the resulting interval would be invalid. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto interval1 = Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1));
auto interval2 = Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1));

interval1.expand(2);
assert(interval1 == Interval!Date(Date(1994, 1, 2), Date(2014, 3, 1)));

interval2.expand(-2);
assert(interval2 == Interval!Date(Date(1998, 1, 2), Date(2010, 3, 1)));
</pre>  </dd> <dt class="d_decl" id="Interval.fwdRange">const IntervalRange!(TP, Direction.fwd) fwdRange(TP delegate(in TP) func, PopFirst popFirst = PopFirst.no)</dt> <dd>
<p>Returns a range which iterates forward over the interval, starting at <code>begin</code>, using <span class="d_param"><code>func</code></span> to generate each successive time point. </p>
<p>The range's <code>front</code> is the interval's <code>begin</code>. <span class="d_param"><code>func</code></span> is used to generate the next <code>front</code> when <code>popFront</code> is called. If <span class="d_param"><code>popFirst</code></span> is <code>PopFirst.yes</code>, then <code>popFront</code> is called before the range is returned (so that <code>front</code> is a time point which <span class="d_param"><code>func</code></span> would generate). <br><br> If <span class="d_param"><code>func</code></span> ever generates a time point less than or equal to the current <code>front</code> of the range, then a <a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> will be thrown. The range will be empty and iteration complete when <span class="d_param"><code>func</code></span> generates a time point equal to or beyond the <code>end</code> of the interval. <br><br> There are helper functions in this module which generate common delegates to pass to <code>fwdRange</code>. Their documentation starts with "Range-generating function," making them easily searchable. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>TP delegate(in TP) <code>func</code>
</td> <td>The function used to generate the time points of the range over the interval.</td>
</tr> <tr>
<td>PopFirst <code>popFirst</code>
</td> <td>Whether <code>popFront</code> should be called on the range before returning it.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if this interval is empty. </dd>
</dl> <dl>
<dt>Warning</dt>
<dd> <span class="d_param"><code>func</code></span> must be logically pure. Ideally, <span class="d_param"><code>func</code></span> would be a function pointer to a pure function, but forcing <span class="d_param"><code>func</code></span> to be pure is far too restrictive to be useful, and in order to have the ease of use of having functions which generate functions to pass to <code>fwdRange</code>, <span class="d_param"><code>func</code></span> must be a delegate. </dd>
</dl> If <span class="d_param"><code>func</code></span> retains state which changes as it is called, then some algorithms will not work correctly, because the range's <code>save</code> will have failed to have really saved the range's state. To avoid such bugs, don't pass a delegate which is not logically pure to <code>fwdRange</code>. If <span class="d_param"><code>func</code></span> is given the same time point with two different calls, it must return the same result both times.  Of course, none of the functions in this module have this problem, so it's only relevant if when creating a custom delegate.  <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto interval = Interval!Date(Date(2010, 9, 1), Date(2010, 9, 9));
auto func = delegate (in Date date) // For iterating over even-numbered days.
            {
                if ((date.day &amp; 1) == 0)
                    return date + dur!"days"(2);

                return date + dur!"days"(1);
            };
auto range = interval.fwdRange(func);

// An odd day. Using PopFirst.yes would have made this Date(2010, 9, 2).
assert(range.front == Date(2010, 9, 1));

range.popFront();
assert(range.front == Date(2010, 9, 2));

range.popFront();
assert(range.front == Date(2010, 9, 4));

range.popFront();
assert(range.front == Date(2010, 9, 6));

range.popFront();
assert(range.front == Date(2010, 9, 8));

range.popFront();
assert(range.empty);
</pre>  </dd> <dt class="d_decl" id="Interval.bwdRange">const IntervalRange!(TP, Direction.bwd) bwdRange(TP delegate(in TP) func, PopFirst popFirst = PopFirst.no)</dt> <dd>
<p>Returns a range which iterates backwards over the interval, starting at <code>end</code>, using <span class="d_param"><code>func</code></span> to generate each successive time point. </p>
<p>The range's <code>front</code> is the interval's <code>end</code>. <span class="d_param"><code>func</code></span> is used to generate the next <code>front</code> when <code>popFront</code> is called. If <span class="d_param"><code>popFirst</code></span> is <code>PopFirst.yes</code>, then <code>popFront</code> is called before the range is returned (so that <code>front</code> is a time point which <span class="d_param"><code>func</code></span> would generate). <br><br> If <span class="d_param"><code>func</code></span> ever generates a time point greater than or equal to the current <code>front</code> of the range, then a <a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> will be thrown. The range will be empty and iteration complete when <span class="d_param"><code>func</code></span> generates a time point equal to or less than the <code>begin</code> of the interval. <br><br> There are helper functions in this module which generate common delegates to pass to <code>bwdRange</code>. Their documentation starts with "Range-generating function," making them easily searchable. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>TP delegate(in TP) <code>func</code>
</td> <td>The function used to generate the time points of the range over the interval.</td>
</tr> <tr>
<td>PopFirst <code>popFirst</code>
</td> <td>Whether <code>popFront</code> should be called on the range before returning it.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if this interval is empty. </dd>
</dl> <dl>
<dt>Warning</dt>
<dd> <span class="d_param"><code>func</code></span> must be logically pure. Ideally, <span class="d_param"><code>func</code></span> would be a function pointer to a pure function, but forcing <span class="d_param"><code>func</code></span> to be pure is far too restrictive to be useful, and in order to have the ease of use of having functions which generate functions to pass to <code>fwdRange</code>, <span class="d_param"><code>func</code></span> must be a delegate. </dd>
</dl> If <span class="d_param"><code>func</code></span> retains state which changes as it is called, then some algorithms will not work correctly, because the range's <code>save</code> will have failed to have really saved the range's state. To avoid such bugs, don't pass a delegate which is not logically pure to <code>fwdRange</code>. If <span class="d_param"><code>func</code></span> is given the same time point with two different calls, it must return the same result both times.  Of course, none of the functions in this module have this problem, so it's only relevant for custom delegates.  <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto interval = Interval!Date(Date(2010, 9, 1), Date(2010, 9, 9));
auto func = delegate (in Date date) // For iterating over even-numbered days.
            {
                if ((date.day &amp; 1) == 0)
                    return date - dur!"days"(2);

                return date - dur!"days"(1);
            };
auto range = interval.bwdRange(func);

// An odd day. Using PopFirst.yes would have made this Date(2010, 9, 8).
assert(range.front == Date(2010, 9, 9));

range.popFront();
assert(range.front == Date(2010, 9, 8));

range.popFront();
assert(range.front == Date(2010, 9, 6));

range.popFront();
assert(range.front == Date(2010, 9, 4));

range.popFront();
assert(range.front == Date(2010, 9, 2));

range.popFront();
assert(range.empty);
</pre>  </dd> <dt class="d_decl" id="Interval.toString">const nothrow string toString()</dt> <dd>
<p>Converts this interval to a string.</p> </dd> </dl> </dd> <dt class="d_decl" id="PosInfInterval">struct PosInfInterval(TP)</dt> <dd>
<p>Represents an interval of time which has positive infinity as its end point. </p>
<p>Any ranges which iterate over a <code>PosInfInterval</code> are infinite. So, the main purpose of using <code>PosInfInterval</code> is to create an infinite range which starts at a fixed point in time and goes to positive infinity.</p> <dl>
<dt class="d_decl" id="PosInfInterval.this">pure nothrow this(in TP begin)</dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>TP <code>begin</code>
</td> <td>The time point which begins the interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto interval = PosInfInterval!Date(Date(1996, 1, 2));
</pre>  </dd> <dt class="d_decl" id="PosInfInterval.opAssign">pure nothrow ref PosInfInterval opAssign(ref const PosInfInterval rhs)</dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>PosInfInterval <code>rhs</code>
</td> <td>The <code>PosInfInterval</code> to assign to this one.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="PosInfInterval.opAssign.2">pure nothrow ref PosInfInterval opAssign(PosInfInterval rhs)</dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>PosInfInterval <code>rhs</code>
</td> <td>The <code>PosInfInterval</code> to assign to this one.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="PosInfInterval.begin">const pure nothrow @property TP begin()</dt> <dd>
<p>The starting point of the interval. It is included in the interval. </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(PosInfInterval!Date(Date(1996, 1, 2)).begin == Date(1996, 1, 2));
</pre>  </dd> <dt class="d_decl" id="PosInfInterval.begin.2">pure nothrow @property void begin(TP timePoint)</dt> <dd>
<p>The starting point of the interval. It is included in the interval. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>TP <code>timePoint</code>
</td> <td>The time point to set <code>begin</code> to.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="PosInfInterval.empty">enum bool empty</dt> <dd>
<p>Whether the interval's length is 0. Always returns <code>false</code>. </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(!PosInfInterval!Date(Date(1996, 1, 2)).empty);
</pre>  </dd> <dt class="d_decl" id="PosInfInterval.contains">const pure nothrow bool contains(TP timePoint)</dt> <dd>
<p>Whether the given time point is within this interval. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>TP <code>timePoint</code>
</td> <td>The time point to check for inclusion in this interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(!PosInfInterval!Date(Date(1996, 1, 2)).contains(Date(1994, 12, 24)));
assert(PosInfInterval!Date(Date(1996, 1, 2)).contains(Date(2000, 1, 5)));
</pre>  </dd> <dt class="d_decl" id="PosInfInterval.contains.2">const pure bool contains(in Interval!TP interval)</dt> <dd>
<p>Whether the given <code>interval</code> is completely within this <code>interval</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Interval!TP <code>interval</code>
</td> <td>The <code>interval</code> to check for inclusion in this <code>interval</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the given <code>interval</code> is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(!PosInfInterval!Date(Date(1996, 1, 2)).contains(
            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));

assert(PosInfInterval!Date(Date(1996, 1, 2)).contains(
            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));

assert(PosInfInterval!Date(Date(1996, 1, 2)).contains(
            Interval!Date(Date(1998, 2, 28), Date(2013, 5, 1))));
</pre>  </dd> <dt class="d_decl" id="PosInfInterval.contains.3">const pure nothrow bool contains(in PosInfInterval interval)</dt> <dd>
<p>Whether the given <code>interval</code> is completely within this <code>interval</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>PosInfInterval <code>interval</code>
</td> <td>The <code>interval</code> to check for inclusion in this <code>interval</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(PosInfInterval!Date(Date(1996, 1, 2)).contains(
            PosInfInterval!Date(Date(1999, 5, 4))));

assert(!PosInfInterval!Date(Date(1996, 1, 2)).contains(
            PosInfInterval!Date(Date(1995, 7, 2))));
</pre>  </dd> <dt class="d_decl" id="PosInfInterval.contains.4">const pure nothrow bool contains(in NegInfInterval!TP interval)</dt> <dd>
<p>Whether the given <code>interval</code> is completely within this <code>interval</code>. </p>
<p>Always returns <code>false</code> because an <code>interval</code> going to positive infinity can never contain an <code>interval</code> beginning at negative infinity. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>NegInfInterval!TP <code>interval</code>
</td> <td>The <code>interval</code> to check for inclusion in this <code>interval</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(!PosInfInterval!Date(Date(1996, 1, 2)).contains(
            NegInfInterval!Date(Date(1996, 5, 4))));
</pre>  </dd> <dt class="d_decl" id="PosInfInterval.isBefore">const pure nothrow bool isBefore(in TP timePoint)</dt> <dd>
<p>Whether this interval is before the given time point. </p>
<p>Always returns <code>false</code> because an interval going to positive infinity can never be before any time point. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>TP <code>timePoint</code>
</td> <td>The time point to check whether this interval is before it.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(!PosInfInterval!Date(Date(1996, 1, 2)).isBefore(Date(1994, 12, 24)));
assert(!PosInfInterval!Date(Date(1996, 1, 2)).isBefore(Date(2000, 1, 5)));
</pre>  </dd> <dt class="d_decl" id="PosInfInterval.isBefore.2">const pure bool isBefore(in Interval!TP interval)</dt> <dd>
<p>Whether this <code>interval</code> is before the given <code>interval</code> and does not intersect it. </p>
<p>Always returns <code>false</code> (unless the given <code>interval</code> is empty) because an <code>interval</code> going to positive infinity can never be before any other <code>interval</code>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Interval!TP <code>interval</code>
</td> <td>The <code>interval</code> to check for against this <code>interval</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the given <code>interval</code> is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(!PosInfInterval!Date(Date(1996, 1, 2)).isBefore(
            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));

assert(!PosInfInterval!Date(Date(1996, 1, 2)).isBefore(
            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));
</pre>  </dd> <dt class="d_decl" id="PosInfInterval.isBefore.3">const pure nothrow bool isBefore(in PosInfInterval interval)</dt> <dd>
<p>Whether this <code>interval</code> is before the given <code>interval</code> and does not intersect it. </p>
<p>Always returns <code>false</code> because an <code>interval</code> going to positive infinity can never be before any other <code>interval</code>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>PosInfInterval <code>interval</code>
</td> <td>The <code>interval</code> to check for against this <code>interval</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(!PosInfInterval!Date(Date(1996, 1, 2)).isBefore(
            PosInfInterval!Date(Date(1992, 5, 4))));

assert(!PosInfInterval!Date(Date(1996, 1, 2)).isBefore(
            PosInfInterval!Date(Date(2013, 3, 7))));
</pre>  </dd> <dt class="d_decl" id="PosInfInterval.isBefore.4">const pure nothrow bool isBefore(in NegInfInterval!TP interval)</dt> <dd>
<p>Whether this <code>interval</code> is before the given <code>interval</code> and does not intersect it. </p>
<p>Always returns <code>false</code> because an <code>interval</code> going to positive infinity can never be before any other <code>interval</code>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>NegInfInterval!TP <code>interval</code>
</td> <td>The <code>interval</code> to check for against this <code>interval</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(!PosInfInterval!Date(Date(1996, 1, 2)).isBefore(
            NegInfInterval!Date(Date(1996, 5, 4))));
</pre>  </dd> <dt class="d_decl" id="PosInfInterval.isAfter">const pure nothrow bool isAfter(in TP timePoint)</dt> <dd>
<p>Whether this interval is after the given time point. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>TP <code>timePoint</code>
</td> <td>The time point to check whether this interval is after it.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(PosInfInterval!Date(Date(1996, 1, 2)).isAfter(Date(1994, 12, 24)));
assert(!PosInfInterval!Date(Date(1996, 1, 2)).isAfter(Date(2000, 1, 5)));
</pre>  </dd> <dt class="d_decl" id="PosInfInterval.isAfter.2">const pure bool isAfter(in Interval!TP interval)</dt> <dd>
<p>Whether this <code>interval</code> is after the given <code>interval</code> and does not intersect it. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Interval!TP <code>interval</code>
</td> <td>The <code>interval</code> to check against this <code>interval</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the given <code>interval</code> is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(!PosInfInterval!Date(Date(1996, 1, 2)).isAfter(
            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));

assert(!PosInfInterval!Date(Date(1996, 1, 2)).isAfter(
            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));

assert(PosInfInterval!Date(Date(1996, 1, 2)).isAfter(
            Interval!Date(Date(1989, 3, 1), Date(1996, 1, 2))));
</pre>  </dd> <dt class="d_decl" id="PosInfInterval.isAfter.3">const pure nothrow bool isAfter(in PosInfInterval interval)</dt> <dd>
<p>Whether this <code>interval</code> is after the given <code>interval</code> and does not intersect it. </p>
<p>Always returns <code>false</code> because an <code>interval</code> going to positive infinity can never be after another <code>interval</code> going to positive infinity. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>PosInfInterval <code>interval</code>
</td> <td>The <code>interval</code> to check against this <code>interval</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(!PosInfInterval!Date(Date(1996, 1, 2)).isAfter(
            PosInfInterval!Date(Date(1990, 1, 7))));

assert(!PosInfInterval!Date(Date(1996, 1, 2)).isAfter(
            PosInfInterval!Date(Date(1999, 5, 4))));
</pre>  </dd> <dt class="d_decl" id="PosInfInterval.isAfter.4">const pure nothrow bool isAfter(in NegInfInterval!TP interval)</dt> <dd>
<p>Whether this <code>interval</code> is after the given <code>interval</code> and does not intersect it. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>NegInfInterval!TP <code>interval</code>
</td> <td>The <code>interval</code> to check against this <code>interval</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(PosInfInterval!Date(Date(1996, 1, 2)).isAfter(
            NegInfInterval!Date(Date(1996, 1, 2))));

assert(!PosInfInterval!Date(Date(1996, 1, 2)).isAfter(
            NegInfInterval!Date(Date(2000, 7, 1))));
</pre>  </dd> <dt class="d_decl" id="PosInfInterval.intersects">const pure bool intersects(in Interval!TP interval)</dt> <dd>
<p>Whether the given <code>interval</code> overlaps this <code>interval</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Interval!TP <code>interval</code>
</td> <td>The <code>interval</code> to check for intersection with this <code>interval</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the given <code>interval</code> is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(PosInfInterval!Date(Date(1996, 1, 2)).intersects(
            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));

assert(PosInfInterval!Date(Date(1996, 1, 2)).intersects(
            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));

assert(!PosInfInterval!Date(Date(1996, 1, 2)).intersects(
            Interval!Date(Date(1989, 3, 1), Date(1996, 1, 2))));
</pre>  </dd> <dt class="d_decl" id="PosInfInterval.intersects.2">const pure nothrow bool intersects(in PosInfInterval interval)</dt> <dd>
<p>Whether the given <code>interval</code> overlaps this <code>interval</code>. </p>
<p>Always returns <code>true</code> because two intervals going to positive infinity always overlap. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>PosInfInterval <code>interval</code>
</td> <td>The <code>interval</code> to check for intersection with this <code>interval</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(PosInfInterval!Date(Date(1996, 1, 2)).intersects(
            PosInfInterval!Date(Date(1990, 1, 7))));

assert(PosInfInterval!Date(Date(1996, 1, 2)).intersects(
            PosInfInterval!Date(Date(1999, 5, 4))));
</pre>  </dd> <dt class="d_decl" id="PosInfInterval.intersects.3">const pure nothrow bool intersects(in NegInfInterval!TP interval)</dt> <dd>
<p>Whether the given <code>interval</code> overlaps this <code>interval</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>NegInfInterval!TP <code>interval</code>
</td> <td>The <code>interval</code> to check for intersection with this <code>interval</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(!PosInfInterval!Date(Date(1996, 1, 2)).intersects(
            NegInfInterval!Date(Date(1996, 1, 2))));

assert(PosInfInterval!Date(Date(1996, 1, 2)).intersects(
            NegInfInterval!Date(Date(2000, 7, 1))));
</pre>  </dd> <dt class="d_decl" id="PosInfInterval.intersection">const Interval!TP intersection(in Interval!TP interval)</dt> <dd>
<p>Returns the <code>intersection</code> of two intervals </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Interval!TP <code>interval</code>
</td> <td>The <code>interval</code> to intersect with this <code>interval</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the two intervals do not intersect or if the given <code>interval</code> is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(PosInfInterval!Date(Date(1996, 1, 2)).intersection(
            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))) ==
       Interval!Date(Date(1996, 1 , 2), Date(2000, 8, 2)));

assert(PosInfInterval!Date(Date(1996, 1, 2)).intersection(
            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))) ==
       Interval!Date(Date(1999, 1 , 12), Date(2011, 9, 17)));
</pre>  </dd> <dt class="d_decl" id="PosInfInterval.intersection.2">const pure nothrow PosInfInterval intersection(in PosInfInterval interval)</dt> <dd>
<p>Returns the <code>intersection</code> of two intervals </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>PosInfInterval <code>interval</code>
</td> <td>The <code>interval</code> to intersect with this <code>interval</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(PosInfInterval!Date(Date(1996, 1, 2)).intersection(
            PosInfInterval!Date(Date(1990, 7, 6))) ==
       PosInfInterval!Date(Date(1996, 1 , 2)));

assert(PosInfInterval!Date(Date(1996, 1, 2)).intersection(
            PosInfInterval!Date(Date(1999, 1, 12))) ==
       PosInfInterval!Date(Date(1999, 1 , 12)));
</pre>  </dd> <dt class="d_decl" id="PosInfInterval.intersection.3">const Interval!TP intersection(in NegInfInterval!TP interval)</dt> <dd>
<p>Returns the <code>intersection</code> of two intervals </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>NegInfInterval!TP <code>interval</code>
</td> <td>The <code>interval</code> to intersect with this <code>interval</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the two intervals do not intersect. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(PosInfInterval!Date(Date(1996, 1, 2)).intersection(
            NegInfInterval!Date(Date(1999, 7, 6))) ==
       Interval!Date(Date(1996, 1 , 2), Date(1999, 7, 6)));

assert(PosInfInterval!Date(Date(1996, 1, 2)).intersection(
            NegInfInterval!Date(Date(2013, 1, 12))) ==
       Interval!Date(Date(1996, 1 , 2), Date(2013, 1, 12)));
</pre>  </dd> <dt class="d_decl" id="PosInfInterval.isAdjacent">const pure bool isAdjacent(in Interval!TP interval)</dt> <dd>
<p>Whether the given <code>interval</code> is adjacent to this <code>interval</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Interval!TP <code>interval</code>
</td> <td>The <code>interval</code> to check whether its adjecent to this <code>interval</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the given <code>interval</code> is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(PosInfInterval!Date(Date(1996, 1, 2)).isAdjacent(
            Interval!Date(Date(1989, 3, 1), Date(1996, 1, 2))));

assert(!PosInfInterval!Date(Date(1999, 1, 12)).isAdjacent(
            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));
</pre>  </dd> <dt class="d_decl" id="PosInfInterval.isAdjacent.2">const pure nothrow bool isAdjacent(in PosInfInterval interval)</dt> <dd>
<p>Whether the given <code>interval</code> is adjacent to this <code>interval</code>. </p>
<p>Always returns <code>false</code> because two intervals going to positive infinity can never be adjacent to one another. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>PosInfInterval <code>interval</code>
</td> <td>The <code>interval</code> to check whether its adjecent to this <code>interval</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(!PosInfInterval!Date(Date(1996, 1, 2)).isAdjacent(
            PosInfInterval!Date(Date(1990, 1, 7))));

assert(!PosInfInterval!Date(Date(1996, 1, 2)).isAdjacent(
            PosInfInterval!Date(Date(1996, 1, 2))));
</pre>  </dd> <dt class="d_decl" id="PosInfInterval.isAdjacent.3">const pure nothrow bool isAdjacent(in NegInfInterval!TP interval)</dt> <dd>
<p>Whether the given <code>interval</code> is adjacent to this <code>interval</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>NegInfInterval!TP <code>interval</code>
</td> <td>The <code>interval</code> to check whether its adjecent to this <code>interval</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(PosInfInterval!Date(Date(1996, 1, 2)).isAdjacent(
            NegInfInterval!Date(Date(1996, 1, 2))));

assert(!PosInfInterval!Date(Date(1996, 1, 2)).isAdjacent(
            NegInfInterval!Date(Date(2000, 7, 1))));
</pre>  </dd> <dt class="d_decl" id="PosInfInterval.merge">const PosInfInterval merge(in Interval!TP interval)</dt> <dd>
<p>Returns the union of two intervals </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Interval!TP <code>interval</code>
</td> <td>The <code>interval</code> to <code>merge</code> with this <code>interval</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the two intervals do not intersect and are not adjacent or if the given <code>interval</code> is empty. </dd>
</dl> <dl>
<dt>Note</dt>
<dd> There is no overload for <code>merge</code> which takes a <code>NegInfInterval</code>, because an <code>interval</code> going from negative infinity to positive infinity is not possible. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(PosInfInterval!Date(Date(1996, 1, 2)).merge(
            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))) ==
       PosInfInterval!Date(Date(1990, 7 , 6)));

assert(PosInfInterval!Date(Date(1996, 1, 2)).merge(
            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))) ==
       PosInfInterval!Date(Date(1996, 1 , 2)));
</pre>  </dd> <dt class="d_decl" id="PosInfInterval.merge.2">const pure nothrow PosInfInterval merge(in PosInfInterval interval)</dt> <dd>
<p>Returns the union of two intervals </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>PosInfInterval <code>interval</code>
</td> <td>The <code>interval</code> to <code>merge</code> with this <code>interval</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Note</dt>
<dd> There is no overload for <code>merge</code> which takes a <code>NegInfInterval</code>, because an <code>interval</code> going from negative infinity to positive infinity is not possible. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(PosInfInterval!Date(Date(1996, 1, 2)).merge(
            PosInfInterval!Date(Date(1990, 7, 6))) ==
       PosInfInterval!Date(Date(1990, 7 , 6)));

assert(PosInfInterval!Date(Date(1996, 1, 2)).merge(
            PosInfInterval!Date(Date(1999, 1, 12))) ==
       PosInfInterval!Date(Date(1996, 1 , 2)));
</pre>  </dd> <dt class="d_decl" id="PosInfInterval.span">const pure PosInfInterval span(in Interval!TP interval)</dt> <dd>
<p>Returns an <code>interval</code> that covers from the earliest time point of two intervals up to (but not including) the latest time point of two intervals. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Interval!TP <code>interval</code>
</td> <td>The <code>interval</code> to create a <code>span</code> together with this <code>interval</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the given <code>interval</code> is empty. </dd>
</dl> <dl>
<dt>Note</dt>
<dd> There is no overload for <code>span</code> which takes a <code>NegInfInterval</code>, because an <code>interval</code> going from negative infinity to positive infinity is not possible. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(PosInfInterval!Date(Date(1996, 1, 2)).span(
            Interval!Date(Date(500, 8, 9), Date(1602, 1, 31))) ==
       PosInfInterval!Date(Date(500, 8, 9)));

assert(PosInfInterval!Date(Date(1996, 1, 2)).span(
            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))) ==
       PosInfInterval!Date(Date(1990, 7 , 6)));

assert(PosInfInterval!Date(Date(1996, 1, 2)).span(
            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))) ==
       PosInfInterval!Date(Date(1996, 1 , 2)));
</pre>  </dd> <dt class="d_decl" id="PosInfInterval.span.2">const pure nothrow PosInfInterval span(in PosInfInterval interval)</dt> <dd>
<p>Returns an <code>interval</code> that covers from the earliest time point of two intervals up to (but not including) the latest time point of two intervals. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>PosInfInterval <code>interval</code>
</td> <td>The <code>interval</code> to create a <code>span</code> together with this <code>interval</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Note</dt>
<dd> There is no overload for <code>span</code> which takes a <code>NegInfInterval</code>, because an <code>interval</code> going from negative infinity to positive infinity is not possible. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(PosInfInterval!Date(Date(1996, 1, 2)).span(
            PosInfInterval!Date(Date(1990, 7, 6))) ==
       PosInfInterval!Date(Date(1990, 7 , 6)));

assert(PosInfInterval!Date(Date(1996, 1, 2)).span(
            PosInfInterval!Date(Date(1999, 1, 12))) ==
       PosInfInterval!Date(Date(1996, 1 , 2)));
</pre>  </dd> <dt class="d_decl" id="PosInfInterval.shift">pure nothrow void shift(D)(D duration)<br><br>  Constraints:<br>    if (__traits(compiles, begin + duration))</dt> <dd>
<p>Shifts the <code>begin</code> of this interval forward or backwards in time by the given <code>duration</code> (a positive <code>duration</code> shifts the interval forward; a negative <code>duration</code> shifts it backward). Effectively, it does <code>begin += duration</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>D <code>duration</code>
</td> <td>The <code>duration</code> to <code>shift</code> the interval by.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto interval1 = PosInfInterval!Date(Date(1996, 1, 2));
auto interval2 = PosInfInterval!Date(Date(1996, 1, 2));

interval1.shift(dur!"days"(50));
assert(interval1 == PosInfInterval!Date(Date(1996, 2, 21)));

interval2.shift(dur!"days"(-50));
assert(interval2 == PosInfInterval!Date(Date(1995, 11, 13)));
</pre>  </dd> <dt class="d_decl" id="PosInfInterval.shift.2">void shift(T)(T years, T months = 0, AllowDayOverflow allowOverflow = AllowDayOverflow.yes)<br><br>  Constraints:<br>    if (isIntegral!T)</dt> <dd>
<p>Shifts the <code>begin</code> of this interval forward or backwards in time by the given number of <code>years</code> and/or <code>months</code> (a positive number of <code>years</code> and <code>months</code> shifts the interval forward; a negative number shifts it backward). It adds the <code>years</code> the given <code>years</code> and <code>months</code> to <code>begin</code>. It effectively calls <code>add!"years"()</code> and then <code>add!"months"()</code> on <code>begin</code> with the given number of <code>years</code> and <code>months</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T <code>years</code>
</td> <td>The number of <code>years</code> to <code>shift</code> the interval by.</td>
</tr> <tr>
<td>T <code>months</code>
</td> <td>The number of <code>months</code> to <code>shift</code> the interval by.</td>
</tr> <tr>
<td>AllowDayOverflow <code>allowOverflow</code>
</td> <td>Whether the days should be allowed to overflow on <code>begin</code>, causing its month to increment.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if this interval is empty or if the resulting interval would be invalid. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto interval1 = PosInfInterval!Date(Date(1996, 1, 2));
auto interval2 = PosInfInterval!Date(Date(1996, 1, 2));

interval1.shift(dur!"days"(50));
assert(interval1 == PosInfInterval!Date(Date(1996, 2, 21)));

interval2.shift(dur!"days"(-50));
assert(interval2 == PosInfInterval!Date(Date(1995, 11, 13)));
</pre>  </dd> <dt class="d_decl" id="PosInfInterval.expand">pure nothrow void expand(D)(D duration)<br><br>  Constraints:<br>    if (__traits(compiles, begin + duration))</dt> <dd>
<p>Expands the interval backwards in time. Effectively, it does <code>begin -= duration</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>D <code>duration</code>
</td> <td>The <code>duration</code> to <code>expand</code> the interval by.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto interval1 = PosInfInterval!Date(Date(1996, 1, 2));
auto interval2 = PosInfInterval!Date(Date(1996, 1, 2));

interval1.expand(dur!"days"(2));
assert(interval1 == PosInfInterval!Date(Date(1995, 12, 31)));

interval2.expand(dur!"days"(-2));
assert(interval2 == PosInfInterval!Date(Date(1996, 1, 4)));
</pre>  </dd> <dt class="d_decl" id="PosInfInterval.expand.2">void expand(T)(T years, T months = 0, AllowDayOverflow allowOverflow = AllowDayOverflow.yes)<br><br>  Constraints:<br>    if (isIntegral!T)</dt> <dd>
<p>Expands the interval forwards and/or backwards in time. Effectively, it subtracts the given number of <code>months</code>/<code>years</code> from <code>begin</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T <code>years</code>
</td> <td>The number of <code>years</code> to <code>expand</code> the interval by.</td>
</tr> <tr>
<td>T <code>months</code>
</td> <td>The number of <code>months</code> to <code>expand</code> the interval by.</td>
</tr> <tr>
<td>AllowDayOverflow <code>allowOverflow</code>
</td> <td>Whether the days should be allowed to overflow on <code>begin</code>, causing its month to increment.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if this interval is empty or if the resulting interval would be invalid. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto interval1 = PosInfInterval!Date(Date(1996, 1, 2));
auto interval2 = PosInfInterval!Date(Date(1996, 1, 2));

interval1.expand(2);
assert(interval1 == PosInfInterval!Date(Date(1994, 1, 2)));

interval2.expand(-2);
assert(interval2 == PosInfInterval!Date(Date(1998, 1, 2)));
</pre>  </dd> <dt class="d_decl" id="PosInfInterval.fwdRange">const PosInfIntervalRange!TP fwdRange(TP delegate(in TP) func, PopFirst popFirst = PopFirst.no)</dt> <dd>
<p>Returns a range which iterates forward over the interval, starting at <code>begin</code>, using <span class="d_param"><code>func</code></span> to generate each successive time point. </p>
<p>The range's <code>front</code> is the interval's <code>begin</code>. <span class="d_param"><code>func</code></span> is used to generate the next <code>front</code> when <code>popFront</code> is called. If <span class="d_param"><code>popFirst</code></span> is <code>PopFirst.yes</code>, then <code>popFront</code> is called before the range is returned (so that <code>front</code> is a time point which <span class="d_param"><code>func</code></span> would generate). <br><br> If <span class="d_param"><code>func</code></span> ever generates a time point less than or equal to the current <code>front</code> of the range, then a <a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> will be thrown. <br><br> There are helper functions in this module which generate common delegates to pass to <code>fwdRange</code>. Their documentation starts with "Range-generating function," to make them easily searchable. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>TP delegate(in TP) <code>func</code>
</td> <td>The function used to generate the time points of the range over the interval.</td>
</tr> <tr>
<td>PopFirst <code>popFirst</code>
</td> <td>Whether <code>popFront</code> should be called on the range before returning it.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if this interval is empty. </dd>
</dl> <dl>
<dt>Warning</dt>
<dd> <span class="d_param"><code>func</code></span> must be logically pure. Ideally, <span class="d_param"><code>func</code></span> would be a function pointer to a pure function, but forcing <span class="d_param"><code>func</code></span> to be pure is far too restrictive to be useful, and in order to have the ease of use of having functions which generate functions to pass to <code>fwdRange</code>, <span class="d_param"><code>func</code></span> must be a delegate. </dd>
</dl> If <span class="d_param"><code>func</code></span> retains state which changes as it is called, then some algorithms will not work correctly, because the range's <code>save</code> will have failed to have really saved the range's state. To avoid such bugs, don't pass a delegate which is not logically pure to <code>fwdRange</code>. If <span class="d_param"><code>func</code></span> is given the same time point with two different calls, it must return the same result both times.  Of course, none of the functions in this module have this problem, so it's only relevant for custom delegates.  <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto interval = PosInfInterval!Date(Date(2010, 9, 1));
auto func = delegate (in Date date) //For iterating over even-numbered days.
            {
                if ((date.day &amp; 1) == 0)
                    return date + dur!"days"(2);

                return date + dur!"days"(1);
            };
auto range = interval.fwdRange(func);

//An odd day. Using PopFirst.yes would have made this Date(2010, 9, 2).
assert(range.front == Date(2010, 9, 1));

range.popFront();
assert(range.front == Date(2010, 9, 2));

range.popFront();
assert(range.front == Date(2010, 9, 4));

range.popFront();
assert(range.front == Date(2010, 9, 6));

range.popFront();
assert(range.front == Date(2010, 9, 8));

range.popFront();
assert(!range.empty);
</pre>  </dd> <dt class="d_decl" id="PosInfInterval.toString">const nothrow string toString()</dt> <dd>
<p>Converts this interval to a string.</p> </dd> </dl> </dd> <dt class="d_decl" id="NegInfInterval">struct NegInfInterval(TP)</dt> <dd>
<p>Represents an interval of time which has negative infinity as its starting point. </p>
<p>Any ranges which iterate over a <code>NegInfInterval</code> are infinite. So, the main purpose of using <code>NegInfInterval</code> is to create an infinite range which starts at negative infinity and goes to a fixed end point. Iterate over it in reverse.</p> <dl>
<dt class="d_decl" id="NegInfInterval.this">pure nothrow this(in TP end)</dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>TP <code>end</code>
</td> <td>The time point which ends the interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto interval = PosInfInterval!Date(Date(1996, 1, 2));
</pre>  </dd> <dt class="d_decl" id="NegInfInterval.opAssign">pure nothrow ref NegInfInterval opAssign(ref const NegInfInterval rhs)</dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>NegInfInterval <code>rhs</code>
</td> <td>The <code>NegInfInterval</code> to assign to this one.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="NegInfInterval.opAssign.2">pure nothrow ref NegInfInterval opAssign(NegInfInterval rhs)</dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>NegInfInterval <code>rhs</code>
</td> <td>The <code>NegInfInterval</code> to assign to this one.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="NegInfInterval.end">const pure nothrow @property TP end()</dt> <dd>
<p>The <code>end</code> point of the interval. It is excluded from the interval. </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(NegInfInterval!Date(Date(2012, 3, 1)).end == Date(2012, 3, 1));
</pre>  </dd> <dt class="d_decl" id="NegInfInterval.end.2">pure nothrow @property void end(TP timePoint)</dt> <dd>
<p>The <code>end</code> point of the interval. It is excluded from the interval. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>TP <code>timePoint</code>
</td> <td>The time point to set <code>end</code> to.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="NegInfInterval.empty">enum bool empty</dt> <dd>
<p>Whether the interval's length is 0. Always returns <code>false</code>. </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(!NegInfInterval!Date(Date(1996, 1, 2)).empty);
</pre>  </dd> <dt class="d_decl" id="NegInfInterval.contains">const pure nothrow bool contains(TP timePoint)</dt> <dd>
<p>Whether the given time point is within this interval. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>TP <code>timePoint</code>
</td> <td>The time point to check for inclusion in this interval.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(NegInfInterval!Date(Date(2012, 3, 1)).contains(Date(1994, 12, 24)));
assert(NegInfInterval!Date(Date(2012, 3, 1)).contains(Date(2000, 1, 5)));
assert(!NegInfInterval!Date(Date(2012, 3, 1)).contains(Date(2012, 3, 1)));
</pre>  </dd> <dt class="d_decl" id="NegInfInterval.contains.2">const pure bool contains(in Interval!TP interval)</dt> <dd>
<p>Whether the given <code>interval</code> is completely within this <code>interval</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Interval!TP <code>interval</code>
</td> <td>The <code>interval</code> to check for inclusion in this <code>interval</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the given <code>interval</code> is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(NegInfInterval!Date(Date(2012, 3, 1)).contains(
            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));

assert(NegInfInterval!Date(Date(2012, 3, 1)).contains(
            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));

assert(!NegInfInterval!Date(Date(2012, 3, 1)).contains(
            Interval!Date(Date(1998, 2, 28), Date(2013, 5, 1))));
</pre>  </dd> <dt class="d_decl" id="NegInfInterval.contains.3">const pure nothrow bool contains(in PosInfInterval!TP interval)</dt> <dd>
<p>Whether the given <code>interval</code> is completely within this <code>interval</code>. </p>
<p>Always returns <code>false</code> because an <code>interval</code> beginning at negative infinity can never contain an <code>interval</code> going to positive infinity. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>PosInfInterval!TP <code>interval</code>
</td> <td>The <code>interval</code> to check for inclusion in this <code>interval</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(!NegInfInterval!Date(Date(2012, 3, 1)).contains(
            PosInfInterval!Date(Date(1999, 5, 4))));
</pre>  </dd> <dt class="d_decl" id="NegInfInterval.contains.4">const pure nothrow bool contains(in NegInfInterval interval)</dt> <dd>
<p>Whether the given <code>interval</code> is completely within this <code>interval</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>NegInfInterval <code>interval</code>
</td> <td>The <code>interval</code> to check for inclusion in this <code>interval</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(NegInfInterval!Date(Date(2012, 3, 1)).contains(
            NegInfInterval!Date(Date(1996, 5, 4))));

assert(!NegInfInterval!Date(Date(2012, 3, 1)).contains(
            NegInfInterval!Date(Date(2013, 7, 9))));
</pre>  </dd> <dt class="d_decl" id="NegInfInterval.isBefore">const pure nothrow bool isBefore(in TP timePoint)</dt> <dd>
<p>Whether this interval is before the given time point. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>TP <code>timePoint</code>
</td> <td>The time point to check whether this interval is before it.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(!NegInfInterval!Date(Date(2012, 3, 1)).isBefore(Date(1994, 12, 24)));
assert(!NegInfInterval!Date(Date(2012, 3, 1)).isBefore(Date(2000, 1, 5)));
assert(NegInfInterval!Date(Date(2012, 3, 1)).isBefore(Date(2012, 3, 1)));
</pre>  </dd> <dt class="d_decl" id="NegInfInterval.isBefore.2">const pure bool isBefore(in Interval!TP interval)</dt> <dd>
<p>Whether this <code>interval</code> is before the given <code>interval</code> and does not intersect it. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Interval!TP <code>interval</code>
</td> <td>The <code>interval</code> to check for against this <code>interval</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the given <code>interval</code> is empty </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(!NegInfInterval!Date(Date(2012, 3, 1)).isBefore(
            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));

assert(!NegInfInterval!Date(Date(2012, 3, 1)).isBefore(
            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));

assert(NegInfInterval!Date(Date(2012, 3, 1)).isBefore(
            Interval!Date(Date(2022, 10, 19), Date(2027, 6, 3))));
</pre>  </dd> <dt class="d_decl" id="NegInfInterval.isBefore.3">const pure nothrow bool isBefore(in PosInfInterval!TP interval)</dt> <dd>
<p>Whether this <code>interval</code> is before the given <code>interval</code> and does not intersect it. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>PosInfInterval!TP <code>interval</code>
</td> <td>The <code>interval</code> to check for against this <code>interval</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(!NegInfInterval!Date(Date(2012, 3, 1)).isBefore(
            PosInfInterval!Date(Date(1999, 5, 4))));

assert(NegInfInterval!Date(Date(2012, 3, 1)).isBefore(
            PosInfInterval!Date(Date(2012, 3, 1))));
</pre>  </dd> <dt class="d_decl" id="NegInfInterval.isBefore.4">const pure nothrow bool isBefore(in NegInfInterval interval)</dt> <dd>
<p>Whether this <code>interval</code> is before the given <code>interval</code> and does not intersect it. </p>
<p>Always returns <code>false</code> because an <code>interval</code> beginning at negative infinity can never be before another <code>interval</code> beginning at negative infinity. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>NegInfInterval <code>interval</code>
</td> <td>The <code>interval</code> to check for against this <code>interval</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(!NegInfInterval!Date(Date(2012, 3, 1)).isBefore(
            NegInfInterval!Date(Date(1996, 5, 4))));

assert(!NegInfInterval!Date(Date(2012, 3, 1)).isBefore(
            NegInfInterval!Date(Date(2013, 7, 9))));
</pre>  </dd> <dt class="d_decl" id="NegInfInterval.isAfter">const pure nothrow bool isAfter(in TP timePoint)</dt> <dd>
<p>Whether this interval is after the given time point. </p>
<p>Always returns <code>false</code> because an interval beginning at negative infinity can never be after any time point. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>TP <code>timePoint</code>
</td> <td>The time point to check whether this interval is after it.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(!NegInfInterval!Date(Date(2012, 3, 1)).isAfter(Date(1994, 12, 24)));
assert(!NegInfInterval!Date(Date(2012, 3, 1)).isAfter(Date(2000, 1, 5)));
assert(!NegInfInterval!Date(Date(2012, 3, 1)).isAfter(Date(2012, 3, 1)));
</pre>  </dd> <dt class="d_decl" id="NegInfInterval.isAfter.2">const pure bool isAfter(in Interval!TP interval)</dt> <dd>
<p>Whether this <code>interval</code> is after the given <code>interval</code> and does not intersect it. </p>
<p>Always returns <code>false</code> (unless the given <code>interval</code> is empty) because an <code>interval</code> beginning at negative infinity can never be after any other <code>interval</code>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Interval!TP <code>interval</code>
</td> <td>The <code>interval</code> to check against this <code>interval</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the given <code>interval</code> is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(!NegInfInterval!Date(Date(2012, 3, 1)).isAfter(
            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));

assert(!NegInfInterval!Date(Date(2012, 3, 1)).isAfter(
            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));

assert(!NegInfInterval!Date(Date(2012, 3, 1)).isAfter(
            Interval!Date(Date(2022, 10, 19), Date(2027, 6, 3))));
</pre>  </dd> <dt class="d_decl" id="NegInfInterval.isAfter.3">const pure nothrow bool isAfter(in PosInfInterval!TP interval)</dt> <dd>
<p>Whether this <code>interval</code> is after the given <code>interval</code> and does not intersect it. </p>
<p>Always returns <code>false</code> because an <code>interval</code> beginning at negative infinity can never be after any other <code>interval</code>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>PosInfInterval!TP <code>interval</code>
</td> <td>The <code>interval</code> to check against this <code>interval</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(!NegInfInterval!Date(Date(2012, 3, 1)).isAfter(
            PosInfInterval!Date(Date(1999, 5, 4))));

assert(!NegInfInterval!Date(Date(2012, 3, 1)).isAfter(
            PosInfInterval!Date(Date(2012, 3, 1))));
</pre>  </dd> <dt class="d_decl" id="NegInfInterval.isAfter.4">const pure nothrow bool isAfter(in NegInfInterval interval)</dt> <dd>
<p>Whether this <code>interval</code> is after the given <code>interval</code> and does not intersect it. </p>
<p>Always returns <code>false</code> because an <code>interval</code> beginning at negative infinity can never be after any other <code>interval</code>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>NegInfInterval <code>interval</code>
</td> <td>The <code>interval</code> to check against this <code>interval</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(!NegInfInterval!Date(Date(2012, 3, 1)).isAfter(
            NegInfInterval!Date(Date(1996, 5, 4))));

assert(!NegInfInterval!Date(Date(2012, 3, 1)).isAfter(
            NegInfInterval!Date(Date(2013, 7, 9))));
</pre>  </dd> <dt class="d_decl" id="NegInfInterval.intersects">const pure bool intersects(in Interval!TP interval)</dt> <dd>
<p>Whether the given <code>interval</code> overlaps this <code>interval</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Interval!TP <code>interval</code>
</td> <td>The <code>interval</code> to check for intersection with this <code>interval</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the given <code>interval</code> is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(NegInfInterval!Date(Date(2012, 3, 1)).intersects(
            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));

assert(NegInfInterval!Date(Date(2012, 3, 1)).intersects(
            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));

assert(!NegInfInterval!Date(Date(2012, 3, 1)).intersects(
            Interval!Date(Date(2022, 10, 19), Date(2027, 6, 3))));
</pre>  </dd> <dt class="d_decl" id="NegInfInterval.intersects.2">const pure nothrow bool intersects(in PosInfInterval!TP interval)</dt> <dd>
<p>Whether the given <code>interval</code> overlaps this <code>interval</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>PosInfInterval!TP <code>interval</code>
</td> <td>The <code>interval</code> to check for intersection with this <code>interval</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(NegInfInterval!Date(Date(2012, 3, 1)).intersects(
            PosInfInterval!Date(Date(1999, 5, 4))));

assert(!NegInfInterval!Date(Date(2012, 3, 1)).intersects(
            PosInfInterval!Date(Date(2012, 3, 1))));
</pre>  </dd> <dt class="d_decl" id="NegInfInterval.intersects.3">const pure nothrow bool intersects(in NegInfInterval!TP interval)</dt> <dd>
<p>Whether the given <code>interval</code> overlaps this <code>interval</code>. </p>
<p>Always returns <code>true</code> because two intervals beginning at negative infinity always overlap. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>NegInfInterval!TP <code>interval</code>
</td> <td>The <code>interval</code> to check for intersection with this <code>interval</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(NegInfInterval!Date(Date(2012, 3, 1)).intersects(
            NegInfInterval!Date(Date(1996, 5, 4))));

assert(NegInfInterval!Date(Date(2012, 3, 1)).intersects(
            NegInfInterval!Date(Date(2013, 7, 9))));
</pre>  </dd> <dt class="d_decl" id="NegInfInterval.intersection">const Interval!TP intersection(in Interval!TP interval)</dt> <dd>
<p>Returns the <code>intersection</code> of two intervals </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Interval!TP <code>interval</code>
</td> <td>The <code>interval</code> to intersect with this <code>interval</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the two intervals do not intersect or if the given <code>interval</code> is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(NegInfInterval!Date(Date(2012, 3, 1)).intersection(
            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))) ==
       Interval!Date(Date(1990, 7 , 6), Date(2000, 8, 2)));

assert(NegInfInterval!Date(Date(2012, 3, 1)).intersection(
            Interval!Date(Date(1999, 1, 12), Date(2015, 9, 2))) ==
       Interval!Date(Date(1999, 1 , 12), Date(2012, 3, 1)));
</pre>  </dd> <dt class="d_decl" id="NegInfInterval.intersection.2">const Interval!TP intersection(in PosInfInterval!TP interval)</dt> <dd>
<p>Returns the <code>intersection</code> of two intervals </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>PosInfInterval!TP <code>interval</code>
</td> <td>The <code>interval</code> to intersect with this <code>interval</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the two intervals do not intersect. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(NegInfInterval!Date(Date(2012, 3, 1)).intersection(
            PosInfInterval!Date(Date(1990, 7, 6))) ==
       Interval!Date(Date(1990, 7 , 6), Date(2012, 3, 1)));

assert(NegInfInterval!Date(Date(2012, 3, 1)).intersection(
            PosInfInterval!Date(Date(1999, 1, 12))) ==
       Interval!Date(Date(1999, 1 , 12), Date(2012, 3, 1)));
</pre>  </dd> <dt class="d_decl" id="NegInfInterval.intersection.3">const nothrow NegInfInterval intersection(in NegInfInterval interval)</dt> <dd>
<p>Returns the <code>intersection</code> of two intervals </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>NegInfInterval <code>interval</code>
</td> <td>The <code>interval</code> to intersect with this <code>interval</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(NegInfInterval!Date(Date(2012, 3, 1)).intersection(
            NegInfInterval!Date(Date(1999, 7, 6))) ==
       NegInfInterval!Date(Date(1999, 7 , 6)));

assert(NegInfInterval!Date(Date(2012, 3, 1)).intersection(
            NegInfInterval!Date(Date(2013, 1, 12))) ==
       NegInfInterval!Date(Date(2012, 3 , 1)));
</pre>  </dd> <dt class="d_decl" id="NegInfInterval.isAdjacent">const pure bool isAdjacent(in Interval!TP interval)</dt> <dd>
<p>Whether the given <code>interval</code> is adjacent to this <code>interval</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Interval!TP <code>interval</code>
</td> <td>The <code>interval</code> to check whether its adjecent to this <code>interval</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the given <code>interval</code> is empty. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(!NegInfInterval!Date(Date(2012, 3, 1)).isAdjacent(
            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));

assert(!NegInfInterval!Date(Date(2012, 3, 1)).isAdjacent(
            Interval!Date(Date(1999, 1, 12), Date(2012, 3, 1))));

assert(NegInfInterval!Date(Date(2012, 3, 1)).isAdjacent(
            Interval!Date(Date(2012, 3, 1), Date(2019, 2, 2))));

assert(!NegInfInterval!Date(Date(2012, 3, 1)).isAdjacent(
            Interval!Date(Date(2022, 10, 19), Date(2027, 6, 3))));
</pre>  </dd> <dt class="d_decl" id="NegInfInterval.isAdjacent.2">const pure nothrow bool isAdjacent(in PosInfInterval!TP interval)</dt> <dd>
<p>Whether the given <code>interval</code> is adjacent to this <code>interval</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>PosInfInterval!TP <code>interval</code>
</td> <td>The <code>interval</code> to check whether its adjecent to this <code>interval</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(!NegInfInterval!Date(Date(2012, 3, 1)).isAdjacent(
            PosInfInterval!Date(Date(1999, 5, 4))));

assert(NegInfInterval!Date(Date(2012, 3, 1)).isAdjacent(
            PosInfInterval!Date(Date(2012, 3, 1))));
</pre>  </dd> <dt class="d_decl" id="NegInfInterval.isAdjacent.3">const pure nothrow bool isAdjacent(in NegInfInterval interval)</dt> <dd>
<p>Whether the given <code>interval</code> is adjacent to this <code>interval</code>. </p>
<p>Always returns <code>false</code> because two intervals beginning at negative infinity can never be adjacent to one another. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>NegInfInterval <code>interval</code>
</td> <td>The <code>interval</code> to check whether its adjecent to this <code>interval</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(!NegInfInterval!Date(Date(2012, 3, 1)).isAdjacent(
            NegInfInterval!Date(Date(1996, 5, 4))));

assert(!NegInfInterval!Date(Date(2012, 3, 1)).isAdjacent(
            NegInfInterval!Date(Date(2012, 3, 1))));
</pre>  </dd> <dt class="d_decl" id="NegInfInterval.merge">const NegInfInterval merge(in Interval!TP interval)</dt> <dd>
<p>Returns the union of two intervals </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Interval!TP <code>interval</code>
</td> <td>The <code>interval</code> to <code>merge</code> with this <code>interval</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the two intervals do not intersect and are not adjacent or if the given <code>interval</code> is empty. </dd>
</dl> <dl>
<dt>Note</dt>
<dd> There is no overload for <code>merge</code> which takes a <code>PosInfInterval</code>, because an <code>interval</code> going from negative infinity to positive infinity is not possible. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(NegInfInterval!Date(Date(2012, 3, 1)).merge(
            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))) ==
       NegInfInterval!Date(Date(2012, 3 , 1)));

assert(NegInfInterval!Date(Date(2012, 3, 1)).merge(
            Interval!Date(Date(1999, 1, 12), Date(2015, 9, 2))) ==
       NegInfInterval!Date(Date(2015, 9 , 2)));
</pre>  </dd> <dt class="d_decl" id="NegInfInterval.merge.2">const pure nothrow NegInfInterval merge(in NegInfInterval interval)</dt> <dd>
<p>Returns the union of two intervals </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>NegInfInterval <code>interval</code>
</td> <td>The <code>interval</code> to <code>merge</code> with this <code>interval</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Note</dt>
<dd> There is no overload for <code>merge</code> which takes a <code>PosInfInterval</code>, because an <code>interval</code> going from negative infinity to positive infinity is not possible. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(NegInfInterval!Date(Date(2012, 3, 1)).merge(
            NegInfInterval!Date(Date(1999, 7, 6))) ==
       NegInfInterval!Date(Date(2012, 3 , 1)));

assert(NegInfInterval!Date(Date(2012, 3, 1)).merge(
            NegInfInterval!Date(Date(2013, 1, 12))) ==
       NegInfInterval!Date(Date(2013, 1 , 12)));
</pre>  </dd> <dt class="d_decl" id="NegInfInterval.span">const pure NegInfInterval span(in Interval!TP interval)</dt> <dd>
<p>Returns an <code>interval</code> that covers from the earliest time point of two intervals up to (but not including) the latest time point of two intervals. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Interval!TP <code>interval</code>
</td> <td>The <code>interval</code> to create a <code>span</code> together with this <code>interval</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the given <code>interval</code> is empty. </dd>
</dl> <dl>
<dt>Note</dt>
<dd> There is no overload for <code>span</code> which takes a <code>PosInfInterval</code>, because an <code>interval</code> going from negative infinity to positive infinity is not possible. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(NegInfInterval!Date(Date(2012, 3, 1)).span(
            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))) ==
       NegInfInterval!Date(Date(2012, 3 , 1)));

assert(NegInfInterval!Date(Date(2012, 3, 1)).span(
            Interval!Date(Date(1999, 1, 12), Date(2015, 9, 2))) ==
       NegInfInterval!Date(Date(2015, 9 , 2)));

assert(NegInfInterval!Date(Date(1600, 1, 7)).span(
            Interval!Date(Date(2012, 3, 11), Date(2017, 7, 1))) ==
       NegInfInterval!Date(Date(2017, 7 , 1)));
</pre>  </dd> <dt class="d_decl" id="NegInfInterval.span.2">const pure nothrow NegInfInterval span(in NegInfInterval interval)</dt> <dd>
<p>Returns an <code>interval</code> that covers from the earliest time point of two intervals up to (but not including) the latest time point of two intervals. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>NegInfInterval <code>interval</code>
</td> <td>The <code>interval</code> to create a <code>span</code> together with this <code>interval</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Note</dt>
<dd> There is no overload for <code>span</code> which takes a <code>PosInfInterval</code>, because an <code>interval</code> going from negative infinity to positive infinity is not possible. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(NegInfInterval!Date(Date(2012, 3, 1)).span(
            NegInfInterval!Date(Date(1999, 7, 6))) ==
       NegInfInterval!Date(Date(2012, 3 , 1)));

assert(NegInfInterval!Date(Date(2012, 3, 1)).span(
            NegInfInterval!Date(Date(2013, 1, 12))) ==
       NegInfInterval!Date(Date(2013, 1 , 12)));
</pre>  </dd> <dt class="d_decl" id="NegInfInterval.shift">pure nothrow void shift(D)(D duration)<br><br>  Constraints:<br>    if (__traits(compiles, end + duration))</dt> <dd>
<p>Shifts the <code>end</code> of this interval forward or backwards in time by the given <code>duration</code> (a positive <code>duration</code> shifts the interval forward; a negative <code>duration</code> shifts it backward). Effectively, it does <code>end += duration</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>D <code>duration</code>
</td> <td>The <code>duration</code> to <code>shift</code> the interval by.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto interval1 = NegInfInterval!Date(Date(2012, 4, 5));
auto interval2 = NegInfInterval!Date(Date(2012, 4, 5));

interval1.shift(dur!"days"(50));
assert(interval1 == NegInfInterval!Date(Date(2012, 5, 25)));

interval2.shift(dur!"days"(-50));
assert(interval2 == NegInfInterval!Date( Date(2012, 2, 15)));
</pre>  </dd> <dt class="d_decl" id="NegInfInterval.shift.2">void shift(T)(T years, T months = 0, AllowDayOverflow allowOverflow = AllowDayOverflow.yes)<br><br>  Constraints:<br>    if (isIntegral!T)</dt> <dd>
<p>Shifts the <code>end</code> of this interval forward or backwards in time by the given number of <code>years</code> and/or <code>months</code> (a positive number of <code>years</code> and <code>months</code> shifts the interval forward; a negative number shifts it backward). It adds the <code>years</code> the given <code>years</code> and <code>months</code> to end. It effectively calls <code>add!"years"()</code> and then <code>add!"months"()</code> on end with the given number of <code>years</code> and <code>months</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T <code>years</code>
</td> <td>The number of <code>years</code> to <code>shift</code> the interval by.</td>
</tr> <tr>
<td>T <code>months</code>
</td> <td>The number of <code>months</code> to <code>shift</code> the interval by.</td>
</tr> <tr>
<td>AllowDayOverflow <code>allowOverflow</code>
</td> <td>Whether the days should be allowed to overflow on <code>end</code>, causing its month to increment.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if empty is <code>true</code> or if the resulting interval would be invalid. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto interval1 = NegInfInterval!Date(Date(2012, 3, 1));
auto interval2 = NegInfInterval!Date(Date(2012, 3, 1));

interval1.shift(2);
assert(interval1 == NegInfInterval!Date(Date(2014, 3, 1)));

interval2.shift(-2);
assert(interval2 == NegInfInterval!Date(Date(2010, 3, 1)));
</pre>  </dd> <dt class="d_decl" id="NegInfInterval.expand">pure nothrow void expand(D)(D duration)<br><br>  Constraints:<br>    if (__traits(compiles, end + duration))</dt> <dd>
<p>Expands the interval forwards in time. Effectively, it does <code>end += duration</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>D <code>duration</code>
</td> <td>The <code>duration</code> to <code>expand</code> the interval by.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto interval1 = NegInfInterval!Date(Date(2012, 3, 1));
auto interval2 = NegInfInterval!Date(Date(2012, 3, 1));

interval1.expand(dur!"days"(2));
assert(interval1 == NegInfInterval!Date(Date(2012, 3, 3)));

interval2.expand(dur!"days"(-2));
assert(interval2 == NegInfInterval!Date(Date(2012, 2, 28)));
</pre>  </dd> <dt class="d_decl" id="NegInfInterval.expand.2">void expand(T)(T years, T months = 0, AllowDayOverflow allowOverflow = AllowDayOverflow.yes)<br><br>  Constraints:<br>    if (isIntegral!T)</dt> <dd>
<p>Expands the interval forwards and/or backwards in time. Effectively, it adds the given number of <code>months</code>/<code>years</code> to end. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T <code>years</code>
</td> <td>The number of <code>years</code> to <code>expand</code> the interval by.</td>
</tr> <tr>
<td>T <code>months</code>
</td> <td>The number of <code>months</code> to <code>expand</code> the interval by.</td>
</tr> <tr>
<td>AllowDayOverflow <code>allowOverflow</code>
</td> <td>Whether the days should be allowed to overflow on <code>end</code>, causing their month to increment.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if empty is <code>true</code> or if the resulting interval would be invalid. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto interval1 = NegInfInterval!Date(Date(2012, 3, 1));
auto interval2 = NegInfInterval!Date(Date(2012, 3, 1));

interval1.expand(2);
assert(interval1 == NegInfInterval!Date(Date(2014, 3, 1)));

interval2.expand(-2);
assert(interval2 == NegInfInterval!Date(Date(2010, 3, 1)));
</pre>  </dd> <dt class="d_decl" id="NegInfInterval.bwdRange">const NegInfIntervalRange!TP bwdRange(TP delegate(in TP) func, PopFirst popFirst = PopFirst.no)</dt> <dd>
<p>Returns a range which iterates backwards over the interval, starting at <code>end</code>, using <span class="d_param"><code>func</code></span> to generate each successive time point. </p>
<p>The range's <code>front</code> is the interval's <code>end</code>. <span class="d_param"><code>func</code></span> is used to generate the next <code>front</code> when <code>popFront</code> is called. If <span class="d_param"><code>popFirst</code></span> is <code>PopFirst.yes</code>, then <code>popFront</code> is called before the range is returned (so that <code>front</code> is a time point which <span class="d_param"><code>func</code></span> would generate). <br><br> If <span class="d_param"><code>func</code></span> ever generates a time point greater than or equal to the current <code>front</code> of the range, then a <a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> will be thrown. <br><br> There are helper functions in this module which generate common delegates to pass to <code>bwdRange</code>. Their documentation starts with "Range-generating function," to make them easily searchable. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>TP delegate(in TP) <code>func</code>
</td> <td>The function used to generate the time points of the range over the interval.</td>
</tr> <tr>
<td>PopFirst <code>popFirst</code>
</td> <td>Whether <code>popFront</code> should be called on the range before returning it.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if this interval is empty. </dd>
</dl> <dl>
<dt>Warning</dt>
<dd> <span class="d_param"><code>func</code></span> must be logically pure. Ideally, <span class="d_param"><code>func</code></span> would be a function pointer to a pure function, but forcing <span class="d_param"><code>func</code></span> to be pure is far too restrictive to be useful, and in order to have the ease of use of having functions which generate functions to pass to <code>fwdRange</code>, <span class="d_param"><code>func</code></span> must be a delegate. </dd>
</dl> If <span class="d_param"><code>func</code></span> retains state which changes as it is called, then some algorithms will not work correctly, because the range's <code>save</code> will have failed to have really saved the range's state. To avoid such bugs, don't pass a delegate which is not logically pure to <code>fwdRange</code>. If <span class="d_param"><code>func</code></span> is given the same time point with two different calls, it must return the same result both times.  Of course, none of the functions in this module have this problem, so it's only relevant for custom delegates.  <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto interval = NegInfInterval!Date(Date(2010, 9, 9));
auto func = delegate (in Date date) //For iterating over even-numbered days.
            {
                if ((date.day &amp; 1) == 0)
                    return date - dur!"days"(2);

                return date - dur!"days"(1);
            };
auto range = interval.bwdRange(func);

assert(range.front == Date(2010, 9, 9)); //An odd day. Using PopFirst.yes would have made this Date(2010, 9, 8).

range.popFront();
assert(range.front == Date(2010, 9, 8));

range.popFront();
assert(range.front == Date(2010, 9, 6));

range.popFront();
assert(range.front == Date(2010, 9, 4));

range.popFront();
assert(range.front == Date(2010, 9, 2));

range.popFront();
assert(!range.empty);
</pre>  </dd> <dt class="d_decl" id="NegInfInterval.toString">const nothrow string toString()</dt> <dd>
<p>Converts this interval to a string.</p> </dd> </dl> </dd> <dt class="d_decl" id="everyDayOfWeek">nothrow TP delegate(in TP) everyDayOfWeek(TP, Direction dir = Direction.fwd)(DayOfWeek dayOfWeek)<br><br>  Constraints:<br>    if (isTimePoint!TP &amp;&amp; (dir == Direction.fwd || dir == Direction.bwd) &amp;&amp; __traits(hasMember, TP, "dayOfWeek") &amp;&amp; !__traits(isStaticFunction, TP.dayOfWeek) &amp;&amp; is(typeof(TP.dayOfWeek) == DayOfWeek))</dt> <dd>
<p>Range-generating function. </p>
<p>Returns a delegate which returns the next time point with the given <code>DayOfWeek</code> in a range. <br><br> Using this delegate allows iteration over successive time points which are all the same day of the week. e.g. passing <code>DayOfWeek.mon</code> to <code>everyDayOfWeek</code> would result in a delegate which could be used to iterate over all of the Mondays in a range. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>dir</td> <td>The direction to iterate in. If passing the return value to <code>fwdRange</code>, use <code>Direction.fwd</code>. If passing it to <code>bwdRange</code>, use <code>Direction.bwd</code>.</td>
</tr> <tr>
<td>DayOfWeek <code>dayOfWeek</code>
</td> <td>The week that each time point in the range will be.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.datetime.date : Date, DayOfWeek;

auto interval = Interval!Date(Date(2010, 9, 2), Date(2010, 9, 27));
auto func = everyDayOfWeek!Date(DayOfWeek.mon);
auto range = interval.fwdRange(func);

// A Thursday. Using PopFirst.yes would have made this Date(2010, 9, 6).
writeln(range.front); // Date(2010, 9, 2)

range.popFront();
writeln(range.front); // Date(2010, 9, 6)

range.popFront();
writeln(range.front); // Date(2010, 9, 13)

range.popFront();
writeln(range.front); // Date(2010, 9, 20)

range.popFront();
assert(range.empty);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="everyMonth">TP delegate(in TP) everyMonth(TP, Direction dir = Direction.fwd)(int month)<br><br>  Constraints:<br>    if (isTimePoint!TP &amp;&amp; (dir == Direction.fwd || dir == Direction.bwd) &amp;&amp; __traits(hasMember, TP, "month") &amp;&amp; !__traits(isStaticFunction, TP.month) &amp;&amp; is(typeof(TP.month) == Month))</dt> <dd>
<p>Range-generating function. </p>
<p>Returns a delegate which returns the next time point with the given <code>month</code> which would be reached by adding months to the given time point. <br><br> So, using this delegate allows iteration over successive time points which are in the same <code>month</code> but different years. For example, iterate over each successive December 25th in an interval by starting with a date which had the 25th as its day and passed <code>Month.dec</code> to <code>everyMonth</code> to create the delegate. <br><br> Since it wouldn't really make sense to be iterating over a specific <code>month</code> and end up with some of the time points in the succeeding <code>month</code> or two years after the previous time point, <code>AllowDayOverflow.no</code> is always used when calculating the next time point. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>dir</td> <td>The direction to iterate in. If passing the return value to <code>fwdRange</code>, use <code>Direction.fwd</code>. If passing it to <code>bwdRange</code>, use <code>Direction.bwd</code>.</td>
</tr> <tr>
<td>int <code>month</code>
</td> <td>The <code>month</code> that each time point in the range will be in (January is 1).</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.datetime.date : Date, Month;

auto interval = Interval!Date(Date(2000, 1, 30), Date(2004, 8, 5));
auto func = everyMonth!Date(Month.feb);
auto range = interval.fwdRange(func);

// Using PopFirst.yes would have made this Date(2010, 2, 29).
writeln(range.front); // Date(2000, 1, 30)

range.popFront();
writeln(range.front); // Date(2000, 2, 29)

range.popFront();
writeln(range.front); // Date(2001, 2, 28)

range.popFront();
writeln(range.front); // Date(2002, 2, 28)

range.popFront();
writeln(range.front); // Date(2003, 2, 28)

range.popFront();
writeln(range.front); // Date(2004, 2, 28)

range.popFront();
assert(range.empty);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="everyDuration">nothrow TP delegate(in TP) everyDuration(TP, Direction dir = Direction.fwd, D)(D duration)<br><br>  Constraints:<br>    if (isTimePoint!TP &amp;&amp; __traits(compiles, TP.init + duration) &amp;&amp; (dir == Direction.fwd || dir == Direction.bwd))</dt> <dd>
<p>Range-generating function. </p>
<p>Returns a delegate which returns the next time point which is the given <code>duration</code> later. <br><br> Using this delegate allows iteration over successive time points which are apart by the given <code>duration</code> e.g. passing <code>dur!"days"(3)</code> to <code>everyDuration</code> would result in a delegate which could be used to iterate over a range of days which are each 3 days apart. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>dir</td> <td>The direction to iterate in. If passing the return value to <code>fwdRange</code>, use <code>Direction.fwd</code>. If passing it to <code>bwdRange</code>, use <code>Direction.bwd</code>.</td>
</tr> <tr>
<td>D <code>duration</code>
</td> <td>The <code>duration</code> which separates each successive time point in the range.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import core.time : dur;
import std.datetime.date : Date;

auto interval = Interval!Date(Date(2010, 9, 2), Date(2010, 9, 27));
auto func = everyDuration!Date(dur!"days"(8));
auto range = interval.fwdRange(func);

// Using PopFirst.yes would have made this Date(2010, 9, 10).
writeln(range.front); // Date(2010, 9, 2)

range.popFront();
writeln(range.front); // Date(2010, 9, 10)

range.popFront();
writeln(range.front); // Date(2010, 9, 18)

range.popFront();
writeln(range.front); // Date(2010, 9, 26)

range.popFront();
assert(range.empty);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="everyDuration.2">nothrow TP delegate(in TP) everyDuration(TP, Direction dir = Direction.fwd, D)(int years, int months = 0, AllowDayOverflow allowOverflow = AllowDayOverflow.yes, D duration = dur!"days"(0))<br><br>  Constraints:<br>    if (isTimePoint!TP &amp;&amp; __traits(compiles, TP.init + duration) &amp;&amp; __traits(compiles, TP.init.add!"years"(years)) &amp;&amp; __traits(compiles, TP.init.add!"months"(months)) &amp;&amp; (dir == Direction.fwd || dir == Direction.bwd))</dt> <dd>
<p>Range-generating function. </p>
<p>Returns a delegate which returns the next time point which is the given number of <code>years</code>, month, and <code>duration</code> later. <br><br> The difference between this version of <code>everyDuration</code> and the version which just takes a <a href="../core_time/#Duration"><code>core.time.Duration</code></a> is that this one also takes the number of <code>years</code> and <code>months</code> (along with an <code>AllowDayOverflow</code> to indicate whether adding <code>years</code> and <code>months</code> should allow the days to overflow). <br><br> Note that if iterating forward, <code>add!"years"()</code> is called on the given time point, then <code>add!"months"()</code>, and finally the <code>duration</code> is added to it. However, if iterating backwards, the <code>duration</code> is added first, then <code>add!"months"()</code> is called, and finally <code>add!"years"()</code> is called. That way, going backwards generates close to the same time points that iterating forward does, but since adding <code>years</code> and <code>months</code> is not entirely reversible (due to possible day overflow, regardless of whether <code>AllowDayOverflow.yes</code> or <code>AllowDayOverflow.no</code> is used), it can't be guaranteed that iterating backwards will give the same time points as iterating forward would have (even assuming that the end of the range is a time point which would be returned by the delegate when iterating forward from <code>begin</code>). </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>dir</td> <td>The direction to iterate in. If passing the return value to <code>fwdRange</code>, use <code>Direction.fwd</code>. If passing it to <code>bwdRange</code>, use <code>Direction.bwd</code>.</td>
</tr> <tr>
<td>int <code>years</code>
</td> <td>The number of <code>years</code> to add to the time point passed to the delegate.</td>
</tr> <tr>
<td>int <code>months</code>
</td> <td>The number of <code>months</code> to add to the time point passed to the delegate.</td>
</tr> <tr>
<td>AllowDayOverflow <code>allowOverflow</code>
</td> <td>Whether the days should be allowed to overflow on <code>begin</code> and <code>end</code>, causing their month to increment.</td>
</tr> <tr>
<td>D <code>duration</code>
</td> <td>The <code>duration</code> to add to the time point passed to the delegate.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import core.time : dur;
import std.datetime.date : AllowDayOverflow, Date;

auto interval = Interval!Date(Date(2010, 9, 2), Date(2025, 9, 27));
auto func = everyDuration!Date(4, 1, AllowDayOverflow.yes, dur!"days"(2));
auto range = interval.fwdRange(func);

// Using PopFirst.yes would have made this Date(2014, 10, 12).
writeln(range.front); // Date(2010, 9, 2)

range.popFront();
writeln(range.front); // Date(2014, 10, 4)

range.popFront();
writeln(range.front); // Date(2018, 11, 6)

range.popFront();
writeln(range.front); // Date(2022, 12, 8)

range.popFront();
assert(range.empty);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="IntervalRange">struct IntervalRange(TP, Direction dir) if (isTimePoint!TP &amp;amp<br>&amp;amp<br>dir != Direction.both)</dt> <dd>
<p>A range over an <a href="#Interval"><code>Interval</code></a>. </p>
<p><code>IntervalRange</code> is only ever constructed by <a href="#Interval"><code>Interval</code></a>. However, when it is constructed, it is given a function, <code>func</code>, which is used to generate the time points which are iterated over. <code>func</code> takes a time point and returns a time point of the same type. For instance, to iterate over all of the days in the interval <code>Interval!Date</code>, pass a function to <a href="#Interval"><code>Interval</code></a>'s <code>fwdRange</code> where that function took a <a href="../std_datetime_date/#Date"><code>std.datetime.date.Date</code></a> and returned a <a href="../std_datetime_date/#Date"><code>std.datetime.date.Date</code></a> which was one day later. That function would then be used by <code>IntervalRange</code>'s <code>popFront</code> to iterate over the <a href="../std_datetime_date/#Date"><code>std.datetime.date.Date</code></a>s in the interval. <br><br> If <code>dir == Direction.fwd</code>, then a range iterates forward in time, whereas if <code>dir == Direction.bwd</code>, then it iterates backwards in time. So, if <code>dir == Direction.fwd</code> then <code>front == interval.begin</code>, whereas if <code>dir == Direction.bwd</code> then <code>front == interval.end</code>. <code>func</code> must generate a time point going in the proper direction of iteration, or a <a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> will be thrown. So, to iterate forward in time, the time point that <code>func</code> generates must be later in time than the one passed to it. If it's either identical or earlier in time, then a <a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> will be thrown. To iterate backwards, then the generated time point must be before the time point which was passed in. <br><br> If the generated time point is ever passed the edge of the range in the proper direction, then the edge of that range will be used instead. So, if iterating forward, and the generated time point is past the interval's <code>end</code>, then <code>front</code> becomes <code>end</code>. If iterating backwards, and the generated time point is before <code>begin</code>, then <code>front</code> becomes <code>begin</code>. In either case, the range would then be empty. <br><br> Also note that while normally the <code>begin</code> of an interval is included in it and its <code>end</code> is excluded from it, if <code>dir == Direction.bwd</code>, then <code>begin</code> is treated as excluded and <code>end</code> is treated as included. This allows for the same behavior in both directions. This works because none of <a href="#Interval"><code>Interval</code></a>'s functions which care about whether <code>begin</code> or <code>end</code> is included or excluded are ever called by <code>IntervalRange</code>. <code>interval</code> returns a normal interval, regardless of whether <code>dir == Direction.fwd</code> or if <code>dir == Direction.bwd</code>, so any <a href="#Interval"><code>Interval</code></a> functions which are called on it which care about whether <code>begin</code> or <code>end</code> are included or excluded will treat <code>begin</code> as included and <code>end</code> as excluded.</p> <dl>
<dt class="d_decl" id="IntervalRange.opAssign">pure nothrow ref IntervalRange opAssign(ref IntervalRange rhs)<br>pure nothrow ref IntervalRange opAssign(IntervalRange rhs)</dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>IntervalRange <code>rhs</code>
</td> <td>The <code>IntervalRange</code> to assign to this one.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="IntervalRange.empty">const pure nothrow @property bool empty()</dt> <dd>
<p>Whether this <code>IntervalRange</code> is <code>empty</code>.</p> </dd> <dt class="d_decl" id="IntervalRange.front">const pure @property TP front()</dt> <dd>
<p>The first time point in the range. </p>
<dl>
<dt>Throws:</dt>
<dd>
<a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the range is empty.</dd>
</dl> </dd> <dt class="d_decl" id="IntervalRange.popFront">void popFront()</dt> <dd>
<p>Pops <code>front</code> from the range, using <code>func</code> to generate the next time point in the range. If the generated time point is beyond the edge of the range, then <code>front</code> is set to that edge, and the range is then empty. So, if iterating forwards, and the generated time point is greater than the interval's <code>end</code>, then <code>front</code> is set to <code>end</code>. If iterating backwards, and the generated time point is less than the interval's <code>begin</code>, then <code>front</code> is set to <code>begin</code>. </p>
<dl>
<dt>Throws:</dt>
<dd>
<a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the range is empty or if the generated time point is in the wrong direction (i.e. if iterating forward and the generated time point is before <code>front</code>, or if iterating backwards and the generated time point is after <code>front</code>).</dd>
</dl> </dd> <dt class="d_decl" id="IntervalRange.save">pure nothrow @property IntervalRange save()</dt> <dd>
<p>Returns a copy of <code>this</code>.</p> </dd> <dt class="d_decl" id="IntervalRange.interval">const pure nothrow @property Interval!TP interval()</dt> <dd>
<p>The <code>interval</code> that this <code>IntervalRange</code> currently covers.</p> </dd> <dt class="d_decl" id="IntervalRange.func">pure nothrow @property TP delegate(in TP) func()</dt> <dd>
<p>The function used to generate the next time point in the range.</p> </dd> <dt class="d_decl" id="IntervalRange.direction">const pure nothrow @property Direction direction()</dt> <dd>
<p>The <code>Direction</code> that this range iterates in.</p> </dd> </dl> </dd> <dt class="d_decl" id="PosInfIntervalRange">struct PosInfIntervalRange(TP) if (isTimePoint!TP)</dt> <dd>
<p>A range over a <code>PosInfInterval</code>. It is an infinite range. </p>
<p><code>PosInfIntervalRange</code> is only ever constructed by <code>PosInfInterval</code>. However, when it is constructed, it is given a function, <code>func</code>, which is used to generate the time points which are iterated over. <code>func</code> takes a time point and returns a time point of the same type. For instance, to iterate over all of the days in the interval <code>PosInfInterval!Date</code>, pass a function to <code>PosInfInterval</code>'s <code>fwdRange</code> where that function took a <a href="../std_datetime_date/#Date"><code>std.datetime.date.Date</code></a> and returned a <a href="../std_datetime_date/#Date"><code>std.datetime.date.Date</code></a> which was one day later. That function would then be used by <code>PosInfIntervalRange</code>'s <code>popFront</code> to iterate over the <a href="../std_datetime_date/#Date"><code>std.datetime.date.Date</code></a>s in the interval - though obviously, since the range is infinite, use a function such as <code>std.range.take</code> with it rather than iterating over <i>all</i> of the dates. <br><br> As the interval goes to positive infinity, the range is always iterated over forwards, never backwards. <code>func</code> must generate a time point going in the proper direction of iteration, or a <a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> will be thrown. So, the time points that <code>func</code> generates must be later in time than the one passed to it. If it's either identical or earlier in time, then a <a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> will be thrown.</p> <dl>
<dt class="d_decl" id="PosInfIntervalRange.opAssign">pure nothrow ref PosInfIntervalRange opAssign(ref PosInfIntervalRange rhs)<br>pure nothrow ref PosInfIntervalRange opAssign(PosInfIntervalRange rhs)</dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>PosInfIntervalRange <code>rhs</code>
</td> <td>The <code>PosInfIntervalRange</code> to assign to this one.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="PosInfIntervalRange.empty">enum bool empty</dt> <dd>
<p>This is an infinite range, so it is never <code>empty</code>.</p> </dd> <dt class="d_decl" id="PosInfIntervalRange.front">const pure nothrow @property TP front()</dt> <dd>
<p>The first time point in the range.</p> </dd> <dt class="d_decl" id="PosInfIntervalRange.popFront">void popFront()</dt> <dd>
<p>Pops <code>front</code> from the range, using <code>func</code> to generate the next time point in the range. </p>
<dl>
<dt>Throws:</dt>
<dd>
<a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the generated time point is less than <code>front</code>.</dd>
</dl> </dd> <dt class="d_decl" id="PosInfIntervalRange.save">pure nothrow @property PosInfIntervalRange save()</dt> <dd>
<p>Returns a copy of <code>this</code>.</p> </dd> <dt class="d_decl" id="PosInfIntervalRange.interval">const pure nothrow @property PosInfInterval!TP interval()</dt> <dd>
<p>The <code>interval</code> that this range currently covers.</p> </dd> <dt class="d_decl" id="PosInfIntervalRange.func">pure nothrow @property TP delegate(in TP) func()</dt> <dd>
<p>The function used to generate the next time point in the range.</p> </dd> </dl> </dd> <dt class="d_decl" id="NegInfIntervalRange">struct NegInfIntervalRange(TP) if (isTimePoint!TP)</dt> <dd>
<p>A range over a <code>NegInfInterval</code>. It is an infinite range. </p>
<p><code>NegInfIntervalRange</code> is only ever constructed by <code>NegInfInterval</code>. However, when it is constructed, it is given a function, <code>func</code>, which is used to generate the time points which are iterated over. <code>func</code> takes a time point and returns a time point of the same type. For instance, to iterate over all of the days in the interval <code>NegInfInterval!Date</code>, pass a function to <code>NegInfInterval</code>'s <code>bwdRange</code> where that function took a <a href="../std_datetime_date/#Date"><code>std.datetime.date.Date</code></a> and returned a <a href="../std_datetime_date/#Date"><code>std.datetime.date.Date</code></a> which was one day earlier. That function would then be used by <code>NegInfIntervalRange</code>'s <code>popFront</code> to iterate over the <a href="../std_datetime_date/#Date"><code>std.datetime.date.Date</code></a>s in the interval - though obviously, since the range is infinite, use a function such as <code>std.range.take</code> with it rather than iterating over <i>all</i> of the dates. <br><br> As the interval goes to negative infinity, the range is always iterated over backwards, never forwards. <code>func</code> must generate a time point going in the proper direction of iteration, or a <a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> will be thrown. So, the time points that <code>func</code> generates must be earlier in time than the one passed to it. If it's either identical or later in time, then a <a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> will be thrown. <br><br> Also note that while normally the <code>end</code> of an interval is excluded from it, <code>NegInfIntervalRange</code> treats it as if it were included. This allows for the same behavior as with <code>PosInfIntervalRange</code>. This works because none of <code>NegInfInterval</code>'s functions which care about whether <code>end</code> is included or excluded are ever called by <code>NegInfIntervalRange</code>. <code>interval</code> returns a normal interval, so any <code>NegInfInterval</code> functions which are called on it which care about whether <code>end</code> is included or excluded will treat <code>end</code> as excluded.</p> <dl>
<dt class="d_decl" id="NegInfIntervalRange.opAssign">pure nothrow ref NegInfIntervalRange opAssign(ref NegInfIntervalRange rhs)<br>pure nothrow ref NegInfIntervalRange opAssign(NegInfIntervalRange rhs)</dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>NegInfIntervalRange <code>rhs</code>
</td> <td>The <code>NegInfIntervalRange</code> to assign to this one.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="NegInfIntervalRange.empty">enum bool empty</dt> <dd>
<p>This is an infinite range, so it is never <code>empty</code>.</p> </dd> <dt class="d_decl" id="NegInfIntervalRange.front">const pure nothrow @property TP front()</dt> <dd>
<p>The first time point in the range.</p> </dd> <dt class="d_decl" id="NegInfIntervalRange.popFront">void popFront()</dt> <dd>
<p>Pops <code>front</code> from the range, using <code>func</code> to generate the next time point in the range. </p>
<dl>
<dt>Throws:</dt>
<dd>
<a href="../std_datetime_date/#DateTimeException"><code>std.datetime.date.DateTimeException</code></a> if the generated time point is greater than <code>front</code>.</dd>
</dl> </dd> <dt class="d_decl" id="NegInfIntervalRange.save">pure nothrow @property NegInfIntervalRange save()</dt> <dd>
<p>Returns a copy of <code>this</code>.</p> </dd> <dt class="d_decl" id="NegInfIntervalRange.interval">const pure nothrow @property NegInfInterval!TP interval()</dt> <dd>
<p>The <code>interval</code> that this range currently covers.</p> </dd> <dt class="d_decl" id="NegInfIntervalRange.func">pure nothrow @property TP delegate(in TP) func()</dt> <dd>
<p>The function used to generate the next time point in the range.</p> </dd> </dl> </dd> </dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 1999–2017 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/phobos/std_datetime_interval.html" class="_attribution-link" target="_blank">https://dlang.org/phobos/std_datetime_interval.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
