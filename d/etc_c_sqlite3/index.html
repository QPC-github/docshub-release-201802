
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>etc.c.sqlite3 - D - W3cubDocs</title>
  
  <meta name="description" content=" &#42; CAPI3REF&#58; Compile-Time Library Version Numbers ">
  <meta name="keywords" content="etc, c, sqlite, -, d">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/d/etc_c_sqlite3/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-e0f881b0fce8cbe96f33dadc355b7159d5d2912911231446d60eb8f9caffa802.css">
  <script type="text/javascript" src="/assets/application-8fc46316434047265cd383f02b8e7f434ed7dec4a59f920dd633deef8d488d1b.js"></script>
  <script src="/json/d.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/d/" class="_nav-link" title="" style="margin-left:0;">D</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _d">
				
<h1>etc.c.sqlite3</h1>  <dl>
<dt class="d_decl" id="SQLITE_VERSION">enum string SQLITE_VERSION<br>enum int SQLITE_VERSION_NUMBER<br>enum string SQLITE_SOURCE_ID</dt> <dd>
<p>* CAPI3REF: Compile-Time Library Version Numbers</p> </dd> <dt class="d_decl" id="sqlite3_version">immutable(char)* sqlite3_version<br>nothrow immutable(char)* sqlite3_libversion()<br>nothrow immutable(char)* sqlite3_sourceid()<br>nothrow int sqlite3_libversion_number()</dt> <dd>
<p>* CAPI3REF: Run-Time Library Version Numbers</p> </dd> <dt class="d_decl" id="sqlite3_compileoption_used">nothrow int sqlite3_compileoption_used(const char* zOptName)<br>nothrow immutable(char)* sqlite3_compileoption_get(int N)</dt> <dd>
<p>* CAPI3REF: Run-Time Library Compilation Options Diagnostics</p> </dd> <dt class="d_decl" id="sqlite3_threadsafe">nothrow int sqlite3_threadsafe()</dt> <dd>
<p>* CAPI3REF: Test To See If The Library Is Threadsafe</p> </dd> <dt class="d_decl" id="sqlite3">struct sqlite3</dt> <dd>
<p>* CAPI3REF: Database Connection Handle</p> </dd> <dt class="d_decl" id="sqlite3_int64">alias sqlite3_int64 = long</dt>  <dt class="d_decl" id="sqlite3_uint64">alias sqlite3_uint64 = ulong</dt>  <dt class="d_decl" id="sqlite3_close">nothrow int sqlite3_close(sqlite3*)</dt> <dd>
<p>* CAPI3REF: Closing A Database Connection *</p> </dd> <dt class="d_decl" id="sqlite3_callback">alias sqlite3_callback = extern (C) int function(void*, int, char**, char**) nothrow</dt> <dd>
<p>* The type for a callback function. * This is legacy and deprecated. It is included for historical * compatibility and is not documented.</p> </dd> <dt class="d_decl" id="sqlite3_exec">nothrow int sqlite3_exec(sqlite3*, const(char)* sql, int function(void*, int, char**, char**) callback, void*, char** errmsg)</dt> <dd>
<p>* CAPI3REF: One-Step Query Execution Interface</p> </dd> <dt class="d_decl" id="SQLITE_OK">SQLITE_OK</dt> <dd>
<p>Successful result</p> </dd> <dt class="d_decl" id="SQLITE_ERROR">SQLITE_ERROR</dt> <dd>
<p>Ditto </p>
<p>SQL error or missing database</p> </dd> <dt class="d_decl" id="SQLITE_INTERNAL">SQLITE_INTERNAL</dt> <dd>
<p>Internal logic error in SQLite</p> </dd> <dt class="d_decl" id="SQLITE_PERM">SQLITE_PERM</dt> <dd>
<p>Access permission denied</p> </dd> <dt class="d_decl" id="SQLITE_ABORT">SQLITE_ABORT</dt> <dd>
<p>Callback routine requested an abort</p> </dd> <dt class="d_decl" id="SQLITE_BUSY">SQLITE_BUSY</dt> <dd>
<p>The database file is locked</p> </dd> <dt class="d_decl" id="SQLITE_LOCKED">SQLITE_LOCKED</dt> <dd>
<p>A table in the database is locked</p> </dd> <dt class="d_decl" id="SQLITE_NOMEM">SQLITE_NOMEM</dt> <dd>
<p>A malloc() failed</p> </dd> <dt class="d_decl" id="SQLITE_READONLY">SQLITE_READONLY</dt> <dd>
<p>Attempt to write a readonly database</p> </dd> <dt class="d_decl" id="SQLITE_INTERRUPT">SQLITE_INTERRUPT</dt> <dd>
<p>Operation terminated by sqlite3_interrupt()</p> </dd> <dt class="d_decl" id="SQLITE_IOERR">SQLITE_IOERR</dt> <dd>
<p>Some kind of disk I/O error occurred</p> </dd> <dt class="d_decl" id="SQLITE_CORRUPT">SQLITE_CORRUPT</dt> <dd>
<p>The database disk image is malformed</p> </dd> <dt class="d_decl" id="SQLITE_NOTFOUND">SQLITE_NOTFOUND</dt> <dd>
<p>Unknown opcode in sqlite3_file_control()</p> </dd> <dt class="d_decl" id="SQLITE_FULL">SQLITE_FULL</dt> <dd>
<p>Insertion failed because database is full</p> </dd> <dt class="d_decl" id="SQLITE_CANTOPEN">SQLITE_CANTOPEN</dt> <dd>
<p>Unable to open the database file</p> </dd> <dt class="d_decl" id="SQLITE_PROTOCOL">SQLITE_PROTOCOL</dt> <dd>
<p>Database lock protocol error</p> </dd> <dt class="d_decl" id="SQLITE_EMPTY">SQLITE_EMPTY</dt> <dd>
<p>Database is empty</p> </dd> <dt class="d_decl" id="SQLITE_SCHEMA">SQLITE_SCHEMA</dt> <dd>
<p>The database schema changed</p> </dd> <dt class="d_decl" id="SQLITE_TOOBIG">SQLITE_TOOBIG</dt> <dd>
<p>String or BLOB exceeds size limit</p> </dd> <dt class="d_decl" id="SQLITE_CONSTRAINT">SQLITE_CONSTRAINT</dt> <dd>
<p>Abort due to constraint violation</p> </dd> <dt class="d_decl" id="SQLITE_MISMATCH">SQLITE_MISMATCH</dt> <dd>
<p>Data type mismatch</p> </dd> <dt class="d_decl" id="SQLITE_MISUSE">SQLITE_MISUSE</dt> <dd>
<p>Library used incorrectly</p> </dd> <dt class="d_decl" id="SQLITE_NOLFS">SQLITE_NOLFS</dt> <dd>
<p>Uses OS features not supported on host</p> </dd> <dt class="d_decl" id="SQLITE_AUTH">SQLITE_AUTH</dt> <dd>
<p>Authorization denied</p> </dd> <dt class="d_decl" id="SQLITE_FORMAT">SQLITE_FORMAT</dt> <dd>
<p>Auxiliary database format error</p> </dd> <dt class="d_decl" id="SQLITE_RANGE">SQLITE_RANGE</dt> <dd>
<p>2nd parameter to sqlite3_bind out of range</p> </dd> <dt class="d_decl" id="SQLITE_NOTADB">SQLITE_NOTADB</dt> <dd>
<p>File opened that is not a database file</p> </dd> <dt class="d_decl" id="SQLITE_ROW">SQLITE_ROW</dt> <dd>
<p>sqlite3_step() has another row ready</p> </dd> <dt class="d_decl" id="SQLITE_DONE">SQLITE_DONE</dt> <dd>
<p>sqlite3_step() has finished executing</p> </dd> <dt class="d_decl" id="SQLITE_OPEN_READONLY">SQLITE_OPEN_READONLY</dt> <dd>
<p>Ok for sqlite3_open_v2()</p> </dd> <dt class="d_decl" id="SQLITE_OPEN_READWRITE">SQLITE_OPEN_READWRITE</dt> <dd>
<p>Ok for sqlite3_open_v2()</p> </dd> <dt class="d_decl" id="SQLITE_OPEN_CREATE">SQLITE_OPEN_CREATE</dt> <dd>
<p>Ok for sqlite3_open_v2()</p> </dd> <dt class="d_decl" id="SQLITE_OPEN_DELETEONCLOSE">SQLITE_OPEN_DELETEONCLOSE</dt> <dd>
<p>VFS only</p> </dd> <dt class="d_decl" id="SQLITE_OPEN_EXCLUSIVE">SQLITE_OPEN_EXCLUSIVE</dt> <dd>
<p>VFS only</p> </dd> <dt class="d_decl" id="SQLITE_OPEN_AUTOPROXY">SQLITE_OPEN_AUTOPROXY</dt> <dd>
<p>VFS only</p> </dd> <dt class="d_decl" id="SQLITE_OPEN_URI">SQLITE_OPEN_URI</dt> <dd>
<p>Ok for sqlite3_open_v2()</p> </dd> <dt class="d_decl" id="SQLITE_OPEN_MEMORY">SQLITE_OPEN_MEMORY</dt> <dd>
<p>Ok for sqlite3_open_v2()</p> </dd> <dt class="d_decl" id="SQLITE_OPEN_MAIN_DB">SQLITE_OPEN_MAIN_DB</dt> <dd>
<p>VFS only</p> </dd> <dt class="d_decl" id="SQLITE_OPEN_TEMP_DB">SQLITE_OPEN_TEMP_DB</dt> <dd>
<p>VFS only</p> </dd> <dt class="d_decl" id="SQLITE_OPEN_TRANSIENT_DB">SQLITE_OPEN_TRANSIENT_DB</dt> <dd>
<p>VFS only</p> </dd> <dt class="d_decl" id="SQLITE_OPEN_MAIN_JOURNAL">SQLITE_OPEN_MAIN_JOURNAL</dt> <dd>
<p>VFS only</p> </dd> <dt class="d_decl" id="SQLITE_OPEN_TEMP_JOURNAL">SQLITE_OPEN_TEMP_JOURNAL</dt> <dd>
<p>VFS only</p> </dd> <dt class="d_decl" id="SQLITE_OPEN_SUBJOURNAL">SQLITE_OPEN_SUBJOURNAL</dt> <dd>
<p>VFS only</p> </dd> <dt class="d_decl" id="SQLITE_OPEN_MASTER_JOURNAL">SQLITE_OPEN_MASTER_JOURNAL</dt> <dd>
<p>VFS only</p> </dd> <dt class="d_decl" id="SQLITE_OPEN_NOMUTEX">SQLITE_OPEN_NOMUTEX</dt> <dd>
<p>Ok for sqlite3_open_v2()</p> </dd> <dt class="d_decl" id="SQLITE_OPEN_FULLMUTEX">SQLITE_OPEN_FULLMUTEX</dt> <dd>
<p>Ok for sqlite3_open_v2()</p> </dd> <dt class="d_decl" id="SQLITE_OPEN_SHAREDCACHE">SQLITE_OPEN_SHAREDCACHE</dt> <dd>
<p>Ok for sqlite3_open_v2()</p> </dd> <dt class="d_decl" id="SQLITE_OPEN_PRIVATECACHE">SQLITE_OPEN_PRIVATECACHE</dt> <dd>
<p>Ok for sqlite3_open_v2()</p> </dd> <dt class="d_decl" id="SQLITE_OPEN_WAL">SQLITE_OPEN_WAL</dt> <dd>
<p>VFS only</p> </dd> <dt class="d_decl" id="sqlite3_file">struct sqlite3_file</dt> <dd>
<p>* CAPI3REF: OS Interface Open File Handle</p> </dd> <dt class="d_decl" id="sqlite3_io_methods">struct sqlite3_io_methods</dt> <dd>
<p>* CAPI3REF: OS Interface File Virtual Methods Object</p> </dd> <dt class="d_decl" id="sqlite3_mutex">struct sqlite3_mutex</dt> <dd>
<p>* CAPI3REF: Mutex Handle</p> </dd> <dt class="d_decl" id="xDlSymReturn">alias xDlSymReturn = extern (C) void* function() nothrow<br>alias sqlite3_syscall_ptr = extern (C) void function() nothrow</dt> <dd>
<p>* CAPI3REF: OS Interface Object</p> </dd> <dt class="d_decl" id="SQLITE_ACCESS_READWRITE">SQLITE_ACCESS_READWRITE</dt> <dd>
<p>Used by PRAGMA temp_store_directory</p> </dd> <dt class="d_decl" id="SQLITE_ACCESS_READ">SQLITE_ACCESS_READ</dt> <dd>
<p>Unused</p> </dd> <dt class="d_decl" id="SQLITE_SHM_NLOCK">enum int SQLITE_SHM_NLOCK</dt> <dd>
<p>* CAPI3REF: Maximum xShmLock index</p> </dd> <dt class="d_decl" id="sqlite3_initialize">nothrow int sqlite3_initialize()<br>nothrow int sqlite3_shutdown()<br>nothrow int sqlite3_os_init()<br>nothrow int sqlite3_os_end()</dt> <dd>
<p>* CAPI3REF: Initialize The SQLite Library</p> </dd> <dt class="d_decl" id="sqlite3_config">nothrow int sqlite3_config(int, ...)</dt> <dd>
<p>* CAPI3REF: Configuring The SQLite Library</p> </dd> <dt class="d_decl" id="sqlite3_db_config">nothrow int sqlite3_db_config(sqlite3*, int op, ...)</dt> <dd>
<p>* CAPI3REF: Configure database connections</p> </dd> <dt class="d_decl" id="sqlite3_mem_methods">struct sqlite3_mem_methods</dt> <dd>
<p>* CAPI3REF: Memory Allocation Routines</p> <dl>
<dt class="d_decl" id="sqlite3_mem_methods.xMalloc">void* function(int) xMalloc</dt> <dd>
<p>Memory allocation function</p> </dd> <dt class="d_decl" id="sqlite3_mem_methods.xFree">void function(void*) xFree</dt> <dd>
<p>Free a prior allocation</p> </dd> <dt class="d_decl" id="sqlite3_mem_methods.xRealloc">void* function(void*, int) xRealloc</dt> <dd>
<p>Resize an allocation</p> </dd> <dt class="d_decl" id="sqlite3_mem_methods.xSize">int function(void*) xSize</dt> <dd>
<p>Return the size of an allocation</p> </dd> <dt class="d_decl" id="sqlite3_mem_methods.xRoundup">int function(int) xRoundup</dt> <dd>
<p>Round up request size to allocation size</p> </dd> <dt class="d_decl" id="sqlite3_mem_methods.xInit">int function(void*) xInit</dt> <dd>
<p>Initialize the memory allocator</p> </dd> <dt class="d_decl" id="sqlite3_mem_methods.xShutdown">void function(void*) xShutdown</dt> <dd>
<p>Deinitialize the memory allocator</p> </dd> <dt class="d_decl" id="sqlite3_mem_methods.pAppData">void* pAppData</dt> <dd>
<p>Argument to xInit() and xShutdown()</p> </dd> </dl> </dd> <dt class="d_decl" id="SQLITE_CONFIG_SINGLETHREAD">SQLITE_CONFIG_SINGLETHREAD</dt> <dd>
<p>nil</p> </dd> <dt class="d_decl" id="SQLITE_CONFIG_MULTITHREAD">SQLITE_CONFIG_MULTITHREAD</dt> <dd>
<p>nil</p> </dd> <dt class="d_decl" id="SQLITE_CONFIG_SERIALIZED">SQLITE_CONFIG_SERIALIZED</dt> <dd>
<p>nil</p> </dd> <dt class="d_decl" id="SQLITE_CONFIG_MALLOC">SQLITE_CONFIG_MALLOC</dt> <dd>
<p>sqlite3_mem_methods*</p> </dd> <dt class="d_decl" id="SQLITE_CONFIG_GETMALLOC">SQLITE_CONFIG_GETMALLOC</dt> <dd>
<p>sqlite3_mem_methods*</p> </dd> <dt class="d_decl" id="SQLITE_CONFIG_SCRATCH">SQLITE_CONFIG_SCRATCH</dt> <dd>
<p>void*, int sz, int N</p> </dd> <dt class="d_decl" id="SQLITE_CONFIG_PAGECACHE">SQLITE_CONFIG_PAGECACHE</dt> <dd>
<p>void*, int sz, int N</p> </dd> <dt class="d_decl" id="SQLITE_CONFIG_HEAP">SQLITE_CONFIG_HEAP</dt> <dd>
<p>void*, int nByte, int min</p> </dd> <dt class="d_decl" id="SQLITE_CONFIG_MEMSTATUS">SQLITE_CONFIG_MEMSTATUS</dt> <dd>
<p>boolean</p> </dd> <dt class="d_decl" id="SQLITE_CONFIG_MUTEX">SQLITE_CONFIG_MUTEX</dt> <dd>
<p>sqlite3_mutex_methods*</p> </dd> <dt class="d_decl" id="SQLITE_CONFIG_GETMUTEX">SQLITE_CONFIG_GETMUTEX</dt> <dd>
<p>sqlite3_mutex_methods*</p> </dd> <dt class="d_decl" id="SQLITE_CONFIG_LOOKASIDE">SQLITE_CONFIG_LOOKASIDE</dt> <dd>
<p>int int</p> </dd> <dt class="d_decl" id="SQLITE_CONFIG_PCACHE">SQLITE_CONFIG_PCACHE</dt> <dd>
<p>sqlite3_pcache_methods*</p> </dd> <dt class="d_decl" id="SQLITE_CONFIG_GETPCACHE">SQLITE_CONFIG_GETPCACHE</dt> <dd>
<p>sqlite3_pcache_methods*</p> </dd> <dt class="d_decl" id="SQLITE_CONFIG_LOG">SQLITE_CONFIG_LOG</dt> <dd>
<p>xFunc, void*</p> </dd> <dt class="d_decl" id="SQLITE_DBCONFIG_LOOKASIDE">SQLITE_DBCONFIG_LOOKASIDE</dt> <dd>
<p>void* int int</p> </dd> <dt class="d_decl" id="SQLITE_DBCONFIG_ENABLE_FKEY">SQLITE_DBCONFIG_ENABLE_FKEY</dt> <dd>
<p>int int*</p> </dd> <dt class="d_decl" id="SQLITE_DBCONFIG_ENABLE_TRIGGER">SQLITE_DBCONFIG_ENABLE_TRIGGER</dt> <dd>
<p>int int*</p> </dd> <dt class="d_decl" id="sqlite3_extended_result_codes">nothrow int sqlite3_extended_result_codes(sqlite3*, int onoff)</dt> <dd>
<p>* CAPI3REF: Enable Or Disable Extended Result Codes</p> </dd> <dt class="d_decl" id="sqlite3_last_insert_rowid">nothrow sqlite3_int64 sqlite3_last_insert_rowid(sqlite3*)</dt> <dd>
<p>* CAPI3REF: Last Insert Rowid</p> </dd> <dt class="d_decl" id="sqlite3_changes">nothrow int sqlite3_changes(sqlite3*)</dt> <dd>
<p>* CAPI3REF: Count The Number Of Rows Modified</p> </dd> <dt class="d_decl" id="sqlite3_total_changes">nothrow int sqlite3_total_changes(sqlite3*)</dt> <dd>
<p>* CAPI3REF: Total Number Of Rows Modified</p> </dd> <dt class="d_decl" id="sqlite3_interrupt">nothrow void sqlite3_interrupt(sqlite3*)</dt> <dd>
<p>* CAPI3REF: Interrupt A Long-Running Query</p> </dd> <dt class="d_decl" id="sqlite3_complete">nothrow int sqlite3_complete(const char* sql)<br>nothrow int sqlite3_complete16(const void* sql)</dt> <dd>
<p>* CAPI3REF: Determine If An SQL Statement Is Complete</p> </dd> <dt class="d_decl" id="sqlite3_busy_handler">nothrow int sqlite3_busy_handler(sqlite3*, int function(void*, int), void*)</dt> <dd>
<p>* CAPI3REF: Register A Callback To Handle SQLITE_BUSY Errors</p> </dd> <dt class="d_decl" id="sqlite3_busy_timeout">nothrow int sqlite3_busy_timeout(sqlite3*, int ms)</dt> <dd>
<p>* CAPI3REF: Set A Busy Timeout</p> </dd> <dt class="d_decl" id="sqlite3_get_table">nothrow int sqlite3_get_table(sqlite3* db, const(char)* zSql, char*** pazResult, int* pnRow, int* pnColumn, char** pzErrmsg)</dt> <dd>
<p>* CAPI3REF: Convenience Routines For Running Queries</p> </dd> <dt class="d_decl" id="sqlite3_free_table">nothrow void sqlite3_free_table(char** result)</dt>  <dt class="d_decl" id="sqlite3_mprintf">nothrow char* sqlite3_mprintf(const char*, ...)</dt> <dd>
<p>* CAPI3REF: Formatted String Printing Functions</p> </dd> <dt class="d_decl" id="sqlite3_malloc">nothrow void* sqlite3_malloc(int)<br>nothrow void* sqlite3_malloc64(sqlite3_uint64)<br>nothrow void* sqlite3_realloc(void*, int)<br>nothrow void* sqlite3_realloc64(void*, sqlite3_uint64)<br>nothrow void sqlite3_free(void*)<br>nothrow sqlite3_uint64 sqlite3_msize(void*)</dt> <dd>
<p>* CAPI3REF: Memory Allocation Subsystem</p> </dd> <dt class="d_decl" id="sqlite3_memory_used">nothrow sqlite3_int64 sqlite3_memory_used()</dt> <dd>
<p>* CAPI3REF: Memory Allocator Statistics</p> </dd> <dt class="d_decl" id="sqlite3_randomness">nothrow void sqlite3_randomness(int N, void* P)</dt> <dd>
<p>* CAPI3REF: Pseudo-Random Number Generator</p> </dd> <dt class="d_decl" id="sqlite3_set_authorizer">nothrow int sqlite3_set_authorizer(sqlite3*, int function(void*, int, const char*, const char*, const char*, const char*) xAuth, void* pUserData)</dt> <dd>
<p>* CAPI3REF: Compile-Time Authorization Callbacks</p> </dd> <dt class="d_decl" id="SQLITE_DENY">SQLITE_DENY</dt> <dd>
<p>Abort the SQL statement with an error</p> </dd> <dt class="d_decl" id="SQLITE_IGNORE">SQLITE_IGNORE</dt> <dd>
<p>Don't allow access, but don't generate an error</p> </dd> <dt class="d_decl" id="SQLITE_CREATE_INDEX">SQLITE_CREATE_INDEX</dt> <dd>
<p>Index Name Table Name</p> </dd> <dt class="d_decl" id="SQLITE_CREATE_TABLE">SQLITE_CREATE_TABLE</dt> <dd>
<p>Table Name NULL</p> </dd> <dt class="d_decl" id="SQLITE_CREATE_TEMP_INDEX">SQLITE_CREATE_TEMP_INDEX</dt> <dd>
<p>Index Name Table Name</p> </dd> <dt class="d_decl" id="SQLITE_CREATE_TEMP_TABLE">SQLITE_CREATE_TEMP_TABLE</dt> <dd>
<p>Table Name NULL</p> </dd> <dt class="d_decl" id="SQLITE_CREATE_TEMP_TRIGGER">SQLITE_CREATE_TEMP_TRIGGER</dt> <dd>
<p>Trigger Name Table Name</p> </dd> <dt class="d_decl" id="SQLITE_CREATE_TEMP_VIEW">SQLITE_CREATE_TEMP_VIEW</dt> <dd>
<p>View Name NULL</p> </dd> <dt class="d_decl" id="SQLITE_CREATE_TRIGGER">SQLITE_CREATE_TRIGGER</dt> <dd>
<p>Trigger Name Table Name</p> </dd> <dt class="d_decl" id="SQLITE_CREATE_VIEW">SQLITE_CREATE_VIEW</dt> <dd>
<p>View Name NULL</p> </dd> <dt class="d_decl" id="SQLITE_DELETE">SQLITE_DELETE</dt> <dd>
<p>Table Name NULL</p> </dd> <dt class="d_decl" id="SQLITE_DROP_INDEX">SQLITE_DROP_INDEX</dt> <dd>
<p>Index Name Table Name</p> </dd> <dt class="d_decl" id="SQLITE_DROP_TABLE">SQLITE_DROP_TABLE</dt> <dd>
<p>Table Name NULL</p> </dd> <dt class="d_decl" id="SQLITE_DROP_TEMP_INDEX">SQLITE_DROP_TEMP_INDEX</dt> <dd>
<p>Index Name Table Name</p> </dd> <dt class="d_decl" id="SQLITE_DROP_TEMP_TABLE">SQLITE_DROP_TEMP_TABLE</dt> <dd>
<p>Table Name NULL</p> </dd> <dt class="d_decl" id="SQLITE_DROP_TEMP_TRIGGER">SQLITE_DROP_TEMP_TRIGGER</dt> <dd>
<p>Trigger Name Table Name</p> </dd> <dt class="d_decl" id="SQLITE_DROP_TEMP_VIEW">SQLITE_DROP_TEMP_VIEW</dt> <dd>
<p>View Name NULL</p> </dd> <dt class="d_decl" id="SQLITE_DROP_TRIGGER">SQLITE_DROP_TRIGGER</dt> <dd>
<p>Trigger Name Table Name</p> </dd> <dt class="d_decl" id="SQLITE_DROP_VIEW">SQLITE_DROP_VIEW</dt> <dd>
<p>View Name NULL</p> </dd> <dt class="d_decl" id="SQLITE_INSERT">SQLITE_INSERT</dt> <dd>
<p>Table Name NULL</p> </dd> <dt class="d_decl" id="SQLITE_PRAGMA">SQLITE_PRAGMA</dt> <dd>
<p>Pragma Name 1st arg or NULL</p> </dd> <dt class="d_decl" id="SQLITE_READ">SQLITE_READ</dt> <dd>
<p>Table Name Column Name</p> </dd> <dt class="d_decl" id="SQLITE_SELECT">SQLITE_SELECT</dt> <dd>
<p>NULL NULL</p> </dd> <dt class="d_decl" id="SQLITE_TRANSACTION">SQLITE_TRANSACTION</dt> <dd>
<p>Operation NULL</p> </dd> <dt class="d_decl" id="SQLITE_UPDATE">SQLITE_UPDATE</dt> <dd>
<p>Table Name Column Name</p> </dd> <dt class="d_decl" id="SQLITE_ATTACH">SQLITE_ATTACH</dt> <dd>
<p>Filename NULL</p> </dd> <dt class="d_decl" id="SQLITE_DETACH">SQLITE_DETACH</dt> <dd>
<p>Database Name NULL</p> </dd> <dt class="d_decl" id="SQLITE_ALTER_TABLE">SQLITE_ALTER_TABLE</dt> <dd>
<p>Database Name Table Name</p> </dd> <dt class="d_decl" id="SQLITE_REINDEX">SQLITE_REINDEX</dt> <dd>
<p>Index Name NULL</p> </dd> <dt class="d_decl" id="SQLITE_ANALYZE">SQLITE_ANALYZE</dt> <dd>
<p>Table Name NULL</p> </dd> <dt class="d_decl" id="SQLITE_CREATE_VTABLE">SQLITE_CREATE_VTABLE</dt> <dd>
<p>Table Name Module Name</p> </dd> <dt class="d_decl" id="SQLITE_DROP_VTABLE">SQLITE_DROP_VTABLE</dt> <dd>
<p>Table Name Module Name</p> </dd> <dt class="d_decl" id="SQLITE_FUNCTION">SQLITE_FUNCTION</dt> <dd>
<p>NULL Function Name</p> </dd> <dt class="d_decl" id="SQLITE_SAVEPOINT">SQLITE_SAVEPOINT</dt> <dd>
<p>Operation Savepoint Name</p> </dd> <dt class="d_decl" id="SQLITE_COPY">SQLITE_COPY</dt> <dd>
<p>No longer used</p> </dd> <dt class="d_decl" id="sqlite3_trace">nothrow void* sqlite3_trace(sqlite3*, void function(void*, const char*) xTrace, void*)<br>nothrow void* sqlite3_profile(sqlite3*, void function(void*, const char*, sqlite3_uint64) xProfile, void*)</dt> <dd>
<p>* CAPI3REF: Tracing And Profiling Functions</p> </dd> <dt class="d_decl" id="sqlite3_progress_handler">nothrow void sqlite3_progress_handler(sqlite3*, int, int function(void*), void*)</dt> <dd>
<p>* CAPI3REF: Query Progress Callbacks</p> </dd> <dt class="d_decl" id="sqlite3_open">nothrow int sqlite3_open(const(char)* filename, sqlite3** ppDb)<br>nothrow int sqlite3_open16(const(void)* filename, sqlite3** ppDb)<br>nothrow int sqlite3_open_v2(const(char)* filename, sqlite3** ppDb, int flags, const(char)* zVfs)<br>nothrow int sqlite3_uri_boolean(const(char)* zFile, const(char)* zParam, int bDefault)<br>nothrow sqlite3_int64 sqlite3_uri_int64(const char*, const char*, sqlite3_int64)</dt> <dd>
<p>* CAPI3REF: Opening A New Database Connection</p> </dd> <dt class="d_decl" id="sqlite3_errcode">nothrow int sqlite3_errcode(sqlite3* db)<br>nothrow int sqlite3_extended_errcode(sqlite3* db)<br>nothrow const(char)* sqlite3_errmsg(sqlite3*)<br>nothrow const(void)* sqlite3_errmsg16(sqlite3*)<br>nothrow const(char)* sqlite3_errstr(int)</dt> <dd>
<p>* CAPI3REF: Error Codes And Messages</p> </dd> <dt class="d_decl" id="sqlite3_stmt">struct sqlite3_stmt</dt> <dd>
<p>* CAPI3REF: SQL Statement Object</p> </dd> <dt class="d_decl" id="sqlite3_limit">nothrow int sqlite3_limit(sqlite3*, int id, int newVal)</dt> <dd>
<p>* CAPI3REF: Run-time Limits</p> </dd> <dt class="d_decl" id="sqlite3_prepare">nothrow int sqlite3_prepare(sqlite3* db, const(char)* zSql, int nByte, sqlite3_stmt** ppStmt, const(char*)* pzTail)<br>nothrow int sqlite3_prepare_v2(sqlite3* db, const(char)* zSql, int nByte, sqlite3_stmt** ppStmt, const(char*)* pzTail)<br>nothrow int sqlite3_prepare16(sqlite3* db, const(void)* zSql, int nByte, sqlite3_stmt** ppStmt, const(void*)* pzTail)<br>nothrow int sqlite3_prepare16_v2(sqlite3* db, const(void)* zSql, int nByte, sqlite3_stmt** ppStmt, const(void*)* pzTail)</dt> <dd>
<p>* CAPI3REF: Compiling An SQL Statement</p> </dd> <dt class="d_decl" id="sqlite3_sql">nothrow const(char)* sqlite3_sql(sqlite3_stmt* pStmt)</dt> <dd>
<p>* CAPI3REF: Retrieving Statement SQL</p> </dd> <dt class="d_decl" id="sqlite3_stmt_busy">nothrow int sqlite3_stmt_busy(sqlite3_stmt*)</dt> <dd>
<p>* CAPI3REF: Determine If A Prepared Statement Has Been Reset</p> </dd> <dt class="d_decl" id="sqlite3_value">struct sqlite3_value</dt> <dd>
<p>* CAPI3REF: Dynamically Typed Value Object</p> </dd> <dt class="d_decl" id="sqlite3_context">struct sqlite3_context</dt> <dd>
<p>* CAPI3REF: SQL Function Context Object</p> </dd> <dt class="d_decl" id="sqlite3_bind_blob">nothrow int sqlite3_bind_blob(sqlite3_stmt*, int, const void*, int n, void function(void*))<br>nothrow int sqlite3_bind_blob64(sqlite3_stmt*, int, const void*, sqlite3_uint64, void function(void*))<br>nothrow int sqlite3_bind_double(sqlite3_stmt*, int, double)<br>nothrow int sqlite3_bind_int(sqlite3_stmt*, int, int)<br>nothrow int sqlite3_bind_int64(sqlite3_stmt*, int, sqlite3_int64)<br>nothrow int sqlite3_bind_null(sqlite3_stmt*, int)<br>nothrow int sqlite3_bind_text(sqlite3_stmt*, int, const char*, int n, void function(void*))<br>nothrow int sqlite3_bind_text16(sqlite3_stmt*, int, const void*, int, void function(void*))<br>nothrow int sqlite3_bind_text64(sqlite3_stmt*, int, const char*, sqlite3_uint64, void function(void*), ubyte encoding)<br>nothrow int sqlite3_bind_value(sqlite3_stmt*, int, const sqlite3_value*)<br>nothrow int sqlite3_bind_zeroblob(sqlite3_stmt*, int, int n)<br>nothrow int sqlite3_bind_zeroblob64(sqlite3_stmt*, int, sqlite3_uint64 n)</dt> <dd>
<p>* CAPI3REF: Binding Values To Prepared Statements</p> </dd> <dt class="d_decl" id="sqlite3_bind_parameter_count">nothrow int sqlite3_bind_parameter_count(sqlite3_stmt*)</dt> <dd>
<p>* CAPI3REF: Number Of SQL Parameters</p> </dd> <dt class="d_decl" id="sqlite3_bind_parameter_name">nothrow const(char)* sqlite3_bind_parameter_name(sqlite3_stmt*, int)</dt> <dd>
<p>* CAPI3REF: Name Of A Host Parameter</p> </dd> <dt class="d_decl" id="sqlite3_bind_parameter_index">nothrow int sqlite3_bind_parameter_index(sqlite3_stmt*, const char* zName)</dt> <dd>
<p>* CAPI3REF: Index Of A Parameter With A Given Name</p> </dd> <dt class="d_decl" id="sqlite3_clear_bindings">nothrow int sqlite3_clear_bindings(sqlite3_stmt*)</dt> <dd>
<p>* CAPI3REF: Reset All Bindings On A Prepared Statement</p> </dd> <dt class="d_decl" id="sqlite3_column_count">nothrow int sqlite3_column_count(sqlite3_stmt* pStmt)</dt> <dd>
<p>* CAPI3REF: Number Of Columns In A Result Set</p> </dd> <dt class="d_decl" id="sqlite3_column_name">nothrow const(char)* sqlite3_column_name(sqlite3_stmt*, int N)<br>nothrow const(void)* sqlite3_column_name16(sqlite3_stmt*, int N)</dt> <dd>
<p>* CAPI3REF: Column Names In A Result Set</p> </dd> <dt class="d_decl" id="sqlite3_column_database_name">nothrow const(char)* sqlite3_column_database_name(sqlite3_stmt*, int)<br>nothrow const(void)* sqlite3_column_database_name16(sqlite3_stmt*, int)<br>nothrow const(char)* sqlite3_column_table_name(sqlite3_stmt*, int)<br>nothrow const(void)* sqlite3_column_table_name16(sqlite3_stmt*, int)<br>nothrow const(char)* sqlite3_column_origin_name(sqlite3_stmt*, int)<br>nothrow const(void)* sqlite3_column_origin_name16(sqlite3_stmt*, int)</dt> <dd>
<p>* CAPI3REF: Source Of Data In A Query Result</p> </dd> <dt class="d_decl" id="sqlite3_column_decltype">nothrow const(char)* sqlite3_column_decltype(sqlite3_stmt*, int)<br>nothrow const(void)* sqlite3_column_decltype16(sqlite3_stmt*, int)</dt> <dd>
<p>* CAPI3REF: Declared Datatype Of A Query Result</p> </dd> <dt class="d_decl" id="sqlite3_step">nothrow int sqlite3_step(sqlite3_stmt*)</dt> <dd>
<p>* CAPI3REF: Evaluate An SQL Statement</p> </dd> <dt class="d_decl" id="sqlite3_data_count">nothrow int sqlite3_data_count(sqlite3_stmt* pStmt)</dt> <dd>
<p>* CAPI3REF: Number of columns in a result set</p> </dd> <dt class="d_decl" id="sqlite3_column_blob">nothrow const(void)* sqlite3_column_blob(sqlite3_stmt*, int iCol)<br>nothrow int sqlite3_column_bytes(sqlite3_stmt*, int iCol)<br>nothrow int sqlite3_column_bytes16(sqlite3_stmt*, int iCol)<br>nothrow double sqlite3_column_double(sqlite3_stmt*, int iCol)<br>nothrow int sqlite3_column_int(sqlite3_stmt*, int iCol)<br>nothrow sqlite3_int64 sqlite3_column_int64(sqlite3_stmt*, int iCol)<br>nothrow const(char)* sqlite3_column_text(sqlite3_stmt*, int iCol)<br>nothrow const(void)* sqlite3_column_text16(sqlite3_stmt*, int iCol)<br>nothrow int sqlite3_column_type(sqlite3_stmt*, int iCol)<br>nothrow sqlite3_value* sqlite3_column_value(sqlite3_stmt*, int iCol)</dt> <dd>
<p>* CAPI3REF: Result Values From A Query</p> </dd> <dt class="d_decl" id="sqlite3_finalize">nothrow int sqlite3_finalize(sqlite3_stmt* pStmt)</dt> <dd>
<p>* CAPI3REF: Destroy A Prepared Statement Object</p> </dd> <dt class="d_decl" id="sqlite3_reset">nothrow int sqlite3_reset(sqlite3_stmt* pStmt)</dt> <dd>
<p>* CAPI3REF: Reset A Prepared Statement Object</p> </dd> <dt class="d_decl" id="sqlite3_create_function">nothrow int sqlite3_create_function(sqlite3* db, const(char)* zFunctionName, int nArg, int eTextRep, void* pApp, void function(sqlite3_context*, int, sqlite3_value**) xFunc, void function(sqlite3_context*, int, sqlite3_value**) xStep, void function(sqlite3_context*) xFinal)<br>nothrow int sqlite3_create_function16(sqlite3* db, const(void)* zFunctionName, int nArg, int eTextRep, void* pApp, void function(sqlite3_context*, int, sqlite3_value**) xFunc, void function(sqlite3_context*, int, sqlite3_value**) xStep, void function(sqlite3_context*) xFinal)<br>nothrow int sqlite3_create_function_v2(sqlite3* db, const(char)* zFunctionName, int nArg, int eTextRep, void* pApp, void function(sqlite3_context*, int, sqlite3_value**) xFunc, void function(sqlite3_context*, int, sqlite3_value**) xStep, void function(sqlite3_context*) xFinal, void function(void*) xDestroy)</dt> <dd>
<p>* CAPI3REF: Create Or Redefine SQL Functions</p> </dd> <dt class="d_decl" id="SQLITE_UTF16">SQLITE_UTF16</dt> <dd>
<p>Use native byte order</p> </dd> <dt class="d_decl" id="SQLITE_ANY">SQLITE_ANY</dt> <dd>
<p>sqlite3_create_function only</p> </dd> <dt class="d_decl" id="SQLITE_UTF16_ALIGNED">SQLITE_UTF16_ALIGNED</dt> <dd>
<p>sqlite3_create_collation only</p> </dd> <dt class="d_decl" id="SQLITE_DETERMINISTIC">enum int SQLITE_DETERMINISTIC</dt> <dd>
<p>* CAPI3REF: Function Flags</p> </dd> <dt class="d_decl" id="sqlite3_aggregate_count">deprecated nothrow int sqlite3_aggregate_count(sqlite3_context*)</dt> <dd>
<p>* CAPI3REF: Deprecated Functions</p> </dd> <dt class="d_decl" id="sqlite3_value_blob">nothrow const(void)* sqlite3_value_blob(sqlite3_value*)<br>nothrow int sqlite3_value_bytes(sqlite3_value*)<br>nothrow int sqlite3_value_bytes16(sqlite3_value*)<br>nothrow double sqlite3_value_double(sqlite3_value*)<br>nothrow int sqlite3_value_int(sqlite3_value*)<br>nothrow sqlite3_int64 sqlite3_value_int64(sqlite3_value*)<br>nothrow const(char)* sqlite3_value_text(sqlite3_value*)<br>nothrow const(void)* sqlite3_value_text16(sqlite3_value*)<br>nothrow const(void)* sqlite3_value_text16le(sqlite3_value*)<br>nothrow const(void)* sqlite3_value_text16be(sqlite3_value*)<br>nothrow int sqlite3_value_type(sqlite3_value*)<br>nothrow int sqlite3_value_numeric_type(sqlite3_value*)</dt> <dd>
<p>* CAPI3REF: Obtaining SQL Function Parameter Values</p> </dd> <dt class="d_decl" id="sqlite3_aggregate_context">nothrow void* sqlite3_aggregate_context(sqlite3_context*, int nBytes)</dt> <dd>
<p>* CAPI3REF: Obtain Aggregate Function Context</p> </dd> <dt class="d_decl" id="sqlite3_user_data">nothrow void* sqlite3_user_data(sqlite3_context*)</dt> <dd>
<p>* CAPI3REF: User Data For Functions</p> </dd> <dt class="d_decl" id="sqlite3_context_db_handle">nothrow sqlite3* sqlite3_context_db_handle(sqlite3_context*)</dt> <dd>
<p>* CAPI3REF: Database Connection For Functions</p> </dd> <dt class="d_decl" id="sqlite3_get_auxdata">nothrow void* sqlite3_get_auxdata(sqlite3_context*, int N)<br>nothrow void sqlite3_set_auxdata(sqlite3_context*, int N, void*, void function(void*))</dt> <dd>
<p>* CAPI3REF: Function Auxiliary Data</p> </dd> <dt class="d_decl" id="sqlite3_destructor_type">alias sqlite3_destructor_type = extern (C) void function(void*) nothrow</dt> <dd>
<p>* CAPI3REF: Constants Defining Special Destructor Behavior</p> </dd> <dt class="d_decl" id="sqlite3_result_blob">nothrow void sqlite3_result_blob(sqlite3_context*, const void*, int, void function(void*))<br>nothrow void sqlite3_result_blob64(sqlite3_context*, const void*, sqlite3_uint64, void function(void*))<br>nothrow void sqlite3_result_double(sqlite3_context*, double)<br>nothrow void sqlite3_result_error(sqlite3_context*, const char*, int)<br>nothrow void sqlite3_result_error16(sqlite3_context*, const void*, int)<br>nothrow void sqlite3_result_error_toobig(sqlite3_context*)<br>nothrow void sqlite3_result_error_nomem(sqlite3_context*)<br>nothrow void sqlite3_result_error_code(sqlite3_context*, int)<br>nothrow void sqlite3_result_int(sqlite3_context*, int)<br>nothrow void sqlite3_result_int64(sqlite3_context*, sqlite3_int64)<br>nothrow void sqlite3_result_null(sqlite3_context*)<br>nothrow void sqlite3_result_text(sqlite3_context*, const char*, int, void function(void*))<br>nothrow void sqlite3_result_text64(sqlite3_context*, const char*, sqlite3_uint64, void function(void*), ubyte encoding)<br>nothrow void sqlite3_result_text16(sqlite3_context*, const void*, int, void function(void*))<br>nothrow void sqlite3_result_text16le(sqlite3_context*, const void*, int, void function(void*))<br>nothrow void sqlite3_result_text16be(sqlite3_context*, const void*, int, void function(void*))<br>nothrow void sqlite3_result_value(sqlite3_context*, sqlite3_value*)<br>nothrow void sqlite3_result_zeroblob(sqlite3_context*, int n)<br>nothrow int sqlite3_result_zeroblob64(sqlite3_context*, sqlite3_uint64 n)</dt> <dd>
<p>* CAPI3REF: Setting The Result Of An SQL Function</p> </dd> <dt class="d_decl" id="sqlite3_create_collation">nothrow int sqlite3_create_collation(sqlite3*, const(char)* zName, int eTextRep, void* pArg, int function(void*, int, const void*, int, const void*) xCompare)<br>nothrow int sqlite3_create_collation_v2(sqlite3*, const(char)* zName, int eTextRep, void* pArg, int function(void*, int, const void*, int, const void*) xCompare, void function(void*) xDestroy)<br>nothrow int sqlite3_create_collation16(sqlite3*, const(void)* zName, int eTextRep, void* pArg, int function(void*, int, const void*, int, const void*) xCompare)</dt> <dd>
<p>* CAPI3REF: Define New Collating Sequences</p> </dd> <dt class="d_decl" id="sqlite3_collation_needed">nothrow int sqlite3_collation_needed(sqlite3*, void*, void function(void*, sqlite3*, int eTextRep, const char*))<br>nothrow int sqlite3_collation_needed16(sqlite3*, void*, void function(void*, sqlite3*, int eTextRep, const void*))</dt> <dd>
<p>* CAPI3REF: Collation Needed Callbacks</p> </dd> <dt class="d_decl" id="sqlite3_key">nothrow int sqlite3_key(sqlite3* db, const(void)* pKey, int nKey)<br>nothrow int sqlite3_key_v2(sqlite3* db, const(char)* zDbName, const(void)* pKey, int nKey)</dt>  <dt class="d_decl" id="sqlite3_rekey">nothrow int sqlite3_rekey(sqlite3* db, const(void)* pKey, int nKey)</dt> <dd>
<p>* Change the key on an open database. If the current database is not * encrypted, this routine will encrypt it. If pNew == 0 or nNew == 0, the * database is decrypted. * * The code to implement this API is not available in the public release * of SQLite.</p> </dd> <dt class="d_decl" id="sqlite3_activate_see">nothrow void sqlite3_activate_see(const(char)* zPassPhrase)</dt> <dd>
<p>* Specify the activation key for a SEE database. Unless * activated, none of the SEE routines will work.</p> </dd> <dt class="d_decl" id="sqlite3_activate_cerod">nothrow void sqlite3_activate_cerod(const(char)* zPassPhrase)</dt> <dd>
<p>* Specify the activation key for a CEROD database. Unless * activated, none of the CEROD routines will work.</p> </dd> <dt class="d_decl" id="sqlite3_sleep">nothrow int sqlite3_sleep(int)</dt> <dd>
<p>* CAPI3REF: Suspend Execution For A Short Time</p> </dd> <dt class="d_decl" id="sqlite3_temp_directory">char* sqlite3_temp_directory</dt> <dd>
<p>* CAPI3REF: Name Of The Folder Holding Temporary Files</p> </dd> <dt class="d_decl" id="sqlite3_data_directory">char* sqlite3_data_directory</dt> <dd>
<p>* CAPI3REF: Name Of The Folder Holding Database Files</p> </dd> <dt class="d_decl" id="sqlite3_get_autocommit">nothrow int sqlite3_get_autocommit(sqlite3*)</dt> <dd>
<p>* CAPI3REF: Test For Auto-Commit Mode</p> </dd> <dt class="d_decl" id="sqlite3_db_handle">nothrow sqlite3* sqlite3_db_handle(sqlite3_stmt*)</dt> <dd>
<p>* CAPI3REF: Find The Database Handle Of A Prepared Statement</p> </dd> <dt class="d_decl" id="sqlite3_db_filename">nothrow const(char)* sqlite3_db_filename(sqlite3* db, const char* zDbName)</dt> <dd>
<p>* CAPI3REF: Return The Filename For A Database Connection</p> </dd> <dt class="d_decl" id="sqlite3_db_readonly">nothrow int sqlite3_db_readonly(sqlite3* db, const char* zDbName)</dt> <dd>
<p>* CAPI3REF: Determine if a database is read-only</p> </dd> <dt class="d_decl" id="sqlite3_commit_hook">nothrow void* sqlite3_commit_hook(sqlite3*, int function(void*), void*)<br>nothrow void* sqlite3_rollback_hook(sqlite3*, void function(void*), void*)</dt> <dd>
<p>* CAPI3REF: Commit And Rollback Notification Callbacks</p> </dd> <dt class="d_decl" id="sqlite3_update_hook">nothrow void* sqlite3_update_hook(sqlite3*, void function(void*, int, char*, char*, sqlite3_int64), void*)</dt> <dd>
<p>* CAPI3REF: Data Change Notification Callbacks</p> </dd> <dt class="d_decl" id="sqlite3_enable_shared_cache">nothrow int sqlite3_enable_shared_cache(int)</dt> <dd>
<p>* CAPI3REF: Enable Or Disable Shared Pager Cache</p> </dd> <dt class="d_decl" id="sqlite3_release_memory">nothrow int sqlite3_release_memory(int)</dt> <dd>
<p>* CAPI3REF: Attempt To Free Heap Memory</p> </dd> <dt class="d_decl" id="sqlite3_db_release_memory">nothrow int sqlite3_db_release_memory(sqlite3*)</dt> <dd>
<p>* CAPI3REF: Free Memory Used By A Database Connection</p> </dd> <dt class="d_decl" id="sqlite3_soft_heap_limit">deprecated nothrow void sqlite3_soft_heap_limit(int N)</dt> <dd>
<p>* CAPI3REF: Deprecated Soft Heap Limit Interface</p> </dd> <dt class="d_decl" id="sqlite3_table_column_metadata">nothrow int sqlite3_table_column_metadata(sqlite3* db, const(char)* zDbName, const(char)* zTableName, const(char)* zColumnName, char** pzDataType, char** pzCollSeq, int* pNotNull, int* pPrimaryKey, int* pAutoinc)</dt> <dd>
<p>* CAPI3REF: Extract Metadata About A Column Of A Table</p> </dd> <dt class="d_decl" id="sqlite3_load_extension">nothrow int sqlite3_load_extension(sqlite3* db, const(char)* zFile, const(char)* zProc, char** pzErrMsg)</dt> <dd>
<p>* CAPI3REF: Load An Extension</p> </dd> <dt class="d_decl" id="sqlite3_enable_load_extension">nothrow int sqlite3_enable_load_extension(sqlite3* db, int onoff)</dt> <dd>
<p>* CAPI3REF: Enable Or Disable Extension Loading</p> </dd> <dt class="d_decl" id="sqlite3_auto_extension">nothrow int sqlite3_auto_extension(void function() xEntryPoint)</dt> <dd>
<p>* CAPI3REF: Automatically Load Statically Linked Extensions</p> </dd> <dt class="d_decl" id="sqlite3_cancel_auto_extension">nothrow int sqlite3_cancel_auto_extension(void function() xEntryPoint)</dt> <dd>
<p>* CAPI3REF: Cancel Automatic Extension Loading</p> </dd> <dt class="d_decl" id="sqlite3_reset_auto_extension">nothrow void sqlite3_reset_auto_extension()</dt> <dd>
<p>* CAPI3REF: Reset Automatic Extension Loading</p> </dd> <dt class="d_decl" id="mapFunction">alias mapFunction = extern (C) void function(sqlite3_context*, int, sqlite3_value**) nothrow<br>struct sqlite3_module</dt> <dd>
<p>* The interface to the virtual-table mechanism is currently considered * to be experimental. The interface might change in incompatible ways. * If this is a problem for you, do not use the interface at this time. * * When the virtual-table mechanism stabilizes, we will declare the * interface fixed, support it indefinitely, and remove this comment. </p>
<p>* CAPI3REF: Virtual Table Object</p> </dd> <dt class="d_decl" id="sqlite3_index_info">struct sqlite3_index_info</dt> <dd>
<p>* CAPI3REF: Virtual Table Indexing Information</p> <dl>
<dt class="d_decl" id="sqlite3_index_info.nConstraint">int nConstraint</dt> <dd>
<p>Number of entries in aConstraint</p> </dd> <dt class="d_decl" id="sqlite3_index_info.aConstraint">sqlite3_index_constraint* aConstraint</dt> <dd>
<p>Table of WHERE clause constraints</p> </dd> <dt class="d_decl" id="sqlite3_index_info.nOrderBy">int nOrderBy</dt> <dd>
<p>Number of terms in the ORDER BY clause</p> </dd> <dt class="d_decl" id="sqlite3_index_info.aOrderBy">sqlite3_index_orderby* aOrderBy</dt> <dd>
<p>The ORDER BY clause</p> </dd> <dt class="d_decl" id="sqlite3_index_info.idxNum">int idxNum</dt> <dd>
<p>Number used to identify the index</p> </dd> <dt class="d_decl" id="sqlite3_index_info.idxStr">char* idxStr</dt> <dd>
<p>String, possibly obtained from sqlite3_malloc</p> </dd> <dt class="d_decl" id="sqlite3_index_info.needToFreeIdxStr">int needToFreeIdxStr</dt> <dd>
<p>Free idxStr using sqlite3_free() if <code>true</code></p> </dd> <dt class="d_decl" id="sqlite3_index_info.orderByConsumed">int orderByConsumed</dt> <dd>
<p>True if output is already ordered</p> </dd> <dt class="d_decl" id="sqlite3_index_info.estimatedCost">double estimatedCost</dt> <dd>
<p>Estimated cost of using this index</p> </dd> </dl> </dd> <dt class="d_decl" id="sqlite3_create_module">nothrow int sqlite3_create_module(sqlite3* db, const(char)* zName, const(sqlite3_module)* p, void* pClientData)<br>nothrow int sqlite3_create_module_v2(sqlite3* db, const(char)* zName, const(sqlite3_module)* p, void* pClientData, void function(void*) xDestroy)</dt> <dd>
<p>* CAPI3REF: Register A Virtual Table Implementation</p> </dd> <dt class="d_decl" id="sqlite3_vtab">struct sqlite3_vtab</dt> <dd>
<p>* CAPI3REF: Virtual Table Instance Object</p> <dl>
<dt class="d_decl" id="sqlite3_vtab.pModule">const(sqlite3_module)* pModule</dt> <dd>
<p>The module for this virtual table</p> </dd> <dt class="d_decl" id="sqlite3_vtab.nRef">int nRef</dt> <dd>
<p>NO LONGER USED</p> </dd> <dt class="d_decl" id="sqlite3_vtab.zErrMsg">char* zErrMsg</dt> <dd>
<p>Error message from sqlite3_mprintf()</p> </dd> </dl> </dd> <dt class="d_decl" id="sqlite3_vtab_cursor">struct sqlite3_vtab_cursor</dt> <dd>
<p>* CAPI3REF: Virtual Table Cursor Object</p> <dl>
<dt class="d_decl" id="sqlite3_vtab_cursor.pVtab">sqlite3_vtab* pVtab</dt> <dd>
<p>Virtual table of this cursor</p> </dd> </dl> </dd> <dt class="d_decl" id="sqlite3_declare_vtab">nothrow int sqlite3_declare_vtab(sqlite3*, const char* zSQL)</dt> <dd>
<p>* CAPI3REF: Declare The Schema Of A Virtual Table</p> </dd> <dt class="d_decl" id="sqlite3_overload_function">nothrow int sqlite3_overload_function(sqlite3*, const char* zFuncName, int nArg)</dt> <dd>
<p>* CAPI3REF: Overload A Function For A Virtual Table</p> </dd> <dt class="d_decl" id="sqlite3_blob">struct sqlite3_blob</dt> <dd>
<p>* The interface to the virtual-table mechanism defined above (back up * to a comment remarkably similar to this one) is currently considered * to be experimental. The interface might change in incompatible ways. * If this is a problem for you, do not use the interface at this time. * * When the virtual-table mechanism stabilizes, we will declare the * interface fixed, support it indefinitely, and remove this comment.</p> </dd> <dt class="d_decl" id="sqlite3_blob_open">nothrow int sqlite3_blob_open(sqlite3*, const(char)* zDb, const(char)* zTable, const(char)* zColumn, sqlite3_int64 iRow, int flags, sqlite3_blob** ppBlob)</dt> <dd>
<p>* CAPI3REF: Open A BLOB For Incremental I/O</p> </dd> <dt class="d_decl" id="sqlite3_blob_reopen">nothrow int sqlite3_blob_reopen(sqlite3_blob*, sqlite3_int64)</dt> <dd>
<p>* CAPI3REF: Move a BLOB Handle to a New Row</p> </dd> <dt class="d_decl" id="sqlite3_blob_close">nothrow int sqlite3_blob_close(sqlite3_blob*)</dt> <dd>
<p>* CAPI3REF: Close A BLOB Handle</p> </dd> <dt class="d_decl" id="sqlite3_blob_bytes">nothrow int sqlite3_blob_bytes(sqlite3_blob*)</dt> <dd>
<p>* CAPI3REF: Return The Size Of An Open BLOB</p> </dd> <dt class="d_decl" id="sqlite3_blob_read">nothrow int sqlite3_blob_read(sqlite3_blob*, void* Z, int N, int iOffset)</dt> <dd>
<p>* CAPI3REF: Read Data From A BLOB Incrementally</p> </dd> <dt class="d_decl" id="sqlite3_blob_write">nothrow int sqlite3_blob_write(sqlite3_blob*, const void* z, int n, int iOffset)</dt> <dd>
<p>* CAPI3REF: Write Data Into A BLOB Incrementally</p> </dd> <dt class="d_decl" id="sqlite3_vfs_find">nothrow sqlite3_vfs* sqlite3_vfs_find(const char* zVfsName)<br>nothrow int sqlite3_vfs_register(sqlite3_vfs*, int makeDflt)<br>nothrow int sqlite3_vfs_unregister(sqlite3_vfs*)</dt> <dd>
<p>* CAPI3REF: Virtual File System Objects</p> </dd> <dt class="d_decl" id="sqlite3_mutex_alloc">nothrow sqlite3_mutex* sqlite3_mutex_alloc(int)<br>nothrow void sqlite3_mutex_free(sqlite3_mutex*)<br>nothrow void sqlite3_mutex_enter(sqlite3_mutex*)<br>nothrow int sqlite3_mutex_try(sqlite3_mutex*)<br>nothrow void sqlite3_mutex_leave(sqlite3_mutex*)</dt> <dd>
<p>* CAPI3REF: Mutexes</p> </dd> <dt class="d_decl" id="sqlite3_mutex_methods">struct sqlite3_mutex_methods</dt> <dd>
<p>* CAPI3REF: Mutex Methods Object</p> </dd> <dt class="d_decl" id="sqlite3_mutex_held">nothrow int sqlite3_mutex_held(sqlite3_mutex*)<br>nothrow int sqlite3_mutex_notheld(sqlite3_mutex*)</dt> <dd>
<p>* CAPI3REF: Mutex Verification Routines</p> </dd> <dt class="d_decl" id="SQLITE_MUTEX_STATIC_MEM">SQLITE_MUTEX_STATIC_MEM</dt> <dd>
<p>sqlite3_malloc()</p> </dd> <dt class="d_decl" id="SQLITE_MUTEX_STATIC_MEM2">SQLITE_MUTEX_STATIC_MEM2</dt> <dd>
<p>NOT USED</p> </dd> <dt class="d_decl" id="SQLITE_MUTEX_STATIC_OPEN">SQLITE_MUTEX_STATIC_OPEN</dt> <dd>
<p>sqlite3BtreeOpen()</p> </dd> <dt class="d_decl" id="SQLITE_MUTEX_STATIC_PRNG">SQLITE_MUTEX_STATIC_PRNG</dt> <dd>
<p>sqlite3_random()</p> </dd> <dt class="d_decl" id="SQLITE_MUTEX_STATIC_LRU">SQLITE_MUTEX_STATIC_LRU</dt> <dd>
<p>lru page list</p> </dd> <dt class="d_decl" id="SQLITE_MUTEX_STATIC_LRU2">SQLITE_MUTEX_STATIC_LRU2</dt> <dd>
<p>NOT USED</p> </dd> <dt class="d_decl" id="SQLITE_MUTEX_STATIC_PMEM">SQLITE_MUTEX_STATIC_PMEM</dt> <dd>
<p>sqlite3PageMalloc()</p> </dd> <dt class="d_decl" id="SQLITE_MUTEX_STATIC_APP1">SQLITE_MUTEX_STATIC_APP1</dt> <dd>
<p>For use by application</p> </dd> <dt class="d_decl" id="SQLITE_MUTEX_STATIC_APP2">SQLITE_MUTEX_STATIC_APP2</dt> <dd>
<p>For use by application</p> </dd> <dt class="d_decl" id="SQLITE_MUTEX_STATIC_APP3">SQLITE_MUTEX_STATIC_APP3</dt> <dd>
<p>For use by application</p> </dd> <dt class="d_decl" id="SQLITE_MUTEX_STATIC_VFS1">SQLITE_MUTEX_STATIC_VFS1</dt> <dd>
<p>For use by built-in VFS</p> </dd> <dt class="d_decl" id="SQLITE_MUTEX_STATIC_VFS2">SQLITE_MUTEX_STATIC_VFS2</dt> <dd>
<p>For use by extension VFS</p> </dd> <dt class="d_decl" id="SQLITE_MUTEX_STATIC_VFS3">SQLITE_MUTEX_STATIC_VFS3</dt> <dd>
<p>For use by application VFS</p> </dd> <dt class="d_decl" id="sqlite3_db_mutex">nothrow sqlite3_mutex* sqlite3_db_mutex(sqlite3*)</dt> <dd>
<p>* CAPI3REF: Retrieve the mutex for a database connection</p> </dd> <dt class="d_decl" id="sqlite3_file_control">nothrow int sqlite3_file_control(sqlite3*, const char* zDbName, int op, void*)</dt> <dd>
<p>* CAPI3REF: Low-Level Control Of Database Files</p> </dd> <dt class="d_decl" id="sqlite3_test_control">nothrow int sqlite3_test_control(int op, ...)</dt> <dd>
<p>* CAPI3REF: Testing Interface</p> </dd> <dt class="d_decl" id="sqlite3_status">nothrow int sqlite3_status(int op, int* pCurrent, int* pHighwater, int resetFlag)<br>nothrow int sqlite3_status64(int op, long* pCurrent, long* pHighwater, int resetFlag)</dt> <dd>
<p>* CAPI3REF: SQLite Runtime Status</p> </dd> <dt class="d_decl" id="sqlite3_db_status">nothrow int sqlite3_db_status(sqlite3*, int op, int* pCur, int* pHiwtr, int resetFlg)</dt> <dd>
<p>* CAPI3REF: Database Connection Status</p> </dd> <dt class="d_decl" id="SQLITE_DBSTATUS_MAX">SQLITE_DBSTATUS_MAX</dt> <dd>
<p>Largest defined DBSTATUS</p> </dd> <dt class="d_decl" id="sqlite3_stmt_status">nothrow int sqlite3_stmt_status(sqlite3_stmt*, int op, int resetFlg)</dt> <dd>
<p>* CAPI3REF: Prepared Statement Status</p> </dd> <dt class="d_decl" id="sqlite3_pcache">struct sqlite3_pcache</dt> <dd>
<p>* CAPI3REF: Custom Page Cache Object</p> </dd> <dt class="d_decl" id="sqlite3_pcache_page">struct sqlite3_pcache_page</dt> <dd>
<p>* CAPI3REF: Custom Page Cache Object</p> </dd> <dt class="d_decl" id="sqlite3_pcache_methods2">struct sqlite3_pcache_methods2</dt> <dd>
<p>* CAPI3REF: Application Defined Page Cache.</p> </dd> <dt class="d_decl" id="sqlite3_backup">struct sqlite3_backup</dt> <dd>
<p>* CAPI3REF: Online Backup Object</p> </dd> <dt class="d_decl" id="sqlite3_backup_init">nothrow sqlite3_backup* sqlite3_backup_init(sqlite3* pDest, const(char)* zDestName, sqlite3* pSource, const(char)* zSourceName)<br>nothrow int sqlite3_backup_step(sqlite3_backup* p, int nPage)<br>nothrow int sqlite3_backup_finish(sqlite3_backup* p)<br>nothrow int sqlite3_backup_remaining(sqlite3_backup* p)<br>nothrow int sqlite3_backup_pagecount(sqlite3_backup* p)</dt> <dd>
<p>* CAPI3REF: Online Backup API.</p> </dd> <dt class="d_decl" id="sqlite3_unlock_notify">nothrow int sqlite3_unlock_notify(sqlite3* pBlocked, void function(void** apArg, int nArg) xNotify, void* pNotifyArg)</dt> <dd>
<p>* CAPI3REF: Unlock Notification</p> </dd> <dt class="d_decl" id="sqlite3_stricmp">nothrow int sqlite3_stricmp(const char*, const char*)</dt> <dd>
<p>* CAPI3REF: String Comparison</p> </dd> <dt class="d_decl" id="sqlite3_log">nothrow void sqlite3_log(int iErrCode, const char* zFormat, ...)</dt> <dd>
<p>* CAPI3REF: Error Logging Interface</p> </dd> <dt class="d_decl" id="sqlite3_wal_hook">nothrow void* sqlite3_wal_hook(sqlite3*, int function(void*, sqlite3*, const char*, int), void*)</dt> <dd>
<p>* CAPI3REF: Write-Ahead Log Commit Hook</p> </dd> <dt class="d_decl" id="sqlite3_wal_autocheckpoint">nothrow int sqlite3_wal_autocheckpoint(sqlite3* db, int N)</dt> <dd>
<p>* CAPI3REF: Configure an auto-checkpoint</p> </dd> <dt class="d_decl" id="sqlite3_wal_checkpoint">nothrow int sqlite3_wal_checkpoint(sqlite3* db, const char* zDb)</dt> <dd>
<p>* CAPI3REF: Checkpoint a database</p> </dd> <dt class="d_decl" id="sqlite3_wal_checkpoint_v2">nothrow int sqlite3_wal_checkpoint_v2(sqlite3* db, const(char)* zDb, int eMode, int* pnLog, int* pnCkpt)</dt> <dd>
<p>* CAPI3REF: Checkpoint a database</p> </dd> <dt class="d_decl" id="SQLITE_VTAB_CONSTRAINT_SUPPORT">enum int SQLITE_VTAB_CONSTRAINT_SUPPORT</dt> <dd>
<p>* CAPI3REF: Virtual Table Configuration Options</p> </dd> <dt class="d_decl" id="sqlite3_rtree_geometry_callback">nothrow int sqlite3_rtree_geometry_callback(sqlite3* db, const(char)* zGeom, int function(sqlite3_rtree_geometry*, int nCoord, double* aCoord, int* pRes) xGeom, void* pContext)</dt> <dd>
<p>* Register a geometry callback named <code>zGeom</code> that can be used as part of an * R-Tree geometry query as follows: * * SELECT ... FROM &lt;rtree&gt; WHERE &lt;rtree col&gt; MATCH <code>zGeom</code>(... params ...)</p> </dd> <dt class="d_decl" id="sqlite3_rtree_geometry">struct sqlite3_rtree_geometry</dt> <dd>
<p>* A pointer to a structure of the following type is passed as the first * argument to callbacks registered using rtree_geometry_callback().</p> <dl>
<dt class="d_decl" id="sqlite3_rtree_geometry.pContext">void* pContext</dt> <dd>
<p>Copy of <code>pContext</code> passed to s_r_g_c()</p> </dd> <dt class="d_decl" id="sqlite3_rtree_geometry.nParam">int nParam</dt> <dd>
<p>Size of array aParam[]</p> </dd> <dt class="d_decl" id="sqlite3_rtree_geometry.aParam">double* aParam</dt> <dd>
<p>Parameters passed to SQL geom function</p> </dd> <dt class="d_decl" id="sqlite3_rtree_geometry.pUser">void* pUser</dt> <dd>
<p>Callback implementation user data</p> </dd> <dt class="d_decl" id="sqlite3_rtree_geometry.xDelUser">void function(void*) xDelUser</dt> <dd>
<p>Called by SQLite to clean up pUser</p> </dd> </dl> </dd> <dt class="d_decl" id="Fts5Context">struct Fts5Context<br>alias fts5_extension_function = extern (C) void function(const(Fts5ExtensionApi*) pApi, Fts5Context* pFts, sqlite3_context* pCtx, int nVal, sqlite3_value** apVal) nothrow<br>struct Fts5PhraseIter<br>struct Fts5ExtensionApi<br>struct Fts5Tokenizer<br>enum int FTS5_TOKENIZE_QUERY<br>enum int FTS5_TOKENIZE_PREFIX<br>enum int FTS5_TOKENIZE_DOCUMENT<br>enum int FTS5_TOKENIZE_AUX<br>enum int FTS5_TOKEN_COLOCATED<br>struct fts5_api</dt> <dd>
<p>* Interfaces to extend FTS5.</p> </dd> </dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 1999–2017 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/phobos/etc_c_sqlite3.html" class="_attribution-link" target="_blank">https://dlang.org/phobos/etc_c_sqlite3.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
