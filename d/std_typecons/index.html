
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>std.typecons - D - W3cubDocs</title>
  
  <meta name="description" content=" This module implements a variety of type constructors, i.e., templates that allow construction of new, useful general-purpose types. ">
  <meta name="keywords" content="std, typecons, -, d">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/d/std_typecons/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-e0f881b0fce8cbe96f33dadc355b7159d5d2912911231446d60eb8f9caffa802.css">
  <script type="text/javascript" src="/assets/application-8fc46316434047265cd383f02b8e7f434ed7dec4a59f920dd633deef8d488d1b.js"></script>
  <script src="/json/d.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/d/" class="_nav-link" title="" style="margin-left:0;">D</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _d">
				
<h1>std.typecons</h1>  <p>This module implements a variety of type constructors, i.e., templates that allow construction of new, useful general-purpose types. </p>
<p> </p>
<table>

<tr>
<th scope="col">Category</th> <th scope="col">Functions</th>
</tr> <tr>
<td>Tuple</td> <td> <a href="#isTuple"><code>isTuple</code></a> <a href="#Tuple"><code>Tuple</code></a> <a href="#tuple"><code>tuple</code></a> <a href="#reverse"><code>reverse</code></a> </td>
</tr> <tr>
<td>Flags</td> <td> <a href="#BitFlags"><code>BitFlags</code></a> <a href="#isBitFlagEnum"><code>isBitFlagEnum</code></a> <a href="#Flag"><code>Flag</code></a> <a href="#No"><code>No</code></a> <a href="#Yes"><code>Yes</code></a> </td>
</tr> <tr>
<td>Memory allocation</td> <td> <a href="#RefCounted"><code>RefCounted</code></a> <a href="#refCounted"><code>refCounted</code></a> <a href="#RefCountedAutoInitialize"><code>RefCountedAutoInitialize</code></a> <a href="#scoped"><code>scoped</code></a> <a href="#Unique"><code>Unique</code></a> </td>
</tr> <tr>
<td>Code generation</td> <td> <a href="#AutoImplement"><code>AutoImplement</code></a> <a href="#BlackHole"><code>BlackHole</code></a> <a href="#generateAssertTrap"><code>generateAssertTrap</code></a> <a href="#generateEmptyFunction"><code>generateEmptyFunction</code></a> <a href="#WhiteHole"><code>WhiteHole</code></a> </td>
</tr> <tr>
<td>Nullable</td> <td> <a href="#Nullable"><code>Nullable</code></a> <a href="#nullable"><code>nullable</code></a> <a href="#NullableRef"><code>NullableRef</code></a> <a href="#nullableRef"><code>nullableRef</code></a> </td>
</tr> <tr>
<td>Proxies</td> <td> <a href="#Proxy"><code>Proxy</code></a> <a href="#rebindable"><code>rebindable</code></a> <a href="#Rebindable"><code>Rebindable</code></a> <a href="#ReplaceType"><code>ReplaceType</code></a> <a href="#unwrap"><code>unwrap</code></a> <a href="#wrap"><code>wrap</code></a> </td>
</tr> <tr>
<td>Types</td> <td> <a href="#alignForSize"><code>alignForSize</code></a> <a href="#Ternary"><code>Ternary</code></a> <a href="#Typedef"><code>Typedef</code></a> <a href="#TypedefType"><code>TypedefType</code></a> <a href="#UnqualRef"><code>UnqualRef</code></a> </td>
</tr> </table>  <dl>
<dt>License:</dt>
<dd>
<a href="http://boost.org/LICENSE_1_0.txt" target="_blank">Boost License 1.0</a>. </dd>
</dl> <dl>
<dt>Source</dt>
<dd> <span class="phobos_src"><a class="https" href="https://github.com/dlang/phobos/blob/master/std/typecons.d" target="_blank">std/typecons.d</a></span> </dd>
</dl> <dl>
<dt>Authors:</dt>
<dd>
<a href="http://erdani.org" target="_blank">Andrei Alexandrescu</a>, <a href="http://bartoszmilewski.wordpress.com" target="_blank">Bartosz Milewski</a>, Don Clugston, Shin Fujishiro, Kenji Hara</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">// value tuples
alias Coord = Tuple!(int, "x", int, "y", int, "z");
Coord c;
c[1] = 1;       // access by index
c.z = 1;        // access by given name
writeln(c); // Coord(0, 1, 1)

// names can be omitted
alias DicEntry = Tuple!(string, string);

// tuples can also be constructed on instantiation
writeln(tuple(2, 3, 4)[1]); // 3
// construction on instantiation works with names too
writeln(tuple!("x", "y", "z")(2, 3, 4).y); // 3

// Rebindable references to const and immutable objects
{
    class Widget { void foo() const @safe {} }
    const w1 = new Widget, w2 = new Widget;
    w1.foo();
    // w1 = w2 would not work; can't rebind const object
    auto r = Rebindable!(const Widget)(w1);
    // invoke method as if r were a Widget object
    r.foo();
    // rebind r to refer to another object
    r = w2;
}
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="Unique">struct Unique(T)</dt> <dd>
<p>Encapsulates unique ownership of a resource. </p>
<p>When a <code>Unique!T</code> goes out of scope it will call <code>destroy</code> on the resource <code>T</code> that it manages, unless it is transferred. One important consequence of <code>destroy</code> is that it will call the destructor of the resource <code>T</code>. GC-managed references are not guaranteed to be valid during a destructor call, but other members of <code>T</code>, such as file handles or pointers to <code>malloc</code> memory, will still be valid during the destructor call. This allows the resource <code>T</code> to deallocate or clean up any non-GC resources. <br><br> If it is desirable to persist a <code>Unique!T</code> outside of its original scope, then it can be transferred. The transfer can be explicit, by calling <code>release</code>, or implicit, when returning <code>Unique</code> from a function. The resource <code>T</code> can be a polymorphic class object or instance of an interface, in which case <code>Unique</code> behaves polymorphically too. <br><br> If <code>T</code> is a value type, then <code>Unique!T</code> will be implemented as a reference to a <code>T</code>.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static struct S
{
    int i;
    this(int i){this.i = i;}
}
Unique!S produce()
{
    // Construct a unique instance of S on the heap
    Unique!S ut = new S(5);
    // Implicit transfer of ownership
    return ut;
}
// Borrow a unique resource by ref
void increment(ref Unique!S ur)
{
    ur.i++;
}
void consume(Unique!S u2)
{
    writeln(u2.i); // 6
    // Resource automatically deleted here
}
Unique!S u1;
assert(u1.isEmpty);
u1 = produce();
increment(u1);
writeln(u1.i); // 6
//consume(u1); // Error: u1 is not copyable
// Transfer ownership of the resource
consume(u1.release);
assert(u1.isEmpty);
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="Unique.RefT">alias RefT = T</dt> <dd>
<p>Represents a reference to <code>T</code>. Resolves to <code>T*</code> if <code>T</code> is a value type.</p> </dd> <dt class="d_decl" id="Unique.create">Unique!T create(A...)(auto ref A args)<br><br>  Constraints:<br>    if (__traits(compiles, new T(args)))</dt> <dd>
<p>Allows safe construction of <code>Unique</code>. It creates the resource and guarantees unique ownership of it (unless <code>T</code> publishes aliases of <code>this</code>). </p>
<dl>
<dt>Note</dt>
<dd> Nested structs/classes cannot be created. </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>A <code>args</code>
</td> <td>Arguments to pass to <code>T</code>'s constructor. <pre data-language="d">static class C {}
auto u = Unique!(C).create();
</pre> </td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="Unique.this">this(RefT p)</dt> <dd>
<p> Constructor that takes an rvalue. It will ensure uniqueness, as long as the rvalue isn't just a view on an lvalue (e.g., a cast). Typical usage: </p>
<pre data-language="d">Unique!Foo f = new Foo;
</pre>  </dd> <dt class="d_decl" id="Unique.this.2">this(ref RefT p)</dt> <dd>
<p>Constructor that takes an lvalue. It nulls its source. The nulling will ensure uniqueness as long as there are no previous aliases to the source.</p> </dd> <dt class="d_decl" id="Unique.this.3">this(U)(Unique!U u)<br><br>  Constraints:<br>    if (is(u.RefT : RefT))</dt> <dd>
<p>Constructor that takes a <code>Unique</code> of a type that is convertible to our type. </p>
<p>Typically used to transfer a <code>Unique</code> rvalue of derived type to a <code>Unique</code> of base type. </p> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">class C : Object {}

Unique!C uc = new C;
Unique!Object uo = uc.release;
</pre>  </dd> <dt class="d_decl" id="Unique.opAssign">void opAssign(U)(Unique!U u)<br><br>  Constraints:<br>    if (is(u.RefT : RefT))</dt> <dd>
<p>Transfer ownership from a <code>Unique</code> of a type that is convertible to our type.</p> </dd> <dt class="d_decl" id="Unique.isEmpty">const @property bool isEmpty()</dt> <dd>
<p>Returns whether the resource exists.</p> </dd> <dt class="d_decl" id="Unique.release">Unique release()</dt> <dd>
<p>Transfer ownership to a <code>Unique</code> rvalue. Nullifies the current contents. Same as calling std.algorithm.move on it.</p> </dd> </dl> </dd> <dt class="d_decl" id="Tuple">struct Tuple(Specs...)</dt> <dd>
<p>Tuple of values, for example <code>Tuple!(int, string)</code> is a record that stores an <code>int</code> and a <code>string</code>. <code>Tuple</code> can be used to bundle values together, notably when returning multiple values from a function. If <code>obj</code> is a <code>Tuple</code>, the individual members are accessible with the syntax <code>obj[0]</code> for the first field, <code>obj[1]</code> for the second, and so on. </p>
<p>The choice of zero-based indexing instead of one-base indexing was motivated by the ability to use value tuples with various compile-time loop constructs (e.g. <a href="../std_meta/#AliasSeq"><code>std.meta.AliasSeq</code></a> iteration), all of which use zero-based indexing. </p> <dl>
<dt>See Also:</dt>
<dd>
<a href="#tuple"><code>tuple</code></a>. </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Specs</td> <td>A list of types (and optionally, member names) that the <code>Tuple</code> contains.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">Tuple!(int, int) point;
// assign coordinates
point[0] = 5;
point[1] = 6;
// read coordinates
auto x = point[0];
auto y = point[1];
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<code>Tuple</code> members can be named. It is legal to mix named and unnamed members. The method above is still applicable to all fields. <pre data-language="d">alias Entry = Tuple!(int, "index", string, "value");
Entry e;
e.index = 4;
e.value = "Hello";
writeln(e[1]); // "Hello"
writeln(e[0]); // 4
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>A <code>Tuple</code> with named fields is a distinct type from a <code>Tuple</code> with unnamed fields, i.e. each naming imparts a separate type for the <code>Tuple</code>. Two <code>Tuple</code>s differing in naming only are still distinct, even though they might have the same structure. <pre data-language="d">Tuple!(int, "x", int, "y") point1;
Tuple!(int, int) point2;
assert(!is(typeof(point1) == typeof(point2)));
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="Tuple.Types">alias Types = staticMap!(extractType, fieldSpecs)</dt> <dd>
<p>The types of the <code>Tuple</code>'s components.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">alias Fields = Tuple!(int, "id", string, float);
static assert(is(Fields.Types == AliasSeq!(int, string, float)));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Tuple.fieldNames">alias fieldNames = staticMap!(extractName, fieldSpecs)</dt> <dd>
<p>The names of the <code>Tuple</code>'s components. Unnamed fields have empty names.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">alias Fields = Tuple!(int, "id", string, float);
static assert(Fields.fieldNames == AliasSeq!("id", "", ""));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Tuple.expand">Types expand</dt> <dd>
<p>Use <code>t.expand</code> for a <code>Tuple</code> <code>t</code> to <code>expand</code> it into its components. The result of <code>expand</code> acts as if the <code>Tuple</code>'s components were listed as a list of values. (Ordinarily, a <code>Tuple</code> acts as a single value.)</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto t1 = tuple(1, " hello ", 2.3);
writeln(t1.toString()); // `Tuple!(int, string, double)(1, " hello ", 2.3)`

void takeSeveralTypes(int n, string s, bool b)
{
    assert(n == 4 &amp;&amp; s == "test" &amp;&amp; b == false);
}

auto t2 = tuple(4, "test", false);
//t.expand acting as a list of values
takeSeveralTypes(t2.expand);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Tuple.this">this(Types values)</dt> <dd>
<p>Constructor taking one value for each field. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Types <code>values</code>
</td> <td>A list of <code>values</code> that are either the same types as those given by the <code>Types</code> field of this <code>Tuple</code>, or can implicitly convert to those types. They must be in the same order as they appear in <code>Types</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">alias ISD = Tuple!(int, string, double);
auto tup = ISD(1, "test", 3.2);
writeln(tup.toString()); // `Tuple!(int, string, double)(1, "test", 3.2)`
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Tuple.this.2">this(U, size_t n)(U[n] values)<br><br>  Constraints:<br>    if (n == Types.length &amp;&amp; allSatisfy!(isBuildableFrom!U, Types))</dt> <dd>
<p>Constructor taking a compatible array. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>U[n] <code>values</code>
</td> <td>A compatible static array to build the <code>Tuple</code> from. Array slices are not supported.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">int[2] ints;
Tuple!(int, int) t = ints;
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Tuple.this.3">this(U)(U another)<br><br>  Constraints:<br>    if (areBuildCompatibleTuples!(typeof(this), U))</dt> <dd>
<p>Constructor taking a compatible <code>Tuple</code>. Two <code>Tuple</code>s are compatible <b>iff</b> they are both of the same length, and, for each type <code>T</code> on the left-hand side, the corresponding type <code>U</code> on the right-hand side can implicitly convert to <code>T</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>U <code>another</code>
</td> <td>A compatible <code>Tuple</code> to build from. Its type must be compatible with the target <code>Tuple</code>'s type.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">alias IntVec = Tuple!(int, int, int);
alias DubVec = Tuple!(double, double, double);

IntVec iv = tuple(1, 1, 1);

//Ok, int can implicitly convert to double
DubVec dv = iv;
//Error: double cannot implicitly convert to int
//IntVec iv2 = dv;
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Tuple.opEquals">bool opEquals(R)(R rhs)<br>const bool opEquals(R)(R rhs)<br><br>  Constraints:<br>    if (areCompatibleTuples!(typeof(this), R, "=="))<br>    if (areCompatibleTuples!(typeof(this), R, "=="))</dt> <dd>
<p>Comparison for equality. Two <code>Tuple</code>s are considered equal <b>iff</b> they fulfill the following criteria: </p>
<p></p>
<ul> <li>Each <code>Tuple</code> is the same length.</li> <li>For each type <code>T</code> on the left-hand side and each type <code>U</code> on the right-hand side, values of type <code>T</code> can be compared with values of type <code>U</code>.</li> <li>For each value <code>v1</code> on the left-hand side and each value <code>v2</code> on the right-hand side, the expression <code>v1 == v2</code> is <code>true</code>.</li>
</ul>  <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>rhs</code>
</td> <td>The <code>Tuple</code> to compare against. It must meeting the criteria for comparison between <code>Tuple</code>s.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>true</code> if both <code>Tuple</code>s are equal, otherwise <code>false</code>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">Tuple!(int, string) t1 = tuple(1, "test");
Tuple!(double, string) t2 =  tuple(1.0, "test");
//Ok, int can be compared with double and
//both have a value of 1
writeln(t1); // t2
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Tuple.opCmp">int opCmp(R)(R rhs)<br>const int opCmp(R)(R rhs)<br><br>  Constraints:<br>    if (areCompatibleTuples!(typeof(this), R, "    if (areCompatibleTuples!(typeof(this), R, "</dt> <dd>
<p>Comparison for ordering. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>rhs</code>
</td> <td>The <code>Tuple</code> to compare against. It must meet the criteria for comparison between <code>Tuple</code>s.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>For any values <code>v1</code> on the right-hand side and <code>v2</code> on the left-hand side:  <ul> <li>A negative integer if the expression <code>v1 &lt; v2</code> is <code>true</code>.</li> <li>A positive integer if the expression <code>v1 &gt; v2</code> is <code>true</code>.</li> <li>0 if the expression <code>v1 == v2</code> is <code>true</code>.</li>
</ul>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>The first <code>v1</code> for which <code>v1 &gt; v2</code> is <code>true</code> determines the result. This could lead to unexpected behaviour. <pre data-language="d">auto tup1 = tuple(1, 1, 1);
auto tup2 = tuple(1, 100, 100);
assert(tup1 &lt; tup2);

//Only the first result matters for comparison
tup1[0] = 2;
assert(tup1 &gt; tup2);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Tuple.opAssign">void opAssign(R)(auto ref R rhs)<br><br>  Constraints:<br>    if (areCompatibleTuples!(typeof(this), R, "="))</dt> <dd>
<p>Assignment from another <code>Tuple</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>rhs</code>
</td> <td>The source <code>Tuple</code> to assign from. Each element of the source <code>Tuple</code> must be implicitly assignable to each respective element of the target <code>Tuple</code>.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="Tuple.rename">ref return auto rename(names...)()<br><br>  Constraints:<br>    if (names.length == 0 || allSatisfy!(isSomeString, typeof(names)))</dt> <dd>
<p>Renames the elements of a <a href="#Tuple"><code>Tuple</code></a>. </p>
<p><code>rename</code> uses the passed <code>names</code> and returns a new <a href="#Tuple"><code>Tuple</code></a> using these names, with the content unchanged. If fewer names are passed than there are members of the <a href="#Tuple"><code>Tuple</code></a> then those trailing members are unchanged. An empty string will remove the name for that member. It is an compile-time error to pass more names than there are members of the <a href="#Tuple"><code>Tuple</code></a>.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto t0 = tuple(4, "hello");

auto t0Named = t0.rename!("val", "tag");
writeln(t0Named.val); // 4
writeln(t0Named.tag); // "hello"

Tuple!(float, "dat", size_t[2], "pos") t1;
t1.pos = [2, 1];
auto t1Named = t1.rename!"height";
t1Named.height = 3.4f;
writeln(t1Named.height); // 3.4f
writeln(t1Named.pos); // [2, 1]
t1Named.rename!"altitude".altitude = 5;
writeln(t1Named.height); // 5

Tuple!(int, "a", int, int, "c") t2;
t2 = tuple(3,4,5);
auto t2Named = t2.rename!("", "b");
// "a" no longer has a name
static assert(!hasMember!(typeof(t2Named), "a"));
writeln(t2Named[0]); // 3
writeln(t2Named.b); // 4
writeln(t2Named.c); // 5

// not allowed to specify more names than the tuple has members
static assert(!__traits(compiles, t2.rename!("a","b","c","d")));

// use it in a range pipeline
import std.range : iota, zip;
import std.algorithm.iteration : map, sum;
auto res = zip(iota(1, 4), iota(10, 13))
    .map!(t =&gt; t.rename!("a", "b"))
    .map!(t =&gt; t.a * t.b)
    .sum;
writeln(res); // 68
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Tuple.rename.2">ref auto rename(alias translate)()<br><br>  Constraints:<br>    if (is(typeof(translate) : V[K], V, K) &amp;&amp; isSomeString!V &amp;&amp; (isSomeString!K || is(K : size_t)))</dt> <dd>
<p>Overload of <a href="#rename"><code>rename</code></a> that takes an associative array <code>translate</code> as a template parameter, where the keys are either the names or indices of the members to be changed and the new names are the corresponding values. Every key in <code>translate</code> must be the name of a member of the <a href="#tuple"><code>tuple</code></a>. The same rules for empty strings apply as for the variadic template overload of <a href="#rename"><code>rename</code></a>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">//replacing names by their current name

Tuple!(float, "dat", size_t[2], "pos") t1;
t1.pos = [2, 1];
auto t1Named = t1.rename!(["dat": "height"]);
t1Named.height = 3.4;
writeln(t1Named.pos); // [2, 1]
t1Named.rename!(["height": "altitude"]).altitude = 5;
writeln(t1Named.height); // 5

Tuple!(int, "a", int, "b") t2;
t2 = tuple(3, 4);
auto t2Named = t2.rename!(["a": "b", "b": "c"]);
writeln(t2Named.b); // 3
writeln(t2Named.c); // 4
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">//replace names by their position

Tuple!(float, "dat", size_t[2], "pos") t1;
t1.pos = [2, 1];
auto t1Named = t1.rename!([0: "height"]);
t1Named.height = 3.4;
writeln(t1Named.pos); // [2, 1]
t1Named.rename!([0: "altitude"]).altitude = 5;
writeln(t1Named.height); // 5

Tuple!(int, "a", int, "b", int, "c") t2;
t2 = tuple(3, 4, 5);
auto t2Named = t2.rename!([0: "c", 2: "a"]);
writeln(t2Named.a); // 5
writeln(t2Named.b); // 4
writeln(t2Named.c); // 3
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Tuple.slice">inout @property ref @trusted inout(Tuple!(sliceSpecs!(from, to))) slice(size_t from, size_t to)()<br><br>  Constraints:<br>    if (from &lt;= to &amp;&amp; to &lt;= Types.length)</dt> <dd>
<p>Takes a <code>slice</code> by-reference of this <code>Tuple</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>from</td> <td>A <code>size_t</code> designating the starting position of the <code>slice</code>.</td>
</tr> <tr>
<td>to</td> <td>A <code>size_t</code> designating the ending position (exclusive) of the <code>slice</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A new <code>Tuple</code> that is a <code>slice</code> from <code>[from, to)</code> of the original. It has the same types and values as the range <code>[from, to)</code> in the original.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">Tuple!(int, string, float, double) a;
a[1] = "abc";
a[2] = 4.5;
auto s = a.slice!(1, 3);
static assert(is(typeof(s) == Tuple!(string, float)));
assert(s[0] == "abc" &amp;&amp; s[1] == 4.5);

// Phobos issue #15645
Tuple!(int, short, bool, double) b;
static assert(!__traits(compiles, b.slice!(2, 4)));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Tuple.toHash">const nothrow @trusted size_t toHash()</dt> <dd>
<p>Creates a hash of this <code>Tuple</code>. </p>
<dl>
<dt>Returns:</dt>
<dd>A <code>size_t</code> representing the hash of this <code>Tuple</code>.</dd>
</dl> </dd> <dt class="d_decl" id="Tuple.toString">template toString()</dt> <dd> <dl>
<dt class="d_decl" id="Tuple.toString.toString.toString">const string toString()()</dt> <dd>
<p>Converts to string. </p>
<dl>
<dt>Returns:</dt>
<dd>The string representation of this <code>Tuple</code>.</dd>
</dl> </dd> <dt class="d_decl" id="Tuple.toString.toString">const void toString(DG)(scope DG sink)<br>const void toString(DG, Char)(scope DG sink, FormatSpec!Char fmt)</dt> <dd>
<p>Formats <code>Tuple</code> with either <code>%s</code>, <code>%(inner%)</code> or <code>%(inner%|sep%)</code>. </p> <center><table>
<caption>Formats supported by Tuple</caption> <tr>
<th class="donthyphenate"><b>Format</b></th>
<th class="donthyphenate"><b>Description</b></th>
</tr> <tr>
<td><p><code>%s</code></p></td>
<td><p>Format like <code>Tuple!(types)(elements formatted with %s each)</code>.</p></td>
</tr> <tr>
<td><p><code>%(inner%)</code></p></td>
<td><p>The format <code>inner</code> is applied the expanded <code>Tuple</code>, so it may contain as many formats as the <code>Tuple</code> has fields.</p></td>
</tr> <tr>
<td><p><code>%(inner%|sep%)</code></p></td>
<td><p>The format <code>inner</code> is one format, that is applied on all fields of the <code>Tuple</code>. The inner format must be compatible to all of them.</p></td>
</tr>
</table></center> <pre data-language="d"> Tuple!(int, double)[3] tupList = [ tuple(1, 1.0), tuple(2, 4.0), tuple(3, 9.0) ];

 // Default format
 assert(format("%s", tuple("a", 1)) == `Tuple!(string, int)("a", 1)`);

 // One Format for each individual component
 assert(format("%(%#x v %.4f w %#x%)", tuple(1, 1.0, 10))         == `0x1 v 1.0000 w 0xa`);
 assert(format(  "%#x v %.4f w %#x"  , tuple(1, 1.0, 10).expand)  == `0x1 v 1.0000 w 0xa`);

 // One Format for all components
 assert(format("%(&gt;%s&lt;%| &amp; %)", tuple("abc", 1, 2.3, [4, 5])) == `&gt;abc&lt; &amp; &gt;1&lt; &amp; &gt;2.3&lt; &amp; &gt;[4, 5]&lt;`);

 // Array of Tuples
 assert(format("%(%(f(%d) = %.1f%);  %)", tupList) == `f(1) = 1.0;  f(2) = 4.0;  f(3) = 9.0`);


 // Error: %( %) missing.
 assertThrown!FormatException(
     format("%d, %f", tuple(1, 2.0)) == `1, 2.0`
 );

 // Error: %( %| %) missing.
 assertThrown!FormatException(
     format("%d", tuple(1, 2)) == `1, 2`
 );

 // Error: %d inadequate for double.
 assertThrown!FormatException(
     format("%(%d%|, %)", tuple(1, 2.0)) == `1, 2.0`
 );
</pre>  </dd> </dl> </dd> </dl> </dd> <dt class="d_decl" id="reverse">auto reverse(T)(T t)<br><br>  Constraints:<br>    if (isTuple!T)</dt> <dd>
<p>Creates a copy of a <a href="#Tuple"><code>Tuple</code></a> with its fields in reverse order. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T <code>t</code>
</td> <td>The <code>Tuple</code> to copy.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A new <code>Tuple</code>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto tup = tuple(1, "2");
writeln(tup.reverse); // tuple("2", 1)
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="tuple">template tuple(Names...)</dt> <dd>
<p>Constructs a <a href="#Tuple"><code>Tuple</code></a> object instantiated and initialized according to the given arguments. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Names</td> <td>An optional list of strings naming each successive field of the <code>Tuple</code>. Each name matches up with the corresponding field given by <code>Args</code>. A name does not have to be provided for every field, but as the names must proceed in order, it is not possible to skip one field and name the next after it.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto value = tuple(5, 6.7, "hello");
writeln(value[0]); // 5
writeln(value[1]); // 6.7
writeln(value[2]); // "hello"

// Field names can be provided.
auto entry = tuple!("index", "value")(4, "Hello");
writeln(entry.index); // 4
writeln(entry.value); // "Hello"
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="tuple.tuple">auto tuple(Args...)(Args args)</dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Args <code>args</code>
</td> <td>Values to initialize the <code>Tuple</code> with. The <code>Tuple</code>'s type will be inferred from the types of the values given.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A new <code>Tuple</code> with its type inferred from the arguments given.</dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="isTuple">enum auto isTuple(T)</dt> <dd>
<p>Returns <code>true</code> if and only if <code>T</code> is an instance of <code>std.typecons.Tuple</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T</td> <td>The type to check.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>true</code> if <code>T</code> is a <code>Tuple</code> type, <code>false</code> otherwise.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert(isTuple!(Tuple!()));
static assert(isTuple!(Tuple!(int)));
static assert(isTuple!(Tuple!(int, real, string)));
static assert(isTuple!(Tuple!(int, "x", real, "y")));
static assert(isTuple!(Tuple!(int, Tuple!(real), string)));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Rebindable">template Rebindable(T) if (is(T == class) || is(T == interface) || isDynamicArray!T || isAssociativeArray!T)</dt> <dd>
<p><code>Rebindable!(T)</code> is a simple, efficient wrapper that behaves just like an object of type <code>T</code>, except that you can reassign it to refer to another object. For completeness, <code>Rebindable!(T)</code> aliases itself away to <code>T</code> if <code>T</code> is a non-const object type. </p>
<p>You may want to use <code>Rebindable</code> when you want to have mutable storage referring to <code>const</code> objects, for example an array of references that must be sorted in place. <code>Rebindable</code> does not break the soundness of D's type system and does not incur any of the risks usually associated with <code>cast</code>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T</td> <td>An object, interface, array slice type, or associative array type.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Regular <code>const</code> object references cannot be reassigned. <pre data-language="d">class Widget { int x; int y() const { return x; } }
const a = new Widget;
// Fine
a.y();
// error! can't modify const a
// a.x = 5;
// error! can't modify const a
// a = new Widget;
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>However, <code>Rebindable!(Widget)</code> does allow reassignment, while otherwise behaving exactly like a <code>const Widget</code>. <pre data-language="d">class Widget { int x; int y() const { return x; } }
auto a = Rebindable!(const Widget)(new Widget);
// Fine
a.y();
// error! can't modify const a
// a.x = 5;
// Fine
a = new Widget;
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="rebindable">Rebindable!T rebindable(T)(T obj)<br><br>  Constraints:<br>    if (is(T == class) || is(T == interface) || isDynamicArray!T || isAssociativeArray!T)</dt> <dd>
<p>Convenience function for creating a <code>Rebindable</code> using automatic type inference. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T <code>obj</code>
</td> <td>A reference to an object, interface, associative array, or an array slice to initialize the <code>Rebindable</code> with.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A newly constructed <code>Rebindable</code> initialized with the given reference.</dd>
</dl> </dd> <dt class="d_decl" id="rebindable.2">Rebindable!T rebindable(T)(Rebindable!T obj)</dt> <dd>
<p>This function simply returns the <code>Rebindable</code> object passed in. It's useful in generic programming cases when a given object may be either a regular <code>class</code> or a <code>Rebindable</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Rebindable!T <code>obj</code>
</td> <td>An instance of Rebindable!T.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>obj</code> without any modification.</dd>
</dl> </dd> <dt class="d_decl" id="UnqualRef">template UnqualRef(T) if (is(T == class) || is(T == interface))</dt> <dd>
<p>Similar to <code>Rebindable!(T)</code> but strips all qualifiers from the reference as opposed to just constness / immutability. Primary intended use case is with shared (having thread-local reference to shared class data) </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T</td> <td>A class or interface type.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">class Data {}

static shared(Data) a;
static UnqualRef!(shared Data) b;

import core.thread;

auto thread = new core.thread.Thread({
    a = new shared Data();
    b = new shared Data();
});

thread.start();
thread.join();

assert(a !is null);
assert(b is null);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="alignForSize">string alignForSize(E...)(const char[][] names...)</dt> <dd>
<p>Order the provided members to minimize size while preserving alignment. Alignment is not always optimal for 80-bit reals, nor for structs declared as align(1). </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>E</td> <td>A list of the types to be aligned, representing fields of an aggregate such as a <code>struct</code> or <code>class</code>.</td>
</tr> <tr>
<td>char[][] <code>names</code>
</td> <td>The <code>names</code> of the fields that are to be aligned.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A string to be mixed in to an aggregate, such as a <code>struct</code> or <code>class</code>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">struct Banner {
    mixin(alignForSize!(byte[6], double)(["name", "height"]));
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Nullable">struct Nullable(T)<br>auto nullable(T)(T t)</dt> <dd>
<p>Defines a value paired with a distinctive "<code>null</code>" state that denotes the absence of a value. If default constructed, a <code>Nullable!T</code> object starts in the <code>null</code> state. Assigning it renders it non-<code>null</code>. Calling <code>nullify</code> can nullify it again. </p>
<p>Practically <code>Nullable!T</code> stores a <code>T</code> and a <code>bool</code>.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">struct CustomerRecord
{
    string name;
    string address;
    int customerNum;
}

Nullable!CustomerRecord getByName(string name)
{
    //A bunch of hairy stuff

    return Nullable!CustomerRecord.init;
}

auto queryResult = getByName("Doe, John");
if (!queryResult.isNull)
{
    //Process Mr. Doe's customer record
    auto address = queryResult.address;
    auto customerNum = queryResult.customerNum;

    //Do some things with this customer's info
}
else
{
    //Add the customer to the database
}
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.exception : assertThrown;

auto a = 42.nullable;
assert(!a.isNull);
writeln(a.get); // 42

a.nullify();
assert(a.isNull);
assertThrown!Throwable(a.get);
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="Nullable.this">inout this(inout T value)</dt> <dd>
<p>Constructor initializing <code>this</code> with <code>value</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T <code>value</code>
</td> <td>The <code>value</code> to initialize this <code>Nullable</code> with.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="Nullable.opEquals">const bool opEquals()(auto ref const(typeof(this)) rhs)<br>const bool opEquals(U)(auto ref const(U) rhs)<br><br>  Constraints:<br>    if (is(typeof(this.get == rhs)))</dt> <dd>
<p>If they are both <code>null</code>, then they are equal. If one is <code>null</code> and the other is not, then they are not equal. If they are both non-<code>null</code>, then they are equal if their values are equal.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">Nullable!int empty;
Nullable!int a = 42;
Nullable!int b = 42;
Nullable!int c = 27;

writeln(empty); // empty
writeln(empty); // Nullable!int.init
assert(empty != a);
assert(empty != b);
assert(empty != c);

writeln(a); // b
assert(a != c);

assert(empty != 42);
writeln(a); // 42
assert(c != 42);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Nullable.isNull">const pure nothrow @property @safe bool isNull()</dt> <dd>
<p>Check if <code>this</code> is in the <code>null</code> state. </p>
<dl>
<dt>Returns:</dt>
<dd>
<code>true</code> <b>iff</b> <code>this</code> is in the <code>null</code> state, otherwise <code>false</code>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">Nullable!int ni;
assert(ni.isNull);

ni = 0;
assert(!ni.isNull);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Nullable.nullify">void nullify()()</dt> <dd>
<p>Forces <code>this</code> to the <code>null</code> state.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">Nullable!int ni = 0;
assert(!ni.isNull);

ni.nullify();
assert(ni.isNull);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Nullable.opAssign">void opAssign()(T value)</dt> <dd>
<p>Assigns <code>value</code> to the internally-held state. If the assignment succeeds, <code>this</code> becomes non-<code>null</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T <code>value</code>
</td> <td>A <code>value</code> of type <code>T</code> to assign to this <code>Nullable</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>If this <code>Nullable</code> wraps a type that already has a <code>null</code> <code>value</code> (such as a pointer), then assigning the <code>null</code> <code>value</code> to this <code>Nullable</code> is no different than assigning any other <code>value</code> of type <code>T</code>, and the resulting code will look very strange. It is strongly recommended that this be avoided by instead using the version of <code>Nullable</code> that takes an additional <code>nullValue</code> template argument. <pre data-language="d">//Passes
Nullable!(int*) npi;
assert(npi.isNull);

//Passes?!
npi = null;
assert(!npi.isNull);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Nullable.get">inout pure nothrow @property ref @safe inout(T) get()</dt> <dd>
<p>Gets the value. <code>this</code> must not be in the <code>null</code> state. This function is also called for the implicit conversion to <code>T</code>. </p>
<dl>
<dt>Returns:</dt>
<dd>The value held internally by this <code>Nullable</code>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import core.exception : AssertError;
import std.exception : assertThrown, assertNotThrown;

Nullable!int ni;
int i = 42;
//`get` is implicitly called. Will throw
//an AssertError in non-release mode
assertThrown!AssertError(i = ni);
writeln(i); // 42

ni = 5;
assertNotThrown!AssertError(i = ni);
writeln(i); // 5
</pre> </dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="Nullable.2">struct Nullable(T, T nullValue)<br>auto nullable(alias nullValue, T)(T t)<br><br>  Constraints:<br>    if (is(typeof(nullValue) == T))</dt> <dd>
<p>Just like <code>Nullable!T</code>, except that the <code>null</code> state is defined as a particular value. For example, <code>Nullable!(uint, uint.max)</code> is an <code>uint</code> that sets aside the value <code>uint.max</code> to denote a <code>null</code> state. <code>Nullable!(T, nullValue)</code> is more storage-efficient than <code>Nullable!T</code> because it does not need to store an extra <code>bool</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T</td> <td>The wrapped type for which <code>Nullable</code> provides a <code>null</code> value.</td>
</tr> <tr>
<td>nullValue</td> <td>The <code>null</code> value which denotes the <code>null</code> state of this <code>Nullable</code>. Must be of type <code>T</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">Nullable!(size_t, size_t.max) indexOf(string[] haystack, string needle)
{
    //Find the needle, returning -1 if not found

    return Nullable!(size_t, size_t.max).init;
}

void sendLunchInvite(string name)
{
}

//It's safer than C...
auto coworkers = ["Jane", "Jim", "Marry", "Fred"];
auto pos = indexOf(coworkers, "Bob");
if (!pos.isNull)
{
    //Send Bob an invitation to lunch
    sendLunchInvite(coworkers[pos]);
}
else
{
    //Bob not found; report the error
}

//And there's no overhead
static assert(Nullable!(size_t, size_t.max).sizeof == size_t.sizeof);
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.exception : assertThrown;

Nullable!(int, int.min) a;
assert(a.isNull);
assertThrown!Throwable(a.get);
a = 5;
assert(!a.isNull);
writeln(a); // 5
static assert(a.sizeof == int.sizeof);
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto a = nullable!(int.min)(8);
writeln(a); // 8
a.nullify();
assert(a.isNull);
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="Nullable.this.2">this(T value)</dt> <dd>
<p>Constructor initializing <code>this</code> with <code>value</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T <code>value</code>
</td> <td>The <code>value</code> to initialize this <code>Nullable</code> with.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="Nullable.isNull.2">const @property bool isNull()</dt> <dd>
<p>Check if <code>this</code> is in the <code>null</code> state. </p>
<dl>
<dt>Returns:</dt>
<dd>
<code>true</code> <b>iff</b> <code>this</code> is in the <code>null</code> state, otherwise <code>false</code>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">Nullable!(int, -1) ni;
//Initialized to "null" state
assert(ni.isNull);

ni = 0;
assert(!ni.isNull);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Nullable.nullify.2">void nullify()()</dt> <dd>
<p>Forces <code>this</code> to the <code>null</code> state.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">Nullable!(int, -1) ni = 0;
assert(!ni.isNull);

ni = -1;
assert(ni.isNull);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Nullable.opAssign.2">void opAssign()(T value)</dt> <dd>
<p>Assigns <code>value</code> to the internally-held state. If the assignment succeeds, <code>this</code> becomes non-<code>null</code>. No <code>null</code> checks are made. Note that the assignment may leave <code>this</code> in the <code>null</code> state. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T <code>value</code>
</td> <td>A <code>value</code> of type <code>T</code> to assign to this <code>Nullable</code>. If it is <code>nullvalue</code>, then the internal state of this <code>Nullable</code> will be set to <code>null</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>If this <code>Nullable</code> wraps a type that already has a <code>null</code> <code>value</code> (such as a pointer), and that <code>null</code> <code>value</code> is not given for <code>nullValue</code>, then assigning the <code>null</code> <code>value</code> to this <code>Nullable</code> is no different than assigning any other <code>value</code> of type <code>T</code>, and the resulting code will look very strange. It is strongly recommended that this be avoided by using <code>T</code>'s "built in" <code>null</code> <code>value</code> for <code>nullValue</code>. <pre data-language="d">//Passes
enum nullVal = cast(int*) 0xCAFEBABE;
Nullable!(int*, nullVal) npi;
assert(npi.isNull);

//Passes?!
npi = null;
assert(!npi.isNull);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Nullable.get.2">inout @property ref inout(T) get()</dt> <dd>
<p>Gets the value. <code>this</code> must not be in the <code>null</code> state. This function is also called for the implicit conversion to <code>T</code>. </p>
<dl>
<dt>Returns:</dt>
<dd>The value held internally by this <code>Nullable</code>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.exception : assertThrown, assertNotThrown;

Nullable!(int, -1) ni;
//`get` is implicitly called. Will throw
//an error in non-release mode
assertThrown!Throwable(ni == 0);

ni = 0;
assertNotThrown!Throwable(ni == 0);
</pre> </dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="NullableRef">struct NullableRef(T)<br>auto nullableRef(T)(T* t)</dt> <dd>
<p>Just like <code>Nullable!T</code>, except that the object refers to a value sitting elsewhere in memory. This makes assignments overwrite the initially assigned value. Internally <code>NullableRef!T</code> only stores a pointer to <code>T</code> (i.e., <code>Nullable!T.sizeof == (T*).sizeof</code>).</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.exception : assertThrown;

int x = 5, y = 7;
auto a = nullableRef(&amp;x);
assert(!a.isNull);
writeln(a); // 5
writeln(x); // 5
a = 42;
writeln(x); // 42
assert(!a.isNull);
writeln(a); // 42
a.nullify();
writeln(x); // 42
assert(a.isNull);
assertThrown!Throwable(a.get);
assertThrown!Throwable(a = 71);
a.bind(&amp;y);
writeln(a); // 7
y = 135;
writeln(a); // 135
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="NullableRef.this">pure nothrow @safe this(T* value)</dt> <dd>
<p>Constructor binding <code>this</code> to <code>value</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T* <code>value</code>
</td> <td>The <code>value</code> to bind to.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="NullableRef.bind">pure nothrow @safe void bind(T* value)</dt> <dd>
<p>Binds the internal state to <code>value</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T* <code>value</code>
</td> <td>A pointer to a <code>value</code> of type <code>T</code> to <code>bind</code> this <code>NullableRef</code> to.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">NullableRef!int nr = new int(42);
writeln(nr); // 42

int* n = new int(1);
nr.bind(n);
writeln(nr); // 1
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="NullableRef.isNull">const pure nothrow @property @safe bool isNull()</dt> <dd>
<p>Returns <code>true</code> if and only if <code>this</code> is in the <code>null</code> state. </p>
<dl>
<dt>Returns:</dt>
<dd>
<code>true</code> if <code>this</code> is in the <code>null</code> state, otherwise <code>false</code>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">NullableRef!int nr;
assert(nr.isNull);

int* n = new int(42);
nr.bind(n);
assert(!nr.isNull &amp;&amp; nr == 42);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="NullableRef.nullify">pure nothrow @safe void nullify()</dt> <dd>
<p>Forces <code>this</code> to the <code>null</code> state.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">NullableRef!int nr = new int(42);
assert(!nr.isNull);

nr.nullify();
assert(nr.isNull);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="NullableRef.opAssign">void opAssign()(T value)<br><br>  Constraints:<br>    if (isAssignable!T)</dt> <dd>
<p>Assigns <code>value</code> to the internally-held state. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T <code>value</code>
</td> <td>A <code>value</code> of type <code>T</code> to assign to this <code>NullableRef</code>. If the internal state of this <code>NullableRef</code> has not been initialized, an error will be thrown in non-release mode.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.exception : assertThrown, assertNotThrown;

NullableRef!int nr;
assert(nr.isNull);
assertThrown!Throwable(nr = 42);

nr.bind(new int(0));
assert(!nr.isNull);
assertNotThrown!Throwable(nr = 42);
writeln(nr); // 42
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="NullableRef.get">inout pure nothrow @property ref @safe inout(T) get()</dt> <dd>
<p>Gets the value. <code>this</code> must not be in the <code>null</code> state. This function is also called for the implicit conversion to <code>T</code>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.exception : assertThrown, assertNotThrown;

NullableRef!int nr;
//`get` is implicitly called. Will throw
//an error in non-release mode
assertThrown!Throwable(nr == 0);

nr.bind(new int(0));
assertNotThrown!Throwable(nr == 0);
</pre> </dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="BlackHole">template BlackHole(Base)</dt> <dd>
<p><code>BlackHole!Base</code> is a subclass of <code>Base</code> which automatically implements all abstract member functions in <code>Base</code> as do-nothing functions. Each auto-implemented function just returns the default value of the return type without doing anything. </p>
<p>The name came from <a href="http://search.cpan.org/~sburke/Class-BlackHole-0.04/lib/Class/BlackHole.pm" target="_blank">Class::BlackHole</a> Perl module by Sean M. Burke. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Base</td> <td>A non-final class for <code>BlackHole</code> to inherit from.</td>
</tr> </table></dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="#AutoImplement"><code>AutoImplement</code></a>, <a href="#generateEmptyFunction"><code>generateEmptyFunction</code></a>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.math : isNaN;

static abstract class C
{
    int m_value;
    this(int v) { m_value = v; }
    int value() @property { return m_value; }

    abstract real realValue() @property;
    abstract void doSomething();
}

auto c = new BlackHole!C(42);
writeln(c.value); // 42

// Returns real.init which is NaN
assert(c.realValue.isNaN);
// Abstract functions are implemented as do-nothing
c.doSomething();
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="WhiteHole">template WhiteHole(Base)</dt> <dd>
<p><code>WhiteHole!Base</code> is a subclass of <code>Base</code> which automatically implements all abstract member functions as functions that always fail. These functions simply throw an <code>Error</code> and never return. <code>Whitehole</code> is useful for trapping the use of class member functions that haven't been implemented. </p>
<p>The name came from <a href="http://search.cpan.org/~mschwern/Class-WhiteHole-0.04/lib/Class/WhiteHole.pm" target="_blank">Class::WhiteHole</a> Perl module by Michael G Schwern. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Base</td> <td>A non-final class for <code>WhiteHole</code> to inherit from.</td>
</tr> </table></dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="#AutoImplement"><code>AutoImplement</code></a>, <a href="#generateAssertTrap"><code>generateAssertTrap</code></a>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.exception : assertThrown;

static class C
{
    abstract void notYetImplemented();
}

auto c = new WhiteHole!C;
assertThrown!NotImplementedError(c.notYetImplemented()); // throws an Error
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="AutoImplement">class AutoImplement(Base, alias how, alias what = isAbstractFunction) if (!is(how == class)): Base<br>class AutoImplement(Interface, BaseClass, alias how, alias what = isAbstractFunction) if (is(Interface == interface) &amp;amp<br>&amp;amp<br>is(BaseClass == class)): BaseClass, Interface</dt> <dd>
<p><code>AutoImplement</code> automatically implements (by default) all abstract member functions in the class or interface <code>Base</code> in specified way. </p>
<p>The second version of <code>AutoImplement</code> automatically implements <code>Interface</code>, while deriving from <code>BaseClass</code>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>how</td> <td>template which specifies how functions will be implemented/overridden.  Two arguments are passed to <code>how</code>: the type <code>Base</code> and an alias to an implemented function. Then <code>how</code> must return an implemented function body as a string.  The generated function body can use these keywords: <ul> <li>
<code>a0</code>, <code>a1</code>, …: arguments passed to the function;</li> <li>
<code>args</code>: a tuple of the arguments;</li> <li>
<code>self</code>: an alias to the function itself;</li> <li>
<code>parent</code>: an alias to the overridden function (if any).</li> </ul>  You may want to use templated property functions (instead of Implicit Template Properties) to generate complex functions: <pre data-language="d">// Prints log messages for each call to overridden functions.
string generateLogger(C, alias fun)() @property
{
    import std.traits;
    enum qname = C.stringof ~ "." ~ __traits(identifier, fun);
    string stmt;

    stmt ~= q{ struct Importer { import std.stdio; } };
    stmt ~= `Importer.writeln("Log: ` ~ qname ~ `(", args, ")");`;
    static if (!__traits(isAbstractFunction, fun))
    {
        static if (is(ReturnType!fun == void))
            stmt ~= q{ parent(args); };
        else
            stmt ~= q{
                auto r = parent(args);
                Importer.writeln("--&gt; ", r);
                return r;
            };
    }
    return stmt;
}
</pre> </td>
</tr> <tr>
<td>what</td> <td>template which determines what functions should be implemented/overridden.  An argument is passed to <code>what</code>: an alias to a non-final member function in <code>Base</code>. Then <code>what</code> must return a boolean value. Return <code>true</code> to indicate that the passed function should be implemented/overridden.  <pre data-language="d">// Sees if fun returns something.
enum bool hasValue(alias fun) = !is(ReturnType!(fun) == void);
</pre> </td>
</tr> </table></dd>
</dl> <dl>
<dt>Note</dt>
<dd> Generated code is inserted in the scope of <code>std.typecons</code> module. Thus, any useful functions outside <code>std.typecons</code> cannot be used in the generated code. To workaround this problem, you may <code>import</code> necessary things in a local struct, as done in the <code>generateLogger()</code> template in the above example. </dd>
</dl>  <dl>
<dt>Bugs:</dt>
<dd><ul> <li>Variadic arguments to constructors are not forwarded to super.</li> <li>Deep interface inheritance causes compile error with messages like "Error: function std.typecons.AutoImplement!(Foo).AutoImplement.bar does not override any function". [<span class="bugzilla"><a class="https" href="https://issues.dlang.org/show_bug.cgi?id=2525" target="_blank">Bugzilla 2525</a></span>, <span class="bugzilla"><a class="https" href="https://issues.dlang.org/show_bug.cgi?id=3525" target="_blank">Bugzilla 3525</a></span>] </li> <li>The <code>parent</code> keyword is actually a delegate to the super class' corresponding member function. [<span class="bugzilla"><a class="https" href="https://issues.dlang.org/show_bug.cgi?id=2540" target="_blank">Bugzilla 2540</a></span>] </li> <li>Using alias template parameter in <code>how</code> and/or <code>what</code> may cause strange compile error. Use template tuple parameter instead to workaround this problem. [<span class="bugzilla"><a class="https" href="https://issues.dlang.org/show_bug.cgi?id=4217" target="_blank">Bugzilla 4217</a></span>] </li> </ul></dd>
</dl> </dd> <dt class="d_decl" id="generateEmptyFunction">template generateEmptyFunction(C, func...)enum string generateAssertTrap(C, func...)</dt> <dd>
<p>Predefined how-policies for <code>AutoImplement</code>. These templates are also used by <code>BlackHole</code> and <code>WhiteHole</code>, respectively.</p> </dd> <dt class="d_decl" id="wrap">template wrap(Targets...) if (Targets.length &amp;gt<br>= 1 &amp;amp<br>&amp;amp<br>allSatisfy!(isMutable, Targets))template wrap(Targets...) if (Targets.length &amp;gt<br>= 1 &amp;amp<br>&amp;amp<br>!allSatisfy!(isMutable, Targets))</dt> <dd>
<p>Supports structural based typesafe conversion. </p>
<p>If <code>Source</code> has structural conformance with the <code>interface</code> <code>Targets</code>, <code>wrap</code> creates internal wrapper class which inherits <code>Targets</code> and <code>wrap</code> <code>src</code> object, then return it.</p> </dd> <dt class="d_decl" id="unwrap">template unwrap(Target) if (isMutable!Target)template unwrap(Target) if (!isMutable!Target)</dt> <dd>
<p>Extract object which wrapped by <code>wrap</code>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">interface Quack
{
    int quack();
    @property int height();
}
interface Flyer
{
    @property int height();
}
class Duck : Quack
{
    int quack() { return 1; }
    @property int height() { return 10; }
}
class Human
{
    int quack() { return 2; }
    @property int height() { return 20; }
}

Duck d1 = new Duck();
Human h1 = new Human();

interface Refleshable
{
    int reflesh();
}
// does not have structural conformance
static assert(!__traits(compiles, d1.wrap!Refleshable));
static assert(!__traits(compiles, h1.wrap!Refleshable));

// strict upcast
Quack qd = d1.wrap!Quack;
assert(qd is d1);
assert(qd.quack() == 1);    // calls Duck.quack
// strict downcast
Duck d2 = qd.unwrap!Duck;
assert(d2 is d1);

// structural upcast
Quack qh = h1.wrap!Quack;
assert(qh.quack() == 2);    // calls Human.quack
// structural downcast
Human h2 = qh.unwrap!Human;
assert(h2 is h1);

// structural upcast (two steps)
Quack qx = h1.wrap!Quack;   // Human -&gt; Quack
Flyer fx = qx.wrap!Flyer;   // Quack -&gt; Flyer
assert(fx.height == 20);    // calls Human.height
// strucural downcast (two steps)
Quack qy = fx.unwrap!Quack; // Flyer -&gt; Quack
Human hy = qy.unwrap!Human; // Quack -&gt; Human
assert(hy is h1);
// strucural downcast (one step)
Human hz = fx.unwrap!Human; // Flyer -&gt; Human
assert(hz is h1);
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.traits : FunctionAttribute, functionAttributes;
interface A { int run(); }
interface B { int stop(); @property int status(); }
class X
{
    int run() { return 1; }
    int stop() { return 2; }
    @property int status() { return 3; }
}

auto x = new X();
auto ab = x.wrap!(A, B);
A a = ab;
B b = ab;
writeln(a.run()); // 1
writeln(b.stop()); // 2
writeln(b.status); // 3
static assert(functionAttributes!(typeof(ab).status) &amp; FunctionAttribute.property);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="RefCountedAutoInitialize">enum RefCountedAutoInitialize: int</dt> <dd>
<p>Options regarding auto-initialization of a <code>RefCounted</code> object (see the definition of <code>RefCounted</code> below).</p> <dl>
<dt class="d_decl" id="RefCountedAutoInitialize.no">no</dt> <dd>
<p>Do not auto-initialize the object</p> </dd> <dt class="d_decl" id="RefCountedAutoInitialize.yes">yes</dt> <dd>
<p>Auto-initialize the object</p> </dd> </dl> </dd> <dt class="d_decl" id="RefCounted">struct RefCounted(T, RefCountedAutoInitialize autoInit = RefCountedAutoInitialize.yes) if (!is(T == class) &amp;amp<br>&amp;amp<br>!is(T == interface))</dt> <dd>
<p>Defines a reference-counted object containing a <code>T</code> value as payload. </p>
<p>An instance of <code>RefCounted</code> is a reference to a structure, which is referred to as the <i>store</i>, or <i>storage implementation struct</i> in this documentation. The store contains a reference count and the <code>T</code> payload. <code>RefCounted</code> uses <code>malloc</code> to allocate the store. As instances of <code>RefCounted</code> are copied or go out of scope, they will automatically increment or decrement the reference count. When the reference count goes down to zero, <code>RefCounted</code> will call <code>destroy</code> against the payload and call <code>free</code> to deallocate the store. If the <code>T</code> payload contains any references to GC-allocated memory, then <code>RefCounted</code> will add it to the GC memory that is scanned for pointers, and remove it from GC scanning before <code>free</code> is called on the store. <br><br> One important consequence of <code>destroy</code> is that it will call the destructor of the <code>T</code> payload. GC-managed references are not guaranteed to be valid during a destructor call, but other members of <code>T</code>, such as file handles or pointers to <code>malloc</code> memory, will still be valid during the destructor call. This allows the <code>T</code> to deallocate or clean up any non-GC resources immediately after the reference count has reached zero. <br><br> <code>RefCounted</code> is unsafe and should be used with care. No references to the payload should be escaped outside the <code>RefCounted</code> object. <br><br> The <code>autoInit</code> option makes the object ensure the store is automatically initialized. Leaving <code>autoInit == RefCountedAutoInitialize.yes</code> (the default option) is convenient but has the cost of a test whenever the payload is accessed. If <code>autoInit == RefCountedAutoInitialize.no</code>, user code must call either <code>refCountedStore.isInitialized</code> or <code>refCountedStore.ensureInitialized</code> before attempting to access the payload. Not doing so results in <code>null</code> pointer dereference.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">// A pair of an `int` and a `size_t` - the latter being the
// reference count - will be dynamically allocated
auto rc1 = RefCounted!int(5);
writeln(rc1); // 5
// No more allocation, add just one extra reference count
auto rc2 = rc1;
// Reference semantics
rc2 = 42;
writeln(rc1); // 42
// the pair will be freed when rc1 and rc2 go out of scope
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="RefCounted.RefCountedStore">struct RefCountedStore</dt> <dd>
<p><code>RefCounted</code> storage implementation.</p> <dl>
<dt class="d_decl" id="RefCounted.RefCountedStore.isInitialized">const pure nothrow @nogc @property @safe bool isInitialized()</dt> <dd>
<p>Returns <code>true</code> if and only if the underlying store has been allocated and initialized.</p> </dd> <dt class="d_decl" id="RefCounted.RefCountedStore.refCount">const pure nothrow @nogc @property @safe size_t refCount()</dt> <dd>
<p>Returns underlying reference count if it is allocated and initialized (a positive integer), and <code>0</code> otherwise.</p> </dd> <dt class="d_decl" id="RefCounted.RefCountedStore.ensureInitialized">void ensureInitialized()</dt> <dd>
<p>Makes sure the payload was properly initialized. Such a call is typically inserted before using the payload.</p> </dd> </dl> </dd> <dt class="d_decl" id="RefCounted.refCountedStore">inout nothrow @property ref @safe inout(RefCountedStore) refCountedStore()</dt> <dd>
<p>Returns storage implementation struct.</p> </dd> <dt class="d_decl" id="RefCounted.this">this(A...)(auto ref A args)<br>this(T val)<br><br>  Constraints:<br>    if (A.length &gt; 0)</dt> <dd>
<p>Constructor that initializes the payload. </p>
<dl>
<dt>Postcondition</dt>
<dd> <code>refCountedStore.isInitialized</code>
</dd>
</dl> </dd> <dt class="d_decl" id="RefCounted.opAssign">void opAssign(typeof(this) rhs)<br>void opAssign(T rhs)</dt> <dd>
<p>Assignment operators</p> </dd> <dt class="d_decl" id="RefCounted.refCountedPayload">@property ref return T refCountedPayload()<br>inout pure nothrow @nogc @property ref return @safe inout(T) refCountedPayload()</dt> <dd>
<p>Returns a reference to the payload. If (autoInit == RefCountedAutoInitialize.yes), calls <code> refCountedStore.ensureInitialized</code>. Otherwise, just issues <code> assert(refCountedStore.isInitialized)</code>. Used with <code>alias refCountedPayload this;</code>, so callers can just use the <code>RefCounted</code> object as a <code>T</code>. </p>
<p><span class="blue">The first overload exists only if <code>autoInit == RefCountedAutoInitialize.yes</code>.</span> So if <code>autoInit == RefCountedAutoInitialize.no</code> or called for a constant or immutable object, then <code>refCountedPayload</code> will also be qualified as safe and nothrow (but will still assert if not initialized).</p> </dd> </dl> </dd> <dt class="d_decl" id="refCounted">RefCounted!(T, RefCountedAutoInitialize.no) refCounted(T)(T val)</dt> <dd>
<p>Initializes a <code>RefCounted</code> with <code>val</code>. The template parameter <code>T</code> of <code>RefCounted</code> is inferred from <code>val</code>. This function can be used to move non-copyable values to the heap. It also disables the <code>autoInit</code> option of <code>RefCounted</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T <code>val</code>
</td> <td>The value to be reference counted</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>An initialized <code>RefCounted</code> containing <code>val</code>. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd><a href="http://en.cppreference.com/w/cpp/memory/shared_ptr/make_shared" target="_blank">C++'s make_shared</a></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static struct File
{
    string name;
    @disable this(this); // not copyable
    ~this() { name = null; }
}

auto file = File("name");
writeln(file.name); // "name"
// file cannot be copied and has unique ownership
static assert(!__traits(compiles, {auto file2 = file;}));

// make the file refcounted to share ownership
import std.algorithm.mutation : move;
auto rcFile = refCounted(move(file));
writeln(rcFile.name); // "name"
writeln(file.name); // null
auto rcFile2 = rcFile;
writeln(rcFile.refCountedStore.refCount); // 2
// file gets properly closed when last reference is dropped
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Proxy">template Proxy(alias a)</dt> <dd>
<p>Creates a proxy for the value <code>a</code> that will forward all operations while disabling implicit conversions. The aliased item <code>a</code> must be an <b>lvalue</b>. This is useful for creating a new type from the "base" type (though this is <b>not</b> a subtype-supertype relationship; the new type is not related to the old type in any way, by design). </p>
<p>The new type supports all operations that the underlying type does, including all operators such as <code>+</code>, <code>--</code>, <code>&lt;</code>, <code>[]</code>, etc. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>a</td> <td>The value to act as a proxy for all operations. It must be an lvalue.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">struct MyInt
{
    private int value;
    mixin Proxy!value;

    this(int n){ value = n; }
}

MyInt n = 10;

// Enable operations that original type has.
++n;
writeln(n); // 11
writeln(n * 2); // 22

void func(int n) { }

// Disable implicit conversions to original type.
//int x = n;
//func(n);
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>The proxied value must be an <b>lvalue</b>. <pre data-language="d">struct NewIntType
{
    //Won't work; the literal '1'
    //is an rvalue, not an lvalue
    //mixin Proxy!1;

    //Okay, n is an lvalue
    int n;
    mixin Proxy!n;

    this(int n) { this.n = n; }
}

NewIntType nit = 0;
nit++;
writeln(nit); // 1


struct NewObjectType
{
    Object obj;
    //Ok, obj is an lvalue
    mixin Proxy!obj;

    this (Object o) { obj = o; }
}

NewObjectType not = new Object();
assert(__traits(compiles, not.toHash()));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>There is one exception to the fact that the new type is not related to the old type. <a href="https://dlang.org/spec/function.html#pseudo-member" target="_blank">Pseudo-member</a> functions are usable with the new type; they will be forwarded on to the proxied value. <pre data-language="d">import std.math;

float f = 1.0;
assert(!f.isInfinity);

struct NewFloat
{
    float _;
    mixin Proxy!_;

    this(float f) { _ = f; }
}

NewFloat nf = 1.0f;
assert(!nf.isInfinity);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Typedef">struct Typedef(T, T init = T.init, string cookie = null)</dt> <dd>
<p><b><code>Typedef</code></b> allows the creation of a unique type which is based on an existing type. Unlike the <code>alias</code> feature, <b><code>Typedef</code></b> ensures the two types are not considered as equals. </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">alias MyInt = Typedef!int;
static void takeInt(int) { }
static void takeMyInt(MyInt) { }

int i;
takeInt(i);    // ok
takeMyInt(i);  // fails

MyInt myInt;
takeInt(myInt);    // fails
takeMyInt(myInt);  // ok
</pre>  <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>init</td> <td>Optional initial value for the new type. For example:  <pre data-language="d">alias MyInt = Typedef!(int, 10);
MyInt myInt;
assert(myInt == 10);  // default-initialized to 10
</pre> </td>
</tr> <tr>
<td>cookie</td> <td>Optional, used to create multiple unique types which are based on the same origin type <code>T</code>. For example:  <pre data-language="d">alias TypeInt1 = Typedef!int;
alias TypeInt2 = Typedef!int;

// The two Typedefs are the same type.
static assert(is(TypeInt1 == TypeInt2));

alias MoneyEuros = Typedef!(float, float.init, "euros");
alias MoneyDollars = Typedef!(float, float.init, "dollars");

// The two Typedefs are _not_ the same type.
static assert(!is(MoneyEuros == MoneyDollars));
</pre> </td>
</tr> </table></dd>
</dl> <dl>
<dt>Note</dt>
<dd> If a library routine cannot handle the <code>Typedef</code> type, you can use the <code>TypedefType</code> template to extract the type which the <code>Typedef</code> wraps.</dd>
</dl> </dd> <dt class="d_decl" id="TypedefType">template TypedefType(T)</dt> <dd>
<p>Get the underlying type which a <code>Typedef</code> wraps. If <code>T</code> is not a <code>Typedef</code> it will alias itself to <code>T</code>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.typecons : Typedef, TypedefType;
import std.conv : to;

alias MyInt = Typedef!int;
static assert(is(TypedefType!MyInt == int));

/// Instantiating with a non-Typedef will return that type
static assert(is(TypedefType!int == int));

string num = "5";

// extract the needed type
MyInt myInt = MyInt( num.to!(TypedefType!MyInt) );
writeln(myInt); // 5

// cast to the underlying type to get the value that's being wrapped
int x = cast(TypedefType!MyInt) myInt;

alias MyIntInit = Typedef!(int, 42);
static assert(is(TypedefType!MyIntInit == int));
static assert(MyIntInit() == 42);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="scoped">template scoped(T) if (is(T == class))</dt> <dd>
<p>Allocates a <code>class</code> object right inside the current scope, therefore avoiding the overhead of <code>new</code>. This facility is unsafe; it is the responsibility of the user to not escape a reference to the object outside the scope. </p>
<p>The class destructor will be called when the result of <code>scoped()</code> is itself destroyed. <br><br> Scoped class instances can be embedded in a parent <code>class</code> or <code>struct</code>, just like a child struct instance. Scoped member variables must have type <code>typeof(scoped!Class(args))</code>, and be initialized with a call to <code>scoped</code>. See below for an example. </p> <dl>
<dt>Note</dt>
<dd> It's illegal to move a class instance even if you are sure there are no pointers to it. As such, it is illegal to move a <code>scoped</code> object.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">class A
{
    int x;
    this()     {x = 0;}
    this(int i){x = i;}
    ~this()    {}
}

// Standard usage, constructing A on the stack
auto a1 = scoped!A();
a1.x = 42;

// Result of `scoped` call implicitly converts to a class reference
A aRef = a1;
writeln(aRef.x); // 42

// Scoped destruction
{
    auto a2 = scoped!A(1);
    writeln(a2.x); // 1
    aRef = a2;
    // a2 is destroyed here, calling A's destructor
}
// aRef is now an invalid reference

// Here the temporary scoped A is immediately destroyed.
// This means the reference is then invalid.
version(Bug)
{
    // Wrong, should use `auto`
    A invalid = scoped!A();
}

// Restrictions
version(Bug)
{
    import std.algorithm.mutation : move;
    auto invalid = a1.move; // illegal, scoped objects can't be moved
}
static assert(!is(typeof({
    auto e1 = a1; // illegal, scoped objects can't be copied
    assert([a1][0].x == 42); // ditto
})));
static assert(!is(typeof({
    alias ScopedObject = typeof(a1);
    auto e2 = ScopedObject();  // illegal, must be built via scoped!A
    auto e3 = ScopedObject(1); // ditto
})));

// Use with alias
alias makeScopedA = scoped!A;
auto a3 = makeScopedA();
auto a4 = makeScopedA(1);

// Use as member variable
struct B
{
    typeof(scoped!A()) a; // note the trailing parentheses

    this(int i)
    {
        // construct member
        a = scoped!A(i);
    }
}

// Stack-allocate
auto b1 = B(5);
aRef = b1.a;
writeln(aRef.x); // 5
destroy(b1); // calls A's destructor for b1.a
// aRef is now an invalid reference

// Heap-allocate
auto b2 = new B(6);
writeln(b2.a.x); // 6
destroy(*b2); // calls A's destructor for b2.a
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="scoped.scoped">@system auto scoped(Args...)(auto ref Args args)</dt> <dd>
<p>Returns the scoped object. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Args <code>args</code>
</td> <td>Arguments to pass to <code>T</code>'s constructor.</td>
</tr> </table></dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="Flag">template Flag(string name)</dt> <dd>
<p>Defines a simple, self-documenting yes/no flag. This makes it easy for APIs to define functions accepting flags without resorting to <code>bool</code>, which is opaque in calls, and without needing to define an enumerated type separately. Using <code>Flag!"Name"</code> instead of <code>bool</code> makes the flag's meaning visible in calls. Each yes/no flag has its own type, which makes confusions and mix-ups impossible. </p>
<dl>
<dt>Example</dt>
<dd> Code calling <code>getLine</code> (usually far away from its definition) can't be understood without looking at the documentation, even by users familiar with the API: </dd>
</dl>
<pre data-language="d">string getLine(bool keepTerminator)
{
    ...
    if (keepTerminator) ...
    ...
}
...
auto line = getLine(false);
</pre>  Assuming the reverse meaning (i.e. "ignoreTerminator") and inserting the wrong code compiles and runs with erroneous results.  After replacing the boolean parameter with an instantiation of <code>Flag</code>, code calling <code>getLine</code> can be easily read and understood even by people not fluent with the API:  <pre data-language="d">string getLine(Flag!"keepTerminator" keepTerminator)
{
    ...
    if (keepTerminator) ...
    ...
}
...
auto line = getLine(Yes.keepTerminator);
</pre>  The structs <code>Yes</code> and <code>No</code> are provided as shorthand for <code>Flag!"Name".yes</code> and <code>Flag!"Name".no</code> and are preferred for brevity and readability. These convenience structs mean it is usually unnecessary and counterproductive to create an alias of a <code>Flag</code> as a way of avoiding typing out the full type while specifying the affirmative or negative options.  Passing categorical data by means of unstructured <code>bool</code> parameters is classified under "simple-data coupling" by Steve McConnell in the <a href="https://google.com/search?btnI=I%27m+Feeling+Lucky&amp;ie=UTF-8&amp;oe=UTF-8&amp;q=Code%20Complete" target="_blank">Code Complete</a> book, along with three other kinds of coupling. The author argues citing several studies that coupling has a negative effect on code quality. <code>Flag</code> offers a simple structuring method for passing yes/no flags to APIs. <dl>
<dt class="d_decl" id="Flag.Flag">enum Flag: bool</dt> <dd> <dl>
<dt class="d_decl" id="Flag.Flag.no">no</dt> <dd>
<p>When creating a value of type <code>Flag!"Name"</code>, use <code> Flag!"Name".no</code> for the negative option. When using a value of type <code>Flag!"Name"</code>, compare it against <code> Flag!"Name".no</code> or just <code>false</code> or <code>0</code>.</p> </dd> <dt class="d_decl" id="Flag.Flag.yes">yes</dt> <dd>
<p>When creating a value of type <code>Flag!"Name"</code>, use <code> Flag!"Name".yes</code> for the affirmative option. When using a value of type <code>Flag!"Name"</code>, compare it against <code> Flag!"Name".yes</code>.</p> </dd> </dl> </dd> </dl> </dd> <dt class="d_decl" id="Yes">struct Yes<br>struct No</dt> <dd>
<p>Convenience names that allow using e.g. <code>Yes.encryption</code> instead of <code>Flag!"encryption".yes</code> and <code>No.encryption</code> instead of <code>Flag!"encryption".no</code>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">Flag!"abc" flag1;
writeln(flag1); // Flag!"abc".no
writeln(flag1); // No.abc
assert(!flag1);
if (flag1) assert(false);
flag1 = Yes.abc;
assert(flag1);
if (!flag1) assert(false);
if (flag1) {} else assert(false);
writeln(flag1); // Yes.abc
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isBitFlagEnum">template isBitFlagEnum(E)</dt> <dd>
<p>Detect whether an enum is of integral type and has only "flag" values (i.e. values with a bit count of exactly 1). Additionally, a zero value is allowed for compatibility with enums including a "None" value.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">enum A
{
    None,
    A = 1 &lt;&lt; 0,
    B = 1 &lt;&lt; 1,
    C = 1 &lt;&lt; 2,
    D = 1 &lt;&lt; 3,
}

static assert(isBitFlagEnum!A);

enum B
{
    A,
    B,
    C,
    D // D == 3
}

static assert(!isBitFlagEnum!B);

enum C: double
{
    A = 1 &lt;&lt; 0,
    B = 1 &lt;&lt; 1
}

static assert(!isBitFlagEnum!C);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="BitFlags">struct BitFlags(E, Flag!"unsafe" unsafe = No.unsafe) if (unsafe || isBitFlagEnum!E)</dt> <dd>
<p>A typesafe structure for storing combinations of enum values. </p>
<p>This template defines a simple struct to represent bitwise OR combinations of enum values. It can be used if all the enum values are integral constants with a bit count of at most 1, or if the <code>unsafe</code> parameter is explicitly set to Yes. This is much safer than using the enum itself to store the OR combination, which can produce surprising effects like this: </p>
<pre data-language="d">enum E
{
    A = 1 &lt;&lt; 0,
    B = 1 &lt;&lt; 1
}
E e = E.A | E.B;
// will throw SwitchError
final switch (e)
{
    case E.A:
        return;
    case E.B:
        return;
}
</pre>  <dl>
<dt>Examples:</dt>
<dd>
<code>BitFlags</code> can be manipulated with the usual operators <pre data-language="d">import std.traits : EnumMembers;

// You can use such an enum with BitFlags straight away
enum Enum
{
    None,
    A = 1 &lt;&lt; 0,
    B = 1 &lt;&lt; 1,
    C = 1 &lt;&lt; 2
}
BitFlags!Enum flags1;
assert(!(flags1 &amp; (Enum.A | Enum.B | Enum.C)));

// You need to specify the `unsafe` parameter for enum with custom values
enum UnsafeEnum
{
    A,
    B,
    C,
    D = B|C
}
static assert(!__traits(compiles, { BitFlags!UnsafeEnum flags2; }));
BitFlags!(UnsafeEnum, Yes.unsafe) flags3;

immutable BitFlags!Enum flags_empty;
// A default constructed BitFlags has no value set
assert(!(flags_empty &amp; Enum.A) &amp;&amp; !(flags_empty &amp; Enum.B) &amp;&amp; !(flags_empty &amp; Enum.C));

// Value can be set with the | operator
immutable BitFlags!Enum flags_A = flags_empty | Enum.A;

// And tested with the &amp; operator
assert(flags_A &amp; Enum.A);

// Which commutes
assert(Enum.A &amp; flags_A);

// BitFlags can be variadically initialized
immutable BitFlags!Enum flags_AB = BitFlags!Enum(Enum.A, Enum.B);
assert((flags_AB &amp; Enum.A) &amp;&amp; (flags_AB &amp; Enum.B) &amp;&amp; !(flags_AB &amp; Enum.C));

// Use the ~ operator for subtracting flags
immutable BitFlags!Enum flags_B = flags_AB &amp; ~BitFlags!Enum(Enum.A);
assert(!(flags_B &amp; Enum.A) &amp;&amp; (flags_B &amp; Enum.B) &amp;&amp; !(flags_B &amp; Enum.C));

// You can use the EnumMembers template to set all flags
immutable BitFlags!Enum flags_all = EnumMembers!Enum;

// use &amp; between BitFlags for intersection
immutable BitFlags!Enum flags_BC = BitFlags!Enum(Enum.B, Enum.C);
writeln(flags_B); // (flags_BC &amp; flags_AB)

// All the binary operators work in their assignment version
BitFlags!Enum temp = flags_empty;
temp |= flags_AB;
writeln(temp); // (flags_empty | flags_AB)
temp = flags_empty;
temp |= Enum.B;
writeln(temp); // (flags_empty | Enum.B)
temp = flags_empty;
temp &amp;= flags_AB;
writeln(temp); // (flags_empty &amp; flags_AB)
temp = flags_empty;
temp &amp;= Enum.A;
writeln(temp); // (flags_empty &amp; Enum.A)

// BitFlags with no value set evaluate to false
assert(!flags_empty);

// BitFlags with at least one value set evaluate to true
assert(flags_A);

// This can be useful to check intersection between BitFlags
assert(flags_A &amp; flags_AB);
assert(flags_AB &amp; Enum.A);

// Finally, you can of course get you raw value out of flags
auto value = cast(int) flags_A;
writeln(value); // Enum.A
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="ReplaceType">template ReplaceType(From, To, T...)</dt> <dd>
<p>Replaces all occurrences of <code>From</code> into <code>To</code>, in one or more types <code>T</code>. For example, <code>ReplaceType!(int, uint, Tuple!(int, float)[string])</code> yields <code>Tuple!(uint, float)[string]</code>. The types in which replacement is performed may be arbitrarily complex, including qualifiers, built-in type constructors (pointers, arrays, associative arrays, functions, and delegates), and template instantiations; replacement proceeds transitively through the type definition. However, member types in <code>struct</code>s or <code>class</code>es are not replaced because there are no ways to express the types resulting after replacement. </p>
<p>This is an advanced type manipulation necessary e.g. for replacing the placeholder type <code>This</code> in <a href="../std_variant/#Algebraic"><code>std.variant.Algebraic</code></a>. </p> <dl>
<dt>Returns:</dt>
<dd>
<code>ReplaceType</code> aliases itself to the type(s) that result after replacement.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert(
    is(ReplaceType!(int, string, int[]) == string[]) &amp;&amp;
    is(ReplaceType!(int, string, int[int]) == string[string]) &amp;&amp;
    is(ReplaceType!(int, string, const(int)[]) == const(string)[]) &amp;&amp;
    is(ReplaceType!(int, string, Tuple!(int[], float))
        == Tuple!(string[], float))
);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Ternary">struct Ternary</dt> <dd>
<p><code>Ternary</code> type with three truth values: </p>
<p></p>
<ul> <li>
<code>Ternary.yes</code> for <code>true</code>
</li> <li>
<code>Ternary.no</code> for <code>false</code>
</li> <li>
<code>Ternary.unknown</code> as an unknown state</li> </ul> <br><br> Also known as trinary, trivalent, or trilean.  <dl>
<dt>See Also:</dt>
<dd><a href="http://en.wikipedia.org/wiki/Three-valued_logic" target="_blank"> Three Valued Logic on Wikipedia</a></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">Ternary a;
writeln(a); // Ternary.unknown

writeln(~Ternary.yes); // Ternary.no
writeln(~Ternary.no); // Ternary.yes
writeln(~Ternary.unknown); // Ternary.unknown
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="Ternary.no">enum Ternary no<br>enum Ternary yes<br>enum Ternary unknown</dt> <dd>
<p>The possible states of the <code>Ternary</code></p> </dd> <dt class="d_decl" id="Ternary.this">pure nothrow @nogc @safe this(bool b)<br>pure nothrow @nogc @safe void opAssign(bool b)</dt> <dd>
<p>Construct and assign from a <code>bool</code>, receiving <code>no</code> for <code>false</code> and <code>yes</code> for <code>true</code>.</p> </dd> <dt class="d_decl" id="Ternary.this.2">pure nothrow @nogc @safe this(const Ternary b)</dt> <dd>
<p>Construct a ternary value from another ternary value</p> </dd> <dt class="d_decl" id="Ternary.opUnary">Ternary opUnary(string s)()<br>Ternary opBinary(string s)(Ternary rhs)<br>Ternary opBinary(string s)(Ternary rhs)<br>Ternary opBinary(string s)(Ternary rhs)<br><br>  Constraints:<br>    if (s == "~")<br>    if (s == "|")<br>    if (s == "&amp;")<br>    if (s == "^")</dt> <dd>
<p></p>
<table>
<caption>Truth table for logical operations</caption> <tr>
<th scope="col"><code>a</code></th> <th scope="col"><code>b</code></th> <th scope="col"><code>˜a</code></th> <th scope="col"><code>a | b</code></th> <th scope="col"><code>a &amp; b</code></th> <th scope="col"><code>a ^ b</code></th>
</tr> <tr>
<td><code>no</code></td> <td><code>no</code></td> <td><code>yes</code></td> <td><code>no</code></td> <td><code>no</code></td> <td><code>no</code></td>
</tr> <tr>
<td><code>no</code></td> <td><code>yes</code></td> <td></td> <td><code>yes</code></td> <td><code>no</code></td> <td><code>yes</code></td>
</tr> <tr>
<td><code>no</code></td> <td><code>unknown</code></td> <td></td> <td><code>unknown</code></td> <td><code>no</code></td> <td><code>unknown</code></td>
</tr> <tr>
<td><code>yes</code></td> <td><code>no</code></td> <td><code>no</code></td> <td><code>yes</code></td> <td><code>no</code></td> <td><code>yes</code></td>
</tr> <tr>
<td><code>yes</code></td> <td><code>yes</code></td> <td></td> <td><code>yes</code></td> <td><code>yes</code></td> <td><code>no</code></td>
</tr> <tr>
<td><code>yes</code></td> <td><code>unknown</code></td> <td></td> <td><code>yes</code></td> <td><code>unknown</code></td> <td><code>unknown</code></td>
</tr> <tr>
<td><code>unknown</code></td> <td><code>no</code></td> <td><code>unknown</code></td> <td><code>unknown</code></td> <td><code>no</code></td> <td><code>unknown</code></td>
</tr> <tr>
<td><code>unknown</code></td> <td><code>yes</code></td> <td></td> <td><code>yes</code></td> <td><code>unknown</code></td> <td><code>unknown</code></td>
</tr> <tr>
<td><code>unknown</code></td> <td><code>unknown</code></td> <td></td> <td><code>unknown</code></td> <td><code>unknown</code></td> <td><code>unknown</code></td>
</tr> </table> </dd> </dl> </dd> </dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 1999–2017 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/phobos/std_typecons.html" class="_attribution-link" target="_blank">https://dlang.org/phobos/std_typecons.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
