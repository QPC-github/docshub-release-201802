
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>std.math - D - W3cubDocs</title>
  
  <meta name="description" content="Contains the elementary mathematical functions (powers, roots, and trigonometric functions), and low-level floating-point operations. Mathematical &hellip;">
  <meta name="keywords" content="std, math, -, d">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/d/std_math/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-e0f881b0fce8cbe96f33dadc355b7159d5d2912911231446d60eb8f9caffa802.css">
  <script type="text/javascript" src="/assets/application-8fc46316434047265cd383f02b8e7f434ed7dec4a59f920dd633deef8d488d1b.js"></script>
  <script src="/json/d.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/d/" class="_nav-link" title="" style="margin-left:0;">D</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _d">
				
<h1>std.math</h1>  <p>Contains the elementary mathematical functions (powers, roots, and trigonometric functions), and low-level floating-point operations. Mathematical special functions are available in <code>std.mathspecial</code>. </p>
<p> <br><br> </p>
<table>

<tr>
<th scope="col">Category</th> <th scope="col">Members</th> </tr> <tr>
<td>Constants</td> <td> <a href="#E"><em class="tt">E</em></a> <a href="#PI"><em class="tt">PI</em></a> <a href="#PI_2"><em class="tt">PI_2</em></a> <a href="#PI_4"><em class="tt">PI_4</em></a> <a href="#M_1_PI"><em class="tt">M_1_PI</em></a> <a href="#M_2_PI"><em class="tt">M_2_PI</em></a> <a href="#M_2_SQRTPI"><em class="tt">M_2_SQRTPI</em></a> <a href="#LN10"><em class="tt">LN10</em></a> <a href="#LN2"><em class="tt">LN2</em></a> <a href="#LOG2"><em class="tt">LOG2</em></a> <a href="#LOG2E"><em class="tt">LOG2E</em></a> <a href="#LOG2T"><em class="tt">LOG2T</em></a> <a href="#LOG10E"><em class="tt">LOG10E</em></a> <a href="#SQRT2"><em class="tt">SQRT2</em></a> <a href="#SQRT1_2"><em class="tt">SQRT1_2</em></a> </td>
</tr> <tr>
<td>Classics</td> <td> <a href="#abs"><em class="tt">abs</em></a> <a href="#fabs"><em class="tt">fabs</em></a> <a href="#sqrt"><em class="tt">sqrt</em></a> <a href="#cbrt"><em class="tt">cbrt</em></a> <a href="#hypot"><em class="tt">hypot</em></a> <a href="#poly"><em class="tt">poly</em></a> <a href="#nextPow2"><em class="tt">nextPow2</em></a> <a href="#truncPow2"><em class="tt">truncPow2</em></a> </td>
</tr> <tr>
<td>Trigonometry</td> <td> <a href="#sin"><em class="tt">sin</em></a> <a href="#cos"><em class="tt">cos</em></a> <a href="#tan"><em class="tt">tan</em></a> <a href="#asin"><em class="tt">asin</em></a> <a href="#acos"><em class="tt">acos</em></a> <a href="#atan"><em class="tt">atan</em></a> <a href="#atan2"><em class="tt">atan2</em></a> <a href="#sinh"><em class="tt">sinh</em></a> <a href="#cosh"><em class="tt">cosh</em></a> <a href="#tanh"><em class="tt">tanh</em></a> <a href="#asinh"><em class="tt">asinh</em></a> <a href="#acosh"><em class="tt">acosh</em></a> <a href="#atanh"><em class="tt">atanh</em></a> <a href="#expi"><em class="tt">expi</em></a> </td>
</tr> <tr>
<td>Rounding</td> <td> <a href="#ceil"><em class="tt">ceil</em></a> <a href="#floor"><em class="tt">floor</em></a> <a href="#round"><em class="tt">round</em></a> <a href="#lround"><em class="tt">lround</em></a> <a href="#trunc"><em class="tt">trunc</em></a> <a href="#rint"><em class="tt">rint</em></a> <a href="#lrint"><em class="tt">lrint</em></a> <a href="#nearbyint"><em class="tt">nearbyint</em></a> <a href="#rndtol"><em class="tt">rndtol</em></a> <a href="#quantize"><em class="tt">quantize</em></a> </td>
</tr> <tr>
<td>Exponentiation &amp; Logarithms</td> <td> <a href="#pow"><em class="tt">pow</em></a> <a href="#exp"><em class="tt">exp</em></a> <a href="#exp2"><em class="tt">exp2</em></a> <a href="#expm1"><em class="tt">expm1</em></a> <a href="#ldexp"><em class="tt">ldexp</em></a> <a href="#frexp"><em class="tt">frexp</em></a> <a href="#log"><em class="tt">log</em></a> <a href="#log2"><em class="tt">log2</em></a> <a href="#log10"><em class="tt">log10</em></a> <a href="#logb"><em class="tt">logb</em></a> <a href="#ilogb"><em class="tt">ilogb</em></a> <a href="#log1p"><em class="tt">log1p</em></a> <a href="#scalbn"><em class="tt">scalbn</em></a> </td>
</tr> <tr>
<td>Modulus</td> <td> <a href="#fmod"><em class="tt">fmod</em></a> <a href="#modf"><em class="tt">modf</em></a> <a href="#remainder"><em class="tt">remainder</em></a> </td>
</tr> <tr>
<td>Floating-point operations</td> <td> <a href="#approxEqual"><em class="tt">approxEqual</em></a> <a href="#feqrel"><em class="tt">feqrel</em></a> <a href="#fdim"><em class="tt">fdim</em></a> <a href="#fmax"><em class="tt">fmax</em></a> <a href="#fmin"><em class="tt">fmin</em></a> <a href="#fma"><em class="tt">fma</em></a> <a href="#nextDown"><em class="tt">nextDown</em></a> <a href="#nextUp"><em class="tt">nextUp</em></a> <a href="#nextafter"><em class="tt">nextafter</em></a> <a href="#NaN"><em class="tt">NaN</em></a> <a href="#getNaNPayload"><em class="tt">getNaNPayload</em></a> <a href="#cmp"><em class="tt">cmp</em></a> </td>
</tr> <tr>
<td>Introspection</td> <td> <a href="#isFinite"><em class="tt">isFinite</em></a> <a href="#isIdentical"><em class="tt">isIdentical</em></a> <a href="#isInfinity"><em class="tt">isInfinity</em></a> <a href="#isNaN"><em class="tt">isNaN</em></a> <a href="#isNormal"><em class="tt">isNormal</em></a> <a href="#isSubnormal"><em class="tt">isSubnormal</em></a> <a href="#signbit"><em class="tt">signbit</em></a> <a href="#sgn"><em class="tt">sgn</em></a> <a href="#copysign"><em class="tt">copysign</em></a> <a href="#isPowerOf2"><em class="tt">isPowerOf2</em></a> </td>
</tr> <tr>
<td>Complex Numbers</td> <td> <a href="#abs"><em class="tt">abs</em></a> <a href="#conj"><em class="tt">conj</em></a> <a href="#sin"><em class="tt">sin</em></a> <a href="#cos"><em class="tt">cos</em></a> <a href="#expi"><em class="tt">expi</em></a> </td>
</tr> <tr>
<td>Hardware Control</td> <td> <a href="#IeeeFlags"><em class="tt">IeeeFlags</em></a> <a href="#FloatingPointControl"><em class="tt">FloatingPointControl</em></a> </td>
</tr> </table>  <br><br> The functionality closely follows the IEEE754-2008 standard for floating-point arithmetic, including the use of camelCase names rather than C99-style lower case names. All of these functions behave correctly when presented with an infinity or NaN. <br><br> The following IEEE 'real' formats are currently supported: <ul> <li>64 bit Big-endian 'double' (eg PowerPC)</li> <li>128 bit Big-endian 'quadruple' (eg SPARC)</li> <li>64 bit Little-endian 'double' (eg x86-SSE2)</li> <li>80 bit Little-endian, with implied bit 'real80' (eg x87, Itanium)</li> <li>128 bit Little-endian 'quadruple' (not implemented on any known processor!)</li> <li>Non-IEEE 128 bit Big-endian 'doubledouble' (eg PowerPC) has partial support</li> </ul> Unlike C, there is no global 'errno' variable. Consequently, almost all of these functions are pure nothrow.  <dl>
<dt>Status</dt>
<dd> The semantics and names of feqrel and approxEqual will be revised. </dd>
</dl> <dl>
<dt>License:</dt>
<dd>
<a href="http://www.boost.org/LICENSE_1_0.txt" target="_blank">Boost License 1.0</a>. </dd>
</dl> <dl>
<dt>Authors:</dt>
<dd>
<a href="http://digitalmars.com" target="_blank">Walter Bright</a>, Don Clugston, Conversion of CEPHES <code>math</code> library to D by Iain Buclaw and David Nadlinger </dd>
</dl> <dl>
<dt>Source</dt>
<dd> <span class="phobos_src"><a class="https" href="https://github.com/dlang/phobos/blob/master/std/math.d" target="_blank">std/math.d</a></span>
</dd>
</dl> <dl>
<dt class="d_decl" id="E">enum real E</dt> <dd>
<p>e = 2.718281...</p> </dd> <dt class="d_decl" id="LOG2T">enum real LOG2T</dt> <dd>
<p>log<sub>2</sub>10 = 3.321928...</p> </dd> <dt class="d_decl" id="LOG2E">enum real LOG2E</dt> <dd>
<p>log<sub>2</sub>e = 1.442695...</p> </dd> <dt class="d_decl" id="LOG2">enum real LOG2</dt> <dd>
<p>log<sub>10</sub>2 = 0.301029...</p> </dd> <dt class="d_decl" id="LOG10E">enum real LOG10E</dt> <dd>
<p>log<sub>10</sub>e = 0.434294...</p> </dd> <dt class="d_decl" id="LN2">enum real LN2</dt> <dd>
<p>ln 2 = 0.693147...</p> </dd> <dt class="d_decl" id="LN10">enum real LN10</dt> <dd>
<p>ln 10 = 2.302585...</p> </dd> <dt class="d_decl" id="PI">enum real PI</dt> <dd>
<p>π = 3.141592...</p> </dd> <dt class="d_decl" id="PI_2">enum real PI_2</dt> <dd>
<p>π / 2 = 1.570796...</p> </dd> <dt class="d_decl" id="PI_4">enum real PI_4</dt> <dd>
<p>π / 4 = 0.785398...</p> </dd> <dt class="d_decl" id="M_1_PI">enum real M_1_PI</dt> <dd>
<p>1 / π = 0.318309...</p> </dd> <dt class="d_decl" id="M_2_PI">enum real M_2_PI</dt> <dd>
<p>2 / π = 0.636619...</p> </dd> <dt class="d_decl" id="M_2_SQRTPI">enum real M_2_SQRTPI</dt> <dd>
<p>2 / √π = 1.128379...</p> </dd> <dt class="d_decl" id="SQRT2">enum real SQRT2</dt> <dd>
<p>√2 = 1.414213...</p> </dd> <dt class="d_decl" id="SQRT1_2">enum real SQRT1_2</dt> <dd>
<p>√½ = 0.707106...</p> </dd> <dt class="d_decl" id="abs">pure nothrow @safe Num abs(Num)(Num x)<br>pure nothrow @nogc @safe auto abs(Num)(Num z)<br>pure nothrow @nogc @safe auto abs(Num)(Num y)<br><br>  Constraints:<br>    if (is(typeof(Num.init &gt;= 0)) &amp;&amp; is(typeof(-Num.init)) &amp;&amp; !(is(Num* : const(ifloat*)) || is(Num* : const(idouble*)) || is(Num* : const(ireal*))))<br>    if (is(Num* : const(cfloat*)) || is(Num* : const(cdouble*)) || is(Num* : const(creal*)))<br>    if (is(Num* : const(ifloat*)) || is(Num* : const(idouble*)) || is(Num* : const(ireal*)))</dt> <dd>
<p>Calculates the absolute value of a number </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Num</td> <td>(template parameter) type of number</td>
</tr> <tr>
<td>Num <code>x</code>
</td> <td>real number value</td>
</tr> <tr>
<td>Num <code>z</code>
</td> <td>complex number value</td>
</tr> <tr>
<td>Num <code>y</code>
</td> <td>imaginary number value</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The absolute value of the number. If floating-point or integral, the return type will be the same as the input; if complex or imaginary, the returned value will be the corresponding floating point type.  For complex numbers, <code>abs</code>(<code>z</code>) = sqrt( <code>z</code>.re<sup>2</sup> + <code>z</code>.im<sup>2</sup> ) = hypot(<code>z</code>.re, <code>z</code>.im).</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>ditto <pre data-language="d">assert(isIdentical(abs(-0.0L), 0.0L));
assert(isNaN(abs(real.nan)));
writeln(abs(-real.infinity)); // real.infinity
writeln(abs(-3.2Li)); // 3.2L
writeln(abs(71.6Li)); // 71.6L
writeln(abs(-56)); // 56
writeln(abs(2321312L)); // 2321312L
writeln(abs(-1L + 1i)); // sqrt(2.0L)
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="conj">pure nothrow @nogc @safe auto conj(Num)(Num z)<br>pure nothrow @nogc @safe auto conj(Num)(Num y)<br><br>  Constraints:<br>    if (is(Num* : const(cfloat*)) || is(Num* : const(cdouble*)) || is(Num* : const(creal*)))<br>    if (is(Num* : const(ifloat*)) || is(Num* : const(idouble*)) || is(Num* : const(ireal*)))</dt> <dd>
<p>Complex conjugate </p>
<p><code>conj</code>(x + iy) = x - iy <br><br> Note that <code>z</code> * <code>conj</code>(<code>z</code>) = <code>z</code>.re<sup>2</sup> - <code>z</code>.im<sup>2</sup> is always a real number</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">creal c = 7 + 3Li;
writeln(conj(c)); // 7 - 3Li
ireal z = -3.2Li;
writeln(conj(z)); // -z
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="cos">pure nothrow @nogc @safe real cos(real x)<br>pure nothrow @nogc @safe double cos(double x)<br>pure nothrow @nogc @safe float cos(float x)</dt> <dd>
<p>Returns cosine of <code>x</code>. <code>x</code> is in radians. </p>
<p></p>
<table> <caption>Special Values</caption> <tr>
<th scope="col"><code>x</code></th> <th scope="col">
<code>cos</code>(<code>x</code>)</th> <th scope="col">invalid?</th>
</tr> <tr>
<td><span class="red">NAN</span></td> <td><span class="red">NAN</span></td> <td>yes</td> </tr> <tr>
<td>±∞</td> <td><span class="red">NAN</span></td> <td>yes</td> </tr> </table>  <dl>
<dt>Bugs:</dt>
<dd>Results are undefined if |<code>x</code>| &gt;= 2<sup>64</sup>.</dd>
</dl> </dd> <dt class="d_decl" id="sin">pure nothrow @nogc @safe real sin(real x)<br>pure nothrow @nogc @safe double sin(double x)<br>pure nothrow @nogc @safe float sin(float x)</dt> <dd>
<p>Returns <a href="http://en.wikipedia.org/wiki/Sine" target="_blank">sine</a> of <code>x</code>. <code>x</code> is in <a href="http://en.wikipedia.org/wiki/Radian" target="_blank">radians</a>. </p>
<p></p>
<table> <caption>Special Values</caption> <tr>
<th scope="col">
<code>x</code> </th> <th scope="col"> <code>sin</code>(<code>x</code>) </th> <th scope="col"> invalid?</th>
</tr> <tr>
<td>
<span class="red">NAN</span> </td> <td> <span class="red">NAN</span> </td> <td> yes </td>
</tr> <tr>
<td>±0.0</td> <td> ±0.0</td> <td> no </td>
</tr> <tr>
<td>±∞</td> <td> <span class="red">NAN</span> </td> <td> yes </td>
</tr> </table>  <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>real <code>x</code>
</td> <td>angle in radians (not degrees)</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>sine of <code>x</code> </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="#cos"><em class="tt">cos</em></a> , <a href="#tan"><em class="tt">tan</em></a> , <a href="#asin"><em class="tt">asin</em></a> </dd>
</dl> <dl>
<dt>Bugs:</dt>
<dd>Results are undefined if |<code>x</code>| &gt;= 2<sup>64</sup>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.math : sin, PI;
import std.stdio : writefln;

void someFunc()
{
  real x = 30.0;
  auto result = sin(x * (PI / 180)); // convert degrees to radians
  writefln("The sine of %s degrees is %s", x, result);
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="sin.2">pure nothrow @nogc @safe creal sin(creal z)<br>pure nothrow @nogc @safe ireal sin(ireal y)</dt> <dd>
<p>Returns sine for complex and imaginary arguments. </p>
<p><code>sin</code>(<code>z</code>) = <code>sin</code>(<code>z</code>.re)*cosh(<code>z</code>.im) + cos(<code>z</code>.re)*sinh(<code>z</code>.im)i <br><br> If both <code>sin</code>(θ) and cos(θ) are required, it is most efficient to use expi(θ).</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(sin(0.0 + 0.0i)); // 0.0
writeln(sin(2.0 + 0.0i)); // sin(2.0L)
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="cos.2">pure nothrow @nogc @safe creal cos(creal z)<br>pure nothrow @nogc @safe real cos(ireal y)</dt> <dd>
<p>cosine, complex and imaginary </p>
<p><code>cos</code>(<code>z</code>) = <code>cos</code>(<code>z</code>.re)*cosh(<code>z</code>.im) - sin(<code>z</code>.re)*sinh(<code>z</code>.im)i</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(cos(0.0 + 0.0i)); // 1.0
writeln(cos(1.3L + 0.0i)); // cos(1.3L)
writeln(cos(5.2Li)); // cosh(5.2L)
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="tan">pure nothrow @nogc @trusted real tan(real x)</dt> <dd>
<p>Returns tangent of <code>x</code>. <code>x</code> is in radians. </p>
<p></p>
<table> <caption>Special Values</caption> <tr>
<th scope="col"><code>x</code></th> <th scope="col">
<code>tan</code>(<code>x</code>)</th> <th scope="col">invalid?</th>
</tr> <tr>
<td><span class="red">NAN</span></td> <td><span class="red">NAN</span></td> <td>yes</td>
</tr> <tr>
<td>±0.0</td> <td>±0.0</td> <td>no</td>
</tr> <tr>
<td>±∞</td> <td><span class="red">NAN</span></td> <td>yes</td>
</tr> </table> </dd> <dt class="d_decl" id="acos">pure nothrow @nogc @safe real acos(real x)<br>pure nothrow @nogc @safe double acos(double x)<br>pure nothrow @nogc @safe float acos(float x)</dt> <dd>
<p>Calculates the arc cosine of <code>x</code>, returning a value ranging from 0 to π. </p>
<p></p>
<table> <caption>Special Values</caption> <tr>
<th scope="col"><code>x</code></th> <th scope="col">
<code>acos</code>(<code>x</code>)</th> <th scope="col">invalid?</th>
</tr> <tr>
<td>&gt;1.0</td> <td><span class="red">NAN</span></td> <td>yes</td>
</tr> <tr>
<td>&lt;-1.0</td> <td><span class="red">NAN</span></td> <td>yes</td>
</tr> <tr>
<td><span class="red">NAN</span></td> <td><span class="red">NAN</span></td> <td>yes</td>
</tr> </table> </dd> <dt class="d_decl" id="asin">pure nothrow @nogc @safe real asin(real x)<br>pure nothrow @nogc @safe double asin(double x)<br>pure nothrow @nogc @safe float asin(float x)</dt> <dd>
<p>Calculates the arc sine of <code>x</code>, returning a value ranging from -π/2 to π/2. </p>
<p></p>
<table> <caption>Special Values</caption> <tr>
<th scope="col"><code>x</code></th> <th scope="col">
<code>asin</code>(<code>x</code>)</th> <th scope="col">invalid?</th>
</tr> <tr>
<td>±0.0</td> <td>±0.0</td> <td>no</td>
</tr> <tr>
<td>&gt;1.0</td> <td><span class="red">NAN</span></td> <td>yes</td>
</tr> <tr>
<td>&lt;-1.0</td> <td><span class="red">NAN</span></td> <td>yes</td>
</tr> </table> </dd> <dt class="d_decl" id="atan">pure nothrow @nogc @safe real atan(real x)<br>pure nothrow @nogc @safe double atan(double x)<br>pure nothrow @nogc @safe float atan(float x)</dt> <dd>
<p>Calculates the arc tangent of <code>x</code>, returning a value ranging from -π/2 to π/2. </p>
<p></p>
<table> <caption>Special Values</caption> <tr>
<th scope="col"><code>x</code></th> <th scope="col">
<code>atan</code>(<code>x</code>)</th> <th scope="col">invalid?</th>
</tr> <tr>
<td>±0.0</td> <td>±0.0</td> <td>no</td>
</tr> <tr>
<td>±∞</td> <td><span class="red">NAN</span></td> <td>yes</td>
</tr> </table> </dd> <dt class="d_decl" id="atan2">pure nothrow @nogc @trusted real atan2(real y, real x)<br>pure nothrow @nogc @safe double atan2(double y, double x)<br>pure nothrow @nogc @safe float atan2(float y, float x)</dt> <dd>
<p>Calculates the arc tangent of <code>y</code> / <code>x</code>, returning a value ranging from -π to π. </p>
<p></p>
<table> <caption>Special Values</caption> <tr>
<th scope="col"><code>y</code></th> <th scope="col"><code>x</code></th> <th scope="col">atan(<code>y</code>, <code>x</code>)</th>
</tr> <tr>
<td><span class="red">NAN</span></td> <td>anything</td> <td><span class="red">NAN</span></td> </tr> <tr>
<td>anything</td> <td><span class="red">NAN</span></td> <td><span class="red">NAN</span></td> </tr> <tr>
<td>±0.0</td> <td>&gt;0.0</td> <td>±0.0</td> </tr> <tr>
<td>±0.0</td> <td>+0.0</td> <td>±0.0</td> </tr> <tr>
<td>±0.0</td> <td>&lt;0.0</td> <td>±π</td>
</tr> <tr>
<td>±0.0</td> <td>-0.0</td> <td>±π</td>
</tr> <tr>
<td>&gt;0.0</td> <td>±0.0</td> <td>π/2</td> </tr> <tr>
<td>&lt;0.0</td> <td>±0.0</td> <td>-π/2</td> </tr> <tr>
<td>&gt;0.0</td> <td>∞</td> <td>±0.0</td> </tr> <tr>
<td>±∞</td> <td>anything</td> <td>±π/2</td>
</tr> <tr>
<td>&gt;0.0</td> <td>-∞</td> <td>±π</td> </tr> <tr>
<td>±∞</td> <td>∞</td> <td>±π/4</td>
</tr> <tr>
<td>±∞</td> <td>-∞</td> <td>±3π/4</td>
</tr> </table> </dd> <dt class="d_decl" id="cosh">pure nothrow @nogc @safe real cosh(real x)<br>pure nothrow @nogc @safe double cosh(double x)<br>pure nothrow @nogc @safe float cosh(float x)</dt> <dd>
<p>Calculates the hyperbolic cosine of <code>x</code>. </p>
<p></p>
<table> <caption>Special Values</caption> <tr>
<th scope="col"><code>x</code></th> <th scope="col">
<code>cosh</code>(<code>x</code>)</th> <th scope="col">invalid?</th>
</tr> <tr>
<td>±∞</td> <td>±0.0</td> <td>no</td> </tr> </table> </dd> <dt class="d_decl" id="sinh">pure nothrow @nogc @safe real sinh(real x)<br>pure nothrow @nogc @safe double sinh(double x)<br>pure nothrow @nogc @safe float sinh(float x)</dt> <dd>
<p>Calculates the hyperbolic sine of <code>x</code>. </p>
<p></p>
<table> <caption>Special Values</caption> <tr>
<th scope="col"><code>x</code></th> <th scope="col">
<code>sinh</code>(<code>x</code>)</th> <th scope="col">invalid?</th>
</tr> <tr>
<td>±0.0</td> <td>±0.0</td> <td>no</td>
</tr> <tr>
<td>±∞</td> <td>±∞</td> <td>no</td>
</tr> </table> </dd> <dt class="d_decl" id="tanh">pure nothrow @nogc @safe real tanh(real x)<br>pure nothrow @nogc @safe double tanh(double x)<br>pure nothrow @nogc @safe float tanh(float x)</dt> <dd>
<p>Calculates the hyperbolic tangent of <code>x</code>. </p>
<p></p>
<table> <caption>Special Values</caption> <tr>
<th scope="col"><code>x</code></th> <th scope="col">
<code>tanh</code>(<code>x</code>)</th> <th scope="col">invalid?</th>
</tr> <tr>
<td>±0.0</td> <td>±0.0</td> <td>no</td> </tr> <tr>
<td>±∞</td> <td>±1.0</td> <td>no</td>
</tr> </table> </dd> <dt class="d_decl" id="acosh">pure nothrow @nogc @safe real acosh(real x)<br>pure nothrow @nogc @safe double acosh(double x)<br>pure nothrow @nogc @safe float acosh(float x)</dt> <dd>
<p>Calculates the inverse hyperbolic cosine of <code>x</code>. </p>
<p>Mathematically, <code>acosh</code>(<code>x</code>) = log(<code>x</code> + sqrt( <code>x</code>*<code>x</code> - 1)) <br><br> </p>
<table> <tr>
<th scope="col">Domain X</th> <th scope="col">Range Y</th>
</tr> <tr>
<td> 1..∞</td> <td> 0..∞ </td>
</tr> </table> <br><br> <table> <caption>Special Values</caption> <tr>
<th scope="col"> <code>x</code>
</th> <th scope="col"> <code>acosh</code>(<code>x</code>) </th>
</tr> <tr>
<td> <span class="red">NAN</span>
</td> <td>
<span class="red">NAN</span> </td>
</tr> <tr>
<td> &lt;1</td> <td> <span class="red">NAN</span> </td>
</tr> <tr>
<td> 1</td> <td> 0 </td>
</tr> <tr>
<td> +∞</td> <td>+∞</td>
</tr> </table> </dd> <dt class="d_decl" id="asinh">pure nothrow @nogc @safe real asinh(real x)<br>pure nothrow @nogc @safe double asinh(double x)<br>pure nothrow @nogc @safe float asinh(float x)</dt> <dd>
<p>Calculates the inverse hyperbolic sine of <code>x</code>. </p>
<p> Mathematically, </p>
<pre data-language="d">asinh(x) =  log( x + sqrt( x*x + 1 )) // if x &gt;= +0
asinh(x) = -log(-x + sqrt( x*x + 1 )) // if x &lt;= -0
</pre> <br><br> <table> <caption>Special Values</caption> <tr>
<th scope="col"><code>x</code></th> <th scope="col"> <code>asinh</code>(<code>x</code>) </th>
</tr> <tr>
<td> <span class="red">NAN</span>
</td> <td> <span class="red">NAN</span> </td>
</tr> <tr>
<td> ±0</td> <td> ±0 </td>
</tr> <tr>
<td> ±∞</td> <td>±∞</td>
</tr> </table> </dd> <dt class="d_decl" id="atanh">pure nothrow @nogc @safe real atanh(real x)<br>pure nothrow @nogc @safe double atanh(double x)<br>pure nothrow @nogc @safe float atanh(float x)</dt> <dd>
<p>Calculates the inverse hyperbolic tangent of <code>x</code>, returning a value from ranging from -1 to 1. </p>
<p>Mathematically, <code>atanh</code>(<code>x</code>) = log( (1+<code>x</code>)/(1-<code>x</code>) ) / 2 <br><br> </p>
<table> <tr>
<th scope="col">Domain X</th> <th scope="col">Range Y</th>
</tr> <tr>
<td> -∞..∞</td> <td> -1 .. 1 </td>
</tr> </table> <br> <table> <caption>Special Values</caption> <tr>
<th scope="col"> <code>x</code>
</th> <th scope="col"> acosh(<code>x</code>) </th>
</tr> <tr>
<td> <span class="red">NAN</span>
</td> <td>
<span class="red">NAN</span> </td>
</tr> <tr>
<td> ±0</td> <td>±0</td>
</tr> <tr>
<td> -∞</td> <td>-0</td>
</tr> </table> </dd> <dt class="d_decl" id="rndtol">pure nothrow @nogc @safe long rndtol(real x)<br>pure nothrow @nogc @safe long rndtol(double x)<br>pure nothrow @nogc @safe long rndtol(float x)</dt> <dd>
<p>Returns <code>x</code> rounded to a long value using the current rounding mode. If the integer value of <code>x</code> is greater than long.max, the result is indeterminate.</p> </dd> <dt class="d_decl" id="rndtonl">real rndtonl(real x)</dt> <dd>
<p>Returns <code>x</code> rounded to a long value using the FE_TONEAREST rounding mode. If the integer value of <code>x</code> is greater than long.max, the result is indeterminate.</p> </dd> <dt class="d_decl" id="sqrt">pure nothrow @nogc @safe float sqrt(float x)<br>pure nothrow @nogc @safe double sqrt(double x)<br>pure nothrow @nogc @safe real sqrt(real x)</dt> <dd>
<p>Compute square root of <code>x</code>. </p>
<p></p>
<table> <caption>Special Values</caption> <tr>
<th scope="col"><code>x</code></th> <th scope="col">
<code>sqrt</code>(<code>x</code>)</th> <th scope="col">invalid?</th>
</tr> <tr>
<td>-0.0</td> <td>-0.0</td> <td>no</td>
</tr> <tr>
<td>&lt;0.0</td> <td><span class="red">NAN</span></td> <td>yes</td>
</tr> <tr>
<td>+∞</td> <td>+∞</td> <td>no</td>
</tr> </table> </dd> <dt class="d_decl" id="exp">pure nothrow @nogc @trusted real exp(real x)<br>pure nothrow @nogc @safe double exp(double x)<br>pure nothrow @nogc @safe float exp(float x)</dt> <dd>
<p>Calculates e<sup><code>x</code></sup>. </p>
<p></p>
<table> <caption>Special Values</caption> <tr>
<th scope="col"><code>x</code></th> <th scope="col">e<sup><code>x</code></sup>
</th> </tr> <tr>
<td>+∞</td> <td>+∞</td> </tr> <tr>
<td>-∞</td> <td>+0.0</td> </tr> <tr>
<td><span class="red">NAN</span></td> <td><span class="red">NAN</span></td> </tr> </table> </dd> <dt class="d_decl" id="expm1">pure nothrow @nogc @trusted real expm1(real x)</dt> <dd>
<p>Calculates the value of the natural logarithm base (e) raised to the power of <code>x</code>, minus 1. </p>
<p>For very small <code>x</code>, <code>expm1</code>(<code>x</code>) is more accurate than exp(<code>x</code>)-1. <br><br> </p>
<table> <caption>Special Values</caption> <tr>
<th scope="col"><code>x</code></th> <th scope="col">e<sup><code>x</code></sup>-1</th> </tr> <tr>
<td>±0.0</td> <td>±0.0</td> </tr> <tr>
<td>+∞</td> <td>+∞</td> </tr> <tr>
<td>-∞</td> <td>-1.0</td> </tr> <tr>
<td><span class="red">NAN</span></td> <td><span class="red">NAN</span></td> </tr> </table> </dd> <dt class="d_decl" id="exp2">pure nothrow @nogc @trusted real exp2(real x)</dt> <dd>
<p>Calculates 2<sup><code>x</code></sup>. </p>
<p></p>
<table> <caption>Special Values</caption> <tr>
<th scope="col"><code>x</code></th> <th scope="col">
<code>exp2</code>(<code>x</code>)</th> </tr> <tr>
<td>+∞</td> <td>+∞</td> </tr> <tr>
<td>-∞</td> <td>+0.0</td> </tr> <tr>
<td><span class="red">NAN</span></td> <td><span class="red">NAN</span></td> </tr> </table> </dd> <dt class="d_decl" id="expi">pure nothrow @nogc @trusted creal expi(real y)</dt> <dd>
<p>Calculate cos(<code>y</code>) + i sin(<code>y</code>). </p>
<p>On many CPUs (such as x86), this is a very efficient operation; almost twice as fast as calculating sin(<code>y</code>) and cos(<code>y</code>) separately, and is the preferred method when both are required.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(expi(1.3e5L)); // cos(1.3e5L) + sin(1.3e5L) * 1i
writeln(expi(0.0L)); // 1L + 0.0Li
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="frexp">pure nothrow @nogc @trusted T frexp(T)(const T value, out int exp)<br><br>  Constraints:<br>    if (isFloatingPoint!T)</dt> <dd>
<p>Separate floating point <code>value</code> into significand and exponent. </p>
<dl>
<dt>Returns:</dt>
<dd>Calculate and return <i>x</i> and <i><code>exp</code></i> such that <code>value</code> =<i>x</i>*2<sup><code>exp</code></sup> and .5 &lt;= |<i>x</i>| &lt; 1.0  <i>x</i> has same sign as <code>value</code>.  <table> <caption>Special Values</caption> <tr>
<th scope="col"><code>value</code></th> <th scope="col">returns</th> <th scope="col"><code>exp</code></th>
</tr> <tr>
<td>±0.0</td> <td>±0.0</td> <td>0</td>
</tr> <tr>
<td>+∞</td> <td>+∞</td> <td>int.max</td>
</tr> <tr>
<td>-∞</td> <td>-∞</td> <td>int.min</td>
</tr> <tr>
<td>±<span class="red">NAN</span>
</td> <td>±<span class="red">NAN</span>
</td> <td>int.min</td>
</tr> </table>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">int exp;
real mantissa = frexp(123.456L, exp);

// check if values are equal to 19 decimal digits of precision
assert(equalsDigit(mantissa * pow(2.0L, cast(real) exp), 123.456L, 19));

assert(frexp(-real.nan, exp) &amp;&amp; exp == int.min);
assert(frexp(real.nan, exp) &amp;&amp; exp == int.min);
assert(frexp(-real.infinity, exp) == -real.infinity &amp;&amp; exp == int.min);
assert(frexp(real.infinity, exp) == real.infinity &amp;&amp; exp == int.max);
assert(frexp(-0.0, exp) == -0.0 &amp;&amp; exp == 0);
assert(frexp(0.0, exp) == 0.0 &amp;&amp; exp == 0);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="ilogb">pure nothrow @nogc @trusted int ilogb(T)(const T x)<br>pure nothrow @nogc @safe int ilogb(T)(const T x)<br>pure nothrow @nogc @safe int ilogb(T)(const T x)<br><br>  Constraints:<br>    if (isFloatingPoint!T)<br>    if (isIntegral!T &amp;&amp; isUnsigned!T)<br>    if (isIntegral!T &amp;&amp; isSigned!T)</dt> <dd>
<p>Extracts the exponent of <code>x</code> as a signed integral value. </p>
<p>If <code>x</code> is not a special value, the result is the same as <code>cast(int) logb(x)</code>. <br><br> </p>
<table> <caption>Special Values</caption> <tr>
<th scope="col"><code>x</code></th> <th scope="col">
<code>ilogb</code>(<code>x</code>)</th> <th scope="col">Range error?</th>
</tr> <tr>
<td>0</td> <td>FP_ILOGB0</td> <td>yes</td>
</tr> <tr>
<td>±∞</td> <td>int.max</td> <td>no</td>
</tr> <tr>
<td><span class="red">NAN</span></td> <td>FP_ILOGBNAN</td> <td>no</td>
</tr> </table> </dd> <dt class="d_decl" id="ldexp">pure nothrow @nogc @safe real ldexp(real n, int exp)<br>pure nothrow @nogc @safe double ldexp(double n, int exp)<br>pure nothrow @nogc @safe float ldexp(float n, int exp)</dt> <dd>
<p>Compute <code>n</code> * 2<sup><code>exp</code></sup> </p>
<dl>
<dt>References</dt>
<dd> frexp</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.meta : AliasSeq;
foreach (T; AliasSeq!(float, double, real))
{
    T r;

    r = ldexp(3.0L, 3);
    writeln(r); // 24

    r = ldexp(cast(T) 3.0, cast(int) 3);
    writeln(r); // 24

    T n = 3.0;
    int exp = 3;
    r = ldexp(n, exp);
    writeln(r); // 24
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="log">pure nothrow @nogc @safe real log(real x)</dt> <dd>
<p>Calculate the natural logarithm of <code>x</code>. </p>
<p></p>
<table> <caption>Special Values</caption> <tr>
<th scope="col"><code>x</code></th> <th scope="col">
<code>log</code>(<code>x</code>)</th> <th scope="col">divide by 0?</th> <th scope="col">invalid?</th>
</tr> <tr>
<td>±0.0</td> <td>-∞</td> <td>yes</td> <td>no</td>
</tr> <tr>
<td>&lt;0.0</td> <td><span class="red">NAN</span></td> <td>no</td> <td>yes</td>
</tr> <tr>
<td>+∞</td> <td>+∞</td> <td>no</td> <td>no</td>
</tr> </table> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(log(E)); // 1
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="log10">pure nothrow @nogc @safe real log10(real x)</dt> <dd>
<p>Calculate the base-10 logarithm of <code>x</code>. </p>
<p></p>
<table> <caption>Special Values</caption> <tr>
<th scope="col"><code>x</code></th> <th scope="col">
<code>log10</code>(<code>x</code>)</th> <th scope="col">divide by 0?</th> <th scope="col">invalid?</th>
</tr> <tr>
<td>±0.0</td> <td>-∞</td> <td>yes</td> <td>no</td>
</tr> <tr>
<td>&lt;0.0</td> <td><span class="red">NAN</span></td> <td>no</td> <td>yes</td>
</tr> <tr>
<td>+∞</td> <td>+∞</td> <td>no</td> <td>no</td>
</tr> </table> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(fabs(log10(1000) - 3) &lt; .000001);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="log1p">pure nothrow @nogc @safe real log1p(real x)</dt> <dd>
<p>Calculates the natural logarithm of 1 + <code>x</code>. </p>
<p>For very small <code>x</code>, <code>log1p</code>(<code>x</code>) will be more accurate than log(1 + <code>x</code>). <br><br> </p>
<table> <caption>Special Values</caption> <tr>
<th scope="col"><code>x</code></th> <th scope="col">
<code>log1p</code>(<code>x</code>)</th> <th scope="col">divide by 0?</th> <th scope="col">invalid?</th>
</tr> <tr>
<td>±0.0</td> <td>±0.0</td> <td>no</td> <td>no</td>
</tr> <tr>
<td>-1.0</td> <td>-∞</td> <td>yes</td> <td>no</td>
</tr> <tr>
<td>&lt;-1.0</td> <td><span class="red">NAN</span></td> <td>no</td> <td>yes</td>
</tr> <tr>
<td>+∞</td> <td>-∞</td> <td>no</td> <td>no</td>
</tr> </table> </dd> <dt class="d_decl" id="log2">pure nothrow @nogc @safe real log2(real x)</dt> <dd>
<p>Calculates the base-2 logarithm of <code>x</code>: log<sub>2</sub><code>x</code> </p>
<p></p>
<table> <caption>Special Values</caption> <tr>
<th scope="col"><code>x</code></th> <th scope="col">
<code>log2</code>(<code>x</code>)</th> <th scope="col">divide by 0?</th> <th scope="col">invalid?</th>
</tr> <tr>
<td>±0.0</td> <td>-∞</td> <td>yes</td> <td>no</td> </tr> <tr>
<td>&lt;0.0</td> <td><span class="red">NAN</span></td> <td>no</td> <td>yes</td> </tr> <tr>
<td>+∞</td> <td>+∞</td> <td>no</td> <td>no</td> </tr> </table> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">// check if values are equal to 19 decimal digits of precision
assert(equalsDigit(log2(1024.0L), 10, 19));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="logb">nothrow @nogc @trusted real logb(real x)</dt> <dd>
<p>Extracts the exponent of <code>x</code> as a signed integral value. </p>
<p>If <code>x</code> is subnormal, it is treated as if it were normalized. For a positive, finite <code>x</code>: <br><br> 1 &lt;= <i><code>x</code></i> * FLT_RADIX<sup>-<code>logb</code>(<code>x</code>)</sup> &lt; FLT_RADIX <br><br> </p>
<table> <caption>Special Values</caption> <tr>
<th scope="col"><code>x</code></th> <th scope="col">
<code>logb</code>(<code>x</code>)</th> <th scope="col">divide by 0?</th> </tr> <tr>
<td>±∞</td> <td>+∞</td> <td>no</td>
</tr> <tr>
<td>±0.0</td> <td>-∞</td> <td>yes</td> </tr> </table> </dd> <dt class="d_decl" id="fmod">nothrow @nogc @trusted real fmod(real x, real y)</dt> <dd>
<p>Calculates the remainder from the calculation <code>x</code>/<code>y</code>. </p>
<dl>
<dt>Returns:</dt>
<dd>The value of <code>x</code> - i * <code>y</code>, where i is the number of times that <code>y</code> can be completely subtracted from <code>x</code>. The result has the same sign as <code>x</code>.  <table> <caption>Special Values</caption> <tr>
<th scope="col"><code>x</code></th> <th scope="col"><code>y</code></th> <th scope="col">
<code>fmod</code>(<code>x</code>, <code>y</code>)</th> <th scope="col">invalid?</th>
</tr> <tr>
<td>±0.0</td> <td>not 0.0</td> <td>±0.0</td> <td>no</td>
</tr> <tr>
<td>±∞</td> <td>anything</td> <td><span class="red">NAN</span></td> <td>yes</td>
</tr> <tr>
<td>anything</td> <td>±0.0</td> <td><span class="red">NAN</span></td> <td>yes</td>
</tr> <tr>
<td>!=±∞</td> <td>±∞</td> <td><code>x</code></td> <td>no</td>
</tr> </table>
</dd>
</dl> </dd> <dt class="d_decl" id="modf">nothrow @nogc @trusted real modf(real x, ref real i)</dt> <dd>
<p>Breaks <code>x</code> into an integral part and a fractional part, each of which has the same sign as <code>x</code>. The integral part is stored in <code>i</code>. </p>
<dl>
<dt>Returns:</dt>
<dd>The fractional part of <code>x</code>.  <table> <caption>Special Values</caption> <tr>
<th scope="col"><code>x</code></th> <th scope="col">
<code>i</code> (on input)</th> <th scope="col">
<code>modf</code>(<code>x</code>, <code>i</code>)</th> <th scope="col">
<code>i</code> (on return)</th>
</tr> <tr>
<td>±∞</td> <td>anything</td> <td>±0.0</td> <td>±∞</td>
</tr> </table>
</dd>
</dl> </dd> <dt class="d_decl" id="scalbn">nothrow @nogc @trusted real scalbn(real x, int n)</dt> <dd>
<p>Efficiently calculates <code>x</code> * 2<sup><code>n</code></sup>. </p>
<p><code>scalbn</code> handles underflow and overflow in the same fashion as the basic arithmetic operators. <br><br> </p>
<table> <caption>Special Values</caption> <tr>
<th scope="col"><code>x</code></th> <th scope="col">scalb(<code>x</code>)</th>
</tr> <tr>
<td>±∞</td> <td>±∞</td> </tr> <tr>
<td>±0.0</td> <td>±0.0</td> </tr> </table> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(scalbn(-real.infinity, 5)); // -real.infinity
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="cbrt">nothrow @nogc @trusted real cbrt(real x)</dt> <dd>
<p>Calculates the cube root of <code>x</code>. </p>
<p></p>
<table> <caption>Special Values</caption> <tr>
<th scope="col"><i><code>x</code></i></th> <th scope="col">
<code>cbrt</code>(<code>x</code>)</th> <th scope="col">invalid?</th>
</tr> <tr>
<td>±0.0</td> <td>±0.0</td> <td>no</td> </tr> <tr>
<td><span class="red">NAN</span></td> <td><span class="red">NAN</span></td> <td>yes</td> </tr> <tr>
<td>±∞</td> <td>±∞</td> <td>no</td> </tr> </table> </dd> <dt class="d_decl" id="fabs">pure nothrow @nogc @safe real fabs(real x)<br>pure nothrow @nogc @safe double fabs(double x)<br>pure nothrow @nogc @safe float fabs(float x)</dt> <dd>
<p>Returns |<code>x</code>| </p>
<p></p>
<table> <caption>Special Values</caption> <tr>
<th scope="col"><code>x</code></th> <th scope="col">
<code>fabs</code>(<code>x</code>)</th>
</tr> <tr>
<td>±0.0</td> <td>+0.0</td> </tr> <tr>
<td>±∞</td> <td>+∞</td> </tr> </table> </dd> <dt class="d_decl" id="hypot">pure nothrow @nogc @safe real hypot(real x, real y)</dt> <dd>
<p>Calculates the length of the hypotenuse of a right-angled triangle with sides of length <code>x</code> and <code>y</code>. The hypotenuse is the value of the square root of the sums of the squares of <code>x</code> and <code>y</code>: </p>
<p>sqrt(<code>x</code><sup>2</sup> + <code>y</code><sup>2</sup>) <br><br> Note that <code>hypot</code>(<code>x</code>, <code>y</code>), <code>hypot</code>(<code>y</code>, <code>x</code>) and <code>hypot</code>(<code>x</code>, -<code>y</code>) are equivalent. <br><br> </p>
<table> <caption>Special Values</caption> <tr>
<th scope="col"><code>x</code></th> <th scope="col"><code>y</code></th> <th scope="col">
<code>hypot</code>(<code>x</code>, <code>y</code>)</th> <th scope="col">invalid?</th>
</tr> <tr>
<td><code>x</code></td> <td>±0.0</td> <td>|<code>x</code>|</td> <td>no</td>
</tr> <tr>
<td>±∞</td> <td><code>y</code></td> <td>+∞</td> <td>no</td>
</tr> <tr>
<td>±∞</td> <td><span class="red">NAN</span></td> <td>+∞</td> <td>no</td>
</tr> </table> </dd> <dt class="d_decl" id="ceil">pure nothrow @nogc @trusted real ceil(real x)</dt> <dd>
<p>Returns the value of <code>x</code> rounded upward to the next integer (toward positive infinity).</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(ceil(+123.456L)); // +124
writeln(ceil(-123.456L)); // -123
writeln(ceil(-1.234L)); // -1
writeln(ceil(-0.123L)); // 0
writeln(ceil(0.0L)); // 0
writeln(ceil(+0.123L)); // 1
writeln(ceil(+1.234L)); // 2
writeln(ceil(real.infinity)); // real.infinity
assert(isNaN(ceil(real.nan)));
assert(isNaN(ceil(real.init)));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="floor">pure nothrow @nogc @trusted real floor(real x)</dt> <dd>
<p>Returns the value of <code>x</code> rounded downward to the next integer (toward negative infinity).</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(floor(+123.456L)); // +123
writeln(floor(-123.456L)); // -124
writeln(floor(-1.234L)); // -2
writeln(floor(-0.123L)); // -1
writeln(floor(0.0L)); // 0
writeln(floor(+0.123L)); // 0
writeln(floor(+1.234L)); // 1
writeln(floor(real.infinity)); // real.infinity
assert(isNaN(floor(real.nan)));
assert(isNaN(floor(real.init)));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="quantize">Unqual!F quantize(alias rfunc = rint, F)(const F val, const F unit)<br><br>  Constraints:<br>    if (is(typeof(rfunc(F.init)) : F) &amp;&amp; isFloatingPoint!F)</dt> <dd>
<p>Round <code>val</code> to a multiple of <code>unit</code>. <code>rfunc</code> specifies the rounding function to use; by default this is <code>rint</code>, which uses the current rounding mode.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(12345.6789L.quantize(0.01L)); // 12345.68L
writeln(12345.6789L.quantize!floor(0.01L)); // 12345.67L
writeln(12345.6789L.quantize(22.0L)); // 12342.0L
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(12345.6789L.quantize(0)); // 12345.6789L
assert(12345.6789L.quantize(real.infinity).isNaN);
assert(12345.6789L.quantize(real.nan).isNaN);
writeln(real.infinity.quantize(0.01L)); // real.infinity
assert(real.infinity.quantize(real.nan).isNaN);
assert(real.nan.quantize(0.01L).isNaN);
assert(real.nan.quantize(real.infinity).isNaN);
assert(real.nan.quantize(real.nan).isNaN);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="quantize.2">Unqual!F quantize(real base, alias rfunc = rint, F, E)(const F val, const E exp)<br>Unqual!F quantize(real base, long exp = 1, alias rfunc = rint, F)(const F val)<br><br>  Constraints:<br>    if (is(typeof(rfunc(F.init)) : F) &amp;&amp; isFloatingPoint!F &amp;&amp; isIntegral!E)<br>    if (is(typeof(rfunc(F.init)) : F) &amp;&amp; isFloatingPoint!F)</dt> <dd>
<p>Round <code>val</code> to a multiple of <code>pow(base, exp)</code>. <code>rfunc</code> specifies the rounding function to use; by default this is <code>rint</code>, which uses the current rounding mode.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(12345.6789L.quantize!10(-2)); // 12345.68L
writeln(12345.6789L.quantize!(10, -2)); // 12345.68L
writeln(12345.6789L.quantize!(10, floor)(-2)); // 12345.67L
writeln(12345.6789L.quantize!(10, -2, floor)); // 12345.67L

writeln(12345.6789L.quantize!22(1)); // 12342.0L
writeln(12345.6789L.quantize!22); // 12342.0L
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="nearbyint">nothrow @nogc @trusted real nearbyint(real x)</dt> <dd>
<p>Rounds <code>x</code> to the nearest integer value, using the current rounding mode. </p>
<p>Unlike the rint functions, <code>nearbyint</code> does not raise the FE_INEXACT exception.</p> </dd> <dt class="d_decl" id="rint">pure nothrow @nogc @safe real rint(real x)<br>pure nothrow @nogc @safe double rint(double x)<br>pure nothrow @nogc @safe float rint(float x)</dt> <dd>
<p>Rounds <code>x</code> to the nearest integer value, using the current rounding mode. If the return value is not equal to <code>x</code>, the FE_INEXACT exception is raised. <b>nearbyint</b> performs the same operation, but does not set the FE_INEXACT exception.</p> </dd> <dt class="d_decl" id="lrint">pure nothrow @nogc @trusted long lrint(real x)</dt> <dd>
<p>Rounds <code>x</code> to the nearest integer value, using the current rounding mode. </p>
<p>This is generally the fastest method to convert a floating-point number to an integer. Note that the results from this function depend on the rounding mode, if the fractional part of <code>x</code> is exactly 0.5. If using the default rounding mode (ties round to even integers) <code>lrint</code>(4.5) == 4, <code>lrint</code>(5.5)==6.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(lrint(4.5)); // 4
writeln(lrint(5.5)); // 6
writeln(lrint(-4.5)); // -4
writeln(lrint(-5.5)); // -6

writeln(lrint(int.max - 0.5)); // 2147483646L
writeln(lrint(int.max + 0.5)); // 2147483648L
writeln(lrint(int.min - 0.5)); // -2147483648L
writeln(lrint(int.min + 0.5)); // -2147483648L
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="round">nothrow @nogc @trusted real round(real x)</dt> <dd>
<p>Return the value of <code>x</code> rounded to the nearest integer. If the fractional part of <code>x</code> is exactly 0.5, the return value is rounded away from zero.</p> </dd> <dt class="d_decl" id="lround">nothrow @nogc @trusted long lround(real x)</dt> <dd>
<p>Return the value of <code>x</code> rounded to the nearest integer. </p>
<p>If the fractional part of <code>x</code> is exactly 0.5, the return value is rounded away from zero. <br><br> <span class="blue">This function is Posix-Only.</span></p> </dd> <dt class="d_decl" id="trunc">nothrow @nogc @trusted real trunc(real x)</dt> <dd>
<p>Returns the integer portion of <code>x</code>, dropping the fractional portion. </p>
<p>This is also known as "chop" rounding.</p> </dd> <dt class="d_decl" id="remainder">nothrow @nogc @trusted real remainder(real x, real y)</dt> <dd>
<p>Calculate the <code>remainder</code> <code>x</code> REM <code>y</code>, following IEC 60559. </p>
<p>REM is the value of <code>x</code> - <code>y</code> * n, where n is the integer nearest the exact value of <code>x</code> / <code>y</code>. If |n - <code>x</code> / <code>y</code>| == 0.5, n is even. If the result is zero, it has the same sign as <code>x</code>. Otherwise, the sign of the result is the sign of <code>x</code> / <code>y</code>. Precision mode has no effect on the <code>remainder</code> functions. <br><br> remquo returns n in the parameter n. <br><br> </p>
<table> <caption>Special Values</caption> <tr>
<th scope="col"><code>x</code></th> <th scope="col"><code>y</code></th> <th scope="col">
<code>remainder</code>(<code>x</code>, <code>y</code>)</th> <th scope="col">n</th> <th scope="col">invalid?</th>
</tr> <tr>
<td>±0.0</td> <td>not 0.0</td> <td>±0.0</td> <td>0.0</td> <td>no</td>
</tr> <tr>
<td>±∞</td> <td>anything</td> <td><span class="red">NAN</span></td> <td>?</td> <td>yes</td>
</tr> <tr>
<td>anything</td> <td>±0.0</td> <td><span class="red">NAN</span></td> <td>?</td> <td>yes</td>
</tr> <tr>
<td>!= ±∞</td> <td>±∞</td> <td><code>x</code></td> <td>?</td> <td>no</td>
</tr> </table> <br><br> <span class="blue"><code>remquo</code> and <code>remainder</code> not supported on Windows.</span> </dd> <dt class="d_decl" id="IeeeFlags">struct IeeeFlags</dt> <dd>
<p>IEEE exception status flags ('sticky bits') </p>
<p>These flags indicate that an exceptional floating-point condition has occurred. They indicate that a NaN or an infinity has been generated, that a result is inexact, or that a signalling NaN has been encountered. If floating-point exceptions are enabled (unmasked), a hardware exception will be generated instead of setting these flags.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static void func() {
    int a = 10 * 10;
}

real a=3.5;
// Set all the flags to zero
resetIeeeFlags();
assert(!ieeeFlags.divByZero);
// Perform a division by zero.
a/=0.0L;
writeln(a); // real.infinity
assert(ieeeFlags.divByZero);
// Create a NaN
a*=0.0L;
assert(ieeeFlags.invalid);
assert(isNaN(a));

// Check that calling func() has no effect on the
// status flags.
IeeeFlags f = ieeeFlags;
func();
writeln(ieeeFlags); // f
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="IeeeFlags.inexact">const @property bool inexact()</dt> <dd>
<p>The result cannot be represented exactly, so rounding occurred. </p>
<dl>
<dt>Example</dt>
<dd> <code>x = sin(0.1);</code>
</dd>
</dl> </dd> <dt class="d_decl" id="IeeeFlags.underflow">const @property bool underflow()</dt> <dd>
<p>A zero was generated by <code>underflow</code> </p>
<dl>
<dt>Example</dt>
<dd> <code>x = real.min*real.epsilon/2;</code>
</dd>
</dl> </dd> <dt class="d_decl" id="IeeeFlags.overflow">const @property bool overflow()</dt> <dd>
<p>An infinity was generated by <code>overflow</code> </p>
<dl>
<dt>Example</dt>
<dd> <code>x = real.max*2;</code>
</dd>
</dl> </dd> <dt class="d_decl" id="IeeeFlags.divByZero">const @property bool divByZero()</dt> <dd>
<p>An infinity was generated by division by zero </p>
<dl>
<dt>Example</dt>
<dd> <code>x = 3/0.0;</code>
</dd>
</dl> </dd> <dt class="d_decl" id="IeeeFlags.invalid">const @property bool invalid()</dt> <dd>
<p>A machine NaN was generated. </p>
<dl>
<dt>Example</dt>
<dd> <code>x = real.infinity * 0.0;</code>
</dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="resetIeeeFlags">@nogc void resetIeeeFlags()</dt> <dd>
<p>Set all of the floating-point status flags to <code>false</code>.</p> </dd> <dt class="d_decl" id="ieeeFlags">@property IeeeFlags ieeeFlags()</dt> <dd>
<dl>
<dt>Returns:</dt>
<dd>snapshot of the current state of the floating-point status flags</dd>
</dl> </dd> <dt class="d_decl" id="FloatingPointControl">struct FloatingPointControl</dt> <dd>
<p>Control the Floating point hardware </p>
<p>Change the IEEE754 floating-point rounding mode and the floating-point hardware exceptions. <br><br> By default, the rounding mode is roundToNearest and all hardware exceptions are disabled. For most applications, debugging is easier if the <i>division by zero</i>, <i>overflow</i>, and <i>invalid operation</i> exceptions are enabled. These three are combined into a <i>severeExceptions</i> value for convenience. Note in particular that if <i>invalidException</i> is enabled, a hardware trap will be generated whenever an uninitialized floating-point variable is used. <br><br> All changes are temporary. The previous state is restored at the end of the scope. <br><br> </p> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">{
    FloatingPointControl fpctrl;

    // Enable hardware exceptions for division by zero, overflow to infinity,
    // invalid operations, and uninitialized floating-point variables.
    fpctrl.enableExceptions(FloatingPointControl.severeExceptions);

    // This will generate a hardware exception, if x is a
    // default-initialized floating point variable:
    real x; // Add `= 0` or even `= real.nan` to not throw the exception.
    real y = x * 3.0;

    // The exception is only thrown for default-uninitialized NaN-s.
    // NaN-s with other payload are valid:
    real z = y * real.nan; // ok

    // Changing the rounding mode:
    fpctrl.rounding = FloatingPointControl.roundUp;
    assert(rint(1.1) == 2);

    // The set hardware exceptions will be disabled when leaving this scope.
    // The original rounding mode will also be restored.
}

// Ensure previous values are returned:
assert(!FloatingPointControl.enabledExceptions);
assert(FloatingPointControl.rounding == FloatingPointControl.roundToNearest);
assert(rint(1.1) == 1);
</pre>  <dl>
<dt class="d_decl" id="FloatingPointControl.RoundingMode">alias RoundingMode = uint</dt>  <dt class="d_decl" id="FloatingPointControl.roundToNearest">roundToNearestroundDownroundUproundToZero</dt> <dd>
<p>IEEE rounding modes. The default mode is <code>roundToNearest</code>.</p> </dd> <dt class="d_decl" id="FloatingPointControl.rounding">@nogc @property void rounding(RoundingMode newMode)</dt> <dd>
<p>Change the floating-point hardware <code>rounding</code> mode</p> </dd> <dt class="d_decl" id="FloatingPointControl.rounding.2">static @nogc @property RoundingMode rounding()</dt> <dd>
<dl>
<dt>Returns:</dt>
<dd>the currently active <code>rounding</code> mode</dd>
</dl> </dd> <dt class="d_decl" id="FloatingPointControl.subnormalException">subnormalExceptioninexactExceptionunderflowExceptionoverflowExceptiondivByZeroExceptioninvalidExceptionsevereExceptionsallExceptions</dt> <dd>
<p>IEEE hardware exceptions. By default, all exceptions are masked (disabled). </p>
<p><code>severeExceptions</code> = The overflow, division by zero, and invalid exceptions.</p> </dd> <dt class="d_decl" id="FloatingPointControl.hasExceptionTraps">static nothrow @nogc @property @safe bool hasExceptionTraps()</dt> <dd>
<dl>
<dt>Returns:</dt>
<dd>
<code>true</code> if the current FPU supports exception trapping</dd>
</dl> </dd> <dt class="d_decl" id="FloatingPointControl.enableExceptions">@nogc void enableExceptions(uint exceptions)</dt> <dd>
<p>Enable (unmask) specific hardware <code>exceptions</code>. Multiple <code>exceptions</code> may be ORed together.</p> </dd> <dt class="d_decl" id="FloatingPointControl.disableExceptions">@nogc void disableExceptions(uint exceptions)</dt> <dd>
<p>Disable (mask) specific hardware <code>exceptions</code>. Multiple <code>exceptions</code> may be ORed together.</p> </dd> <dt class="d_decl" id="FloatingPointControl.enabledExceptions">static @nogc @property uint enabledExceptions()</dt> <dd>
<dl>
<dt>Returns:</dt>
<dd>the exceptions which are currently enabled (unmasked)</dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="isNaN">pure nothrow @nogc @trusted bool isNaN(X)(X x)<br><br>  Constraints:<br>    if (isFloatingPoint!X)</dt> <dd>
<p>Determines if <span class="d_param"><code>x</code></span> is NaN. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>X <code>x</code>
</td> <td>a floating point number.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>true</code> if <span class="d_param"><code>x</code></span> is Nan.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert( isNaN(float.init));
assert( isNaN(-double.init));
assert( isNaN(real.nan));
assert( isNaN(-real.nan));
assert(!isNaN(cast(float) 53.6));
assert(!isNaN(cast(real)-53.6));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isFinite">pure nothrow @nogc @trusted bool isFinite(X)(X x)</dt> <dd>
<p>Determines if <span class="d_param"><code>x</code></span> is finite. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>X <code>x</code>
</td> <td>a floating point number.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>true</code> if <span class="d_param"><code>x</code></span> is finite.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert( isFinite(1.23f));
assert( isFinite(float.max));
assert( isFinite(float.min_normal));
assert(!isFinite(float.nan));
assert(!isFinite(float.infinity));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isNormal">pure nothrow @nogc @trusted bool isNormal(X)(X x)</dt> <dd>
<p>Determines if <span class="d_param"><code>x</code></span> is normalized. </p>
<p>A normalized number must not be zero, subnormal, infinite nor <span class="red">NAN</span>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>X <code>x</code>
</td> <td>a floating point number.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>true</code> if <span class="d_param"><code>x</code></span> is normalized.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">float f = 3;
double d = 500;
real e = 10e+48;

assert(isNormal(f));
assert(isNormal(d));
assert(isNormal(e));
f = d = e = 0;
assert(!isNormal(f));
assert(!isNormal(d));
assert(!isNormal(e));
assert(!isNormal(real.infinity));
assert(isNormal(-real.max));
assert(!isNormal(real.min_normal/4));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isSubnormal">pure nothrow @nogc @trusted bool isSubnormal(X)(X x)</dt> <dd>
<p>Determines if <span class="d_param"><code>x</code></span> is subnormal. </p>
<p>Subnormals (also known as "denormal number"), have a 0 exponent and a 0 most significant mantissa bit. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>X <code>x</code>
</td> <td>a floating point number.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>true</code> if <span class="d_param"><code>x</code></span> is a denormal number.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.meta : AliasSeq;

foreach (T; AliasSeq!(float, double, real))
{
    T f;
    for (f = 1.0; !isSubnormal(f); f /= 2)
        assert(f != 0);
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isInfinity">pure nothrow @nogc @trusted bool isInfinity(X)(X x)<br><br>  Constraints:<br>    if (isFloatingPoint!X)</dt> <dd>
<p>Determines if <span class="d_param"><code>x</code></span> is ±∞. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>X <code>x</code>
</td> <td>a floating point number.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>true</code> if <span class="d_param"><code>x</code></span> is ±∞.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(!isInfinity(float.init));
assert(!isInfinity(-float.init));
assert(!isInfinity(float.nan));
assert(!isInfinity(-float.nan));
assert(isInfinity(float.infinity));
assert(isInfinity(-float.infinity));
assert(isInfinity(-1.0f / 0.0f));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isIdentical">pure nothrow @nogc @trusted bool isIdentical(real x, real y)</dt> <dd>
<p>Is the binary representation of <code>x</code> identical to <code>y</code>? </p>
<p>Same as ==, except that positive and negative zero are not identical, and two <span class="red">NAN</span>s are identical if they have the same 'payload'.</p> </dd> <dt class="d_decl" id="signbit">pure nothrow @nogc @trusted int signbit(X)(X x)</dt> <dd>
<p>Return 1 if sign bit of e is set, 0 if not.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(!signbit(float.nan));
assert(signbit(-float.nan));
assert(!signbit(168.1234f));
assert(signbit(-168.1234f));
assert(!signbit(0.0f));
assert(signbit(-0.0f));
assert(signbit(-float.max));
assert(!signbit(float.max));

assert(!signbit(double.nan));
assert(signbit(-double.nan));
assert(!signbit(168.1234));
assert(signbit(-168.1234));
assert(!signbit(0.0));
assert(signbit(-0.0));
assert(signbit(-double.max));
assert(!signbit(double.max));

assert(!signbit(real.nan));
assert(signbit(-real.nan));
assert(!signbit(168.1234L));
assert(signbit(-168.1234L));
assert(!signbit(0.0L));
assert(signbit(-0.0L));
assert(signbit(-real.max));
assert(!signbit(real.max));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="copysign">pure nothrow @nogc @trusted R copysign(R, X)(R to, X from)<br><br>  Constraints:<br>    if (isFloatingPoint!R &amp;&amp; isFloatingPoint!X)</dt> <dd>
<p>Return a value composed of <code>to</code> with <code>from</code>'s sign bit.</p> </dd> <dt class="d_decl" id="sgn">pure nothrow @nogc @safe F sgn(F)(F x)</dt> <dd>
<p>Returns <code>-1</code> if <code>x &lt; 0</code>, <code>x</code> if <code>x == 0</code>, <code>1</code> if <code>x &gt; 0</code>, and <span class="red">NAN</span> if <code>x</code>==<span class="red">NAN</span>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(sgn(168.1234)); // 1
writeln(sgn(-168.1234)); // -1
writeln(sgn(0.0)); // 0
writeln(sgn(-0.0)); // 0
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="NaN">pure nothrow @nogc @trusted real NaN(ulong payload)</dt> <dd>
<p>Create a quiet <span class="red">NAN</span>, storing an integer inside the <code>payload</code>. </p>
<p>For floats, the largest possible <code>payload</code> is 0x3F_FFFF. For doubles, it is 0x3_FFFF_FFFF_FFFF. For 80-bit or 128-bit reals, it is 0x3FFF_FFFF_FFFF_FFFF.</p> </dd> <dt class="d_decl" id="getNaNPayload">pure nothrow @nogc @trusted ulong getNaNPayload(real x)</dt> <dd>
<p>Extract an integral payload from a <span class="red">NAN</span>. </p>
<dl>
<dt>Returns:</dt>
<dd>the integer payload as a ulong.  For floats, the largest possible payload is 0x3F_FFFF. For doubles, it is 0x3_FFFF_FFFF_FFFF. For 80-bit or 128-bit reals, it is 0x3FFF_FFFF_FFFF_FFFF.</dd>
</dl> </dd> <dt class="d_decl" id="nextUp">pure nothrow @nogc @trusted real nextUp(real x)<br>pure nothrow @nogc @trusted double nextUp(double x)<br>pure nothrow @nogc @trusted float nextUp(float x)</dt> <dd>
<p>Calculate the next largest floating point value after <code>x</code>. </p>
<p>Return the least number greater than <code>x</code> that is representable as a real; thus, it gives the next point on the IEEE number line. <br><br> </p>
<table> <caption>Special Values</caption> <tr>
<th scope="col"><code>x</code></th> <th scope="col"> <code>nextUp</code>(<code>x</code>) </th>
</tr> <tr>
<td> -∞</td> <td> -real.max </td>
</tr> <tr>
<td> ±0.0</td> <td>real.min_normal*real.epsilon </td>
</tr> <tr>
<td> real.max</td> <td> ∞ </td>
</tr> <tr>
<td> ∞</td> <td> ∞ </td>
</tr> <tr>
<td> <span class="red">NAN</span>
</td> <td> <span class="red">NAN</span> </td>
</tr> </table> </dd> <dt class="d_decl" id="nextDown">pure nothrow @nogc @safe real nextDown(real x)<br>pure nothrow @nogc @safe double nextDown(double x)<br>pure nothrow @nogc @safe float nextDown(float x)</dt> <dd>
<p>Calculate the next smallest floating point value before <code>x</code>. </p>
<p>Return the greatest number less than <code>x</code> that is representable as a real; thus, it gives the previous point on the IEEE number line. <br><br> </p>
<table> <caption>Special Values</caption> <tr>
<th scope="col"><code>x</code></th> <th scope="col"> <code>nextDown</code>(<code>x</code>) </th>
</tr> <tr>
<td> ∞</td> <td> real.max </td>
</tr> <tr>
<td> ±0.0</td> <td>-real.min_normal*real.epsilon </td>
</tr> <tr>
<td> -real.max</td> <td> -∞ </td>
</tr> <tr>
<td> -∞</td> <td> -∞ </td>
</tr> <tr>
<td> <span class="red">NAN</span>
</td> <td> <span class="red">NAN</span> </td>
</tr> </table> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(nextDown(1.0 + real.epsilon)); // 1.0
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="nextafter">pure nothrow @nogc @safe T nextafter(T)(const T x, const T y)</dt> <dd>
<p>Calculates the next representable value after <code>x</code> in the direction of <code>y</code>. </p>
<p>If <code>y</code> &gt; <code>x</code>, the result will be the next largest floating-point value; if <code>y</code> &lt; <code>x</code>, the result will be the next smallest value. If <code>x</code> == <code>y</code>, the result is <code>y</code>. </p> <dl>
<dt>Remarks</dt>
<dd> This function is not generally very useful; it's almost always better to use the faster functions nextUp() or nextDown() instead. </dd>
</dl> The FE_INEXACT and FE_OVERFLOW exceptions will be raised if <code>x</code> is finite and the function result is infinite. The FE_INEXACT and FE_UNDERFLOW exceptions will be raised if the function value is subnormal, and <code>x</code> is not equal to <code>y</code>. <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">float a = 1;
assert(is(typeof(nextafter(a, a)) == float));
assert(nextafter(a, a.infinity) &gt; a);

double b = 2;
assert(is(typeof(nextafter(b, b)) == double));
assert(nextafter(b, b.infinity) &gt; b);

real c = 3;
assert(is(typeof(nextafter(c, c)) == real));
assert(nextafter(c, c.infinity) &gt; c);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="fdim">pure nothrow @nogc @safe real fdim(real x, real y)</dt> <dd>
<p>Returns the positive difference between <code>x</code> and <code>y</code>. </p>
<dl>
<dt>Returns:</dt>
<dd><table> <caption>Special Values</caption> <tr>
<th scope="col">
<code>x</code>, <code>y</code>
</th> <th scope="col">
<code>fdim</code>(<code>x</code>, <code>y</code>)</th>
</tr> <tr>
<td>
<code>x</code> &gt; <code>y</code>
</td> <td>
<code>x</code> - <code>y</code>
</td>
</tr> <tr>
<td>
<code>x</code> &lt;= <code>y</code>
</td> <td>+0.0</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="fmax">pure nothrow @nogc @safe real fmax(real x, real y)</dt> <dd>
<p>Returns the larger of <code>x</code> and <code>y</code>.</p> </dd> <dt class="d_decl" id="fmin">pure nothrow @nogc @safe real fmin(real x, real y)</dt> <dd>
<p>Returns the smaller of <code>x</code> and <code>y</code>.</p> </dd> <dt class="d_decl" id="fma">pure nothrow @nogc @safe real fma(real x, real y, real z)</dt> <dd>
<p>Returns (<code>x</code> * <code>y</code>) + <code>z</code>, rounding only once according to the current rounding mode. </p>
<dl>
<dt>Bugs:</dt>
<dd>Not currently implemented - rounds twice.</dd>
</dl> </dd> <dt class="d_decl" id="pow">pure nothrow @nogc @trusted Unqual!F pow(F, G)(F x, G n)<br><br>  Constraints:<br>    if (isFloatingPoint!F &amp;&amp; isIntegral!G)</dt> <dd>
<p>Compute the value of <code>x</code> <sup><code>n</code></sup>, where <code>n</code> is an integer</p> </dd> <dt class="d_decl" id="pow.2">pure nothrow @nogc @trusted typeof(Unqual!F.init * Unqual!G.init) pow(F, G)(F x, G n)<br><br>  Constraints:<br>    if (isIntegral!F &amp;&amp; isIntegral!G)</dt> <dd>
<p>Compute the value of an integer <code>x</code>, raised to the power of a positive integer <code>n</code>. </p>
<p>If both <code>x</code> and <code>n</code> are 0, the result is 1. If <code>n</code> is negative, an integer divide error will occur at runtime, regardless of the value of <code>x</code>.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">immutable int one = 1;
immutable byte two = 2;
immutable ubyte three = 3;
immutable short four = 4;
immutable long ten = 10;

writeln(pow(two, three)); // 8
writeln(pow(two, ten)); // 1024
writeln(pow(one, ten)); // 1
writeln(pow(ten, four)); // 10_000
writeln(pow(four, 10)); // 1_048_576
writeln(pow(three, four)); // 81
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="pow.3">pure nothrow @nogc @trusted real pow(I, F)(I x, F y)<br><br>  Constraints:<br>    if (isIntegral!I &amp;&amp; isFloatingPoint!F)</dt> <dd>
<p>Computes integer to floating point powers.</p> </dd> <dt class="d_decl" id="pow.4">pure nothrow @nogc @trusted Unqual!(Largest!(F, G)) pow(F, G)(F x, G y)<br><br>  Constraints:<br>    if (isFloatingPoint!F &amp;&amp; isFloatingPoint!G)</dt> <dd>
<p>Calculates <code>x</code><sup><code>y</code></sup>. </p>
<p></p>
<table> <caption>Special Values</caption> <tr>
<th scope="col"><code>x</code></th> <th scope="col"><code>y</code></th> <th scope="col">
<code>pow</code>(<code>x</code>, <code>y</code>)</th> <th scope="col">div 0</th> <th scope="col">invalid?</th>
</tr> <tr>
<td>anything</td> <td>±0.0</td> <td>1.0</td> <td>no</td> <td>no</td> </tr> <tr>
<td>|<code>x</code>| &gt; 1</td> <td>+∞</td> <td>+∞</td> <td>no</td> <td>no</td> </tr> <tr>
<td>|<code>x</code>| &lt; 1</td> <td>+∞</td> <td>+0.0</td> <td>no</td> <td>no</td> </tr> <tr>
<td>|<code>x</code>| &gt; 1</td> <td>-∞</td> <td>+0.0</td> <td>no</td> <td>no</td> </tr> <tr>
<td>|<code>x</code>| &lt; 1</td> <td>-∞</td> <td>+∞</td> <td>no</td> <td>no</td> </tr> <tr>
<td>+∞</td> <td>&gt; 0.0</td> <td>+∞</td> <td>no</td> <td>no</td> </tr> <tr>
<td>+∞</td> <td>&lt; 0.0</td> <td>+0.0</td> <td>no</td> <td>no</td> </tr> <tr>
<td>-∞</td> <td>odd integer &gt; 0.0</td> <td>-∞</td> <td>no</td> <td>no</td> </tr> <tr>
<td>-∞</td> <td>&gt; 0.0, not odd integer</td> <td>+∞</td> <td>no</td> <td>no</td>
</tr> <tr>
<td>-∞</td> <td>odd integer &lt; 0.0</td> <td>-0.0</td> <td>no</td> <td>no</td> </tr> <tr>
<td>-∞</td> <td>&lt; 0.0, not odd integer</td> <td>+0.0</td> <td>no</td> <td>no</td> </tr> <tr>
<td>±1.0</td> <td>±∞</td> <td><span class="red">NAN</span></td> <td>no</td> <td>yes</td> </tr> <tr>
<td>&lt; 0.0</td> <td>finite, nonintegral</td> <td><span class="red">NAN</span></td> <td>no</td> <td>yes</td>
</tr> <tr>
<td>±0.0</td> <td>odd integer &lt; 0.0</td> <td>±∞</td> <td>yes</td> <td>no</td> </tr> <tr>
<td>±0.0</td> <td>&lt; 0.0, not odd integer</td> <td>+∞</td> <td>yes</td> <td>no</td>
</tr> <tr>
<td>±0.0</td> <td>odd integer &gt; 0.0</td> <td>±0.0</td> <td>no</td> <td>no</td> </tr> <tr>
<td>±0.0</td> <td>&gt; 0.0, not odd integer</td> <td>+0.0</td> <td>no</td> <td>no</td> </tr> </table> </dd> <dt class="d_decl" id="feqrel">pure nothrow @nogc @trusted int feqrel(X)(const X x, const X y)<br><br>  Constraints:<br>    if (isFloatingPoint!X)</dt> <dd>
<p>To what precision is <code>x</code> equal to <code>y</code>? </p>
<dl>
<dt>Returns:</dt>
<dd>the number of mantissa bits which are equal in <code>x</code> and <code>y</code>. eg, 0x1.F8p+60 and 0x1.F1p+60 are equal to 5 bits of precision.  <table> <caption>Special Values</caption> <tr>
<th scope="col"><code>x</code></th> <th scope="col"><code>y</code></th> <th scope="col">
<code>feqrel</code>(<code>x</code>, <code>y</code>)</th>
</tr> <tr>
<td><code>x</code></td> <td><code>x</code></td> <td>real.mant_dig</td>
</tr> <tr>
<td><code>x</code></td> <td>&gt;= 2*<code>x</code>
</td> <td>0</td>
</tr> <tr>
<td><code>x</code></td> <td>&lt;= <code>x</code>/2</td> <td>0</td>
</tr> <tr>
<td><span class="red">NAN</span></td> <td>any</td> <td>0</td>
</tr> <tr>
<td>any</td> <td><span class="red">NAN</span></td> <td>0</td>
</tr> </table>
</dd>
</dl> </dd> <dt class="d_decl" id="poly">pure nothrow @nogc @trusted Unqual!(CommonType!(T1, T2)) poly(T1, T2)(T1 x, in T2[] A)<br><br>  Constraints:<br>    if (isFloatingPoint!T1 &amp;&amp; isFloatingPoint!T2)</dt> <dd>
<p>Evaluate polynomial <code>A</code>(<code>x</code>) = a<sub>0</sub> + a<sub>1</sub><code>x</code> + a<sub>2</sub><code>x</code><sup>2</sup> + a<sub>3</sub><code>x</code><sup>3</sup>; ... </p>
<p>Uses Horner's rule <code>A</code>(<code>x</code>) = a<sub>0</sub> + <code>x</code>(a<sub>1</sub> + <code>x</code>(a<sub>2</sub> + <code>x</code>(a<sub>3</sub> + ...))) </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T1 <code>x</code>
</td> <td>the value to evaluate.</td>
</tr> <tr>
<td>T2[] <code>A</code>
</td> <td>array of coefficients a<sub>0</sub>, a<sub>1</sub>, etc.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">real x = 3.1;
static real[] pp = [56.1, 32.7, 6];

writeln(poly(x, pp)); // (56.1L + (32.7L + 6.0L * x) * x)
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="approxEqual">bool approxEqual(T, U, V)(T lhs, U rhs, V maxRelDiff, V maxAbsDiff = 1e-05)</dt> <dd>
<p>Computes whether two values are approximately equal, admitting a maximum relative difference, and a maximum absolute difference. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T <code>lhs</code>
</td> <td>First item to compare.</td>
</tr> <tr>
<td>U <code>rhs</code>
</td> <td>Second item to compare.</td>
</tr> <tr>
<td>V <code>maxRelDiff</code>
</td> <td>Maximum allowable difference relative to <code>rhs</code>.</td>
</tr> <tr>
<td>V <code>maxAbsDiff</code>
</td> <td>Maximum absolute difference.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>true</code> if the two items are approximately equal under either criterium. If one item is a range, and the other is a single value, then the result is the logical and-ing of calling <code>approxEqual</code> on each element of the ranged item against the single item. If both items are ranges, then <code>approxEqual</code> returns <code>true</code> if and only if the ranges have the same number of elements and if <code>approxEqual</code> evaluates to <code>true</code> for each pair of elements.</dd>
</dl> </dd> <dt class="d_decl" id="approxEqual.2">bool approxEqual(T, U)(T lhs, U rhs)</dt> <dd>
<p>Returns <code>approxEqual(lhs, rhs, 1e-2, 1e-5)</code>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(approxEqual(1.0, 1.0099));
assert(!approxEqual(1.0, 1.011));
float[] arr1 = [ 1.0, 2.0, 3.0 ];
double[] arr2 = [ 1.001, 1.999, 3 ];
assert(approxEqual(arr1, arr2));

real num = real.infinity;
assert(num == real.infinity);  // Passes.
assert(approxEqual(num, real.infinity));  // Fails.
num = -real.infinity;
assert(num == -real.infinity);  // Passes.
assert(approxEqual(num, -real.infinity));  // Fails.

assert(!approxEqual(3, 0));
assert(approxEqual(3, 3));
assert(approxEqual(3.0, 3));
assert(approxEqual([3, 3, 3], 3.0));
assert(approxEqual([3.0, 3.0, 3.0], 3));
int a = 10;
assert(approxEqual(10, a));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="cmp">pure nothrow @nogc @trusted int cmp(T)(const(T) x, const(T) y)<br><br>  Constraints:<br>    if (isFloatingPoint!T)</dt> <dd>
<p>Defines a total order on all floating-point numbers. </p>
<p> The order is defined as follows: </p>
<ul> <li>All numbers in [-∞, +∞] are ordered the same way as by built-in comparison, with the exception of -0.0, which is less than +0.0;</li> <li>If the sign bit is set (that is, it's 'negative'), <span class="red">NAN</span> is less than any number; if the sign bit is not set (it is 'positive'), <span class="red">NAN</span> is greater than any number;</li> <li>
<span class="red">NAN</span>s of the same sign are ordered by the payload ('negative' ones - in reverse order).</li> </ul>  <dl>
<dt>Returns:</dt>
<dd>negative value if <code>x</code> precedes <code>y</code> in the order specified above; 0 if <code>x</code> and <code>y</code> are identical, and positive value otherwise. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="#isIdentical"><em class="tt">isIdentical</em></a> </dd>
</dl> <dl>
<dt>Standards:</dt>
<dd>Conforms to IEEE 754-2008</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Most numbers are ordered naturally. <pre data-language="d">assert(cmp(-double.infinity, -double.max) &lt; 0);
assert(cmp(-double.max, -100.0) &lt; 0);
assert(cmp(-100.0, -0.5) &lt; 0);
assert(cmp(-0.5, 0.0) &lt; 0);
assert(cmp(0.0, 0.5) &lt; 0);
assert(cmp(0.5, 100.0) &lt; 0);
assert(cmp(100.0, double.max) &lt; 0);
assert(cmp(double.max, double.infinity) &lt; 0);

writeln(cmp(1.0, 1.0)); // 0
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Positive and negative zeroes are distinct. <pre data-language="d">assert(cmp(-0.0, +0.0) &lt; 0);
assert(cmp(+0.0, -0.0) &gt; 0);
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Depending on the sign, <span class="red">NAN</span>s go to either end of the spectrum. <pre data-language="d">assert(cmp(-double.nan, -double.infinity) &lt; 0);
assert(cmp(double.infinity, double.nan) &lt; 0);
assert(cmp(-double.nan, double.nan) &lt; 0);
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<span class="red">NAN</span>s of the same sign are ordered by the payload. <pre data-language="d">assert(cmp(NaN(10), NaN(20)) &lt; 0);
assert(cmp(-NaN(20), -NaN(10)) &lt; 0);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="nextPow2">T nextPow2(T)(const T val)<br>T nextPow2(T)(const T val)<br><br>  Constraints:<br>    if (isIntegral!T)<br>    if (isFloatingPoint!T)</dt> <dd>
<p>Gives the next power of two after <code>val</code>. <code>T</code> can be any built-in numerical type. </p>
<p>If the operation would lead to an over/underflow, this function will return <code>0</code>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T <code>val</code>
</td> <td>any number</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>the next power of two after <code>val</code>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(nextPow2(2)); // 4
writeln(nextPow2(10)); // 16
writeln(nextPow2(4000)); // 4096

writeln(nextPow2(-2)); // -4
writeln(nextPow2(-10)); // -16

writeln(nextPow2(uint.max)); // 0
writeln(nextPow2(uint.min)); // 0
writeln(nextPow2(size_t.max)); // 0
writeln(nextPow2(size_t.min)); // 0

writeln(nextPow2(int.max)); // 0
writeln(nextPow2(int.min)); // 0
writeln(nextPow2(long.max)); // 0
writeln(nextPow2(long.min)); // 0
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(nextPow2(2.1)); // 4.0
writeln(nextPow2(-2.0)); // -4.0
writeln(nextPow2(0.25)); // 0.5
writeln(nextPow2(-4.0)); // -8.0

writeln(nextPow2(double.max)); // 0.0
writeln(nextPow2(double.infinity)); // double.infinity
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="truncPow2">T truncPow2(T)(const T val)<br>T truncPow2(T)(const T val)<br><br>  Constraints:<br>    if (isIntegral!T)<br>    if (isFloatingPoint!T)</dt> <dd>
<p>Gives the last power of two before <code>val</code>. &lt;&gt;&gt; can be any built-in numerical type. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T <code>val</code>
</td> <td>any number</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>the last power of two before <code>val</code>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(truncPow2(3)); // 2
writeln(truncPow2(4)); // 4
writeln(truncPow2(10)); // 8
writeln(truncPow2(4000)); // 2048

writeln(truncPow2(-5)); // -4
writeln(truncPow2(-20)); // -16

writeln(truncPow2(uint.max)); // int.max + 1
writeln(truncPow2(uint.min)); // 0
writeln(truncPow2(ulong.max)); // long.max + 1
writeln(truncPow2(ulong.min)); // 0

writeln(truncPow2(int.max)); // (int.max / 2) + 1
writeln(truncPow2(int.min)); // int.min
writeln(truncPow2(long.max)); // (long.max / 2) + 1
writeln(truncPow2(long.min)); // long.min
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(truncPow2(2.1)); // 2.0
writeln(truncPow2(7.0)); // 4.0
writeln(truncPow2(-1.9)); // -1.0
writeln(truncPow2(0.24)); // 0.125
writeln(truncPow2(-7.0)); // -4.0

writeln(truncPow2(double.infinity)); // double.infinity
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isPowerOf2">pure nothrow @nogc @safe bool isPowerOf2(X)(const X x)<br><br>  Constraints:<br>    if (isNumeric!X)</dt> <dd>
<p>Check whether a number is an integer power of two. </p>
<p>Note that only positive numbers can be integer powers of two. This function always return <code>false</code> if <code>x</code> is negative or zero. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>X <code>x</code>
</td> <td>the number to test</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>true</code> if <code>x</code> is an integer power of two.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert( isPowerOf2(1.0L));
assert( isPowerOf2(2.0L));
assert( isPowerOf2(0.5L));
assert( isPowerOf2(pow(2.0L, 96)));
assert( isPowerOf2(pow(2.0L, -77)));

assert(!isPowerOf2(-2.0L));
assert(!isPowerOf2(-0.5L));
assert(!isPowerOf2(0.0L));
assert(!isPowerOf2(4.315));
assert(!isPowerOf2(1.0L / 3.0L));

assert(!isPowerOf2(real.nan));
assert(!isPowerOf2(real.infinity));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert( isPowerOf2(1));
assert( isPowerOf2(2));
assert( isPowerOf2(1uL &lt;&lt; 63));

assert(!isPowerOf2(-4));
assert(!isPowerOf2(0));
assert(!isPowerOf2(1337u));
</pre> </dd>
</dl> </dd> </dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 1999–2017 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/phobos/std_math.html" class="_attribution-link" target="_blank">https://dlang.org/phobos/std_math.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
