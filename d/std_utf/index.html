
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>std.utf - D - W3cubDocs</title>
  
  <meta name="description" content=" Encode and decode UTF-8, UTF-16 and UTF-32 strings. ">
  <meta name="keywords" content="std, utf, -, d">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/d/std_utf/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-e0f881b0fce8cbe96f33dadc355b7159d5d2912911231446d60eb8f9caffa802.css">
  <script type="text/javascript" src="/assets/application-8fc46316434047265cd383f02b8e7f434ed7dec4a59f920dd633deef8d488d1b.js"></script>
  <script src="/json/d.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/d/" class="_nav-link" title="" style="margin-left:0;">D</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _d">
				
<h1>std.utf</h1>  <p>Encode and decode UTF-8, UTF-16 and UTF-32 strings. </p>
<p>UTF character support is restricted to <code>'\u0000' &lt;= character &lt;= '\U0010FFFF'</code>. <br><br>  </p>
<table>

<tr>
<th scope="col">Category</th> <th scope="col">Functions</th>
</tr> <tr>
<td>Decode</td> <td> <a href="#decode"><code>decode</code></a> <a href="#decodeFront"><code>decodeFront</code></a> </td>
</tr> <tr>
<td>Lazy decode</td> <td> <a href="#byCodeUnit"><code>byCodeUnit</code></a> <a href="#byChar"><code>byChar</code></a> <a href="#byWchar"><code>byWchar</code></a> <a href="#byDchar"><code>byDchar</code></a> <a href="#byUTF"><code>byUTF</code></a> </td>
</tr> <tr>
<td>Encode</td> <td> <a href="#encode"><code>encode</code></a> <a href="#toUTF8"><code>toUTF8</code></a> <a href="#toUTF16"><code>toUTF16</code></a> <a href="#toUTF32"><code>toUTF32</code></a> <a href="#toUTFz"><code>toUTFz</code></a> <a href="#toUTF16z"><code>toUTF16z</code></a> </td>
</tr> <tr>
<td>Length</td> <td> <a href="#codeLength"><code>codeLength</code></a> <a href="#count"><code>count</code></a> <a href="#stride"><code>stride</code></a> <a href="#strideBack"><code>strideBack</code></a> </td>
</tr> <tr>
<td>Index</td> <td> <a href="#toUCSindex"><code>toUCSindex</code></a> <a href="#toUTFindex"><code>toUTFindex</code></a> </td>
</tr> <tr>
<td>Validation</td> <td> <a href="#isValidDchar"><code>isValidDchar</code></a> <a href="#validate"><code>validate</code></a> </td>
</tr> <tr>
<td>Miscellaneous</td> <td> <a href="#replacementDchar"><code>replacementDchar</code></a> <a href="#UseReplacementDchar"><code>UseReplacementDchar</code></a> <a href="#UTFException"><code>UTFException</code></a> </td>
</tr> </table>  <dl>
<dt>See Also:</dt>
<dd>
<a href="http://en.wikipedia.org/wiki/Unicode" target="_blank">Wikipedia</a><br> <a href="http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8" target="_blank">http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8</a><br> <a href="http://anubis.dkuug.dk/JTC1/SC2/WG2/docs/n1335" target="_blank">http://anubis.dkuug.dk/JTC1/SC2/WG2/docs/n1335</a> </dd>
</dl> <dl>
<dt>License:</dt>
<dd>
<a href="http://www.boost.org/LICENSE_1_0.txt" target="_blank">Boost License 1.0</a>. </dd>
</dl> <dl>
<dt>Authors:</dt>
<dd>
<a href="http://digitalmars.com" target="_blank">Walter Bright</a> and Jonathan M Davis </dd>
</dl> <dl>
<dt>Source</dt>
<dd> <span class="phobos_src"><a class="https" href="https://github.com/dlang/phobos/blob/master/std/utf.d" target="_blank">std/utf.d</a></span>
</dd>
</dl> <dl>
<dt class="d_decl" id="UTFException">class UTFException: object.Exception</dt> <dd>
<p>Exception thrown on errors in std.utf functions.</p> </dd> <dt class="d_decl" id="isValidDchar">pure nothrow @nogc @safe bool isValidDchar(dchar c)</dt> <dd>
<p>Check whether the given Unicode code point is valid. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>dchar <code>c</code>
</td> <td>code point to check</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>true</code> iff <code>c</code> is a valid Unicode code point </dd>
</dl> <dl>
<dt>Note</dt>
<dd> <code>'\uFFFE'</code> and <code>'\uFFFF'</code> are considered valid by <code>isValidDchar</code>, as they are permitted for internal use by an application, but they are not allowed for interchange by the Unicode standard.</dd>
</dl> </dd> <dt class="d_decl" id="stride">uint stride(S)(auto ref S str, size_t index)<br>uint stride(S)(auto ref S str)<br>uint stride(S)(auto ref S str, size_t index)<br>pure @safe uint stride(S)(auto ref S str)<br>uint stride(S)(auto ref S str)<br>uint stride(S)(auto ref S str, size_t index = 0)<br><br>  Constraints:<br>    if (is(S : const(char[])) || isRandomAccessRange!S &amp;&amp; is(Unqual!(ElementType!S) == char))<br>    if (is(S : const(char[])) || isInputRange!S &amp;&amp; is(Unqual!(ElementType!S) == char))<br>    if (is(S : const(wchar[])) || isRandomAccessRange!S &amp;&amp; is(Unqual!(ElementType!S) == wchar))<br>    if (is(S : const(wchar[])))<br>    if (isInputRange!S &amp;&amp; is(Unqual!(ElementType!S) == wchar))<br>    if (is(S : const(dchar[])) || isInputRange!S &amp;&amp; is(Unqual!(ElementEncodingType!S) == dchar))</dt> <dd>
<p>Calculate the length of the UTF sequence starting at <code>index</code> in <code>str</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>S <code>str</code>
</td> <td>input range of UTF code units. Must be random access if <code>index</code> is passed</td>
</tr> <tr>
<td>size_t <code>index</code>
</td> <td>starting <code>index</code> of UTF sequence (default: <code>0</code>)</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The number of code units in the UTF sequence. For UTF-8, this is a value between 1 and 4 (as per <a href="http://tools.ietf.org/html/rfc3629#section-3" target="_blank">RFC 3629, section 3</a>). For UTF-16, it is either 1 or 2. For UTF-32, it is always 1. </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>May throw a <code>UTFException</code> if <code>str[index]</code> is not the start of a valid UTF sequence. </dd>
</dl> <dl>
<dt>Note</dt>
<dd> <code>stride</code> will only analyze the first <code>str[index]</code> element. It will not fully verify the validity of the UTF sequence, nor even verify the presence of the sequence: it will not actually guarantee that <code>index + stride(str, index) &lt;= str.length</code>.</dd>
</dl> </dd> <dt class="d_decl" id="strideBack">uint strideBack(S)(auto ref S str, size_t index)<br>uint strideBack(S)(auto ref S str)<br>uint strideBack(S)(auto ref S str)<br>uint strideBack(S)(auto ref S str, size_t index)<br>uint strideBack(S)(auto ref S str)<br>uint strideBack(S)(auto ref S str, size_t index)<br>uint strideBack(S)(auto ref S str)<br><br>  Constraints:<br>    if (is(S : const(char[])) || isRandomAccessRange!S &amp;&amp; is(Unqual!(ElementType!S) == char))<br>    if (is(S : const(char[])) || isRandomAccessRange!S &amp;&amp; hasLength!S &amp;&amp; is(Unqual!(ElementType!S) == char))<br>    if (isBidirectionalRange!S &amp;&amp; is(Unqual!(ElementType!S) == char) &amp;&amp; !isRandomAccessRange!S)<br>    if (is(S : const(wchar[])) || isRandomAccessRange!S &amp;&amp; is(Unqual!(ElementType!S) == wchar))<br>    if (is(S : const(wchar[])) || isBidirectionalRange!S &amp;&amp; is(Unqual!(ElementType!S) == wchar))<br>    if (isRandomAccessRange!S &amp;&amp; is(Unqual!(ElementEncodingType!S) == dchar))<br>    if (isBidirectionalRange!S &amp;&amp; is(Unqual!(ElementEncodingType!S) == dchar))</dt> <dd>
<p>Calculate the length of the UTF sequence ending one code unit before <code>index</code> in <code>str</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>S <code>str</code>
</td> <td>bidirectional range of UTF code units. Must be random access if <code>index</code> is passed</td>
</tr> <tr>
<td>size_t <code>index</code>
</td> <td>
<code>index</code> one past end of UTF sequence (default: <code>str.length</code>)</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The number of code units in the UTF sequence. For UTF-8, this is a value between 1 and 4 (as per <a href="http://tools.ietf.org/html/rfc3629#section-3" target="_blank">RFC 3629, section 3</a>). For UTF-16, it is either 1 or 2. For UTF-32, it is always 1. </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>May throw a <code>UTFException</code> if <code>str[index]</code> is not one past the end of a valid UTF sequence. </dd>
</dl> <dl>
<dt>Note</dt>
<dd> <code>strideBack</code> will only analyze the element at <code>str[index - 1]</code> element. It will not fully verify the validity of the UTF sequence, nor even verify the presence of the sequence: it will not actually guarantee that <code>strideBack(str, index) &lt;= index</code>.</dd>
</dl> </dd> <dt class="d_decl" id="toUCSindex">pure @safe size_t toUCSindex(C)(const(C)[] str, size_t index)<br><br>  Constraints:<br>    if (isSomeChar!C)</dt> <dd>
<p>Given <code>index</code> into <code>str</code> and assuming that <code>index</code> is at the start of a UTF sequence, <code>toUCSindex</code> determines the number of UCS characters up to <code>index</code>. So, <code>index</code> is the <code>index</code> of a code unit at the beginning of a code point, and the return value is how many code points into the string that that code point is.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(toUCSindex(`hello world`, 7)); // 7
writeln(toUCSindex(`hello world`w, 7)); // 7
writeln(toUCSindex(`hello world`d, 7)); // 7

writeln(toUCSindex(`Ma Chérie`, 7)); // 6
writeln(toUCSindex(`Ma Chérie`w, 7)); // 7
writeln(toUCSindex(`Ma Chérie`d, 7)); // 7

writeln(toUCSindex(`さいごの果実 / ミツバチと科学者`, 9)); // 3
writeln(toUCSindex(`さいごの果実 / ミツバチと科学者`w, 9)); // 9
writeln(toUCSindex(`さいごの果実 / ミツバチと科学者`d, 9)); // 9
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="toUTFindex">pure @safe size_t toUTFindex(C)(const(C)[] str, size_t n)<br><br>  Constraints:<br>    if (isSomeChar!C)</dt> <dd>
<p>Given a UCS index <code>n</code> into <code>str</code>, returns the UTF index. So, <code>n</code> is how many code points into the string the code point is, and the array index of the code unit is returned.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(toUTFindex(`hello world`, 7)); // 7
writeln(toUTFindex(`hello world`w, 7)); // 7
writeln(toUTFindex(`hello world`d, 7)); // 7

writeln(toUTFindex(`Ma Chérie`, 6)); // 7
writeln(toUTFindex(`Ma Chérie`w, 7)); // 7
writeln(toUTFindex(`Ma Chérie`d, 7)); // 7

writeln(toUTFindex(`さいごの果実 / ミツバチと科学者`, 3)); // 9
writeln(toUTFindex(`さいごの果実 / ミツバチと科学者`w, 9)); // 9
writeln(toUTFindex(`さいごの果実 / ミツバチと科学者`d, 9)); // 9
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="UseReplacementDchar">alias UseReplacementDchar = std.typecons.Flag!"useReplacementDchar".Flag</dt> <dd>
<p>Whether or not to replace invalid UTF with <a href="#replacementDchar"><code>replacementDchar</code></a></p> </dd> <dt class="d_decl" id="decode">dchar decode(UseReplacementDchar useReplacementDchar = No.useReplacementDchar, S)(auto ref S str, ref size_t index)<br><br>  Constraints:<br>    if (!isSomeString!S &amp;&amp; isRandomAccessRange!S &amp;&amp; hasSlicing!S &amp;&amp; hasLength!S &amp;&amp; isSomeChar!(ElementType!S))</dt> <dd>
<p>Decodes and returns the code point starting at <code>str[index]</code>. <code>index</code> is advanced to one past the decoded code point. If the code point is not well-formed, then a <code>UTFException</code> is thrown and <code>index</code> remains unchanged. </p>
<p><code>decode</code> will only work with strings and random access ranges of code units with length and slicing, whereas <a href="#decodeFront"><code>decodeFront</code></a> will work with any input range of code units. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>useReplacementDchar</td> <td>if invalid UTF, return replacementDchar rather than throwing</td>
</tr> <tr>
<td>S <code>str</code>
</td> <td>input string or indexable Range</td>
</tr> <tr>
<td>size_t <code>index</code>
</td> <td>starting <code>index</code> into s[]; incremented by number of code units processed</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>decoded character </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="#UTFException"><code>UTFException</code></a> if <code>str[index]</code> is not the start of a valid UTF sequence and useReplacementDchar is <code>No.useReplacementDchar</code>
</dd>
</dl> </dd> <dt class="d_decl" id="decodeFront">dchar decodeFront(UseReplacementDchar useReplacementDchar = No.useReplacementDchar, S)(ref S str, out size_t numCodeUnits)<br>dchar decodeFront(UseReplacementDchar useReplacementDchar = No.useReplacementDchar, S)(ref S str)<br><br>  Constraints:<br>    if (!isSomeString!S &amp;&amp; isInputRange!S &amp;&amp; isSomeChar!(ElementType!S))<br>    if (isInputRange!S &amp;&amp; isSomeChar!(ElementType!S))</dt> <dd>
<p><code>decodeFront</code> is a variant of <a href="#decode"><code>decode</code></a> which specifically decodes the first code point. Unlike <a href="#decode"><code>decode</code></a>, <code>decodeFront</code> accepts any input range of code units (rather than just a string or random access range). It also takes the range by <code>ref</code> and pops off the elements as it decodes them. If <code>numCodeUnits</code> is passed in, it gets set to the number of code units which were in the code point which was decoded. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>useReplacementDchar</td> <td>if invalid UTF, return replacementDchar rather than throwing</td>
</tr> <tr>
<td>S <code>str</code>
</td> <td>input string or indexable Range</td>
</tr> <tr>
<td>size_t <code>numCodeUnits</code>
</td> <td>set to number of code units processed</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>decoded character </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="#UTFException"><code>UTFException</code></a> if <code>str.front</code> is not the start of a valid UTF sequence. If an exception is thrown, then there is no guarantee as to the number of code units which were popped off, as it depends on the type of range being used and how many code units had to be popped off before the code point was determined to be invalid.</dd>
</dl> </dd> <dt class="d_decl" id="decodeBack">dchar decodeBack(UseReplacementDchar useReplacementDchar = No.useReplacementDchar, S)(ref S str, out size_t numCodeUnits)<br>dchar decodeBack(UseReplacementDchar useReplacementDchar = No.useReplacementDchar, S)(ref S str, out size_t numCodeUnits)<br>dchar decodeBack(UseReplacementDchar useReplacementDchar = No.useReplacementDchar, S)(ref S str)<br><br>  Constraints:<br>    if (isSomeString!S)<br>    if (!isSomeString!S &amp;&amp; isSomeChar!(ElementType!S) &amp;&amp; isBidirectionalRange!S &amp;&amp; (isRandomAccessRange!S &amp;&amp; hasLength!S || !isRandomAccessRange!S))<br>    if (isSomeString!S || isRandomAccessRange!S &amp;&amp; hasLength!S &amp;&amp; isSomeChar!(ElementType!S) || !isRandomAccessRange!S &amp;&amp; isBidirectionalRange!S &amp;&amp; isSomeChar!(ElementType!S))</dt> <dd>
<p><code>decodeBack</code> is a variant of <a href="#decode"><code>decode</code></a> which specifically decodes the last code point. Unlike <a href="#decode"><code>decode</code></a>, <code>decodeBack</code> accepts any bidirectional range of code units (rather than just a string or random access range). It also takes the range by <code>ref</code> and pops off the elements as it decodes them. If <code>numCodeUnits</code> is passed in, it gets set to the number of code units which were in the code point which was decoded. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>useReplacementDchar</td> <td>if invalid UTF, return <code>replacementDchar</code> rather than throwing</td>
</tr> <tr>
<td>S <code>str</code>
</td> <td>input string or bidirectional Range</td>
</tr> <tr>
<td>size_t <code>numCodeUnits</code>
</td> <td>gives the number of code units processed</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A decoded UTF character. </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<a href="#UTFException"><code>UTFException</code></a> if <code>str.back</code> is not the end of a valid UTF sequence. If an exception is thrown, the <code>str</code> itself remains unchanged, but there is no guarantee as to the value of <code>numCodeUnits</code> (when passed).</dd>
</dl> </dd> <dt class="d_decl" id="encode">pure @safe size_t encode(UseReplacementDchar useReplacementDchar = No.useReplacementDchar)(out char[4] buf, dchar c)<br>pure @safe size_t encode(UseReplacementDchar useReplacementDchar = No.useReplacementDchar)(out wchar[2] buf, dchar c)<br>pure @safe size_t encode(UseReplacementDchar useReplacementDchar = No.useReplacementDchar)(out dchar[1] buf, dchar c)</dt> <dd>
<p>Encodes <code>c</code> into the static array, <code>buf</code>, and returns the actual length of the encoded character (a number between <code>1</code> and <code>4</code> for <code>char[4]</code> buffers and a number between <code>1</code> and <code>2</code> for <code>wchar[2]</code> buffers). </p>
<dl>
<dt>Throws:</dt>
<dd>
<code>UTFException</code> if <code>c</code> is not a valid UTF code point.</dd>
</dl> </dd> <dt class="d_decl" id="encode.2">pure @safe void encode(UseReplacementDchar useReplacementDchar = No.useReplacementDchar)(ref char[] str, dchar c)<br>pure @safe void encode(UseReplacementDchar useReplacementDchar = No.useReplacementDchar)(ref wchar[] str, dchar c)<br>pure @safe void encode(UseReplacementDchar useReplacementDchar = No.useReplacementDchar)(ref dchar[] str, dchar c)</dt> <dd>
<p>Encodes <code>c</code> in <code>str</code>'s encoding and appends it to <code>str</code>. </p>
<dl>
<dt>Throws:</dt>
<dd>
<code>UTFException</code> if <code>c</code> is not a valid UTF code point.</dd>
</dl> </dd> <dt class="d_decl" id="codeLength">pure nothrow @nogc @safe ubyte codeLength(C)(dchar c)<br><br>  Constraints:<br>    if (isSomeChar!C)</dt> <dd>
<p>Returns the number of code units that are required to encode the code point <code>c</code> when <code>C</code> is the character type used to encode it.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(codeLength!char('a')); // 1
writeln(codeLength!wchar('a')); // 1
writeln(codeLength!dchar('a')); // 1

writeln(codeLength!char('\U0010FFFF')); // 4
writeln(codeLength!wchar('\U0010FFFF')); // 2
writeln(codeLength!dchar('\U0010FFFF')); // 1
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="codeLength.2">size_t codeLength(C, InputRange)(InputRange input)<br><br>  Constraints:<br>    if (isInputRange!InputRange &amp;&amp; !isInfinite!InputRange &amp;&amp; is(ElementType!InputRange : dchar))</dt> <dd>
<p>Returns the number of code units that are required to encode <code>str</code> in a string whose character type is <code>C</code>. This is particularly useful when slicing one string with the length of another and the two string types use different character types. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>C</td> <td>the character type to get the encoding length for</td>
</tr> <tr>
<td>InputRange <code>input</code>
</td> <td>the <code>input</code> range to calculate the encoding length from</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The number of code units in <code>input</code> when encoded to <code>C</code>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.conv : to;
assert(codeLength!char("hello world") ==
       to!string("hello world").length);
assert(codeLength!wchar("hello world") ==
       to!wstring("hello world").length);
assert(codeLength!dchar("hello world") ==
       to!dstring("hello world").length);

assert(codeLength!char(`プログラミング`) ==
       to!string(`プログラミング`).length);
assert(codeLength!wchar(`プログラミング`) ==
       to!wstring(`プログラミング`).length);
assert(codeLength!dchar(`プログラミング`) ==
       to!dstring(`プログラミング`).length);

string haystack = `Être sans la verité, ça, ce ne serait pas bien.`;
wstring needle = `Être sans la verité`;
assert(haystack[codeLength!char(needle) .. $] ==
       `, ça, ce ne serait pas bien.`);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="validate">pure @safe void validate(S)(in S str)<br><br>  Constraints:<br>    if (isSomeString!S)</dt> <dd>
<p>Checks to see if <code>str</code> is well-formed unicode or not. </p>
<dl>
<dt>Throws:</dt>
<dd>
<code>UTFException</code> if <code>str</code> is not well-formed.</dd>
</dl> </dd> <dt class="d_decl" id="toUTF8">string toUTF8(S)(S s)<br><br>  Constraints:<br>    if (isInputRange!S &amp;&amp; !isInfinite!S &amp;&amp; isSomeChar!(ElementEncodingType!S))</dt> <dd>
<p>Encodes the elements of <code>s</code> to UTF-8 and returns a newly allocated string of the elements. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>S <code>s</code>
</td> <td>the string to encode</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A UTF-8 string </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>For a lazy, non-allocating version of these functions, see <a href="#byUTF"><code>byUTF</code></a>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;

// The ö is represented by two UTF-8 code units
assert("Hellø"w.toUTF8.equal(['H', 'e', 'l', 'l', 0xC3, 0xB8]));

// 𐐷 is four code units in UTF-8
assert("𐐷"d.toUTF8.equal([0xF0, 0x90, 0x90, 0xB7]));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="toUTF16">wstring toUTF16(S)(S s)<br><br>  Constraints:<br>    if (isInputRange!S &amp;&amp; !isInfinite!S &amp;&amp; isSomeChar!(ElementEncodingType!S))</dt> <dd>
<p>Encodes the elements of <code>s</code> to UTF-16 and returns a newly GC allocated <code>wstring</code> of the elements. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>S <code>s</code>
</td> <td>the range to encode</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A UTF-16 string </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>For a lazy, non-allocating version of these functions, see <a href="#byUTF"><code>byUTF</code></a>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;

// these graphemes are two code units in UTF-16 and one in UTF-32
writeln("𤭢"d.length); // 1
writeln("𐐷"d.length); // 1

assert("𤭢"d.toUTF16.equal([0xD852, 0xDF62]));
assert("𐐷"d.toUTF16.equal([0xD801, 0xDC37]));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="toUTF32">dstring toUTF32(S)(S s)<br><br>  Constraints:<br>    if (isInputRange!S &amp;&amp; !isInfinite!S &amp;&amp; isSomeChar!(ElementEncodingType!S))</dt> <dd>
<p>Encodes the elements of <code>s</code> to UTF-32 and returns a newly GC allocated <code>dstring</code> of the elements. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>S <code>s</code>
</td> <td>the range to encode</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A UTF-32 string </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>For a lazy, non-allocating version of these functions, see <a href="#byUTF"><code>byUTF</code></a>.</dd>
</dl> </dd> <dt class="d_decl" id="toUTFz">template toUTFz(P)</dt> <dd>
<p>Returns a C-style zero-terminated string equivalent to <code>str</code>. <code>str</code> must not contain embedded <code>'\0'</code>'s as any C function will treat the first <code>'\0'</code> that it sees as the end of the string. If <code>str.empty</code> is <code>true</code>, then a string containing only <code>'\0'</code> is returned. </p>
<p><code>toUTFz</code> accepts any type of string and is templated on the type of character pointer that you wish to convert to. It will avoid allocating a new string if it can, but there's a decent chance that it will end up having to allocate a new string - particularly when dealing with character types other than <code>char</code>. <br><br> <span class="red">Warning 1:</span> If the result of <code>toUTFz</code> equals <code>str.ptr</code>, then if anything alters the character one past the end of <code>str</code> (which is the <code>'\0'</code> character terminating the string), then the string won't be zero-terminated anymore. The most likely scenarios for that are if you append to <code>str</code> and no reallocation takes place or when <code>str</code> is a slice of a larger array, and you alter the character in the larger array which is one character past the end of <code>str</code>. Another case where it could occur would be if you had a mutable character array immediately after <code>str</code> in memory (for example, if they're member variables in a user-defined type with one declared right after the other) and that character array happened to start with <code>'\0'</code>. Such scenarios will never occur if you immediately use the zero-terminated string after calling <code>toUTFz</code> and the C function using it doesn't keep a reference to it. Also, they are unlikely to occur even if you save the zero-terminated string (the cases above would be among the few examples of where it could happen). However, if you save the zero-terminate string and want to be absolutely certain that the string stays zero-terminated, then simply append a <code>'\0'</code> to the string and use its <code>ptr</code> property rather than calling <code>toUTFz</code>. <br><br> <span class="red">Warning 2:</span> When passing a character pointer to a C function, and the C function keeps it around for any reason, make sure that you keep a reference to it in your D code. Otherwise, it may go away during a garbage collection cycle and cause a nasty bug when the C code tries to use it.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto p1 = toUTFz!(char*)("hello world");
auto p2 = toUTFz!(const(char)*)("hello world");
auto p3 = toUTFz!(immutable(char)*)("hello world");
auto p4 = toUTFz!(char*)("hello world"d);
auto p5 = toUTFz!(const(wchar)*)("hello world");
auto p6 = toUTFz!(immutable(dchar)*)("hello world"w);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="toUTF16z">pure @safe const(wchar)* toUTF16z(C)(const(C)[] str)<br><br>  Constraints:<br>    if (isSomeChar!C)</dt> <dd>
<p><code>toUTF16z</code> is a convenience function for <code>toUTFz!(const(wchar)*)</code>. </p>
<p>Encodes string <code>s</code> into UTF-16 and returns the encoded string. <code>toUTF16z</code> is suitable for calling the 'W' functions in the Win32 API that take an <code>LPWSTR</code> or <code>LPCWSTR</code> argument.</p> </dd> <dt class="d_decl" id="count">pure nothrow @nogc @trusted size_t count(C)(const(C)[] str)<br><br>  Constraints:<br>    if (isSomeChar!C)</dt> <dd>
<p>Returns the total number of code points encoded in <code>str</code>. </p>
<dl>
<dt>Supercedes</dt>
<dd> This function supercedes <a href="#toUCSindex"><code>toUCSindex</code></a>. </dd>
</dl> <dl>
<dt>Standards:</dt>
<dd>Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252 </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<code>UTFException</code> if <code>str</code> is not well-formed.</dd>
</dl> </dd> <dt class="d_decl" id="replacementDchar">enum dchar replacementDchar</dt> <dd>
<p>Inserted in place of invalid UTF sequences. </p>
<dl>
<dt>References</dt>
<dd> <a href="http://en.wikipedia.org/wiki/Replacement_character#Replacement_character" target="_blank">http://en.wikipedia.org/wiki/Replacement_character#Replacement_character</a>
</dd>
</dl> </dd> <dt class="d_decl" id="byCodeUnit">auto byCodeUnit(R)(R r)<br><br>  Constraints:<br>    if (isAutodecodableString!R || isInputRange!R &amp;&amp; isSomeChar!(ElementEncodingType!R) || is(R : const(dchar[])) &amp;&amp; !isStaticArray!R)</dt> <dd>
<p>Iterate a range of char, wchar, or dchars by code unit. </p>
<p>The purpose is to bypass the special case decoding that <a href="../std_range_primitives/#front"><code>std.range.primitives.front</code></a> does to character arrays. As a result, using ranges with <code>byCodeUnit</code> can be <code>nothrow</code> while <a href="../std_range_primitives/#front"><code>std.range.primitives.front</code></a> throws when it encounters invalid Unicode sequences. <br><br> A code unit is a building block of the UTF encodings. Generally, an individual code unit does not represent what's perceived as a full character (a.k.a. a grapheme cluster in Unicode terminology). Many characters are encoded with multiple code units. For example, the UTF-8 code units for <code>ø</code> are <code>0xC3 0xB8</code>. That means, an individual element of <code>byCodeUnit</code> often does not form a character on its own. Attempting to treat it as one while iterating over the resulting range will give nonsensical results. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>r</code>
</td> <td>an input range of characters (including strings) or a type that implicitly converts to a string type.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>If <code>r</code> is not an auto-decodable string (i.e. a narrow string or a user-defined type that implicits converts to a string type), then <code>r</code> is returned.  Otherwise, <code>r</code> is converted to its corresponding string type (if it's not already a string) and wrapped in a random-access range where the element encoding type of the string (its code unit) is the element type of the range, and that range returned. The range has slicing.  If <code>r</code> is quirky enough to be a struct or class which is an input range of characters on its own (i.e. it has the input range API as member functions), <i>and</i> it's implicitly convertible to a string type, then <code>r</code> is returned, and no implicit conversion takes place. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>Refer to the <a href="../std_uni/"><code>std.uni</code></a> docs for a reference on Unicode terminology.  For a range that iterates by grapheme cluster (written character) see <a href="../std_uni/#byGrapheme"><code>std.uni.byGrapheme</code></a>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.range.primitives;

auto r = "Hello, World!".byCodeUnit();
static assert(hasLength!(typeof(r)));
static assert(hasSlicing!(typeof(r)));
static assert(isRandomAccessRange!(typeof(r)));
static assert(is(ElementType!(typeof(r)) == immutable char));

// contrast with the range capabilities of standard strings
auto s = "Hello, World!";
static assert(isBidirectionalRange!(typeof(r)));
static assert(is(ElementType!(typeof(s)) == dchar));

static assert(!isRandomAccessRange!(typeof(s)));
static assert(!hasSlicing!(typeof(s)));
static assert(!hasLength!(typeof(s)));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<code>byCodeUnit</code> does no Unicode decoding <pre data-language="d">string noel1 = "noe\u0308l"; // noël using e + combining diaeresis
assert(noel1.byCodeUnit[2] != 'ë');
writeln(noel1.byCodeUnit[2]); // 'e'

string noel2 = "no\u00EBl"; // noël using a precomposed ë character
// Because string is UTF-8, the code unit at index 2 is just
// the first of a sequence that encodes 'ë'
assert(noel2.byCodeUnit[2] != 'ë');
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="byChar">alias byChar = byUTF!char.byUTF(R)(R r) if (isAutodecodableString!R &amp;amp<br>&amp;amp<br>isInputRange!R &amp;amp<br>&amp;amp<br>isSomeChar!(ElementEncodingType!R))<br>alias byWchar = byUTF!wchar.byUTF(R)(R r) if (isAutodecodableString!R &amp;amp<br>&amp;amp<br>isInputRange!R &amp;amp<br>&amp;amp<br>isSomeChar!(ElementEncodingType!R))<br>alias byDchar = byUTF!dchar.byUTF(R)(R r) if (isAutodecodableString!R &amp;amp<br>&amp;amp<br>isInputRange!R &amp;amp<br>&amp;amp<br>isSomeChar!(ElementEncodingType!R))</dt> <dd>
<p>Iterate an input range of characters by char, wchar, or dchar. These aliases simply forward to <a href="#byUTF"><code>byUTF</code></a> with the corresponding C argument. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R r</td> <td>input range of characters, or array of characters</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="byUTF">template byUTF(C) if (isSomeChar!C)</dt> <dd>
<p>Iterate an input range of characters by char type <code>C</code> by encoding the elements of the range. </p>
<p>UTF sequences that cannot be converted to the specified encoding are replaced by U+FFFD per "5.22 Best Practice for U+FFFD Substitution" of the Unicode Standard 6.2. Hence <code>byUTF</code> is not symmetric. This algorithm is lazy, and does not allocate memory. <code>@nogc</code>, <code>pure</code>-ity, <code>nothrow</code>, and <code>@safe</code>-ty are inferred from the <code>r</code> parameter. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>C</td> <td>
<code>char</code>, <code>wchar</code>, or <code>dchar</code>
</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A forward range if <code>R</code> is a range and not auto-decodable, as defined by <a href="../std_traits/#isAutodecodableString"><code>std.traits.isAutodecodableString</code></a>, and if the base range is also a forward range.  Or, if <code>R</code> is a range and it is auto-decodable and <code>is(ElementEncodingType!typeof(r) == C)</code>, then the range is passed to <a href="#byCodeUnit"><code>byCodeUnit</code></a>.  Otherwise, an input range of characters.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;

// hellö as a range of `char`s, which are UTF-8
"hell\u00F6".byUTF!char().equal(['h', 'e', 'l', 'l', 0xC3, 0xB6]);

// `wchar`s are able to hold the ö in a single element (UTF-16 code unit)
"hell\u00F6".byUTF!wchar().equal(['h', 'e', 'l', 'l', 'ö']);

// 𐐷 is four code units in UTF-8, two in UTF-16, and one in UTF-32
"𐐷".byUTF!char().equal([0xF0, 0x90, 0x90, 0xB7]);
"𐐷".byUTF!wchar().equal([0xD801, 0xDC37]);
"𐐷".byUTF!dchar().equal([0x00010437]);
</pre> </dd>
</dl> </dd> </dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 1999–2017 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/phobos/std_utf.html" class="_attribution-link" target="_blank">https://dlang.org/phobos/std_utf.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
