
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>std.xml - D - W3cubDocs</title>
  
  <meta name="description" content="Warning&#58; This module is considered out-dated and not up to Phobos&#39; current standards. It will remain until we have a suitable replacement, &hellip;">
  <meta name="keywords" content="std, xml, -, d">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/d/std_xml/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-e0f881b0fce8cbe96f33dadc355b7159d5d2912911231446d60eb8f9caffa802.css">
  <script type="text/javascript" src="/assets/application-8fc46316434047265cd383f02b8e7f434ed7dec4a59f920dd633deef8d488d1b.js"></script>
  <script src="/json/d.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/d/" class="_nav-link" title="" style="margin-left:0;">D</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _d">
				
<h1>std.xml</h1>  <p><span class="red">Warning: This module is considered out-dated and not up to Phobos' current standards. It will remain until we have a suitable replacement, but be aware that it will not remain long term.</span> </p>
<p>Classes and functions for creating and parsing XML <br><br> The basic architecture of this module is that there are standalone functions, classes for constructing an XML document from scratch (Tag, Element and Document), and also classes for parsing a pre-existing XML file (ElementParser and DocumentParser). The parsing classes <i>may</i> be used to build a Document, but that is not their primary purpose. The handling capabilities of DocumentParser and ElementParser are sufficiently customizable that you can make them do pretty much whatever you want. </p> <dl>
<dt>Example</dt>
<dd> This example creates a DOM (Document Object Model) tree from an XML file. </dd>
</dl>
<pre data-language="d">import std.xml;
import std.stdio;
import std.string;
import std.file;

// books.xml is used in various samples throughout the Microsoft XML Core
// Services (MSXML) SDK.
//
// See http://msdn2.microsoft.com/en-us/library/ms762271(VS.85).aspx

void main()
{
    string s = cast(string) std.file.read("books.xml");

    // Check for well-formedness
    check(s);

    // Make a DOM tree
    auto doc = new Document(s);

    // Plain-print it
    writeln(doc);
}
</pre>  <dl>
<dt>Example</dt>
<dd> This example does much the same thing, except that the file is deconstructed and reconstructed by hand. This is more work, but the techniques involved offer vastly more power. </dd>
</dl>
<pre data-language="d">import std.xml;
import std.stdio;
import std.string;

struct Book
{
    string id;
    string author;
    string title;
    string genre;
    string price;
    string pubDate;
    string description;
}

void main()
{
    string s = cast(string) std.file.read("books.xml");

    // Check for well-formedness
    check(s);

    // Take it apart
    Book[] books;

    auto xml = new DocumentParser(s);
    xml.onStartTag["book"] = (ElementParser xml)
    {
        Book book;
        book.id = xml.tag.attr["id"];

        xml.onEndTag["author"]       = (in Element e) { book.author      = e.text(); };
        xml.onEndTag["title"]        = (in Element e) { book.title       = e.text(); };
        xml.onEndTag["genre"]        = (in Element e) { book.genre       = e.text(); };
        xml.onEndTag["price"]        = (in Element e) { book.price       = e.text(); };
        xml.onEndTag["publish-date"] = (in Element e) { book.pubDate     = e.text(); };
        xml.onEndTag["description"]  = (in Element e) { book.description = e.text(); };

        xml.parse();

        books ~= book;
    };
    xml.parse();

    // Put it back together again;
    auto doc = new Document(new Tag("catalog"));
    foreach (book;books)
    {
        auto element = new Element("book");
        element.tag.attr["id"] = book.id;

        element ~= new Element("author",      book.author);
        element ~= new Element("title",       book.title);
        element ~= new Element("genre",       book.genre);
        element ~= new Element("price",       book.price);
        element ~= new Element("publish-date",book.pubDate);
        element ~= new Element("description", book.description);

        doc ~= element;
    }

    // Pretty-print it
    writefln(join(doc.pretty(3),"\n"));
}
</pre>  <dl>
<dt>License:</dt>
<dd>
<a href="http://www.boost.org/LICENSE_1_0.txt" target="_blank">Boost License 1.0</a>. </dd>
</dl> <dl>
<dt>Authors:</dt>
<dd>Janice Caron </dd>
</dl> <dl>
<dt>Source</dt>
<dd> <span class="phobos_src"><a class="https" href="https://github.com/dlang/phobos/blob/master/std/xml.d" target="_blank">std/xml.d</a></span>
</dd>
</dl> <dl>
<dt class="d_decl" id="isChar">pure nothrow @nogc @safe bool isChar(dchar c)</dt> <dd>
<p>Returns <code>true</code> if the character is a character according to the XML standard </p>
<dl>
<dt>Standards:</dt>
<dd>
<a href="http://www.w3.org/TR/1998/REC-xml-19980210" target="_blank">XML 1.0</a> </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>dchar <code>c</code>
</td> <td>the character to be tested</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="isSpace">pure nothrow @nogc @safe bool isSpace(dchar c)</dt> <dd>
<p>Returns <code>true</code> if the character is whitespace according to the XML standard </p>
<p>Only the following characters are considered whitespace in XML - space, tab, carriage return and linefeed </p> <dl>
<dt>Standards:</dt>
<dd>
<a href="http://www.w3.org/TR/1998/REC-xml-19980210" target="_blank">XML 1.0</a> </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>dchar <code>c</code>
</td> <td>the character to be tested</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="isDigit">pure nothrow @nogc @safe bool isDigit(dchar c)</dt> <dd>
<p>Returns <code>true</code> if the character is a digit according to the XML standard </p>
<dl>
<dt>Standards:</dt>
<dd>
<a href="http://www.w3.org/TR/1998/REC-xml-19980210" target="_blank">XML 1.0</a> </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>dchar <code>c</code>
</td> <td>the character to be tested</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="isLetter">pure nothrow @nogc @safe bool isLetter(dchar c)</dt> <dd>
<p>Returns <code>true</code> if the character is a letter according to the XML standard </p>
<dl>
<dt>Standards:</dt>
<dd>
<a href="http://www.w3.org/TR/1998/REC-xml-19980210" target="_blank">XML 1.0</a> </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>dchar <code>c</code>
</td> <td>the character to be tested</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="isIdeographic">pure nothrow @nogc @safe bool isIdeographic(dchar c)</dt> <dd>
<p>Returns <code>true</code> if the character is an ideographic character according to the XML standard </p>
<dl>
<dt>Standards:</dt>
<dd>
<a href="http://www.w3.org/TR/1998/REC-xml-19980210" target="_blank">XML 1.0</a> </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>dchar <code>c</code>
</td> <td>the character to be tested</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="isBaseChar">pure nothrow @nogc @safe bool isBaseChar(dchar c)</dt> <dd>
<p>Returns <code>true</code> if the character is a base character according to the XML standard </p>
<dl>
<dt>Standards:</dt>
<dd>
<a href="http://www.w3.org/TR/1998/REC-xml-19980210" target="_blank">XML 1.0</a> </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>dchar <code>c</code>
</td> <td>the character to be tested</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="isCombiningChar">pure nothrow @nogc @safe bool isCombiningChar(dchar c)</dt> <dd>
<p>Returns <code>true</code> if the character is a combining character according to the XML standard </p>
<dl>
<dt>Standards:</dt>
<dd>
<a href="http://www.w3.org/TR/1998/REC-xml-19980210" target="_blank">XML 1.0</a> </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>dchar <code>c</code>
</td> <td>the character to be tested</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="isExtender">pure nothrow @nogc @safe bool isExtender(dchar c)</dt> <dd>
<p>Returns <code>true</code> if the character is an extender according to the XML standard </p>
<dl>
<dt>Standards:</dt>
<dd>
<a href="http://www.w3.org/TR/1998/REC-xml-19980210" target="_blank">XML 1.0</a> </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>dchar <code>c</code>
</td> <td>the character to be tested</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="encode">S encode(S)(S s)</dt> <dd>
<p>Encodes a string by replacing all characters which need to be escaped with appropriate predefined XML entities. </p>
<p><code>encode</code>() escapes certain characters (ampersand, quote, apostrophe, less-than and greater-than), and similarly, decode() unescapes them. These functions are provided for convenience only. You do not need to use them when using the std.xml classes, because then all the encoding and decoding will be done for you automatically. <br><br> If the string is not modified, the original will be returned. </p> <dl>
<dt>Standards:</dt>
<dd>
<a href="http://www.w3.org/TR/1998/REC-xml-19980210" target="_blank">XML 1.0</a> </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>S <code>s</code>
</td> <td>The string to be encoded</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The encoded string </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">writefln(encode("a &gt; b")); // writes "a &amp;gt; b"
</pre>  </dd> <dt class="d_decl" id="DecodeMode">enum DecodeMode: int</dt> <dd>
<p>Mode to use for decoding. </p>
<p></p>
<dl>NONE</dl> Do not decode <dl>LOOSE</dl> Decode, but ignore errors <dl>STRICT</dl> Decode, and throw exception on error </dd> <dt class="d_decl" id="decode">pure @safe string decode(string s, DecodeMode mode = DecodeMode.LOOSE)</dt> <dd>
<p>Decodes a string by unescaping all predefined XML entities. </p>
<p>encode() escapes certain characters (ampersand, quote, apostrophe, less-than and greater-than), and similarly, <code>decode</code>() unescapes them. These functions are provided for convenience only. You do not need to use them when using the std.xml classes, because then all the encoding and decoding will be done for you automatically. <br><br> This function decodes the entities &amp;amp;, &amp;quot;, &amp;apos;, &amp;lt; and &amp;gt, as well as decimal and hexadecimal entities such as &amp;#x20AC; <br><br> If the string does not contain an ampersand, the original will be returned. <br><br> Note that the "<code>mode</code>" parameter can be one of DecodeMode.NONE (do not <code>decode</code>), DecodeMode.LOOSE (<code>decode</code>, but ignore errors), or DecodeMode.STRICT (<code>decode</code>, and throw a DecodeException in the event of an error). </p> <dl>
<dt>Standards:</dt>
<dd>
<a href="http://www.w3.org/TR/1998/REC-xml-19980210" target="_blank">XML 1.0</a> </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>string <code>s</code>
</td> <td>The string to be decoded</td>
</tr> <tr>
<td>DecodeMode <code>mode</code>
</td> <td>(optional) Mode to use for decoding. (Defaults to LOOSE).</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>DecodeException if <code>mode</code> == DecodeMode.STRICT and <code>decode</code> fails </dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The decoded string </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">writefln(decode("a &amp;gt; b")); // writes "a &gt; b"
</pre>  </dd> <dt class="d_decl" id="Document">class Document: std.xml.Element</dt> <dd>
<p>Class representing an XML document. </p>
<dl>
<dt>Standards:</dt>
<dd><a href="http://www.w3.org/TR/1998/REC-xml-19980210" target="_blank">XML 1.0</a></dd>
</dl> <dl>
<dt class="d_decl" id="Document.prolog">string prolog</dt> <dd>
<p>Contains all text which occurs before the root element. Defaults to &lt;?xml version="1.0"?&gt;</p> </dd> <dt class="d_decl" id="Document.epilog">string epilog</dt> <dd>
<p>Contains all text which occurs after the root element. Defaults to the empty string</p> </dd> <dt class="d_decl" id="Document.this">this(string s)</dt> <dd>
<p>Constructs a Document by parsing XML text. </p>
<p>This function creates a complete DOM (Document Object Model) tree. <br><br> The input to this function MUST be valid XML. This is enforced by DocumentParser'<code>s</code> in contract. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>string <code>s</code>
</td> <td>the complete XML text.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="Document.this.2">this(const(Tag) tag)</dt> <dd>
<p>Constructs a Document from a Tag. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const(Tag) <code>tag</code>
</td> <td>the start <code>tag</code> of the document.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="Document.opEquals">const bool opEquals(scope const Object o)</dt> <dd>
<p>Compares two Documents for equality </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">Document d1,d2;
if (d1 == d2) { }
</pre>  </dd> <dt class="d_decl" id="Document.opCmp">const scope int opCmp(scope const Object o)</dt> <dd>
<p>Compares two Documents </p>
<p>You should rarely need to call this function. It exists so that Documents can be used as associative array keys. </p> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">Document d1,d2;
if (d1 &lt; d2) { }
</pre>  </dd> <dt class="d_decl" id="Document.toHash">const scope @trusted size_t toHash()</dt> <dd>
<p>Returns the hash of a Document </p>
<p>You should rarely need to call this function. It exists so that Documents can be used as associative array keys.</p> </dd> <dt class="d_decl" id="Document.toString">const scope @safe string toString()</dt> <dd>
<p>Returns the string representation of a Document. (That is, the complete XML of a document).</p> </dd> </dl> </dd> <dt class="d_decl" id="Element">class Element: std.xml.Item</dt> <dd>
<p>Class representing an XML element. </p>
<dl>
<dt>Standards:</dt>
<dd><a href="http://www.w3.org/TR/1998/REC-xml-19980210" target="_blank">XML 1.0</a></dd>
</dl> <dl>
<dt class="d_decl" id="Element.tag">Tag tag</dt> <dd>
<p>The start <code>tag</code> of the element</p> </dd> <dt class="d_decl" id="Element.items">Item[] items</dt> <dd>
<p>The element's <code>items</code></p> </dd> <dt class="d_decl" id="Element.texts">Text[] texts</dt> <dd>
<p>The element's text items</p> </dd> <dt class="d_decl" id="Element.cdatas">CData[] cdatas</dt> <dd>
<p>The element's CData items</p> </dd> <dt class="d_decl" id="Element.comments">Comment[] comments</dt> <dd>
<p>The element's <code>comments</code></p> </dd> <dt class="d_decl" id="Element.pis">ProcessingInstruction[] pis</dt> <dd>
<p>The element's processing instructions</p> </dd> <dt class="d_decl" id="Element.elements">Element[] elements</dt> <dd>
<p>The element's child <code>elements</code></p> </dd> <dt class="d_decl" id="Element.this">pure @safe this(string name, string interior = null)</dt> <dd>
<p>Constructs an Element given a <code>name</code> and a string to be used as a Text <code>interior</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>string <code>name</code>
</td> <td>the <code>name</code> of the element.</td>
</tr> <tr>
<td>string <code>interior</code>
</td> <td>(optional) the string <code>interior</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto element = new Element("title","Serenity")
    // constructs the element &lt;title&gt;Serenity&lt;/title&gt;
</pre>  </dd> <dt class="d_decl" id="Element.this.2">pure @safe this(const(Tag) tag_)</dt> <dd>
<p>Constructs an Element from a Tag. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const(Tag) <code>tag_</code>
</td> <td>the start or empty tag of the element.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="Element.opCatAssign">pure @safe void opCatAssign(Text item)</dt> <dd>
<p>Append a text <code>item</code> to the interior of this element </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Text <code>item</code>
</td> <td>the <code>item</code> you wish to append.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">Element element;
element ~= new Text("hello");
</pre>  </dd> <dt class="d_decl" id="Element.opCatAssign.2">pure @safe void opCatAssign(CData item)</dt> <dd>
<p>Append a CData <code>item</code> to the interior of this element </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>CData <code>item</code>
</td> <td>the <code>item</code> you wish to append.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">Element element;
element ~= new CData("hello");
</pre>  </dd> <dt class="d_decl" id="Element.opCatAssign.3">pure @safe void opCatAssign(Comment item)</dt> <dd>
<p>Append a comment to the interior of this element </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Comment <code>item</code>
</td> <td>the <code>item</code> you wish to append.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">Element element;
element ~= new Comment("hello");
</pre>  </dd> <dt class="d_decl" id="Element.opCatAssign.4">pure @safe void opCatAssign(ProcessingInstruction item)</dt> <dd>
<p>Append a processing instruction to the interior of this element </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>ProcessingInstruction <code>item</code>
</td> <td>the <code>item</code> you wish to append.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">Element element;
element ~= new ProcessingInstruction("hello");
</pre>  </dd> <dt class="d_decl" id="Element.opCatAssign.5">pure @safe void opCatAssign(Element item)</dt> <dd>
<p>Append a complete element to the interior of this element </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Element <code>item</code>
</td> <td>the <code>item</code> you wish to append.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">Element element;
Element other = new Element("br");
element ~= other;
   // appends element representing &lt;br /&gt;
</pre>  </dd> <dt class="d_decl" id="Element.opEquals">const bool opEquals(scope const Object o)</dt> <dd>
<p>Compares two Elements for equality </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">Element e1,e2;
if (e1 == e2) { }
</pre>  </dd> <dt class="d_decl" id="Element.opCmp">const @safe int opCmp(scope const Object o)</dt> <dd>
<p>Compares two Elements </p>
<p>You should rarely need to call this function. It exists so that Elements can be used as associative array keys. </p> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">Element e1,e2;
if (e1 &lt; e2) { }
</pre>  </dd> <dt class="d_decl" id="Element.toHash">const scope @safe size_t toHash()</dt> <dd>
<p>Returns the hash of an Element </p>
<p>You should rarely need to call this function. It exists so that Elements can be used as associative array keys.</p> </dd> <dt class="d_decl" id="Element.text">const string text(DecodeMode mode = DecodeMode.LOOSE)</dt> <dd>
<p>Returns the decoded interior of an element. </p>
<p>The element is assumed to contain <code>text</code> <i>only</i>. So, for example, given XML such as "&lt;title&gt;Good &amp;amp; Bad&lt;/title&gt;", will return "Good &amp; Bad". </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>DecodeMode <code>mode</code>
</td> <td>(optional) Mode to use for decoding. (Defaults to LOOSE).</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>DecodeException if decode fails</dd>
</dl> </dd> <dt class="d_decl" id="Element.pretty">const scope string[] pretty(uint indent = 2)</dt> <dd>
<p>Returns an indented string representation of this item </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>uint <code>indent</code>
</td> <td>(optional) number of spaces by which to <code>indent</code> this element. Defaults to 2.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="Element.toString">const scope @safe string toString()</dt> <dd>
<p>Returns the string representation of an Element </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto element = new Element("br");
writefln(element.toString()); // writes "&lt;br /&gt;"
</pre>  </dd> </dl> </dd> <dt class="d_decl" id="TagType">enum TagType: int</dt> <dd>
<p>Tag types. </p>
<p></p>
<dl>START</dl> Used for start tags <dl>END</dl> Used for end tags <dl>EMPTY</dl> Used for empty tags </dd> <dt class="d_decl" id="Tag">class Tag</dt> <dd>
<p>Class representing an XML tag. </p>
<dl>
<dt>Standards:</dt>
<dd>
<a href="http://www.w3.org/TR/1998/REC-xml-19980210" target="_blank">XML 1.0</a>  The class invariant guarantees <ul> <li> that <b>type</b> is a valid enum TagType value</li> <li> that <b>name</b> consists of valid characters</li> <li> that each attribute name consists of valid characters</li> </ul>
</dd>
</dl> <dl>
<dt class="d_decl" id="Tag.type">TagType type</dt> <dd>
<p>Type of tag</p> </dd> <dt class="d_decl" id="Tag.name">string name</dt> <dd>
<p>Tag <code>name</code></p> </dd> <dt class="d_decl" id="Tag.attr">string[string] attr</dt> <dd>
<p>Associative array of attributes</p> </dd> <dt class="d_decl" id="Tag.this">pure @safe this(string name, TagType type = TagType.START)</dt> <dd>
<p>Constructs an instance of Tag with a specified <code>name</code> and <code>type</code> </p>
<p>The constructor does not initialize the attributes. To initialize the attributes, you access the <b>attr</b> member variable. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>string <code>name</code>
</td> <td>the Tag's <code>name</code>
</td>
</tr> <tr>
<td>TagType <code>type</code>
</td> <td>(optional) the Tag's <code>type</code>. If omitted, defaults to TagType.START.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto tag = new Tag("img",Tag.EMPTY);
tag.attr["src"] = "http://example.com/example.jpg";
</pre>  </dd> <dt class="d_decl" id="Tag.opEquals">const bool opEquals(scope Object o)</dt> <dd>
<p>Compares two Tags for equality </p>
<p>You should rarely need to call this function. It exists so that Tags can be used as associative array keys. </p> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">Tag tag1,tag2
if (tag1 == tag2) { }
</pre>  </dd> <dt class="d_decl" id="Tag.opCmp">const int opCmp(Object o)</dt> <dd>
<p>Compares two Tags </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">Tag tag1,tag2
if (tag1 &lt; tag2) { }
</pre>  </dd> <dt class="d_decl" id="Tag.toHash">const size_t toHash()</dt> <dd>
<p>Returns the hash of a Tag </p>
<p>You should rarely need to call this function. It exists so that Tags can be used as associative array keys.</p> </dd> <dt class="d_decl" id="Tag.toString">const @safe string toString()</dt> <dd>
<p>Returns the string representation of a Tag </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto tag = new Tag("book",TagType.START);
writefln(tag.toString()); // writes "&lt;book&gt;"
</pre>  </dd> <dt class="d_decl" id="Tag.isStart">const pure nothrow @nogc @property @safe bool isStart()</dt> <dd>
<p>Returns <code>true</code> if the Tag is a start tag </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">if (tag.isStart) { }
</pre>  </dd> <dt class="d_decl" id="Tag.isEnd">const pure nothrow @nogc @property @safe bool isEnd()</dt> <dd>
<p>Returns <code>true</code> if the Tag is an end tag </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">if (tag.isEnd) { }
</pre>  </dd> <dt class="d_decl" id="Tag.isEmpty">const pure nothrow @nogc @property @safe bool isEmpty()</dt> <dd>
<p>Returns <code>true</code> if the Tag is an empty tag </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">if (tag.isEmpty) { }
</pre>  </dd> </dl> </dd> <dt class="d_decl" id="Comment">class Comment: std.xml.Item</dt> <dd>
<p>Class representing a comment</p> <dl>
<dt class="d_decl" id="Comment.this">pure @safe this(string content)</dt> <dd>
<p>Construct a comment </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>string <code>content</code>
</td> <td>the body of the comment</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>CommentException if the comment body is illegal (contains "--" or exactly equals "-") </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto item = new Comment("This is a comment");
   // constructs &lt;!--This is a comment--&gt;
</pre>  </dd> <dt class="d_decl" id="Comment.opEquals">const bool opEquals(scope const Object o)</dt> <dd>
<p>Compares two comments for equality </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">Comment item1,item2;
if (item1 == item2) { }
</pre>  </dd> <dt class="d_decl" id="Comment.opCmp">const scope int opCmp(scope const Object o)</dt> <dd>
<p>Compares two comments </p>
<p>You should rarely need to call this function. It exists so that Comments can be used as associative array keys. </p> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">Comment item1,item2;
if (item1 &lt; item2) { }
</pre>  </dd> <dt class="d_decl" id="Comment.toHash">const nothrow scope size_t toHash()</dt> <dd>
<p>Returns the hash of a Comment </p>
<p>You should rarely need to call this function. It exists so that Comments can be used as associative array keys.</p> </dd> <dt class="d_decl" id="Comment.toString">const pure nothrow scope @safe string toString()</dt> <dd>
<p>Returns a string representation of this comment</p> </dd> <dt class="d_decl" id="Comment.isEmptyXML">const pure nothrow @nogc @property scope @safe bool isEmptyXML()</dt> <dd>
<p>Returns <code>false</code> always</p> </dd> </dl> </dd> <dt class="d_decl" id="CData">class CData: std.xml.Item</dt> <dd>
<p>Class representing a Character Data section</p> <dl>
<dt class="d_decl" id="CData.this">pure @safe this(string content)</dt> <dd>
<p>Construct a character data section </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>string <code>content</code>
</td> <td>the body of the character data segment</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>CDataException if the segment body is illegal (contains "]]&gt;") </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto item = new CData("&lt;b&gt;hello&lt;/b&gt;");
   // constructs &lt;![CDATA[&lt;b&gt;hello&lt;/b&gt;]]&gt;
</pre>  </dd> <dt class="d_decl" id="CData.opEquals">const bool opEquals(scope const Object o)</dt> <dd>
<p>Compares two CDatas for equality </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">CData item1,item2;
if (item1 == item2) { }
</pre>  </dd> <dt class="d_decl" id="CData.opCmp">const scope int opCmp(scope const Object o)</dt> <dd>
<p>Compares two CDatas </p>
<p>You should rarely need to call this function. It exists so that CDatas can be used as associative array keys. </p> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">CData item1,item2;
if (item1 &lt; item2) { }
</pre>  </dd> <dt class="d_decl" id="CData.toHash">const nothrow scope size_t toHash()</dt> <dd>
<p>Returns the hash of a CData </p>
<p>You should rarely need to call this function. It exists so that CDatas can be used as associative array keys.</p> </dd> <dt class="d_decl" id="CData.toString">const pure nothrow scope @safe string toString()</dt> <dd>
<p>Returns a string representation of this CData section</p> </dd> <dt class="d_decl" id="CData.isEmptyXML">const pure nothrow @nogc @property scope @safe bool isEmptyXML()</dt> <dd>
<p>Returns <code>false</code> always</p> </dd> </dl> </dd> <dt class="d_decl" id="Text">class Text: std.xml.Item</dt> <dd>
<p>Class representing a text (aka Parsed Character Data) section</p> <dl>
<dt class="d_decl" id="Text.this">pure @safe this(string content)</dt> <dd>
<p>Construct a text (aka PCData) section </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>string <code>content</code>
</td> <td>the text. This function encodes the text before insertion, so it is safe to insert any text</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto Text = new CData("a &lt; b");
   // constructs a &amp;lt; b
</pre>  </dd> <dt class="d_decl" id="Text.opEquals">const bool opEquals(scope const Object o)</dt> <dd>
<p>Compares two text sections for equality </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">Text item1,item2;
if (item1 == item2) { }
</pre>  </dd> <dt class="d_decl" id="Text.opCmp">const scope int opCmp(scope const Object o)</dt> <dd>
<p>Compares two text sections </p>
<p>You should rarely need to call this function. It exists so that Texts can be used as associative array keys. </p> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">Text item1,item2;
if (item1 &lt; item2) { }
</pre>  </dd> <dt class="d_decl" id="Text.toHash">const nothrow scope size_t toHash()</dt> <dd>
<p>Returns the hash of a text section </p>
<p>You should rarely need to call this function. It exists so that Texts can be used as associative array keys.</p> </dd> <dt class="d_decl" id="Text.toString">const pure nothrow @nogc scope @safe string toString()</dt> <dd>
<p>Returns a string representation of this Text section</p> </dd> <dt class="d_decl" id="Text.isEmptyXML">const pure nothrow @nogc @property scope @safe bool isEmptyXML()</dt> <dd>
<p>Returns <code>true</code> if the content is the empty string</p> </dd> </dl> </dd> <dt class="d_decl" id="XMLInstruction">class XMLInstruction: std.xml.Item</dt> <dd>
<p>Class representing an XML Instruction section</p> <dl>
<dt class="d_decl" id="XMLInstruction.this">pure @safe this(string content)</dt> <dd>
<p>Construct an XML Instruction section </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>string <code>content</code>
</td> <td>the body of the instruction segment</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>XIException if the segment body is illegal (contains "&gt;") </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto item = new XMLInstruction("ATTLIST");
   // constructs &lt;!ATTLIST&gt;
</pre>  </dd> <dt class="d_decl" id="XMLInstruction.opEquals">const bool opEquals(scope const Object o)</dt> <dd>
<p>Compares two XML instructions for equality </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">XMLInstruction item1,item2;
if (item1 == item2) { }
</pre>  </dd> <dt class="d_decl" id="XMLInstruction.opCmp">const scope int opCmp(scope const Object o)</dt> <dd>
<p>Compares two XML instructions </p>
<p>You should rarely need to call this function. It exists so that XmlInstructions can be used as associative array keys. </p> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">XMLInstruction item1,item2;
if (item1 &lt; item2) { }
</pre>  </dd> <dt class="d_decl" id="XMLInstruction.toHash">const nothrow scope size_t toHash()</dt> <dd>
<p>Returns the hash of an XMLInstruction </p>
<p>You should rarely need to call this function. It exists so that XmlInstructions can be used as associative array keys.</p> </dd> <dt class="d_decl" id="XMLInstruction.toString">const pure nothrow scope @safe string toString()</dt> <dd>
<p>Returns a string representation of this XmlInstruction</p> </dd> <dt class="d_decl" id="XMLInstruction.isEmptyXML">const pure nothrow @nogc @property scope @safe bool isEmptyXML()</dt> <dd>
<p>Returns <code>false</code> always</p> </dd> </dl> </dd> <dt class="d_decl" id="ProcessingInstruction">class ProcessingInstruction: std.xml.Item</dt> <dd>
<p>Class representing a Processing Instruction section</p> <dl>
<dt class="d_decl" id="ProcessingInstruction.this">pure @safe this(string content)</dt> <dd>
<p>Construct a Processing Instruction section </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>string <code>content</code>
</td> <td>the body of the instruction segment</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>PIException if the segment body is illegal (contains "?&gt;") </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">auto item = new ProcessingInstruction("php");
   // constructs &lt;?php?&gt;
</pre>  </dd> <dt class="d_decl" id="ProcessingInstruction.opEquals">const bool opEquals(scope const Object o)</dt> <dd>
<p>Compares two processing instructions for equality </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">ProcessingInstruction item1,item2;
if (item1 == item2) { }
</pre>  </dd> <dt class="d_decl" id="ProcessingInstruction.opCmp">const scope int opCmp(scope const Object o)</dt> <dd>
<p>Compares two processing instructions </p>
<p>You should rarely need to call this function. It exists so that ProcessingInstructions can be used as associative array keys. </p> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">ProcessingInstruction item1,item2;
if (item1 &lt; item2) { }
</pre>  </dd> <dt class="d_decl" id="ProcessingInstruction.toHash">const nothrow scope size_t toHash()</dt> <dd>
<p>Returns the hash of a ProcessingInstruction </p>
<p>You should rarely need to call this function. It exists so that ProcessingInstructions can be used as associative array keys.</p> </dd> <dt class="d_decl" id="ProcessingInstruction.toString">const pure nothrow scope @safe string toString()</dt> <dd>
<p>Returns a string representation of this ProcessingInstruction</p> </dd> <dt class="d_decl" id="ProcessingInstruction.isEmptyXML">const pure nothrow @nogc @property scope @safe bool isEmptyXML()</dt> <dd>
<p>Returns <code>false</code> always</p> </dd> </dl> </dd> <dt class="d_decl" id="Item">abstract class Item</dt> <dd>
<p>Abstract base class for XML items</p> <dl>
<dt class="d_decl" id="Item.opEquals">abstract const @safe bool opEquals(scope const Object o)</dt> <dd>
<p>Compares with another Item of same type for equality</p> </dd> <dt class="d_decl" id="Item.opCmp">abstract const @safe int opCmp(scope const Object o)</dt> <dd>
<p>Compares with another Item of same type</p> </dd> <dt class="d_decl" id="Item.toHash">abstract const scope @safe size_t toHash()</dt> <dd>
<p>Returns the hash of this item</p> </dd> <dt class="d_decl" id="Item.toString">abstract const scope @safe string toString()</dt> <dd>
<p>Returns a string representation of this item</p> </dd> <dt class="d_decl" id="Item.pretty">const scope @safe string[] pretty(uint indent)</dt> <dd>
<p>Returns an indented string representation of this item </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>uint <code>indent</code>
</td> <td>number of spaces by which to <code>indent</code> child elements</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="Item.isEmptyXML">abstract const pure nothrow @nogc @property scope @safe bool isEmptyXML()</dt> <dd>
<p>Returns <code>true</code> if the item represents empty XML text</p> </dd> </dl> </dd> <dt class="d_decl" id="DocumentParser">class DocumentParser: std.xml.ElementParser</dt> <dd>
<p>Class for parsing an XML Document. </p>
<p>This is a subclass of ElementParser. Most of the useful functions are documented there. </p> <dl>
<dt>Standards:</dt>
<dd>
<a href="http://www.w3.org/TR/1998/REC-xml-19980210" target="_blank">XML 1.0</a> </dd>
</dl> <dl>
<dt>Bugs:</dt>
<dd>Currently only supports UTF documents.  If there is an encoding attribute in the prolog, it is ignored.</dd>
</dl> <dl>
<dt class="d_decl" id="DocumentParser.this">this(string xmlText_)</dt> <dd>
<p>Constructs a DocumentParser. </p>
<p>The input to this function MUST be valid XML. This is enforced by the function's in contract. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>string <code>xmlText_</code>
</td> <td>the entire XML document as text</td>
</tr> </table></dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="ElementParser">class ElementParser</dt> <dd>
<p>Class for parsing an XML element. </p>
<dl>
<dt>Standards:</dt>
<dd>
<a href="http://www.w3.org/TR/1998/REC-xml-19980210" target="_blank">XML 1.0</a>  Note that you cannot construct instances of this class directly. You can construct a DocumentParser (which is a subclass of <code>ElementParser</code>), but otherwise, Instances of <code>ElementParser</code> will be created for you by the library, and passed your way via onStartTag handlers.</dd>
</dl> <dl>
<dt class="d_decl" id="ElementParser.tag">const pure nothrow @nogc @property @safe const(Tag) tag()</dt> <dd>
<p>The Tag at the start of the element being parsed. You can read this to determine the <code>tag</code>'s name and attributes.</p> </dd> <dt class="d_decl" id="ElementParser.onStartTag">ParserHandler[string] onStartTag</dt> <dd>
<p>Register a handler which will be called whenever a start tag is encountered which matches the specified name. You can also pass <code>null</code> as the name, in which case the handler will be called for any unmatched start tag. </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">// Call this function whenever a &lt;podcast&gt; start tag is encountered
onStartTag["podcast"] = (ElementParser xml)
{
    // Your code here
    //
    // This is a a closure, so code here may reference
    // variables which are outside of this scope
};

// call myEpisodeStartHandler (defined elsewhere) whenever an &lt;episode&gt;
// start tag is encountered
onStartTag["episode"] = &amp;myEpisodeStartHandler;

// call delegate dg for all other start tags
onStartTag[null] = dg;
</pre>  This library will supply your function with a new instance of ElementHandler, which may be used to parse inside the element whose start tag was just found, or to identify the tag attributes of the element, etc.  Note that your function will be called for both start tags and empty tags. That is, we make no distinction between &lt;br&gt;&lt;/br&gt; and &lt;br/&gt;. </dd> <dt class="d_decl" id="ElementParser.onEndTag">ElementHandler[string] onEndTag</dt> <dd>
<p>Register a handler which will be called whenever an end tag is encountered which matches the specified name. You can also pass <code>null</code> as the name, in which case the handler will be called for any unmatched end tag. </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">// Call this function whenever a &lt;/podcast&gt; end tag is encountered
onEndTag["podcast"] = (in Element e)
{
    // Your code here
    //
    // This is a a closure, so code here may reference
    // variables which are outside of this scope
};

// call myEpisodeEndHandler (defined elsewhere) whenever an &lt;/episode&gt;
// end tag is encountered
onEndTag["episode"] = &amp;myEpisodeEndHandler;

// call delegate dg for all other end tags
onEndTag[null] = dg;
</pre>  Note that your function will be called for both start tags and empty tags. That is, we make no distinction between &lt;br&gt;&lt;/br&gt; and &lt;br/&gt;. </dd> <dt class="d_decl" id="ElementParser.onText">pure nothrow @nogc @property @safe void onText(Handler handler)</dt> <dd>
<p>Register a <code>handler</code> which will be called whenever text is encountered. </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">// Call this function whenever text is encountered
onText = (string s)
{
    // Your code here

    // The passed parameter s will have been decoded by the time you see
    // it, and so may contain any character.
    //
    // This is a a closure, so code here may reference
    // variables which are outside of this scope
};
</pre>  </dd> <dt class="d_decl" id="ElementParser.onTextRaw">pure nothrow @nogc @safe void onTextRaw(Handler handler)</dt> <dd>
<p>Register an alternative <code>handler</code> which will be called whenever text is encountered. This differs from onText in that onText will decode the text, whereas <code>onTextRaw</code> will not. This allows you to make design choices, since onText will be more accurate, but slower, while <code>onTextRaw</code> will be faster, but less accurate. Of course, you can still call decode() within your <code>handler</code>, if you want, but you'd probably want to use <code>onTextRaw</code> only in circumstances where you know that decoding is unnecessary. </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">// Call this function whenever text is encountered
onText = (string s)
{
    // Your code here

    // The passed parameter s will NOT have been decoded.
    //
    // This is a a closure, so code here may reference
    // variables which are outside of this scope
};
</pre>  </dd> <dt class="d_decl" id="ElementParser.onCData">pure nothrow @nogc @property @safe void onCData(Handler handler)</dt> <dd>
<p>Register a <code>handler</code> which will be called whenever a character data segment is encountered. </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">// Call this function whenever a CData section is encountered
onCData = (string s)
{
    // Your code here

    // The passed parameter s does not include the opening &lt;![CDATA[
    // nor closing ]]&gt;
    //
    // This is a a closure, so code here may reference
    // variables which are outside of this scope
};
</pre>  </dd> <dt class="d_decl" id="ElementParser.onComment">pure nothrow @nogc @property @safe void onComment(Handler handler)</dt> <dd>
<p>Register a <code>handler</code> which will be called whenever a comment is encountered. </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">// Call this function whenever a comment is encountered
onComment = (string s)
{
    // Your code here

    // The passed parameter s does not include the opening &lt;!-- nor
    // closing --&gt;
    //
    // This is a a closure, so code here may reference
    // variables which are outside of this scope
};
</pre>  </dd> <dt class="d_decl" id="ElementParser.onPI">pure nothrow @nogc @property @safe void onPI(Handler handler)</dt> <dd>
<p>Register a <code>handler</code> which will be called whenever a processing instruction is encountered. </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">// Call this function whenever a processing instruction is encountered
onPI = (string s)
{
    // Your code here

    // The passed parameter s does not include the opening &lt;? nor
    // closing ?&gt;
    //
    // This is a a closure, so code here may reference
    // variables which are outside of this scope
};
</pre>  </dd> <dt class="d_decl" id="ElementParser.onXI">pure nothrow @nogc @property @safe void onXI(Handler handler)</dt> <dd>
<p>Register a <code>handler</code> which will be called whenever an XML instruction is encountered. </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">// Call this function whenever an XML instruction is encountered
// (Note: XML instructions may only occur preceding the root tag of a
// document).
onPI = (string s)
{
    // Your code here

    // The passed parameter s does not include the opening &lt;! nor
    // closing &gt;
    //
    // This is a a closure, so code here may reference
    // variables which are outside of this scope
};
</pre>  </dd> <dt class="d_decl" id="ElementParser.parse">void parse()</dt> <dd>
<p>Parse an XML element. </p>
<p>Parsing will continue until the end of the current element. Any items encountered for which a handler has been registered will invoke that handler. </p> <dl>
<dt>Throws:</dt>
<dd>various kinds of XMLException</dd>
</dl> </dd> <dt class="d_decl" id="ElementParser.toString">const pure nothrow @nogc @safe string toString()</dt> <dd>
<p>Returns that part of the element which has already been parsed</p> </dd> </dl> </dd> <dt class="d_decl" id="check">pure @safe void check(string s)</dt> <dd>
<p>Check an entire XML document for well-formedness </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>string <code>s</code>
</td> <td>the document to be checked, passed as a string</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>CheckException if the document is not well formed  CheckException'<code>s</code> toString() method will yield the complete hierarchy of parse failure (the XML equivalent of a stack trace), giving the line and column number of every failure at every level.</dd>
</dl> </dd> <dt class="d_decl" id="XMLException">class XMLException: object.Exception</dt> <dd>
<p>The base class for exceptions thrown by this module</p> </dd> <dt class="d_decl" id="CommentException">class CommentException: std.xml.XMLException</dt> <dd>
<p>Thrown during Comment constructor</p> </dd> <dt class="d_decl" id="CDataException">class CDataException: std.xml.XMLException</dt> <dd>
<p>Thrown during CData constructor</p> </dd> <dt class="d_decl" id="XIException">class XIException: std.xml.XMLException</dt> <dd>
<p>Thrown during XMLInstruction constructor</p> </dd> <dt class="d_decl" id="PIException">class PIException: std.xml.XMLException</dt> <dd>
<p>Thrown during ProcessingInstruction constructor</p> </dd> <dt class="d_decl" id="TextException">class TextException: std.xml.XMLException</dt> <dd>
<p>Thrown during Text constructor</p> </dd> <dt class="d_decl" id="DecodeException">class DecodeException: std.xml.XMLException</dt> <dd>
<p>Thrown during decode()</p> </dd> <dt class="d_decl" id="InvalidTypeException">class InvalidTypeException: std.xml.XMLException</dt> <dd>
<p>Thrown if comparing with wrong type</p> </dd> <dt class="d_decl" id="TagException">class TagException: std.xml.XMLException</dt> <dd>
<p>Thrown when parsing for Tags</p> </dd> <dt class="d_decl" id="CheckException">class CheckException: std.xml.XMLException</dt> <dd>
<p>Thrown during check()</p> <dl>
<dt class="d_decl" id="CheckException.err">CheckException err</dt> <dd>
<p>Parent in hierarchy</p> </dd> <dt class="d_decl" id="CheckException.msg">string msg</dt> <dd>
<p>Name of production rule which failed to parse, or specific error message</p> </dd> <dt class="d_decl" id="CheckException.line">size_t line</dt> <dd>
<p>Line number at which parse failure occurred</p> </dd> <dt class="d_decl" id="CheckException.column">size_t column</dt> <dd>
<p>Column number at which parse failure occurred</p> </dd> </dl> </dd> </dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 1999–2017 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/phobos/std_xml.html" class="_attribution-link" target="_blank">https://dlang.org/phobos/std_xml.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
