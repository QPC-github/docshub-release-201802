
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>std.range - D - W3cubDocs</title>
  
  <meta name="description" content="This module defines the notion of a range. Ranges generalize the concept of arrays, lists, or anything that involves sequential access. This &hellip;">
  <meta name="keywords" content="std, range, -, d">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/d/std_range/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-e0f881b0fce8cbe96f33dadc355b7159d5d2912911231446d60eb8f9caffa802.css">
  <script type="text/javascript" src="/assets/application-8fc46316434047265cd383f02b8e7f434ed7dec4a59f920dd633deef8d488d1b.js"></script>
  <script src="/json/d.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/d/" class="_nav-link" title="" style="margin-left:0;">D</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _d">
				
<h1>std.range</h1>  <p>This module defines the notion of a <code>range</code>. Ranges generalize the concept of arrays, lists, or anything that involves sequential access. This abstraction enables the same set of algorithms (see <a href="../std_algorithm/"><code>std.algorithm</code></a>) to be used with a vast variety of different concrete types. For example, a linear search algorithm such as <a href="../std_algorithm_searching/#find"><code>std.algorithm.searching.find</code></a> works not just for arrays, but for linked-lists, input files, incoming network data, etc. </p>
<dl>
<dt>Guides</dt>
<dd> There are many articles available that can bolster understanding ranges: </dd>
</dl> <ul> <li>Ali Ã‡ehreli's <a href="http://ddili.org/ders/d.en/ranges.html" target="_blank">tutorial on ranges</a> for the basics of working with and creating <code>range</code>-based code.</li> <li>Jonathan M. Davis <a href="http://dconf.org/2015/talks/davis.html" target="_blank"><i>Introduction to Ranges</i></a> talk at DConf 2015 a vivid introduction from its core constructs to practical advice.</li> <li>The DLang Tour's <a href="http://tour.dlang.org/tour/en/basics/ranges" target="_blank">chapter on ranges</a> for an interactive introduction.</li> <li>H. S. Teoh's <a href="http://wiki.dlang.org/Component_programming_with_ranges" target="_blank">tutorial on component programming with ranges</a> for a real-world showcase of the influence of range-based programming on complex algorithms.</li> <li>Andrei Alexandrescu's article <a href="http://www.informit.com/articles/printerfriendly.aspx?p=1407357&amp;rll=1" target="_blank"> <i>On Iteration</i></a> for conceptual aspect of ranges and the motivation </li> </ul>  <dl>
<dt>Submodules</dt>
<dd> This module has two submodules: </dd>
</dl> The <a href="../std_range_primitives/"><code>std.range.primitives</code></a> submodule provides basic range functionality. It defines several templates for testing whether a given object is a range, what kind of range it is, and provides some common range operations.  The <a href="../std_range_interfaces/"><code>std.range.interfaces</code></a> submodule provides object-based interfaces for working with ranges via runtime polymorphism.  The remainder of this module provides a rich set of range creation and composition templates that let you construct new ranges out of existing ranges:    <table>
 <tr>
<td><a href="#chain"><code>chain</code></a></td> <td>Concatenates several ranges into a single range. </td>
</tr> <tr>
<td><a href="#choose"><code>choose</code></a></td> <td>Chooses one of two ranges at runtime based on a boolean condition. </td>
</tr> <tr>
<td><a href="#chooseAmong"><code>chooseAmong</code></a></td> <td>Chooses one of several ranges at runtime based on an index. </td>
</tr> <tr>
<td><a href="#chunks"><code>chunks</code></a></td> <td>Creates a range that returns fixed-size chunks of the original range. </td>
</tr> <tr>
<td><a href="#cycle"><code>cycle</code></a></td> <td>Creates an infinite range that repeats the given forward range indefinitely. Good for implementing circular buffers. </td>
</tr> <tr>
<td><a href="#drop"><code>drop</code></a></td> <td>Creates the range that results from discarding the first <i>n</i> elements from the given range. </td>
</tr> <tr>
<td><a href="#dropBack"><code>dropBack</code></a></td> <td>Creates the range that results from discarding the last <i>n</i> elements from the given range. </td>
</tr> <tr>
<td><a href="#dropExactly"><code>dropExactly</code></a></td> <td>Creates the range that results from discarding exactly <i>n</i> of the first elements from the given range. </td>
</tr> <tr>
<td><a href="#dropBackExactly"><code>dropBackExactly</code></a></td> <td>Creates the range that results from discarding exactly <i>n</i> of the last elements from the given range. </td>
</tr> <tr>
<td><a href="#dropOne"><code>dropOne</code></a></td> <td>Creates the range that results from discarding the first element from the given range. </td>
</tr> <tr>
<td><code><a href="#dropBackOne">dropBackOne</a></code></td> <td>Creates the range that results from discarding the last element from the given range. </td>
</tr> <tr>
<td><a href="#enumerate"><code>enumerate</code></a></td> <td>Iterates a range with an attached index variable. </td>
</tr> <tr>
<td><a href="#evenChunks"><code>evenChunks</code></a></td> <td>Creates a range that returns a number of chunks of approximately equal length from the original range. </td>
</tr> <tr>
<td><a href="#frontTransversal"><code>frontTransversal</code></a></td> <td>Creates a range that iterates over the first elements of the given ranges. </td>
</tr> <tr>
<td><a href="#generate"><code>generate</code></a></td> <td>Creates a range by successive calls to a given function. This allows to create ranges as a single delegate. </td>
</tr> <tr>
<td><a href="#indexed"><code>indexed</code></a></td> <td>Creates a range that offers a view of a given range as though its elements were reordered according to a given range of indices. </td>
</tr> <tr>
<td><a href="#iota"><code>iota</code></a></td> <td>Creates a range consisting of numbers between a starting point and ending point, spaced apart by a given interval. </td>
</tr> <tr>
<td><a href="#lockstep"><code>lockstep</code></a></td> <td>Iterates <i>n</i> ranges in lockstep, for use in a <code>foreach</code> loop. Similar to <code>zip</code>, except that <code>lockstep</code> is designed especially for <code>foreach</code> loops. </td>
</tr> <tr>
<td><a href="#NullSink"><code>NullSink</code></a></td> <td>An output range that discards the data it receives. </td>
</tr> <tr>
<td><a href="#only"><code>only</code></a></td> <td>Creates a range that iterates over the given arguments. </td>
</tr> <tr>
<td><a href="#padLeft"><code>padLeft</code></a></td> <td>Pads a range to a specified length by adding a given element to the front of the range. Is lazy if the range has a known length. </td>
</tr> <tr>
<td><a href="#padRight"><code>padRight</code></a></td> <td>Lazily pads a range to a specified length by adding a given element to the back of the range. </td>
</tr> <tr>
<td><a href="#radial"><code>radial</code></a></td> <td>Given a random-access range and a starting point, creates a range that alternately returns the next left and next right element to the starting point. </td>
</tr> <tr>
<td><a href="#recurrence"><code>recurrence</code></a></td> <td>Creates a forward range whose values are defined by a mathematical recurrence relation. </td>
</tr> <tr>
<td><a href="#refRange"><code>refRange</code></a></td> <td>Pass a range by reference. Both the original range and the RefRange will always have the exact same elements. Any operation done on one will affect the other. </td>
</tr> <tr>
<td><a href="#repeat"><code>repeat</code></a></td> <td>Creates a range that consists of a single element repeated <i>n</i> times, or an infinite range repeating that element indefinitely. </td>
</tr> <tr>
<td><a href="#retro"><code>retro</code></a></td> <td>Iterates a bidirectional range backwards. </td>
</tr> <tr>
<td><a href="#roundRobin"><code>roundRobin</code></a></td> <td>Given <i>n</i> ranges, creates a new range that return the <i>n</i> first elements of each range, in turn, then the second element of each range, and so on, in a round-robin fashion. </td>
</tr> <tr>
<td><a href="#sequence"><code>sequence</code></a></td> <td>Similar to <code>recurrence</code>, except that a random-access range is created. </td>
</tr> <tr>
<td><a href="#stride"><code>stride</code></a></td> <td>Iterates a range with stride <i>n</i>. </td>
</tr> <tr>
<td><a href="#tail"><code>tail</code></a></td> <td>Return a range advanced to within <code>n</code> elements of the end of the given range. </td>
</tr> <tr>
<td><a href="#take"><code>take</code></a></td> <td>Creates a sub-range consisting of only up to the first <i>n</i> elements of the given range. </td>
</tr> <tr>
<td><a href="#takeExactly"><code>takeExactly</code></a></td> <td>Like <code>take</code>, but assumes the given range actually has <i>n</i> elements, and therefore also defines the <code>length</code> property. </td>
</tr> <tr>
<td><a href="#takeNone"><code>takeNone</code></a></td> <td>Creates a random-access range consisting of zero elements of the given range. </td>
</tr> <tr>
<td><a href="#takeOne"><code>takeOne</code></a></td> <td>Creates a random-access range consisting of exactly the first element of the given range. </td>
</tr> <tr>
<td><a href="#tee"><code>tee</code></a></td> <td>Creates a range that wraps a given range, forwarding along its elements while also calling a provided function with each element. </td>
</tr> <tr>
<td><a href="#transposed"><code>transposed</code></a></td> <td>Transposes a range of ranges. </td>
</tr> <tr>
<td><a href="#transversal"><code>transversal</code></a></td> <td>Creates a range that iterates over the <i>n</i>'th elements of the given random-access ranges. </td>
</tr> <tr>
<td><a href="#zip"><code>zip</code></a></td> <td>Given <i>n</i> ranges, creates a range that successively returns a tuple of all the first elements, a tuple of all the second elements, etc. </td>
</tr> </table>  <dl>
<dt>Sortedness</dt>
<dd> Ranges whose elements are sorted afford better efficiency with certain operations. For this, the <a href="#assumeSorted"><code>assumeSorted</code></a> function can be used to construct a <a href="#SortedRange"><code>SortedRange</code></a> from a pre-sorted range. The <a href="../std_algorithm_sorting/#sort"><code>std.algorithm.sorting.sort</code></a> function also conveniently returns a <a href="#SortedRange"><code>SortedRange</code></a>. <a href="#SortedRange"><code>SortedRange</code></a> objects provide some additional range operations that take advantage of the fact that the range is sorted. </dd>
</dl> <dl>
<dt>Source</dt>
<dd> <span class="phobos_src"><a class="https" href="https://github.com/dlang/phobos/blob/master/std/range/package.d" target="_blank">std/range/package.d</a></span> </dd>
</dl> <dl>
<dt>License:</dt>
<dd>
<a href="http://boost.org/LICENSE_1_0.txt" target="_blank">Boost License 1.0</a>. </dd>
</dl> <dl>
<dt>Authors:</dt>
<dd>
<a href="http://erdani.com" target="_blank">Andrei Alexandrescu</a>, David Simcha, Jonathan M Davis, and Jack Stouffer. Credit for some of the ideas in building this module goes to <a href="http://fantascienza.net/leonardo/so/" target="_blank">Leonardo Maffi</a>.</dd>
</dl> <dl>
<dt class="d_decl" id="retro">auto retro(Range)(Range r)<br><br>  Constraints:<br>    if (isBidirectionalRange!(Unqual!Range))</dt> <dd>
<p>Iterates a bidirectional range backwards. The original range can be accessed by using the <code>source</code> property. Applying <code>retro</code> twice to the same range yields the original range. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Range <code>r</code>
</td> <td>the bidirectional range to iterate backwards</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A bidirectional range with length if <code>r</code> also provides a length. Or, if <code>r</code> is a random access range, then the return value will be random access as well. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="../std_algorithm_mutation/#reverse"><code>std.algorithm.mutation.reverse</code></a> for mutating the source range directly.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
int[5] a = [ 1, 2, 3, 4, 5 ];
int[5] b = [ 5, 4, 3, 2, 1 ];
assert(equal(retro(a[]), b[]));
assert(retro(a[]).source is a[]);
assert(retro(retro(a[])) is a[]);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="stride">auto stride(Range)(Range r, size_t n)<br><br>  Constraints:<br>    if (isInputRange!(Unqual!Range))</dt> <dd>
<p>Iterates range <code>r</code> with <code>stride</code> <code>n</code>. If the range is a random-access range, moves by indexing into the range; otherwise, moves by successive calls to <code>popFront</code>. Applying <code>stride</code> twice to the same range results in a <code>stride</code> with a step that is the product of the two applications. It is an error for <code>n</code> to be 0. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Range <code>r</code>
</td> <td>the input range to <code>stride</code> over</td>
</tr> <tr>
<td>size_t <code>n</code>
</td> <td>the number of elements to skip over</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>At minimum, an input range. The resulting range will adopt the range primitives of the underlying range as long as <a href="../std_range_primitives/#hasLength"><code>std.range.primitives.hasLength</code></a> is <code>true</code>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;

int[] a = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 ];
assert(equal(stride(a, 3), [ 1, 4, 7, 10 ][]));
writeln(stride(stride(a, 2), 3)); // stride(a, 6)
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="chain">auto chain(Ranges...)(Ranges rs)<br><br>  Constraints:<br>    if (Ranges.length &gt; 0 &amp;&amp; allSatisfy!(isInputRange, staticMap!(Unqual, Ranges)) &amp;&amp; !is(CommonType!(staticMap!(ElementType, staticMap!(Unqual, Ranges))) == void))</dt> <dd>
<p>Spans multiple ranges in sequence. The function <code>chain</code> takes any number of ranges and returns a <code>Chain!(R1, R2,...)</code> object. The ranges may be different, but they must have the same element type. The result is a range that offers the <code>front</code>, <code>popFront</code>, and <code>empty</code> primitives. If all input ranges offer random access and <code>length</code>, <code>Chain</code> offers them as well. </p>
<p>If only one range is offered to <code>Chain</code> or <code>chain</code>, the <code>Chain</code> type exits the picture by aliasing itself directly to that range's type. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Ranges <code>rs</code>
</td> <td>the input ranges to <code>chain</code> together</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>An input range at minimum. If all of the ranges in <code>rs</code> provide a range primitive, the returned range will also provide that range primitive. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="#only"><code>only</code></a> to <code>chain</code> values to a range</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;

int[] arr1 = [ 1, 2, 3, 4 ];
int[] arr2 = [ 5, 6 ];
int[] arr3 = [ 7 ];
auto s = chain(arr1, arr2, arr3);
writeln(s.length); // 7
writeln(s[5]); // 6
assert(equal(s, [1, 2, 3, 4, 5, 6, 7][]));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Range primitives are carried over to the returned range if all of the ranges provide them <pre data-language="d">import std.algorithm.comparison : equal;
import std.algorithm.sorting : sort;

int[] arr1 = [5, 2, 8];
int[] arr2 = [3, 7, 9];
int[] arr3 = [1, 4, 6];

// in-place sorting across all of the arrays
auto s = arr1.chain(arr2, arr3).sort;

assert(s.equal([1, 2, 3, 4, 5, 6, 7, 8, 9]));
assert(arr1.equal([1, 2, 3]));
assert(arr2.equal([4, 5, 6]));
assert(arr3.equal([7, 8, 9]));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="choose">auto choose(R1, R2)(bool condition, R1 r1, R2 r2)<br><br>  Constraints:<br>    if (isInputRange!(Unqual!R1) &amp;&amp; isInputRange!(Unqual!R2) &amp;&amp; !is(CommonType!(ElementType!(Unqual!R1), ElementType!(Unqual!R2)) == void))</dt> <dd>
<p>Choose one of two ranges at runtime depending on a Boolean <code>condition</code>. </p>
<p>The ranges may be different, but they must have compatible element types (i.e. <code>CommonType</code> must exist for the two element types). The result is a range that offers the weakest capabilities of the two (e.g. <code>ForwardRange</code> if <code>R1</code> is a random-access range and <code>R2</code> is a forward range). </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>bool <code>condition</code>
</td> <td>which range to <code>choose</code>: <code>r1</code> if <code>true</code>, <code>r2</code> otherwise</td>
</tr> <tr>
<td>R1 <code>r1</code>
</td> <td>the "<code>true</code>" range</td>
</tr> <tr>
<td>R2 <code>r2</code>
</td> <td>the "<code>false</code>" range</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A range type dependent on <code>R1</code> and <code>R2</code>. </dd>
</dl> <dl>
<dt>Bugs:</dt>
<dd><span class="bugzilla"><a class="https" href="https://issues.dlang.org/show_bug.cgi?id=14660" target="_blank">Bugzilla 14660</a></span></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
import std.algorithm.iteration : filter, map;

auto data1 = [ 1, 2, 3, 4 ].filter!(a =&gt; a != 3);
auto data2 = [ 5, 6, 7, 8 ].map!(a =&gt; a + 1);

// choose() is primarily useful when you need to select one of two ranges
// with different types at runtime.
static assert(!is(typeof(data1) == typeof(data2)));

auto chooseRange(bool pickFirst)
{
    // The returned range is a common wrapper type that can be used for
    // returning or storing either range without running into a type error.
    return choose(pickFirst, data1, data2);

    // Simply returning the chosen range without using choose() does not
    // work, because map() and filter() return different types.
    //return pickFirst ? data1 : data2; // does not compile
}

auto result = chooseRange(true);
assert(result.equal([ 1, 2, 4 ]));

result = chooseRange(false);
assert(result.equal([ 6, 7, 8, 9 ]));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="chooseAmong">auto chooseAmong(Ranges...)(size_t index, Ranges rs)<br><br>  Constraints:<br>    if (Ranges.length &gt;= 2 &amp;&amp; allSatisfy!(isInputRange, staticMap!(Unqual, Ranges)) &amp;&amp; !is(CommonType!(staticMap!(ElementType, Ranges)) == void))</dt> <dd>
<p>Choose one of multiple ranges at runtime. </p>
<p>The ranges may be different, but they must have compatible element types. The result is a range that offers the weakest capabilities of all <code>Ranges</code>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>size_t <code>index</code>
</td> <td>which range to choose, must be less than the number of ranges</td>
</tr> <tr>
<td>Ranges <code>rs</code>
</td> <td>two or more ranges</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The indexed range. If <code>rs</code> consists of only one range, the return type is an alias of that range's type.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;

int[] arr1 = [ 1, 2, 3, 4 ];
int[] arr2 = [ 5, 6 ];
int[] arr3 = [ 7 ];

{
    auto s = chooseAmong(0, arr1, arr2, arr3);
    auto t = s.save;
    writeln(s.length); // 4
    writeln(s[2]); // 3
    s.popFront();
    assert(equal(t, [1, 2, 3, 4][]));
}
{
    auto s = chooseAmong(1, arr1, arr2, arr3);
    writeln(s.length); // 2
    s.front = 8;
    assert(equal(s, [8, 6][]));
}
{
    auto s = chooseAmong(1, arr1, arr2, arr3);
    writeln(s.length); // 2
    s[1] = 9;
    assert(equal(s, [8, 9][]));
}
{
    auto s = chooseAmong(1, arr2, arr1, arr3)[1 .. 3];
    writeln(s.length); // 2
    assert(equal(s, [2, 3][]));
}
{
    auto s = chooseAmong(0, arr1, arr2, arr3);
    writeln(s.length); // 4
    writeln(s.back); // 4
    s.popBack();
    s.back = 5;
    assert(equal(s, [1, 2, 5][]));
    s.back = 3;
    assert(equal(s, [1, 2, 3][]));
}
{
    uint[] foo = [1,2,3,4,5];
    uint[] bar = [6,7,8,9,10];
    auto c = chooseAmong(1,foo, bar);
    writeln(c[3]); // 9
    c[3] = 42;
    writeln(c[3]); // 42
    writeln(c.moveFront()); // 6
    writeln(c.moveBack()); // 10
    writeln(c.moveAt(4)); // 10
}
{
    import std.range : cycle;
    auto s = chooseAmong(1, cycle(arr2), cycle(arr3));
    assert(isInfinite!(typeof(s)));
    assert(!s.empty);
    writeln(s[100]); // 7
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="roundRobin">auto roundRobin(Rs...)(Rs rs)<br><br>  Constraints:<br>    if (Rs.length &gt; 1 &amp;&amp; allSatisfy!(isInputRange, staticMap!(Unqual, Rs)))</dt> <dd>
<p><code>roundRobin(r1, r2, r3)</code> yields <code>r1.front</code>, then <code>r2.front</code>, then <code>r3.front</code>, after which it pops off one element from each and continues again from <code>r1</code>. For example, if two ranges are involved, it alternately yields elements off the two ranges. <code>roundRobin</code> stops after it has consumed all ranges (skipping over the ones that finish early).</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;

int[] a = [ 1, 2, 3 ];
int[] b = [ 10, 20, 30, 40 ];
auto r = roundRobin(a, b);
assert(equal(r, [ 1, 10, 2, 20, 3, 30, 40 ]));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<code>roundRobin</code> can be used to create "interleave" functionality which inserts an element between each element in a range. <pre data-language="d">import std.algorithm.comparison : equal;

auto interleave(R, E)(R range, E element)
if ((isInputRange!R &amp;&amp; hasLength!R) || isForwardRange!R)
{
    static if (hasLength!R)
        immutable len = range.length;
    else
        immutable len = range.save.walkLength;

    return roundRobin(
        range,
        element.repeat(len - 1)
    );
}

assert(interleave([1, 2, 3], 0).equal([1, 0, 2, 0, 3]));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="radial">auto radial(Range, I)(Range r, I startingIndex)<br>auto radial(R)(R r)<br><br>  Constraints:<br>    if (isRandomAccessRange!(Unqual!Range) &amp;&amp; hasLength!(Unqual!Range) &amp;&amp; hasSlicing!(Unqual!Range) &amp;&amp; isIntegral!I)<br>    if (isRandomAccessRange!(Unqual!R) &amp;&amp; hasLength!(Unqual!R) &amp;&amp; hasSlicing!(Unqual!R))</dt> <dd>
<p>Iterates a random-access range starting from a given point and progressively extending left and right from that point. If no initial point is given, iteration starts from the middle of the range. Iteration spans the entire range. </p>
<p>When <code>startingIndex</code> is 0 the range will be fully iterated in order and in reverse order when <code>r.length</code> is given. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Range <code>r</code>
</td> <td>a random access range with length and slicing</td>
</tr> <tr>
<td>I <code>startingIndex</code>
</td> <td>the index to begin iteration from</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A forward range with length</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
int[] a = [ 1, 2, 3, 4, 5 ];
assert(equal(radial(a), [ 3, 4, 2, 5, 1 ]));
a = [ 1, 2, 3, 4 ];
assert(equal(radial(a), [ 2, 3, 1, 4 ]));

// If the left end is reached first, the remaining elements on the right
// are concatenated in order:
a = [ 0, 1, 2, 3, 4, 5 ];
assert(equal(radial(a, 1), [ 1, 2, 0, 3, 4, 5 ]));

// If the right end is reached first, the remaining elements on the left
// are concatenated in reverse order:
assert(equal(radial(a, 4), [ 4, 5, 3, 2, 1, 0 ]));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="take">Take!R take(R)(R input, size_t n)<br>struct Take(Range) if (isInputRange!(Unqual!Range) &amp;amp<br>&amp;amp<br>!(!isInfinite!(Unqual!Range) &amp;amp<br>&amp;amp<br>hasSlicing!(Unqual!Range) || is(Range T == Take!T)))<br><br>  Constraints:<br>    if (isInputRange!(Unqual!R))</dt> <dd>
<p>Lazily takes only up to <code>n</code> elements of a range. This is particularly useful when using with infinite ranges. </p>
<p>Unlike <a href="#takeExactly"><code>takeExactly</code></a>, <code>take</code> does not require that there are <code>n</code> or more elements in <code>input</code>. As a consequence, length information is not applied to the result unless <code>input</code> also has length information. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>input</code>
</td> <td>an <code>input</code> range to iterate over up to <code>n</code> times</td>
</tr> <tr>
<td>size_t <code>n</code>
</td> <td>the number of elements to <code>take</code>
</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>At minimum, an <code>input</code> range. If the range offers random access and <code>length</code>, <code>take</code> offers them as well.</dd>
</dl> </dd> <dt class="d_decl" id="Take.2">template Take(R) if (isInputRange!(Unqual!R) &amp;amp<br>&amp;amp<br>(!isInfinite!(Unqual!R) &amp;amp<br>&amp;amp<br>hasSlicing!(Unqual!R) || is(R T == Take!T)))</dt> <dd>
<p>This template simply aliases itself to R and is useful for consistency in generic code.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;

int[] arr1 = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ];
auto s = take(arr1, 5);
writeln(s.length); // 5
writeln(s[4]); // 5
assert(equal(s, [ 1, 2, 3, 4, 5 ][]));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>If the range runs out before <code>n</code> elements, <code>take</code> simply returns the entire range (unlike <a href="#takeExactly"><code>takeExactly</code></a>, which will cause an assertion failure if the range ends prematurely): <pre data-language="d">import std.algorithm.comparison : equal;

int[] arr2 = [ 1, 2, 3 ];
auto t = take(arr2, 5);
writeln(t.length); // 3
assert(equal(t, [ 1, 2, 3 ]));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="takeExactly">auto takeExactly(R)(R range, size_t n)<br><br>  Constraints:<br>    if (isInputRange!R)</dt> <dd>
<p>Similar to <a href="#take"><code>take</code></a>, but assumes that <code>range</code> has at least <code>n</code> elements. Consequently, the result of <code>takeExactly(range, n)</code> always defines the <code>length</code> property (and initializes it to <code>n</code>) even when <code>range</code> itself does not define <code>length</code>. </p>
<p>The result of <code>takeExactly</code> is identical to that of <a href="#take"><code>take</code></a> in cases where the original <code>range</code> defines <code>length</code> or is infinite. <br><br> Unlike <a href="#take"><code>take</code></a>, however, it is illegal to pass a <code>range</code> with less than <code>n</code> elements to <code>takeExactly</code>; this will cause an assertion failure.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;

auto a = [ 1, 2, 3, 4, 5 ];

auto b = takeExactly(a, 3);
assert(equal(b, [1, 2, 3]));
static assert(is(typeof(b.length) == size_t));
writeln(b.length); // 3
writeln(b.front); // 1
writeln(b.back); // 3
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="takeOne">auto takeOne(R)(R source)<br><br>  Constraints:<br>    if (isInputRange!R)</dt> <dd>
<p>Returns a range with at most one element; for example, <code>takeOne([42, 43, 44])</code> returns a range consisting of the integer <code>42</code>. Calling <code>popFront()</code> off that range renders it empty. </p>
<p>In effect <code>takeOne(r)</code> is somewhat equivalent to <code>take(r, 1)</code> but in certain interfaces it is important to know statically that the range may only have at most one element. <br><br> The type returned by <code>takeOne</code> is a random-access range with length regardless of <code>R</code>'s capabilities, as long as it is a forward range. (another feature that distinguishes <code>takeOne</code> from <code>take</code>). If (D R) is an input range but not a forward range, return type is an input range with all random-access capabilities except save.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto s = takeOne([42, 43, 44]);
static assert(isRandomAccessRange!(typeof(s)));
writeln(s.length); // 1
assert(!s.empty);
writeln(s.front); // 42
s.front = 43;
writeln(s.front); // 43
writeln(s.back); // 43
writeln(s[0]); // 43
s.popFront();
writeln(s.length); // 0
assert(s.empty);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="takeNone">auto takeNone(R)()<br><br>  Constraints:<br>    if (isInputRange!R)</dt> <dd>
<p>Returns an empty range which is statically known to be empty and is guaranteed to have <code>length</code> and be random access regardless of <code>R</code>'s capabilities.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto range = takeNone!(int[])();
writeln(range.length); // 0
assert(range.empty);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="takeNone.2">auto takeNone(R)(R range)<br><br>  Constraints:<br>    if (isInputRange!R)</dt> <dd>
<p>Creates an empty <code>range</code> from the given <code>range</code> in <span class="bigoh">ÎŸ(<code>1</code>)</span>. If it can, it will return the same <code>range</code> type. If not, it will return <code>takeExactly(range, 0)</code>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.iteration : filter;
assert(takeNone([42, 27, 19]).empty);
assert(takeNone("dlang.org").empty);
assert(takeNone(filter!"true"([42, 27, 19])).empty);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="tail">auto tail(Range)(Range range, size_t n)<br><br>  Constraints:<br>    if (isInputRange!Range &amp;&amp; !isInfinite!Range &amp;&amp; (hasLength!Range || isForwardRange!Range))</dt> <dd>
<p>Return a range advanced to within <code>n</code> elements of the end of <code>range</code>. </p>
<p>Intended as the range equivalent of the Unix <a href="http://en.wikipedia.org/wiki/Tail_%28Unix%29" target="_blank">tail</a> utility. When the length of <code>range</code> is less than or equal to <code>n</code>, <code>range</code> is returned as-is. <br><br> Completes in <span class="bigoh">ÎŸ(<code>1</code>)</span> steps for ranges that support slicing and have length. Completes in <span class="bigoh">ÎŸ(<code>range.length</code>)</span> time for all other ranges. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Range <code>range</code>
</td> <td>range to get tail of</td>
</tr> <tr>
<td>size_t <code>n</code>
</td> <td>maximum number of elements to include in tail</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>Returns the tail of <code>range</code> augmented with length information</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">// tail -c n
writeln([1, 2, 3].tail(1)); // [3]
writeln([1, 2, 3].tail(2)); // [2, 3]
writeln([1, 2, 3].tail(3)); // [1, 2, 3]
writeln([1, 2, 3].tail(4)); // [1, 2, 3]
writeln([1, 2, 3].tail(0).length); // 0

// tail --lines=n
import std.algorithm.comparison : equal;
import std.algorithm.iteration : joiner;
import std.exception : assumeWontThrow;
import std.string : lineSplitter;
assert("one\ntwo\nthree"
    .lineSplitter
    .tail(2)
    .joiner("\n")
    .equal("two\nthree")
    .assumeWontThrow);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="drop">R drop(R)(R range, size_t n)<br>R dropBack(R)(R range, size_t n)<br><br>  Constraints:<br>    if (isInputRange!R)<br>    if (isBidirectionalRange!R)</dt> <dd>
<p>Convenience function which calls <a href="../std_range_primitives/#popFrontN"><code>std.range.primitives.popFrontN</code></a><code>(range, n)</code> and returns <code>range</code>. <code>drop</code> makes it easier to pop elements from a <code>range</code> and then pass it to another function within a single expression, whereas <code>popFrontN</code> would require multiple statements. </p>
<p><code>dropBack</code> provides the same functionality but instead calls <a href="../std_range_primitives/#popBackN"><code>std.range.primitives.popBackN</code></a><code>(range, n)</code> </p> <dl>
<dt>Note</dt>
<dd> <code>drop</code> and <code>dropBack</code> will only pop <i>up to</i> <code>n</code> elements but will stop if the <code>range</code> is empty first. In other languages this is sometimes called <code>skip</code>. </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>range</code>
</td> <td>the input <code>range</code> to <code>drop</code> from</td>
</tr> <tr>
<td>size_t <code>n</code>
</td> <td>the number of elements to <code>drop</code>
</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>range</code> with up to <code>n</code> elements dropped </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="../std_range_primitives/#popFront"><code>std.range.primitives.popFront</code></a>, <a href="../std_range_primitives/#popBackN"><code>std.range.primitives.popBackN</code></a>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;

writeln([0, 2, 1, 5, 0, 3].drop(3)); // [5, 0, 3]
writeln("hello world".drop(6)); // "world"
assert("hello world".drop(50).empty);
assert("hello world".take(6).drop(3).equal("lo "));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="dropExactly">R dropExactly(R)(R range, size_t n)<br>R dropBackExactly(R)(R range, size_t n)<br><br>  Constraints:<br>    if (isInputRange!R)<br>    if (isBidirectionalRange!R)</dt> <dd>
<p>Similar to <a href="#drop"><code>drop</code></a> and <code>dropBack</code> but they call <code>range.<a href="#popFrontExactly">popFrontExactly</a>(n)</code> and <code>range.popBackExactly(n)</code> instead. </p>
<dl>
<dt>Note</dt>
<dd> Unlike <code>drop</code>, <code>dropExactly</code> will assume that the <code>range</code> holds at least <code>n</code> elements. This makes <code>dropExactly</code> faster than <code>drop</code>, but it also means that if <code>range</code> does not contain at least <code>n</code> elements, it will attempt to call <code>popFront</code> on an empty <code>range</code>, which is undefined behavior. So, only use <code>popFrontExactly</code> when it is guaranteed that <code>range</code> holds at least <code>n</code> elements. </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>range</code>
</td> <td>the input <code>range</code> to drop from</td>
</tr> <tr>
<td>size_t <code>n</code>
</td> <td>the number of elements to drop</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>range</code> with <code>n</code> elements dropped </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="../std_range_primitives/#popFrontExcatly"><code>std.range.primitives.popFrontExcatly</code></a>, <a href="../std_range_primitives/#popBackExcatly"><code>std.range.primitives.popBackExcatly</code></a>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
import std.algorithm.iteration : filterBidirectional;

auto a = [1, 2, 3];
writeln(a.dropExactly(2)); // [3]
writeln(a.dropBackExactly(2)); // [1]

string s = "æ—¥æœ¬èªž";
writeln(s.dropExactly(2)); // "èªž"
writeln(s.dropBackExactly(2)); // "æ—¥"

auto bd = filterBidirectional!"true"([1, 2, 3]);
assert(bd.dropExactly(2).equal([3]));
assert(bd.dropBackExactly(2).equal([1]));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="dropOne">R dropOne(R)(R range)<br>R dropBackOne(R)(R range)<br><br>  Constraints:<br>    if (isInputRange!R)<br>    if (isBidirectionalRange!R)</dt> <dd>
<p>Convenience function which calls <code>range.popFront()</code> and returns <code>range</code>. <code>dropOne</code> makes it easier to pop an element from a <code>range</code> and then pass it to another function within a single expression, whereas <code>popFront</code> would require multiple statements. </p>
<p><code>dropBackOne</code> provides the same functionality but instead calls <code>range.popBack()</code>.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
import std.algorithm.iteration : filterBidirectional;
import std.container.dlist : DList;

auto dl = DList!int(9, 1, 2, 3, 9);
assert(dl[].dropOne().dropBackOne().equal([1, 2, 3]));

auto a = [1, 2, 3];
writeln(a.dropOne()); // [2, 3]
writeln(a.dropBackOne()); // [1, 2]

string s = "æ—¥æœ¬èªž";
import std.exception : assumeWontThrow;
assert(assumeWontThrow(s.dropOne() == "æœ¬èªž"));
assert(assumeWontThrow(s.dropBackOne() == "æ—¥æœ¬"));

auto bd = filterBidirectional!"true"([1, 2, 3]);
assert(bd.dropOne().equal([2, 3]));
assert(bd.dropBackOne().equal([1, 2]));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Repeat">struct Repeat(T)<br>Repeat!T repeat(T)(T value)</dt> <dd>
<p>Create a range which repeats one <code>value</code> forever. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T <code>value</code>
</td> <td>the <code>value</code> to <code>repeat</code>
</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>An infinite random access range with slicing.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;

assert(equal(5.repeat().take(4), [ 5, 5, 5, 5 ]));
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="Repeat.front">inout @property inout(T) front()<br>inout @property inout(T) back()<br>enum bool empty<br>void popFront()<br>void popBack()<br>inout @property auto save()<br>inout inout(T) opIndex(size_t)<br>auto opSlice(size_t i, size_t j)<br>enum auto opDollar<br>inout auto opSlice(size_t, DollarToken)</dt> <dd>
<p>Range primitives</p> </dd> </dl> </dd> <dt class="d_decl" id="repeat.2">Take!(Repeat!T) repeat(T)(T value, size_t n)</dt> <dd>
<p>Repeats <code>value</code> exactly <code>n</code> times. Equivalent to <code> take(repeat(value), n)</code>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;

assert(equal(5.repeat(4), 5.repeat().take(4)));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="generate">auto generate(Fun)(Fun fun)<br>auto generate(alias fun)()<br><br>  Constraints:<br>    if (isCallable!fun)<br>    if (isCallable!fun)</dt> <dd>
<p>Given callable (<a href="../std_traits/#isCallable"><code>std.traits.isCallable</code></a>) <code>fun</code>, create as a range whose front is defined by successive calls to <code>fun()</code>. This is especially useful to call function with global side effects (random functions), or to create ranges expressed as a single delegate, rather than an entire <code>front</code>/<code>popFront</code>/<code>empty</code> structure. <code>fun</code> maybe be passed either a template alias parameter (existing function, delegate, struct type defining <code>static opCall</code>) or a run-time value argument (delegate, function object). The result range models an InputRange (<a href="../std_range_primitives/#isInputRange"><code>std.range.primitives.isInputRange</code></a>). The resulting range will call <code>fun()</code> on construction, and every call to <code>popFront</code>, and the cached value will be returned when <code>front</code> is called. </p>
<dl>
<dt>Returns:</dt>
<dd>an <code>inputRange</code> where each element represents another call to <code>fun</code>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
import std.algorithm.iteration : map;

int i = 1;
auto powersOfTwo = generate!(() =&gt; i *= 2)().take(10);
assert(equal(powersOfTwo, iota(1, 11).map!"2^^a"()));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;

//Returns a run-time delegate
auto infiniteIota(T)(T low, T high)
{
    T i = high;
    return (){if (i == high) i = low; return i++;};
}
//adapted as a range.
assert(equal(generate(infiniteIota(1, 4)).take(10), [1, 2, 3, 1, 2, 3, 1, 2, 3, 1]));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.format : format;
import std.random : uniform;

auto r = generate!(() =&gt; uniform(0, 6)).take(10);
format("%(%s %)", r);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Cycle">struct Cycle(R) if (isForwardRange!R &amp;amp<br>&amp;amp<br>!isInfinite!R)<br>template Cycle(R) if (isInfinite!R)</dt> <dd>
<p>Repeats the given forward range ad infinitum. If the original range is infinite (fact that would make <code>Cycle</code> the identity application), <code>Cycle</code> detects that and aliases itself to the range type itself. That works for non-forward ranges too. If the original range has random access, <code>Cycle</code> offers random access and also offers a constructor taking an initial position <code>index</code>. <code>Cycle</code> works with static arrays in addition to ranges, mostly for performance reasons. </p>
<dl>
<dt>Note</dt>
<dd> The input range must not be empty. </dd>
</dl> <dl>
<dt>Tip</dt>
<dd> This is a great way to implement simple circular buffers.</dd>
</dl> <dl>
<dt class="d_decl" id="Cycle.this">this(R input, size_t index = 0)<br>@property ref auto front()<br>const @property ref auto front()<br>@property void front(ElementType!R val)<br>enum bool empty<br>void popFront()<br>ref auto opIndex(size_t n)<br>const ref auto opIndex(size_t n)<br>void opIndexAssign(ElementType!R val, size_t n)<br>@property Cycle save()<br>enum auto opDollar<br>auto opSlice(size_t i, size_t j)<br>auto opSlice(size_t i, DollarToken)</dt> <dd>
<p>Range primitives</p> </dd> </dl> </dd> <dt class="d_decl" id="Cycle.2">struct Cycle(R) if (isStaticArray!R)<br>auto cycle(R)(R input)<br>Cycle!R cycle(R)(R input, size_t index = 0)<br>@system Cycle!R cycle(R)(ref R input, size_t index = 0)<br><br>  Constraints:<br>    if (isInputRange!R)<br>    if (isRandomAccessRange!R &amp;&amp; !isInfinite!R)<br>    if (isStaticArray!R)</dt> <dd>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
import std.range : cycle, take;

// Here we create an infinitive cyclic sequence from [1, 2]
// (i.e. get here [1, 2, 1, 2, 1, 2 and so on]) then
// take 5 elements of this sequence (so we have [1, 2, 1, 2, 1])
// and compare them with the expected values for equality.
assert(cycle([1, 2]).take(5).equal([ 1, 2, 1, 2, 1 ]));
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="Cycle.this.2">@system this(ref R input, size_t index = 0)<br>inout @property ref @safe inout(ElementType) front()<br>enum bool empty<br>@safe void popFront()<br>inout ref @safe inout(ElementType) opIndex(size_t n)<br>inout @property @safe inout(Cycle) save()<br>enum auto opDollar<br>@safe auto opSlice(size_t i, size_t j)<br>inout @safe inout(typeof(this)) opSlice(size_t i, DollarToken)</dt> <dd>
<p>Range primitives</p> </dd> </dl> </dd> <dt class="d_decl" id="Zip">struct Zip(Ranges...) if (Ranges.length &amp;amp<br>&amp;amp<br>allSatisfy!(isInputRange, Ranges))<br>auto zip(Ranges...)(Ranges ranges)<br>auto zip(Ranges...)(StoppingPolicy sp, Ranges ranges)<br><br>  Constraints:<br>    if (Ranges.length &amp;&amp; allSatisfy!(isInputRange, Ranges))<br>    if (Ranges.length &amp;&amp; allSatisfy!(isInputRange, Ranges))</dt> <dd>
<p>Iterate several <code>ranges</code> in lockstep. The element type is a proxy tuple that allows accessing the current element in the <code>n</code>th range by using <code>e[n]</code>. </p>
<p><code>zip</code> is similar to <a href="#lockstep"><code>lockstep</code></a>, but <code>lockstep</code> doesn't bundle its elements and uses the <code>opApply</code> protocol. <code>lockstep</code> allows reference access to the elements in <code>foreach</code> iterations. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>StoppingPolicy <code>sp</code>
</td> <td>controls what <code>zip</code> will do if the ranges are different lengths</td>
</tr> <tr>
<td>Ranges <code>ranges</code>
</td> <td>the <code>ranges</code> to <code>zip</code> together</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>At minimum, an input range. <code>Zip</code> offers the lowest range facilities of all components, e.g. it offers random access iff all <code>ranges</code> offer random access, and also offers mutation and swapping if all <code>ranges</code> offer it. Due to this, <code>Zip</code> is extremely powerful because it allows manipulating several <code>ranges</code> in lockstep. </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>An <code>Exception</code> if all of the ranges are not the same length and <code>sp</code> is set to <code>StoppingPolicy.requireSameLength</code>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
import std.algorithm.iteration : map;

// pairwise sum
auto arr = [0, 1, 2];
assert(zip(arr, arr.dropOne).map!"a[0] + a[1]".equal([1, 3]));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.conv : to;

int[] a = [ 1, 2, 3 ];
string[] b = [ "a", "b", "c" ];
string[] result;

foreach (tup; zip(a, b))
{
    result ~= tup[0].to!string ~ tup[1];
}

writeln(result); // ["1a", "2b", "3c"]

size_t idx = 0;
// unpacking tuple elements with foreach
foreach (e1, e2; zip(a, b))
{
    writeln(e1); // a[idx]
    writeln(e2); // b[idx]
    ++idx;
}
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<code>zip</code> is powerful - the following code sorts two arrays in parallel: <pre data-language="d">import std.algorithm.sorting : sort;

int[] a = [ 1, 2, 3 ];
string[] b = [ "a", "c", "b" ];
zip(a, b).sort!((t1, t2) =&gt; t1[0] &gt; t2[0]);

writeln(a); // [3, 2, 1]
// b is sorted according to a's sorting
writeln(b); // ["b", "c", "a"]
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="Zip.this">this(R rs, StoppingPolicy s = StoppingPolicy.shortest)</dt> <dd>
<p>Builds an object. Usually this is invoked indirectly by using the <a href="#zip"><code>zip</code></a> function.</p> </dd> <dt class="d_decl" id="Zip.empty">enum bool empty</dt> <dd>
<p>Returns <code>true</code> if the range is at end. The test depends on the stopping policy.</p> </dd> <dt class="d_decl" id="Zip.save">@property Zip save()</dt>  <dt class="d_decl" id="Zip.front">@property ElementType front()</dt> <dd>
<p>Returns the current iterated element.</p> </dd> <dt class="d_decl" id="Zip.front.2">@property void front(ElementType v)</dt> <dd>
<p>Sets the <code>front</code> of all iterated ranges.</p> </dd> <dt class="d_decl" id="Zip.moveFront">ElementType moveFront()</dt> <dd>
<p>Moves out the front.</p> </dd> <dt class="d_decl" id="Zip.back">@property ElementType back()</dt> <dd>
<p>Returns the rightmost element.</p> </dd> <dt class="d_decl" id="Zip.moveBack">ElementType moveBack()</dt> <dd>
<p>Moves out the back. </p>
<p>Returns the rightmost element.</p> </dd> <dt class="d_decl" id="Zip.back.2">@property void back(ElementType v)</dt> <dd>
<p>Returns the current iterated element. </p>
<p>Returns the rightmost element.</p> </dd> <dt class="d_decl" id="Zip.popFront">void popFront()</dt> <dd>
<p>Advances to the next element in all controlled ranges.</p> </dd> <dt class="d_decl" id="Zip.popBack">void popBack()</dt> <dd>
<p>Calls <code>popBack</code> for all controlled ranges.</p> </dd> <dt class="d_decl" id="Zip.length">@property auto length()</dt> <dd>
<p>Returns the <code>length</code> of this range. Defined only if all ranges define <code>length</code>.</p> </dd> <dt class="d_decl" id="Zip.opDollar">alias opDollar = length</dt> <dd>
<p>Returns the length of this range. Defined only if all ranges define <code>length</code>.</p> </dd> <dt class="d_decl" id="Zip.opSlice">auto opSlice(size_t from, size_t to)</dt> <dd>
<p>Returns a slice of the range. Defined only if all range define slicing.</p> </dd> <dt class="d_decl" id="Zip.opIndex">ElementType opIndex(size_t n)</dt> <dd>
<p>Returns the <code>n</code>th element in the composite range. Defined if all ranges offer random access.</p> </dd> <dt class="d_decl" id="Zip.opIndexAssign">void opIndexAssign(ElementType v, size_t n)</dt> <dd>
<p>Assigns to the <code>n</code>th element in the composite range. Defined if all ranges offer random access. </p>
<p>Returns the <code>n</code>th element in the composite range. Defined if all ranges offer random access.</p> </dd> <dt class="d_decl" id="Zip.moveAt">ElementType moveAt(size_t n)</dt> <dd>
<p>Destructively reads the <code>n</code>th element in the composite range. Defined if all ranges offer random access. </p>
<p>Returns the <code>n</code>th element in the composite range. Defined if all ranges offer random access.</p> </dd> </dl> </dd> <dt class="d_decl" id="StoppingPolicy">enum StoppingPolicy: int</dt> <dd>
<p>Dictates how iteration in a <code>Zip</code> should stop. By default stop at the end of the shortest of all ranges.</p> <dl>
<dt class="d_decl" id="StoppingPolicy.shortest">shortest</dt> <dd>
<p>Stop when the <code>shortest</code> range is exhausted</p> </dd> <dt class="d_decl" id="StoppingPolicy.longest">longest</dt> <dd>
<p>Stop when the <code>longest</code> range is exhausted</p> </dd> <dt class="d_decl" id="StoppingPolicy.requireSameLength">requireSameLength</dt> <dd>
<p>Require that all ranges are equal</p> </dd> </dl> </dd> <dt class="d_decl" id="Lockstep">struct Lockstep(Ranges...) if (Ranges.length &amp;gt<br>1 &amp;amp<br>&amp;amp<br>allSatisfy!(isInputRange, Ranges))<br>Lockstep!Ranges lockstep(Ranges...)(Ranges ranges)<br>Lockstep!Ranges lockstep(Ranges...)(Ranges ranges, StoppingPolicy s)<br><br>  Constraints:<br>    if (allSatisfy!(isInputRange, Ranges))<br>    if (allSatisfy!(isInputRange, Ranges))</dt> <dd>
<p>Iterate multiple <code>ranges</code> in <code>lockstep</code> using a <code>foreach</code> loop. In contrast to <a href="#zip"><code>zip</code></a> it allows reference access to its elements. If only a single range is passed in, the <code>Lockstep</code> aliases itself away. If the <code>ranges</code> are of different lengths and <code>s</code> == <code>StoppingPolicy.shortest</code> stop after the shortest range is empty. If the <code>ranges</code> are of different lengths and <code>s</code> == <code>StoppingPolicy.requireSameLength</code>, throw an exception. <code>s</code> may not be <code>StoppingPolicy.longest</code>, and passing this will throw an exception. </p>
<p>Iterating over <code>Lockstep</code> in reverse and with an index is only possible when <code>s</code> == <code>StoppingPolicy.requireSameLength</code>, in order to preserve indexes. If an attempt is made at iterating in reverse when <code>s</code> == <code>StoppingPolicy.shortest</code>, an exception will be thrown. <br><br> By default <code>StoppingPolicy</code> is set to <code>StoppingPolicy.shortest</code>. </p> <dl>
<dt>See Also:</dt>
<dd>
<a href="#zip"><code>zip</code></a>  <code>lockstep</code> is similar to <a href="#zip"><code>zip</code></a>, but <code>zip</code> bundles its elements and returns a range. <code>lockstep</code> also supports reference access. Use <code>zip</code> if you want to pass the result to a range function.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto arr1 = [1,2,3,4,5,100];
auto arr2 = [6,7,8,9,10];

foreach (ref a, b; lockstep(arr1, arr2))
{
    a += b;
}

writeln(arr1); // [7, 9, 11, 13, 15, 100]

/// Lockstep also supports iterating with an index variable:
foreach (index, a, b; lockstep(arr1, arr2))
{
    writeln(arr1[index]); // a
    writeln(arr2[index]); // b
}
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="Lockstep.this">this(R ranges, StoppingPolicy sp = StoppingPolicy.shortest)</dt>  </dl> </dd> <dt class="d_decl" id="Recurrence">struct Recurrence(alias fun, StateType, size_t stateSize)<br>Recurrence!(fun, CommonType!State, State.length) recurrence(alias fun, State...)(State initial)</dt> <dd>
<p>Creates a mathematical sequence given the <code>initial</code> values and a <code>recurrence</code> function that computes the next value from the existing values. The sequence comes in the form of an infinite forward range. The type <code>Recurrence</code> itself is seldom used directly; most often, recurrences are obtained by calling the function <code>recurrence</code>. </p>
<p>When calling <code>recurrence</code>, the function that computes the next value is specified as a template argument, and the <code>initial</code> values in the <code>recurrence</code> are passed as regular arguments. For example, in a Fibonacci sequence, there are two <code>initial</code> values (and therefore a state size of 2) because computing the next Fibonacci value needs the past two values. <br><br> The signature of this function should be: </p>
<pre data-language="d">auto fun(R)(R state, size_t n)
</pre> where <code>n</code> will be the index of the current value, and <code>state</code> will be an opaque state vector that can be indexed with array-indexing notation <code>state[i]</code>, where valid values of <code>i</code> range from <code>(n - 1)</code> to <code>(n - State.length)</code>. <br><br> If the function is passed in string form, the state has name <code>"a"</code> and the zero-based index in the <code>recurrence</code> has name <code>"n"</code>. The given string must return the desired value for <code>a[n]</code> given <code>a[n - 1]</code>, <code>a[n - 2]</code>, <code>a[n - 3]</code>,..., <code>a[n - stateSize]</code>. The state size is dictated by the number of arguments passed to the call to <code>recurrence</code>. The <code>Recurrence</code> struct itself takes care of managing the <code>recurrence</code>'s state and shifting it appropriately. <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;

// The Fibonacci numbers, using function in string form:
// a[0] = 1, a[1] = 1, and compute a[n+1] = a[n-1] + a[n]
auto fib = recurrence!("a[n-1] + a[n-2]")(1, 1);
assert(fib.take(10).equal([1, 1, 2, 3, 5, 8, 13, 21, 34, 55]));

// The factorials, using function in lambda form:
auto fac = recurrence!((a,n) =&gt; a[n-1] * n)(1);
assert(take(fac, 10).equal([
    1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880
]));

// The triangular numbers, using function in explicit form:
static size_t genTriangular(R)(R state, size_t n)
{
    return state[n-1] + n;
}
auto tri = recurrence!genTriangular(0);
assert(take(tri, 10).equal([0, 1, 3, 6, 10, 15, 21, 28, 36, 45]));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Sequence">struct Sequence(alias fun, State)<br>auto sequence(alias fun, State...)(State args)</dt> <dd>
<p><code>Sequence</code> is similar to <code>Recurrence</code> except that iteration is presented in the so-called <a href="http://en.wikipedia.org/wiki/Closed_form" target="_blank"> closed form</a>. This means that the <code>n</code>th element in the series is computable directly from the initial values and <code>n</code> itself. This implies that the interface offered by <code>Sequence</code> is a random-access range, as opposed to the regular <code>Recurrence</code>, which only offers forward iteration. </p>
<p>The state of the <code>sequence</code> is stored as a <code>Tuple</code> so it can be heterogeneous.</p> <dl>
<dt>Examples:</dt>
<dd>Odd numbers, using function in string form: <pre data-language="d">auto odds = sequence!("a[0] + n * a[1]")(1, 2);
writeln(odds.front); // 1
odds.popFront();
writeln(odds.front); // 3
odds.popFront();
writeln(odds.front); // 5
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Triangular numbers, using function in lambda form: <pre data-language="d">auto tri = sequence!((a,n) =&gt; n*(n+1)/2)();

// Note random access
writeln(tri[0]); // 0
writeln(tri[3]); // 6
writeln(tri[1]); // 1
writeln(tri[4]); // 10
writeln(tri[2]); // 3
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Fibonacci numbers, using function in explicit form: <pre data-language="d">import std.math : pow, round, sqrt;
static ulong computeFib(S)(S state, size_t n)
{
    // Binet's formula
    return cast(ulong)(round((pow(state[0], n+1) - pow(state[1], n+1)) /
                             state[2]));
}
auto fib = sequence!computeFib(
    (1.0 + sqrt(5.0)) / 2.0,    // Golden Ratio
    (1.0 - sqrt(5.0)) / 2.0,    // Conjugate of Golden Ratio
    sqrt(5.0));

// Note random access with [] operator
writeln(fib[1]); // 1
writeln(fib[4]); // 5
writeln(fib[3]); // 3
writeln(fib[2]); // 2
writeln(fib[9]); // 55
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="iota">auto iota(B, E, S)(B begin, E end, S step)<br>auto iota(B, E)(B begin, E end)<br>auto iota(B, E)(B begin, E end)<br>auto iota(E)(E end)<br>auto iota(B, E, S)(B begin, E end, S step)<br>auto iota(B, E)(B begin, E end)<br><br>  Constraints:<br>    if ((isIntegral!(CommonType!(B, E)) || isPointer!(CommonType!(B, E))) &amp;&amp; isIntegral!S)<br>    if (isFloatingPoint!(CommonType!(B, E)))<br>    if (isIntegral!(CommonType!(B, E)) || isPointer!(CommonType!(B, E)))<br>    if (is(typeof(iota(E(0), end))))<br>    if (isFloatingPoint!(CommonType!(B, E, S)))<br>    if (!isIntegral!(CommonType!(B, E)) &amp;&amp; !isFloatingPoint!(CommonType!(B, E)) &amp;&amp; !isPointer!(CommonType!(B, E)) &amp;&amp; is(typeof((ref B b) { ++b; } )) &amp;&amp; (is(typeof(B.init &lt; E.init)) || is(typeof(B.init == E.init))))</dt> <dd>
<p>Creates a range of values that span the given starting and stopping values. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>B <code>begin</code>
</td> <td>The starting value.</td>
</tr> <tr>
<td>E <code>end</code>
</td> <td>The value that serves as the stopping criterion. This value is not included in the range.</td>
</tr> <tr>
<td>S <code>step</code>
</td> <td>The value to add to the current value at each iteration.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A range that goes through the numbers <code>begin</code>, <code>begin + step</code>, <code>begin + 2 * step</code>, <code>...</code>, up to and excluding <code>end</code>.  The two-argument overloads have <code>step = 1</code>. If <code>begin &lt; end &amp;&amp; step &lt; 0</code> or <code>begin &gt; end &amp;&amp; step &gt; 0</code> or <code>begin == end</code>, then an empty range is returned. If <code>step == 0</code> then <code>begin == end</code> is an error.  For built-in types, the range returned is a random access range. For user-defined types that support <code>++</code>, the range is an input range.  An integral <code>iota</code> also supports <code>in</code> operator from the right. It takes the stepping into account, the integral won't be considered contained if it falls between two consecutive values of the range. <code>contains</code> does the same as in, but from lefthand side. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">void main()
{
    import std.stdio;

    // The following groups all produce the same output of:
    // 0 1 2 3 4

    foreach (i; 0 .. 5)
        writef("%s ", i);
    writeln();

    import std.range : iota;
    foreach (i; iota(0, 5))
        writef("%s ", i);
    writeln();

    writefln("%(%s %|%)", iota(0, 5));

    import std.algorithm.iteration : map;
    import std.algorithm.mutation : copy;
    import std.format;
    iota(0, 5).map!(i =&gt; format("%s ", i)).copy(stdout.lockingTextWriter());
    writeln();
}
</pre>  <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
import std.math : approxEqual;

auto r = iota(0, 10, 1);
assert(equal(r, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]));
assert(equal(r, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]));
assert(3 in r);
assert(r.contains(3)); //Same as above
assert(!(10 in r));
assert(!(-8 in r));
r = iota(0, 11, 3);
assert(equal(r, [0, 3, 6, 9]));
writeln(r[2]); // 6
assert(!(2 in r));
auto rf = iota(0.0, 0.5, 0.1);
assert(approxEqual(rf, [0.0, 0.1, 0.2, 0.3, 0.4]));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="TransverseOptions">enum TransverseOptions: int</dt> <dd>
<p>Options for the <a href="#FrontTransversal"><code>FrontTransversal</code></a> and <a href="#Transversal"><code>Transversal</code></a> ranges (below).</p> <dl>
<dt class="d_decl" id="TransverseOptions.assumeJagged">assumeJagged</dt> <dd>
<p>When transversed, the elements of a range of ranges are assumed to have different lengths (e.g. a jagged array).</p> </dd> <dt class="d_decl" id="TransverseOptions.enforceNotJagged">enforceNotJagged</dt> <dd>
<p>The transversal enforces that the elements of a range of ranges have all the same length (e.g. an array of arrays, all having the same length). Checking is done once upon construction of the transversal range.</p> </dd> <dt class="d_decl" id="TransverseOptions.assumeNotJagged">assumeNotJagged</dt> <dd>
<p>The transversal assumes, without verifying, that the elements of a range of ranges have all the same length. This option is useful if checking was already done from the outside of the range.</p> </dd> </dl> </dd> <dt class="d_decl" id="FrontTransversal">struct FrontTransversal(Ror, TransverseOptions opt = TransverseOptions.assumeJagged)<br>FrontTransversal!(RangeOfRanges, opt) frontTransversal(TransverseOptions opt = TransverseOptions.assumeJagged, RangeOfRanges)(RangeOfRanges rr)</dt> <dd>
<p>Given a range of ranges, iterate transversally through the first elements of each of the enclosed ranges.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
int[][] x = new int[][2];
x[0] = [1, 2];
x[1] = [3, 4];
auto ror = frontTransversal(x);
assert(equal(ror, [ 1, 3 ][]));
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="FrontTransversal.this">this(RangeOfRanges input)</dt> <dd>
<p>Construction from an <code>input</code>.</p> </dd> <dt class="d_decl" id="FrontTransversal.empty">enum bool empty<br>@property ref auto front()<br>ElementType moveFront()<br>void popFront()</dt> <dd>
<p>Forward range primitives.</p> </dd> <dt class="d_decl" id="FrontTransversal.save">@property FrontTransversal save()</dt> <dd>
<p>Duplicates this <code>frontTransversal</code>. Note that only the encapsulating range of range will be duplicated. Underlying ranges will not be duplicated.</p> </dd> <dt class="d_decl" id="FrontTransversal.back">@property ref auto back()<br>void popBack()<br>ElementType moveBack()</dt> <dd>
<p>Bidirectional primitives. They are offered if <code> isBidirectionalRange!RangeOfRanges</code>.</p> </dd> <dt class="d_decl" id="FrontTransversal.opIndex">ref auto opIndex(size_t n)<br>ElementType moveAt(size_t n)<br>void opIndexAssign(ElementType val, size_t n)<br>@property size_t length()<br>alias opDollar = length</dt> <dd>
<p>Random-access primitive. It is offered if <code> isRandomAccessRange!RangeOfRanges &amp;&amp; (opt == TransverseOptions.assumeNotJagged || opt == TransverseOptions.enforceNotJagged)</code>.</p> </dd> <dt class="d_decl" id="FrontTransversal.opSlice">typeof(this) opSlice(size_t lower, size_t upper)</dt> <dd>
<p>Slicing if offered if <code>RangeOfRanges</code> supports slicing and all the conditions for supporting indexing are met.</p> </dd> </dl> </dd> <dt class="d_decl" id="Transversal">struct Transversal(Ror, TransverseOptions opt = TransverseOptions.assumeJagged)<br>Transversal!(RangeOfRanges, opt) transversal(TransverseOptions opt = TransverseOptions.assumeJagged, RangeOfRanges)(RangeOfRanges rr, size_t n)</dt> <dd>
<p>Given a range of ranges, iterate transversally through the <code>n</code>th element of each of the enclosed ranges. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>opt</td> <td>Controls the assumptions the function makes about the lengths of the ranges</td>
</tr> <tr>
<td>RangeOfRanges <code>rr</code>
</td> <td>An input range of random access ranges</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>At minimum, an input range. Range primitives such as bidirectionality and random access are given if the element type of <code>rr</code> provides them.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
int[][] x = new int[][2];
x[0] = [1, 2];
x[1] = [3, 4];
auto ror = transversal(x, 1);
assert(equal(ror, [ 2, 4 ][]));
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="Transversal.this">this(RangeOfRanges input, size_t n)</dt> <dd>
<p>Construction from an <code>input</code> and an index.</p> </dd> <dt class="d_decl" id="Transversal.empty">enum bool empty<br>@property ref auto front()<br>E moveFront()<br>@property void front(E val)<br>void popFront()<br>@property typeof(this) save()</dt> <dd>
<p>Forward range primitives.</p> </dd> <dt class="d_decl" id="Transversal.back">@property ref auto back()<br>void popBack()<br>E moveBack()<br>@property void back(E val)</dt> <dd>
<p>Bidirectional primitives. They are offered if <code> isBidirectionalRange!RangeOfRanges</code>.</p> </dd> <dt class="d_decl" id="Transversal.opIndex">ref auto opIndex(size_t n)<br>E moveAt(size_t n)<br>void opIndexAssign(E val, size_t n)<br>@property size_t length()<br>alias opDollar = length</dt> <dd>
<p>Random-access primitive. It is offered if <code> isRandomAccessRange!RangeOfRanges &amp;&amp; (opt == TransverseOptions.assumeNotJagged || opt == TransverseOptions.enforceNotJagged)</code>.</p> </dd> <dt class="d_decl" id="Transversal.opSlice">typeof(this) opSlice(size_t lower, size_t upper)</dt> <dd>
<p>Slicing if offered if <code>RangeOfRanges</code> supports slicing and all the conditions for supporting indexing are met.</p> </dd> </dl> </dd> <dt class="d_decl" id="transposed">Transposed!RangeOfRanges transposed(RangeOfRanges)(RangeOfRanges rr)<br><br>  Constraints:<br>    if (isForwardRange!RangeOfRanges &amp;&amp; isInputRange!(ElementType!RangeOfRanges) &amp;&amp; hasAssignableElements!RangeOfRanges)</dt> <dd>
<p>Given a range of ranges, returns a range of ranges where the <i>i</i>'th subrange contains the <i>i</i>'th elements of the original subranges.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
int[][] ror = [
    [1, 2, 3],
    [4, 5, 6]
];
auto xp = transposed(ror);
assert(equal!"a.equal(b)"(xp, [
    [1, 4],
    [2, 5],
    [3, 6]
]));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">int[][] x = new int[][2];
x[0] = [1, 2];
x[1] = [3, 4];
auto tr = transposed(x);
int[][] witness = [ [ 1, 3 ], [ 2, 4 ] ];
uint i;

foreach (e; tr)
{
    writeln(array(e)); // witness[i++]
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Indexed">struct Indexed(Source, Indices) if (isRandomAccessRange!Source &amp;amp<br>&amp;amp<br>isInputRange!Indices &amp;amp<br>&amp;amp<br>is(typeof(Source.init[ElementType!Indices.init])))<br>Indexed!(Source, Indices) indexed(Source, Indices)(Source source, Indices indices)</dt> <dd>
<p>This struct takes two ranges, <code>source</code> and <code>indices</code>, and creates a view of <code>source</code> as if its elements were reordered according to <code>indices</code>. <code>indices</code> may include only a subset of the elements of <code>source</code> and may also repeat elements. </p>
<p><code>Source</code> must be a random access range. The returned range will be bidirectional or random-access if <code>Indices</code> is bidirectional or random-access, respectively.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
auto source = [1, 2, 3, 4, 5];
auto indices = [4, 3, 1, 2, 0, 4];
auto ind = indexed(source, indices);
assert(equal(ind, [5, 4, 2, 3, 1, 5]));
assert(equal(retro(ind), [5, 1, 3, 2, 4, 5]));
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="Indexed.front">@property ref auto front()<br>void popFront()<br>@property typeof(this) save()<br>@property ref auto front(ElementType!Source newVal)<br>auto moveFront()<br>@property ref auto back()<br>void popBack()<br>@property ref auto back(ElementType!Source newVal)<br>auto moveBack()<br>@property size_t length()<br>ref auto opIndex(size_t index)<br>typeof(this) opSlice(size_t a, size_t b)<br>auto opIndexAssign(ElementType!Source newVal, size_t index)<br>auto moveAt(size_t index)</dt> <dd>
<p>Range primitives</p> </dd> <dt class="d_decl" id="Indexed.source">@property Source source()</dt> <dd>
<p>Returns the <code>source</code> range.</p> </dd> <dt class="d_decl" id="Indexed.indices">@property Indices indices()</dt> <dd>
<p>Returns the <code>indices</code> range.</p> </dd> <dt class="d_decl" id="Indexed.physicalIndex">size_t physicalIndex(size_t logicalIndex)</dt> <dd>
<p>Returns the physical index into the source range corresponding to a given logical index. This is useful, for example, when indexing an <code>Indexed</code> without adding another layer of indirection.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto ind = indexed([1, 2, 3, 4, 5], [1, 3, 4]);
writeln(ind.physicalIndex(0)); // 1
</pre> </dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="Chunks">struct Chunks(Source) if (isInputRange!Source)<br>Chunks!Source chunks(Source)(Source source, size_t chunkSize)<br><br>  Constraints:<br>    if (isInputRange!Source)</dt> <dd>
<p>This range iterates over fixed-sized <code>chunks</code> of size <code>chunkSize</code> of a <code>source</code> range. <code>Source</code> must be an input range. <code>chunkSize</code> must be greater than zero. </p>
<p>If <code>!isInfinite!Source</code> and <code>source.walkLength</code> is not evenly divisible by <code>chunkSize</code>, the back element of this range will contain fewer than <code>chunkSize</code> elements. <br><br> If <code>Source</code> is a forward range, the resulting range will be forward ranges as well. Otherwise, the resulting <code>chunks</code> will be input ranges consuming the same input: iterating over <code>front</code> will shrink the chunk such that subsequent invocations of <code>front</code> will no longer return the full chunk, and calling <code>popFront</code> on the outer range will invalidate any lingering references to previous values of <code>front</code>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Source <code>source</code>
</td> <td>Range from which the <code>chunks</code> will be selected</td>
</tr> <tr>
<td>size_t <code>chunkSize</code>
</td> <td>Chunk size</td>
</tr> </table></dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="#slide"><code>slide</code></a> </dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>Range of <code>chunks</code>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
auto source = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
auto chunks = chunks(source, 4);
writeln(chunks[0]); // [1, 2, 3, 4]
writeln(chunks[1]); // [5, 6, 7, 8]
writeln(chunks[2]); // [9, 10]
writeln(chunks.back); // chunks[2]
writeln(chunks.front); // chunks[0]
writeln(chunks.length); // 3
assert(equal(retro(array(chunks)), array(retro(chunks))));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Non-forward input ranges are supported, but with limited semantics. <pre data-language="d">import std.algorithm.comparison : equal;

int i;

// The generator doesn't save state, so it cannot be a forward range.
auto inputRange = generate!(() =&gt; ++i).take(10);

// We can still process it in chunks, but it will be single-pass only.
auto chunked = inputRange.chunks(2);

assert(chunked.front.equal([1, 2]));
assert(chunked.front.empty); // Iterating the chunk has consumed it
chunked.popFront;
assert(chunked.front.equal([3, 4]));
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="Chunks.this">this(Source source, size_t chunkSize)</dt> <dd>
<p>Standard constructor</p> </dd> <dt class="d_decl" id="Chunks.front">@property auto front()<br>void popFront()<br>@property bool empty()</dt> <dd>
<p>Input range primitives. Always present.</p> </dd> <dt class="d_decl" id="Chunks.save">@property typeof(this) save()</dt> <dd>
<p>Forward range primitives. Only present if <code>Source</code> is a forward range.</p> </dd> <dt class="d_decl" id="Chunks.length">@property size_t length()</dt> <dd>
<p>Length. Only if <code>hasLength!Source</code> is <code>true</code></p> </dd> <dt class="d_decl" id="Chunks.opIndex">auto opIndex(size_t index)<br>typeof(this) opSlice(size_t lower, size_t upper)</dt> <dd>
<p>Indexing and slicing operations. Provided only if <code>hasSlicing!Source</code> is <code>true</code>.</p> </dd> <dt class="d_decl" id="Chunks.back">@property auto back()<br>void popBack()</dt> <dd>
<p>Bidirectional range primitives. Provided only if both <code>hasSlicing!Source</code> and <code>hasLength!Source</code> are <code>true</code>.</p> </dd> </dl> </dd> <dt class="d_decl" id="EvenChunks">struct EvenChunks(Source) if (isForwardRange!Source &amp;amp<br>&amp;amp<br>hasLength!Source)<br>EvenChunks!Source evenChunks(Source)(Source source, size_t chunkCount)<br><br>  Constraints:<br>    if (isForwardRange!Source &amp;&amp; hasLength!Source)</dt> <dd>
<p>This range splits a <code>source</code> range into <code>chunkCount</code> chunks of approximately equal length. <code>Source</code> must be a forward range with known length. </p>
<p>Unlike <a href="#chunks"><code>chunks</code></a>, <code>evenChunks</code> takes a chunk count (not size). The returned range will contain zero or more <code>source.length / chunkCount + 1</code> elements followed by <code>source.length / chunkCount</code> elements. If <code>source.length &lt; chunkCount</code>, some chunks will be empty. <br><br> <code>chunkCount</code> must not be zero, unless <code>source</code> is also empty.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
auto source = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
auto chunks = evenChunks(source, 3);
writeln(chunks[0]); // [1, 2, 3, 4]
writeln(chunks[1]); // [5, 6, 7]
writeln(chunks[2]); // [8, 9, 10]
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="EvenChunks.this">this(Source source, size_t chunkCount)</dt> <dd>
<p>Standard constructor</p> </dd> <dt class="d_decl" id="EvenChunks.front">@property auto front()<br>void popFront()<br>@property bool empty()<br>@property typeof(this) save()</dt> <dd>
<p>Forward range primitives. Always present.</p> </dd> <dt class="d_decl" id="EvenChunks.length">const @property size_t length()</dt> <dd>
<p>Length</p> </dd> <dt class="d_decl" id="EvenChunks.opIndex">auto opIndex(size_t index)<br>typeof(this) opSlice(size_t lower, size_t upper)<br>@property auto back()<br>void popBack()</dt> <dd>
<p>Indexing, slicing and bidirectional operations and range primitives. Provided only if <code>hasSlicing!Source</code> is <code>true</code>.</p> </dd> </dl> </dd> <dt class="d_decl" id="only">auto only(Values...)(auto ref Values values)<br><br>  Constraints:<br>    if (!is(CommonType!Values == void) || Values.length == 0)</dt> <dd>
<p>Assemble <code>values</code> into a range that carries all its elements in-situ. </p>
<p>Useful when a single value or multiple disconnected <code>values</code> must be passed to an algorithm expecting a range, without having to perform dynamic memory allocation. <br><br> As copying the range means copying all elements, it can be safely returned from functions. For the same reason, copying the returned range may be expensive for a large number of arguments. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Values <code>values</code>
</td> <td>the <code>values</code> to assemble together</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A <code>RandomAccessRange</code> of the assembled <code>values</code>. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="#chain"><code>chain</code></a> to chain ranges</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
import std.algorithm.iteration : filter, joiner, map;
import std.algorithm.searching : findSplitBefore;
import std.uni : isUpper;

assert(equal(only('â™¡'), "â™¡"));
writeln([1, 2, 3, 4].findSplitBefore(only(3))[0]); // [1, 2]

assert(only("one", "two", "three").joiner(" ").equal("one two three"));

string title = "The D Programming Language";
assert(title
    .filter!isUpper // take the upper case letters
    .map!only       // make each letter its own range
    .joiner(".")    // join the ranges together lazily
    .equal("T.D.P.L"));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="enumerate">auto enumerate(Enumerator = size_t, Range)(Range range, Enumerator start = 0)<br><br>  Constraints:<br>    if (isIntegral!Enumerator &amp;&amp; isInputRange!Range)</dt> <dd>
<p>Iterate over <code>range</code> with an attached index variable. </p>
<p>Each element is a <a href="../std_typecons/#Tuple"><code>std.typecons.Tuple</code></a> containing the index and the element, in that order, where the index member is named <code>index</code> and the element member is named <code>value</code>. <br><br> The index starts at <code>start</code> and is incremented by one on every iteration. </p> <dl>
<dt>Overflow</dt>
<dd> If <code>range</code> has length, then it is an error to pass a value for <code>start</code> so that <code>start + range.length</code> is bigger than <code>Enumerator.max</code>, thus it is ensured that overflow cannot happen. </dd>
</dl> If <code>range</code> does not have length, and <code>popFront</code> is called when <code>front.index == Enumerator.max</code>, the index will overflow and continue from <code>Enumerator.min</code>.  <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Range <code>range</code>
</td> <td>the input <code>range</code> to attach indexes to</td>
</tr> <tr>
<td>Enumerator <code>start</code>
</td> <td>the number to <code>start</code> the index counter from</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>At minimum, an input <code>range</code>. All other <code>range</code> primitives are given in the resulting <code>range</code> if <code>range</code> has them. The exceptions are the bidirectional primitives, which are propagated only if <code>range</code> has length. </dd>
</dl> <dl>
<dt>Example</dt>
<dd> Useful for using <code>foreach</code> with an index loop variable: </dd>
</dl>
<pre data-language="d">    import std.stdio : stdin, stdout;
    import std.range : enumerate;

    foreach (lineNum, line; stdin.byLine().enumerate(1))
        stdout.writefln("line #%s: %s", lineNum, line);
</pre>  <dl>
<dt>Examples:</dt>
<dd>Can <code>start</code> enumeration from a negative position: <pre data-language="d">import std.array : assocArray;
import std.range : enumerate;

bool[int] aa = true.repeat(3).enumerate(-1).assocArray();
assert(aa[-1]);
assert(aa[0]);
assert(aa[1]);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isTwoWayCompatible">enum auto isTwoWayCompatible(alias fn, T1, T2)</dt> <dd>
<p> Returns <code>true</code> if <code>fn</code> accepts variables of type T1 and T2 in any order. The following code should compile: </p>
<pre data-language="d">T1 foo();
T2 bar();

fn(foo(), bar());
fn(bar(), foo());
</pre>  </dd> <dt class="d_decl" id="SearchPolicy">enum SearchPolicy: int</dt> <dd>
<p>Policy used with the searching primitives <code>lowerBound</code>, <code> upperBound</code>, and <code>equalRange</code> of <a href="#SortedRange"><code>SortedRange</code></a> below.</p> <dl>
<dt class="d_decl" id="SearchPolicy.linear">linear</dt> <dd>
<p>Searches in a <code>linear</code> fashion.</p> </dd> <dt class="d_decl" id="SearchPolicy.trot">trot</dt> <dd>
<p>Searches with a step that is grows linearly (1, 2, 3,...) leading to a quadratic search schedule (indexes tried are 0, 1, 3, 6, 10, 15, 21, 28,...) Once the search overshoots its target, the remaining interval is searched using binary search. The search is completed in <span class="bigoh">ÎŸ(<code>sqrt(n)</code>)</span> time. Use it when you are reasonably confident that the value is around the beginning of the range.</p> </dd> <dt class="d_decl" id="SearchPolicy.gallop">gallop</dt> <dd>
<p>Performs a <a href="https://en.wikipedia.org/wiki/Exponential_search" target="_blank"> galloping search algorithm</a>, i.e. searches with a step that doubles every time, (1, 2, 4, 8, ...) leading to an exponential search schedule (indexes tried are 0, 1, 3, 7, 15, 31, 63,...) Once the search overshoots its target, the remaining interval is searched using binary search. A value is found in <span class="bigoh">ÎŸ(<code>log(n)</code>)</span> time.</p> </dd> <dt class="d_decl" id="SearchPolicy.binarySearch">binarySearch</dt> <dd>
<p>Searches using a classic interval halving policy. The search starts in the middle of the range, and each search step cuts the range in half. This policy finds a value in <span class="bigoh">ÎŸ(<code>log(n)</code>)</span> time but is less cache friendly than <code>gallop</code> for large ranges. The <code>binarySearch</code> policy is used as the last step of <code>trot</code>, <code>gallop</code>, <code>trotBackwards</code>, and <code> gallopBackwards</code> strategies.</p> </dd> <dt class="d_decl" id="SearchPolicy.trotBackwards">trotBackwards</dt> <dd>
<p>Similar to <code>trot</code> but starts backwards. Use it when confident that the value is around the end of the range.</p> </dd> <dt class="d_decl" id="SearchPolicy.gallopBackwards">gallopBackwards</dt> <dd>
<p>Similar to <code>gallop</code> but starts backwards. Use it when confident that the value is around the end of the range.</p> </dd> </dl> </dd> <dt class="d_decl" id="SortedRange">struct SortedRange(Range, alias pred = "a &amp;lt<br>b") if (isInputRange!Range)</dt> <dd>
<p>Represents a sorted range. In addition to the regular range primitives, supports additional operations that take advantage of the ordering, such as merge and binary search. To obtain a <code>SortedRange</code> from an unsorted range <code>r</code>, use <a href="../std_algorithm_sorting/#sort"><code>std.algorithm.sorting.sort</code></a> which sorts <code>r</code> in place and returns the corresponding <code>SortedRange</code>. To construct a <code>SortedRange</code> from a range <code>r</code> that is known to be already sorted, use <a href="#assumeSorted"><code>assumeSorted</code></a> described below.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.sorting : sort;
auto a = [ 1, 2, 3, 42, 52, 64 ];
auto r = assumeSorted(a);
assert(r.contains(3));
assert(!r.contains(32));
auto r1 = sort!"a &gt; b"(a);
assert(r1.contains(3));
assert(!r1.contains(32));
writeln(r1.release()); // [64, 52, 42, 3, 2, 1]
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<code>SortedRange</code> could accept ranges weaker than random-access, but it is unable to provide interesting functionality for them. Therefore, <code>SortedRange</code> is currently restricted to random-access ranges.  No copy of the original range is ever made. If the underlying range is changed concurrently with its corresponding <code>SortedRange</code> in ways that break its sorted-ness, <code>SortedRange</code> will work erratically. <pre data-language="d">import std.algorithm.mutation : swap;
auto a = [ 1, 2, 3, 42, 52, 64 ];
auto r = assumeSorted(a);
assert(r.contains(42));
swap(a[3], a[5]);         // illegal to break sortedness of original range
assert(!r.contains(42));  // passes although it shouldn't
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="SortedRange.empty">@property bool empty()<br>@property auto save()<br>@property ref auto front()<br>void popFront()<br>@property ref auto back()<br>void popBack()<br>ref auto opIndex(size_t i)<br>auto opSlice(size_t a, size_t b)<br>@property size_t length()<br>alias opDollar = length</dt> <dd>
<p>Range primitives.</p> </dd> <dt class="d_decl" id="SortedRange.release">auto release()</dt> <dd>
<p>Releases the controlled range and returns it.</p> </dd> <dt class="d_decl" id="SortedRange.lowerBound">auto lowerBound(SearchPolicy sp = SearchPolicy.binarySearch, V)(V value)<br><br>  Constraints:<br>    if (isTwoWayCompatible!(predFun, ElementType!Range, V) &amp;&amp; hasSlicing!Range)</dt> <dd>
<p>This function uses a search with policy <code>sp</code> to find the largest left subrange on which <code>pred(x, value)</code> is <code>true</code> for all <code>x</code> (e.g., if <code>pred</code> is "less than", returns the portion of the range with elements strictly smaller than <code>value</code>). The search schedule and its complexity are documented in <a href="#SearchPolicy"><code>SearchPolicy</code></a>. See also STL's <a href="http://sgi.com/tech/stl/lower_bound.html" target="_blank">lower_bound</a>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
auto a = assumeSorted([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]);
auto p = a.lowerBound(4);
assert(equal(p, [ 0, 1, 2, 3 ]));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="SortedRange.upperBound">auto upperBound(SearchPolicy sp = SearchPolicy.binarySearch, V)(V value)<br><br>  Constraints:<br>    if (isTwoWayCompatible!(predFun, ElementType!Range, V))</dt> <dd>
<p>This function searches with policy <code>sp</code> to find the largest right subrange on which <code>pred(value, x)</code> is <code>true</code> for all <code>x</code> (e.g., if <code>pred</code> is "less than", returns the portion of the range with elements strictly greater than <code>value</code>). The search schedule and its complexity are documented in <a href="#SearchPolicy"><code>SearchPolicy</code></a>. </p>
<p>For ranges that do not offer random access, <code>SearchPolicy.linear</code> is the only policy allowed (and it must be specified explicitly lest it exposes user code to unexpected inefficiencies). For random-access searches, all policies are allowed, and <code>SearchPolicy.binarySearch</code> is the default. </p> <dl>
<dt>See Also:</dt>
<dd>STL's <a href="http://sgi.com/tech/stl/lower_bound.html" target="_blank">upper_bound</a>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
auto a = assumeSorted([ 1, 2, 3, 3, 3, 4, 4, 5, 6 ]);
auto p = a.upperBound(3);
assert(equal(p, [4, 4, 5, 6]));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="SortedRange.equalRange">auto equalRange(V)(V value)<br><br>  Constraints:<br>    if (isTwoWayCompatible!(predFun, ElementType!Range, V) &amp;&amp; isRandomAccessRange!Range)</dt> <dd>
<p>Returns the subrange containing all elements <code>e</code> for which both <code> pred(e, value)</code> and <code>pred(value, e)</code> evaluate to <code>false</code> (e.g., if <code>pred</code> is "less than", returns the portion of the range with elements equal to <code>value</code>). Uses a classic binary search with interval halving until it finds a <code>value</code> that satisfies the condition, then uses <code>SearchPolicy.gallopBackwards</code> to find the left boundary and <code>SearchPolicy.gallop</code> to find the right boundary. These policies are justified by the fact that the two boundaries are likely to be near the first found <code>value</code> (i.e., equal ranges are relatively small). Completes the entire search in <span class="bigoh">ÎŸ(<code>log(n)</code>)</span> time. See also STL's <a href="http://sgi.com/tech/stl/equal_range.html" target="_blank">equal_range</a>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
auto a = [ 1, 2, 3, 3, 3, 4, 4, 5, 6 ];
auto r = a.assumeSorted.equalRange(3);
assert(equal(r, [ 3, 3, 3 ]));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="SortedRange.trisect">auto trisect(V)(V value)<br><br>  Constraints:<br>    if (isTwoWayCompatible!(predFun, ElementType!Range, V) &amp;&amp; isRandomAccessRange!Range &amp;&amp; hasLength!Range)</dt> <dd>
<p>Returns a tuple <code>r</code> such that <code>r[0]</code> is the same as the result of <code>lowerBound(value)</code>, <code>r[1]</code> is the same as the result of <code>equalRange(value)</code>, and <code>r[2]</code> is the same as the result of <code>upperBound(value)</code>. The call is faster than computing all three separately. Uses a search schedule similar to <code>equalRange</code>. Completes the entire search in <span class="bigoh">ÎŸ(<code>log(n)</code>)</span> time.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
auto a = [ 1, 2, 3, 3, 3, 4, 4, 5, 6 ];
auto r = assumeSorted(a).trisect(3);
assert(equal(r[0], [ 1, 2 ]));
assert(equal(r[1], [ 3, 3, 3 ]));
assert(equal(r[2], [ 4, 4, 5, 6 ]));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="SortedRange.contains">bool contains(V)(V value)<br><br>  Constraints:<br>    if (isRandomAccessRange!Range)</dt> <dd>
<p>Returns <code>true</code> if and only if <code>value</code> can be found in <code>range</code>, which is assumed to be sorted. Performs <span class="bigoh">ÎŸ(<code>log(r.length)</code>)</span> evaluations of <code>pred</code>. See also STL's <a href="http://sgi.com/tech/stl/binary_search.html" target="_blank">binary_search</a>.</p> </dd> <dt class="d_decl" id="SortedRange.groupBy">auto groupBy()()</dt> <dd>
<p>Returns a range of subranges of elements that are equivalent according to the sorting relation.</p> </dd> </dl> </dd> <dt class="d_decl" id="assumeSorted">auto assumeSorted(alias pred = "a &amp;lt<br>b", R)(R r)<br><br>  Constraints:<br>    if (isInputRange!(Unqual!R))</dt> <dd>
<p>Assumes <code>r</code> is sorted by predicate <code>pred</code> and returns the corresponding <code>SortedRange!(pred, R)</code> having <code>r</code> as support. To keep the checking costs low, the cost is <span class="bigoh">ÎŸ(<code>1</code>)</span> in release mode (no checks for sorted-ness are performed). In debug mode, a few random elements of <code>r</code> are checked for sorted-ness. The size of the sample is proportional <span class="bigoh">ÎŸ(<code>log(r.length)</code>)</span>. That way, checking has no effect on the complexity of subsequent operations specific to sorted ranges (such as binary search). The probability of an arbitrary unsorted range failing the test is very high (however, an almost-sorted range is likely to pass it). To check for sorted-ness at cost <span class="bigoh">ÎŸ(<code>n</code>)</span>, use <a href="../std_algorithm_sorting/#isSorted"><code>std.algorithm.sorting.isSorted</code></a>.</p> </dd> <dt class="d_decl" id="RefRange">struct RefRange(R) if (isInputRange!R)<br>auto refRange(R)(R* range)<br><br>  Constraints:<br>    if (isInputRange!R)</dt> <dd>
<p>Wrapper which effectively makes it possible to pass a <code>range</code> by reference. Both the original <code>range</code> and the <code>RefRange</code> will always have the exact same elements. Any operation done on one will affect the other. So, for instance, if it's passed to a function which would implicitly copy the original <code>range</code> if it were passed to it, the original <code>range</code> is <i>not</i> copied but is consumed as if it were a reference type. </p>
<dl>
<dt>Note</dt>
<dd> <code>save</code> works as normal and operates on a new range, so if <code>save</code> is ever called on the <code>RefRange</code>, then no operations on the saved range will affect the original. </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R* <code>range</code>
</td> <td>the <code>range</code> to construct the <code>RefRange</code> from</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A <code>RefRange</code>. If the given range is a class type (and thus is already a reference type), then the original <code>range</code> is returned rather than a <code>RefRange</code>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>Basic Example <pre data-language="d">import std.algorithm.searching : find;
ubyte[] buffer = [1, 9, 45, 12, 22];
auto found1 = find(buffer, 45);
writeln(found1); // [45, 12, 22]
writeln(buffer); // [1, 9, 45, 12, 22]

auto wrapped1 = refRange(&amp;buffer);
auto found2 = find(wrapped1, 45);
writeln(*found2.ptr); // [45, 12, 22]
writeln(buffer); // [45, 12, 22]

auto found3 = find(wrapped1.save, 22);
writeln(*found3.ptr); // [22]
writeln(buffer); // [45, 12, 22]

string str = "hello world";
auto wrappedStr = refRange(&amp;str);
writeln(str.front); // 'h'
str.popFrontN(5);
writeln(str); // " world"
writeln(wrappedStr.front); // ' '
writeln(*wrappedStr.ptr); // " world"
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>opAssign Example. <pre data-language="d">ubyte[] buffer1 = [1, 2, 3, 4, 5];
ubyte[] buffer2 = [6, 7, 8, 9, 10];
auto wrapped1 = refRange(&amp;buffer1);
auto wrapped2 = refRange(&amp;buffer2);
assert(wrapped1.ptr is &amp;buffer1);
assert(wrapped2.ptr is &amp;buffer2);
assert(wrapped1.ptr !is wrapped2.ptr);
assert(buffer1 != buffer2);

wrapped1 = wrapped2;

//Everything points to the same stuff as before.
assert(wrapped1.ptr is &amp;buffer1);
assert(wrapped2.ptr is &amp;buffer2);
assert(wrapped1.ptr !is wrapped2.ptr);

//But buffer1 has changed due to the assignment.
writeln(buffer1); // [6, 7, 8, 9, 10]
writeln(buffer2); // [6, 7, 8, 9, 10]

buffer2 = [11, 12, 13, 14, 15];

//Everything points to the same stuff as before.
assert(wrapped1.ptr is &amp;buffer1);
assert(wrapped2.ptr is &amp;buffer2);
assert(wrapped1.ptr !is wrapped2.ptr);

//But buffer2 has changed due to the assignment.
writeln(buffer1); // [6, 7, 8, 9, 10]
writeln(buffer2); // [11, 12, 13, 14, 15]

wrapped2 = null;

//The pointer changed for wrapped2 but not wrapped1.
assert(wrapped1.ptr is &amp;buffer1);
assert(wrapped2.ptr is null);
assert(wrapped1.ptr !is wrapped2.ptr);

//buffer2 is not affected by the assignment.
writeln(buffer1); // [6, 7, 8, 9, 10]
writeln(buffer2); // [11, 12, 13, 14, 15]
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.iteration : map, joiner, group;
import std.algorithm.searching : until;
// fix for std.algorithm
auto r = map!(x =&gt; 0)([1]);
chain(r, r);
zip(r, r);
roundRobin(r, r);

struct NRAR {
    typeof(r) input;
    @property empty() { return input.empty; }
    @property front() { return input.front; }
    void popFront()   { input.popFront(); }
    @property save()  { return NRAR(input.save); }
}
auto n1 = NRAR(r);
cycle(n1);  // non random access range version

assumeSorted(r);

// fix for std.range
joiner([r], [9]);

struct NRAR2 {
    NRAR input;
    @property empty() { return true; }
    @property front() { return input; }
    void popFront() { }
    @property save()  { return NRAR2(input.save); }
}
auto n2 = NRAR2(n1);
joiner(n2);

group(r);

until(r, 7);
static void foo(R)(R r) { until!(x =&gt; x &gt; 7)(r); }
foo(r);
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="RefRange.this">pure nothrow @safe this(R* range)</dt>  <dt class="d_decl" id="RefRange.opAssign">auto opAssign(RefRange rhs)</dt> <dd>
<p>This does not assign the pointer of <code>rhs</code> to this <code>RefRange</code>. Rather it assigns the range pointed to by <code>rhs</code> to the range pointed to by this <code>RefRange</code>. This is because <i>any</i> operation on a <code>RefRange</code> is the same is if it occurred to the original range. The one exception is when a <code>RefRange</code> is assigned <code>null</code> either directly or because <code>rhs</code> is <code>null</code>. In that case, <code>RefRange</code> no longer refers to the original range but is <code>null</code>.</p> </dd> <dt class="d_decl" id="RefRange.opAssign.2">void opAssign(typeof(null) rhs)</dt>  <dt class="d_decl" id="RefRange.ptr">inout pure nothrow @property @safe inout(R*) ptr()</dt> <dd>
<p>A pointer to the wrapped range.</p> </dd> <dt class="d_decl" id="RefRange.front">@property auto front()<br>const @property auto front()<br>@property auto front(ElementType!R value)</dt>  <dt class="d_decl" id="RefRange.empty">@property bool empty()<br>const @property bool empty()</dt>  <dt class="d_decl" id="RefRange.popFront">void popFront()</dt>  <dt class="d_decl" id="RefRange.save">@property auto save()<br>const @property auto save()<br>auto opSlice()<br>const auto opSlice()</dt> <dd>
<p>Only defined if <code>isForwardRange!R</code> is <code>true</code>.</p> </dd> <dt class="d_decl" id="RefRange.back">@property auto back()<br>const @property auto back()<br>@property auto back(ElementType!R value)<br>void popBack()</dt> <dd>
<p>Only defined if <code>isBidirectionalRange!R</code> is <code>true</code>.</p> </dd> <dt class="d_decl" id="RefRange.opIndex">ref auto opIndex(IndexType)(IndexType index)<br>const ref auto opIndex(IndexType)(IndexType index)</dt> <dd>
<p>Only defined if <code>isRandomAccesRange!R</code> is <code>true</code>.</p> </dd> <dt class="d_decl" id="RefRange.moveFront">auto moveFront()</dt> <dd>
<p>Only defined if <code>hasMobileElements!R</code> and <code>isForwardRange!R</code> are <code>true</code>.</p> </dd> <dt class="d_decl" id="RefRange.moveBack">auto moveBack()</dt> <dd>
<p>Only defined if <code>hasMobileElements!R</code> and <code>isBidirectionalRange!R</code> are <code>true</code>.</p> </dd> <dt class="d_decl" id="RefRange.moveAt">auto moveAt(size_t index)</dt> <dd>
<p>Only defined if <code>hasMobileElements!R</code> and <code>isRandomAccessRange!R</code> are <code>true</code>.</p> </dd> <dt class="d_decl" id="RefRange.length">@property auto length()<br>const @property auto length()<br>alias opDollar = length</dt> <dd>
<p>Only defined if <code>hasLength!R</code> is <code>true</code>.</p> </dd> <dt class="d_decl" id="RefRange.opSlice.2">auto opSlice(IndexType1, IndexType2)(IndexType1 begin, IndexType2 end)<br>const auto opSlice(IndexType1, IndexType2)(IndexType1 begin, IndexType2 end)</dt> <dd>
<p>Only defined if <code>hasSlicing!R</code> is <code>true</code>.</p> </dd> </dl> </dd> <dt class="d_decl" id="bitwise">auto bitwise(R)(auto ref R range)<br><br>  Constraints:<br>    if (isInputRange!R &amp;&amp; isIntegral!(ElementType!R))</dt> <dd>
<p>Bitwise adapter over an integral type <code>range</code>. Consumes the <code>range</code> elements bit by bit, from the least significant bit to the most significant bit. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R</td> <td>an integral input <code>range</code> to iterate over</td>
</tr> <tr>
<td>R <code>range</code>
</td> <td>
<code>range</code> to consume bit by by</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A <code>Bitwise</code> input <code>range</code> with propagated forward, bidirectional and random access capabilities</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
import std.format : format;

// 00000011 00001001
ubyte[] arr = [3, 9];
auto r = arr.bitwise;

// iterate through it as with any other range
writeln(format("%(%d%)", r)); // "1100000010010000"
assert(format("%(%d%)", r.retro).equal("1100000010010000".retro));

auto r2 = r[5 .. $];
// set a bit
r[2] = 1;
writeln(arr[0]); // 7
writeln(r[5]); // r2[0]
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>You can use <code>bitwise</code> to implement an uniform bool generator <pre data-language="d">import std.algorithm.comparison : equal;
import std.random : rndGen;

auto rb = rndGen.bitwise;
static assert(isInfinite!(typeof(rb)));

auto rb2 = rndGen.bitwise;
// Don't forget that structs are passed by value
assert(rb.take(10).equal(rb2.take(10)));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="NullSink">struct NullSink</dt> <dd>
<p>An OutputRange that discards the data it receives.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.iteration : map;
import std.algorithm.mutation : copy;
[4, 5, 6].map!(x =&gt; x * 2).copy(NullSink()); // data is discarded
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="tee">auto tee(Flag!"pipeOnPop" pipeOnPop = Yes.pipeOnPop, R1, R2)(R1 inputRange, R2 outputRange)<br>auto tee(alias fun, Flag!"pipeOnPop" pipeOnPop = Yes.pipeOnPop, R1)(R1 inputRange)<br><br>  Constraints:<br>    if (isInputRange!R1 &amp;&amp; isOutputRange!(R2, ElementType!R1))<br>    if (is(typeof(fun) == void) || isSomeFunction!fun)</dt> <dd>
<p>Implements a "<code>tee</code>" style pipe, wrapping an input range so that elements of the range can be passed to a provided function or <a href="#OutputRange"><code>OutputRange</code></a> as they are iterated over. This is useful for printing out intermediate values in a long chain of range code, performing some operation with side-effects on each call to <code>front</code> or <code>popFront</code>, or diverting the elements of a range into an auxiliary <a href="#OutputRange"><code>OutputRange</code></a>. </p>
<p>It is important to note that as the resultant range is evaluated lazily, in the case of the version of <code>tee</code> that takes a function, the function will not actually be executed until the range is "walked" using functions that evaluate ranges, such as <a href="../std_array/#array"><code>std.array.array</code></a> or <a href="../std_algorithm_iteration/#fold"><code>std.algorithm.iteration.fold</code></a>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>pipeOnPop</td> <td>If <code>Yes.pipeOnPop</code>, simply iterating the range without ever calling <code>front</code> is enough to have <code>tee</code> mirror elements to <code>outputRange</code> (or, respectively, <code>fun</code>). If <code>No.pipeOnPop</code>, only elements for which <code>front</code> does get called will be also sent to <code>outputRange</code>/<code>fun</code>.</td>
</tr> <tr>
<td>R1 <code>inputRange</code>
</td> <td>The input range being passed through.</td>
</tr> <tr>
<td>R2 <code>outputRange</code>
</td> <td>This range will receive elements of <code>inputRange</code> progressively as iteration proceeds.</td>
</tr> <tr>
<td>fun</td> <td>This function will be called with elements of <code>inputRange</code> progressively as iteration proceeds.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>An input range that offers the elements of <code>inputRange</code>. Regardless of whether <code>inputRange</code> is a more powerful range (forward, bidirectional etc), the result is always an input range. Reading this causes <code>inputRange</code> to be iterated and returns its elements in turn. In addition, the same elements will be passed to <code>outputRange</code> or <code>fun</code> as well. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd><a href="../std_algorithm_iteration/#each"><code>std.algorithm.iteration.each</code></a></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
import std.algorithm.iteration : filter, map;

// Sum values while copying
int[] values = [1, 4, 9, 16, 25];
int sum = 0;
auto newValues = values.tee!(a =&gt; sum += a).array;
assert(equal(newValues, values));
writeln(sum); // 1 + 4 + 9 + 16 + 25

// Count values that pass the first filter
int count = 0;
auto newValues4 = values.filter!(a =&gt; a &lt; 10)
                        .tee!(a =&gt; count++)
                        .map!(a =&gt; a + 1)
                        .filter!(a =&gt; a &lt; 10);

//Fine, equal also evaluates any lazy ranges passed to it.
//count is not 3 until equal evaluates newValues4
assert(equal(newValues4, [2, 5]));
writeln(count); // 3
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="padLeft">auto padLeft(R, E)(R r, E e, size_t n)<br><br>  Constraints:<br>    if ((isInputRange!R &amp;&amp; hasLength!R || isForwardRange!R) &amp;&amp; !is(CommonType!(ElementType!R, E) == void))</dt> <dd>
<p>Extends the length of the input range <code>r</code> by padding out the start of the range with the element <code>e</code>. The element <code>e</code> must be of a common type with the element type of the range <code>r</code> as defined by <a href="../std_traits/#CommonType"><code>std.traits.CommonType</code></a>. If <code>n</code> is less than the length of of <code>r</code>, then <code>r</code> is returned unmodified. </p>
<p>If <code>r</code> is a string with Unicode characters in it, <code>padLeft</code> follows D's rules about length for strings, which is not the number of characters, or graphemes, but instead the number of encoding units. If you want to treat each grapheme as only one encoding unit long, then call <a href="../std_uni/#byGrapheme"><code>std.uni.byGrapheme</code></a> before calling this function. <br><br> If <code>r</code> has a length, then this is <span class="bigoh">ÎŸ(<code>1</code>)</span>. Otherwise, it's <span class="bigoh">ÎŸ(<code>r.length</code>)</span>. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>r</code>
</td> <td>an input range with a length, or a forward range</td>
</tr> <tr>
<td>E <code>e</code>
</td> <td>element to pad the range with</td>
</tr> <tr>
<td>size_t <code>n</code>
</td> <td>the length to pad to</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A range containing the elements of the original range with the extra padding  See Also: <a href="../std_string/#leftJustifier"><code>std.string.leftJustifier</code></a>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;

assert([1, 2, 3, 4].padLeft(0, 6).equal([0, 0, 1, 2, 3, 4]));
assert([1, 2, 3, 4].padLeft(0, 3).equal([1, 2, 3, 4]));

assert("abc".padLeft('_', 6).equal("___abc"));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="padRight">auto padRight(R, E)(R r, E e, size_t n)<br><br>  Constraints:<br>    if (isInputRange!R &amp;&amp; !isInfinite!R &amp;&amp; !is(CommonType!(ElementType!R, E) == void))</dt> <dd>
<p>Extend the length of the input range <code>r</code> by padding out the end of the range with the element <code>e</code>. The element <code>e</code> must be of a common type with the element type of the range <code>r</code> as defined by <a href="../std_traits/#CommonType"><code>std.traits.CommonType</code></a>. If <code>n</code> is less than the length of of <code>r</code>, then the contents of <code>r</code> are returned. </p>
<p>The range primitives that the resulting range provides depends whether or not <code>r</code> provides them. Except the functions <code>back</code> and <code>popBack</code>, which also require the range to have a length as well as <code>back</code> and <code>popBack</code> </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>r</code>
</td> <td>an input range with a length</td>
</tr> <tr>
<td>E <code>e</code>
</td> <td>element to pad the range with</td>
</tr> <tr>
<td>size_t <code>n</code>
</td> <td>the length to pad to</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A range containing the elements of the original range with the extra padding  See Also: <a href="../std_string/#rightJustifier"><code>std.string.rightJustifier</code></a>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;

assert([1, 2, 3, 4].padRight(0, 6).equal([1, 2, 3, 4, 0, 0]));
assert([1, 2, 3, 4].padRight(0, 4).equal([1, 2, 3, 4]));

assert("abc".padRight('_', 6).equal("abc___"));
</pre> </dd>
</dl> </dd> </dl>
<div class="_attribution">
  <p class="_attribution-p">
    Â© 1999â€“2017 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/phobos/std_range.html" class="_attribution-link" target="_blank">https://dlang.org/phobos/std_range.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
