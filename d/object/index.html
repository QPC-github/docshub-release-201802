
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Object - D - W3cubDocs</title>
  
  <meta name="description" content=" Forms the symbols available to all D programs. Includes Object, which is the root of the class object hierarchy. This module is implicitly imported. ">
  <meta name="keywords" content="object, -, d">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/d/object/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-e0f881b0fce8cbe96f33dadc355b7159d5d2912911231446d60eb8f9caffa802.css">
  <script type="text/javascript" src="/assets/application-8fc46316434047265cd383f02b8e7f434ed7dec4a59f920dd633deef8d488d1b.js"></script>
  <script src="/json/d.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/d/" class="_nav-link" title="" style="margin-left:0;">D</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _d">
				
<h1>object</h1>  <p>Forms the symbols available to all D programs. Includes Object, which is the root of the class <code>object</code> hierarchy. This module is implicitly imported. </p>
<dl>
<dt>License:</dt>
<dd>
<a href="http://www.boost.org/LICENSE_1_0.txt" target="_blank">Boost License 1.0</a>. </dd>
</dl> <dl>
<dt>Authors:</dt>
<dd>Walter Bright, Sean Kelly</dd>
</dl> <dl>
<dt class="d_decl" id="Object">class Object</dt> <dd>
<p>All D class objects inherit from <code>Object</code>.</p> <dl>
<dt class="d_decl" id="Object.toString">string toString()</dt> <dd>
<p>Convert Object to a human readable string.</p> </dd> <dt class="d_decl" id="Object.toHash">nothrow @trusted size_t toHash()</dt> <dd>
<p>Compute hash function for Object.</p> </dd> <dt class="d_decl" id="Object.opCmp">int opCmp(Object o)</dt> <dd>
<p>Compare with another Object obj. </p>
<dl>
<dt>Returns:</dt>
<dd><table>

<tr>
<td>this &lt; obj</td> <td>&lt; 0</td>
</tr> <tr>
<td>this == obj</td> <td>0</td>
</tr> <tr>
<td>this &gt; obj</td> <td>&gt; 0</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="Object.opEquals">bool opEquals(Object o)</dt> <dd>
<p>Test whether <code>this</code> is equal to <code>o</code>. The default implementation only compares by identity (using the <code>is</code> operator). Generally, overrides for <code>opEquals</code> should attempt to compare objects by their contents.</p> </dd> <dt class="d_decl" id="Object.factory">static Object factory(string classname)</dt> <dd>
<p>Create instance of class specified by the fully qualified name <code>classname</code>. The class must either have no constructors or have a default constructor. </p>
<dl>
<dt>Returns:</dt>
<dd>
<code>null</code> if failed </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">module foo.bar;

class C
{
    this() { x = 10; }
    int x;
}

void main()
{
    auto c = cast(C)Object.factory("foo.bar.C");
    assert(c !is null &amp;&amp; c.x == 10);
}
</pre>  </dd> </dl> </dd> <dt class="d_decl" id="opEquals">auto opEquals(const Object lhs, const Object rhs)</dt> <dd>
<p>Returns <code>true</code> if <code>lhs</code> and <code>rhs</code> are equal.</p> </dd> <dt class="d_decl" id="Interface">struct Interface</dt> <dd>
<p>Information about an interface. When an object is accessed via an interface, an <code>Interface</code>* appears as the first entry in its vtbl.</p> <dl>
<dt class="d_decl" id="Interface.classinfo">TypeInfo_Class classinfo</dt> <dd>
<p>.<code>classinfo</code> for this interface (not for containing class)</p> </dd> <dt class="d_decl" id="Interface.offset">size_t offset</dt> <dd>
<p><code>offset</code> to Interface 'this' from Object 'this'</p> </dd> </dl> </dd> <dt class="d_decl" id="OffsetTypeInfo">struct OffsetTypeInfo</dt> <dd>
<p>Array of pairs giving the offset and type information for each member in an aggregate.</p> <dl>
<dt class="d_decl" id="OffsetTypeInfo.offset">size_t offset</dt> <dd>
<p>Offset of member from start of object</p> </dd> <dt class="d_decl" id="OffsetTypeInfo.ti">TypeInfo ti</dt> <dd>
<p>TypeInfo for this member</p> </dd> </dl> </dd> <dt class="d_decl" id="TypeInfo">abstract class TypeInfo</dt> <dd>
<p>Runtime type information about a type. Can be retrieved for any type using a <a href="https://dlang.org/spec/expression.html#TypeidExpression" target="_blank"><i>TypeidExpression</i></a>.</p> <dl>
<dt class="d_decl" id="TypeInfo.getHash">const nothrow @trusted size_t getHash(in void* p)</dt> <dd>
<p>Computes a hash of the instance of a type. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>void* <code>p</code>
</td> <td>pointer to start of instance of the type</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>the hash </dd>
</dl> <dl>
<dt>Bugs:</dt>
<dd>fix <a href="https://issues.dlang.org/show_bug.cgi?id=12516" target="_blank">https://issues.dlang.org/show_bug.cgi?id=12516</a> e.g. by changing this to a truly safe interface.</dd>
</dl> </dd> <dt class="d_decl" id="TypeInfo.equals">const bool equals(in void* p1, in void* p2)</dt> <dd>
<p>Compares two instances for equality.</p> </dd> <dt class="d_decl" id="TypeInfo.compare">const int compare(in void* p1, in void* p2)</dt> <dd>
<p>Compares two instances for &lt;, ==, or &gt;.</p> </dd> <dt class="d_decl" id="TypeInfo.tsize">const pure nothrow @nogc @property @safe size_t tsize()</dt> <dd>
<p>Returns size of the type.</p> </dd> <dt class="d_decl" id="TypeInfo.swap">const void swap(void* p1, void* p2)</dt> <dd>
<p>Swaps two instances of the type.</p> </dd> <dt class="d_decl" id="TypeInfo.next">inout pure nothrow @nogc @property inout(TypeInfo) next()</dt> <dd>
<p>Get TypeInfo for '<code>next</code>' type, as defined by what kind of type this is, <code>null</code> if none.</p> </dd> <dt class="d_decl" id="TypeInfo.initializer">abstract const pure nothrow @nogc @safe const(void)[] initializer()</dt> <dd>
<p>Return default <code>initializer</code>. If the type should be initialized to all zeros, an array with a <code>null</code> ptr and a length equal to the type size will be returned. For static arrays, this returns the default <code>initializer</code> for a single element of the array, use <code>tsize</code> to get the correct size.</p> </dd> <dt class="d_decl" id="TypeInfo.flags">const pure nothrow @nogc @property @safe uint flags()</dt> <dd>
<p>Get <code>flags</code> for type: 1 means GC should scan for pointers, 2 means arg of this type is passed in XMM register</p> </dd> <dt class="d_decl" id="TypeInfo.offTi">const const(OffsetTypeInfo)[] offTi()</dt> <dd>
<p>Get type information on the contents of the type; <code>null</code> if not available</p> </dd> <dt class="d_decl" id="TypeInfo.destroy">const void destroy(void* p)</dt> <dd>
<p>Run the destructor on the object and all its sub-objects</p> </dd> <dt class="d_decl" id="TypeInfo.postblit">const void postblit(void* p)</dt> <dd>
<p>Run the <code>postblit</code> on the object and all its sub-objects</p> </dd> <dt class="d_decl" id="TypeInfo.talign">const pure nothrow @nogc @property @safe size_t talign()</dt> <dd>
<p>Return alignment of type</p> </dd> <dt class="d_decl" id="TypeInfo.argTypes">nothrow @safe int argTypes(out TypeInfo arg1, out TypeInfo arg2)</dt> <dd>
<p>Return internal info on arguments fitting into 8byte. See X86-64 ABI 3.2.3</p> </dd> <dt class="d_decl" id="TypeInfo.rtInfo">const pure nothrow @nogc @property @safe immutable(void)* rtInfo()</dt> <dd>
<p>Return info used by the garbage collector to do precise collection.</p> </dd> </dl> </dd> <dt class="d_decl" id="TypeInfo_Class">class TypeInfo_Class: object.TypeInfo</dt> <dd>
<p>Runtime type information about a class. Can be retrieved from an object instance by using the <a href="https://dlang.org/spec/property.html#classinfo" target="_blank">.classinfo</a> property.</p> <dl>
<dt class="d_decl" id="TypeInfo_Class.m_init">byte[] m_init</dt> <dd>
<p>class static initializer (init.length gives size in bytes of class)</p> </dd> <dt class="d_decl" id="TypeInfo_Class.name">string name</dt> <dd>
<p>class <code>name</code></p> </dd> <dt class="d_decl" id="TypeInfo_Class.vtbl">void*[] vtbl</dt> <dd>
<p>virtual function pointer table</p> </dd> <dt class="d_decl" id="TypeInfo_Class.interfaces">Interface[] interfaces</dt> <dd>
<p><code>interfaces</code> this class implements</p> </dd> <dt class="d_decl" id="TypeInfo_Class.base">TypeInfo_Class base</dt> <dd>
<p><code>base</code> class</p> </dd> <dt class="d_decl" id="TypeInfo_Class.find">static const(TypeInfo_Class) find(in char[] classname)</dt> <dd>
<p>Search all modules for TypeInfo_Class corresponding to <code>classname</code>. </p>
<dl>
<dt>Returns:</dt>
<dd>
<code>null</code> if not found</dd>
</dl> </dd> <dt class="d_decl" id="TypeInfo_Class.create">const Object create()</dt> <dd>
<p>Create instance of Object represented by 'this'.</p> </dd> </dl> </dd> <dt class="d_decl" id="Throwable">class Throwable</dt> <dd>
<p>The base class of all thrown objects. </p>
<p>All thrown objects must inherit from <code>Throwable</code>. Class <code>Exception</code>, which derives from this class, represents the category of thrown objects that are safe to catch and handle. In principle, one should not catch <code>Throwable</code> objects that are not derived from <code>Exception</code>, as they represent unrecoverable runtime errors. Certain runtime guarantees may fail to hold when these errors are thrown, making it unsafe to continue execution after catching them.</p> <dl>
<dt class="d_decl" id="Throwable.msg">string msg</dt> <dd>
<p>A message describing the error.</p> </dd> <dt class="d_decl" id="Throwable.file">string file</dt> <dd>
<p>The file name of the D source code corresponding with where the error was thrown from.</p> </dd> <dt class="d_decl" id="Throwable.line">size_t line</dt> <dd>
<p>The line number of the D source code corresponding with where the error was thrown from.</p> </dd> <dt class="d_decl" id="Throwable.info">TraceInfo info</dt> <dd>
<p>The stack trace of where the error happened. This is an opaque object that can either be converted to <code>string</code>, or iterated over with <code> foreach</code> to extract the items in the stack trace (as strings).</p> </dd> <dt class="d_decl" id="Throwable.next">Throwable next</dt> <dd>
<p>A reference to the next error in the list. This is used when a new <code>Throwable</code> is thrown from inside a <code>catch</code> block. The originally caught <code>Exception</code> will be chained to the new <code>Throwable</code> via this field.</p> </dd> <dt class="d_decl" id="Throwable.toString">string toString()</dt> <dd>
<p>Overrides <code>Object.toString</code> and returns the error message. Internally this forwards to the <code>toString</code> overload that takes a <span class="d_param">sink</span> delegate.</p> </dd> <dt class="d_decl" id="Throwable.toString.2">const void toString(scope void delegate(in char[]) sink)</dt> <dd>
<p>The Throwable hierarchy uses a <code>toString</code> overload that takes a <span class="d_param">sink</span> delegate to avoid GC allocations, which cannot be performed in certain error situations. Override this <code> toString</code> method to customize the error message.</p> </dd> </dl> </dd> <dt class="d_decl" id="Exception">class Exception: object.Throwable</dt> <dd>
<p>The base class of all errors that are safe to catch and handle. </p>
<p>In principle, only thrown objects derived from this class are safe to catch inside a <code>catch</code> block. Thrown objects not derived from <code>Exception</code> represent runtime errors that should not be caught, as certain runtime guarantees may not hold, making it unsafe to continue program execution.</p> <dl>
<dt class="d_decl" id="Exception.this">pure nothrow @nogc @safe this(string msg, string file = __FILE__, size_t line = __LINE__, Throwable next = null)</dt> <dd>
<p>Creates a new instance of Exception. The <code>next</code> parameter is used internally and should always be <code>null</code> when passed by user code. This constructor does not automatically throw the newly-created Exception; the <code>throw</code> statement should be used for that purpose.</p> </dd> </dl> </dd> <dt class="d_decl" id="Error">class Error: object.Throwable</dt> <dd>
<p>The base class of all unrecoverable runtime errors. </p>
<p>This represents the category of <code>Throwable</code> objects that are <b>not</b> safe to catch and handle. In principle, one should not catch <code>Error</code> objects, as they represent unrecoverable runtime errors. Certain runtime guarantees may fail to hold when these errors are thrown, making it unsafe to continue execution after catching them.</p> <dl>
<dt class="d_decl" id="Error.this">pure nothrow @nogc @safe this(string msg, Throwable next = null)</dt> <dd>
<p>Creates a new instance of Error. The <code>next</code> parameter is used internally and should always be <code>null</code> when passed by user code. This constructor does not automatically throw the newly-created Error; the <code>throw</code> statement should be used for that purpose.</p> </dd> <dt class="d_decl" id="Error.bypassedException">Throwable bypassedException</dt> <dd>
<p>The first <code>Exception</code> which was bypassed when this Error was thrown, or <code>null</code> if no <code>Exception</code>s were pending.</p> </dd> </dl> </dd> <dt class="d_decl" id="destroy">void destroy(T)(T obj)<br>void destroy(T)(T obj)<br>void destroy(T)(ref T obj)<br>void destroy(T : U[n], U, size_t n)(ref T obj)<br>void destroy(T)(ref T obj)<br><br>  Constraints:<br>    if (is(T == class))<br>    if (is(T == interface))<br>    if (is(T == struct))<br>    if (!is(T == struct))<br>    if (!is(T == struct) &amp;&amp; !is(T == interface) &amp;&amp; !is(T == class) &amp;&amp; !_isStaticArray!T)</dt> <dd>
<p>Destroys the given object and puts it in an invalid state. It's used to destroy an object so that any cleanup which its destructor or finalizer does is done and so that it no longer references any other objects. It does <i>not</i> initiate a GC cycle or free any GC memory.</p> </dd> <dt class="d_decl" id="capacity">pure nothrow @property @trusted size_t capacity(T)(T[] arr)</dt> <dd>
<p>(Property) Gets the current capacity of a slice. The capacity is the size that the slice can grow to before the underlying array must be reallocated or extended. </p>
<p>If an append must reallocate a slice with no possibility of extension, then <code>0</code> is returned. This happens when the slice references a static array, or if another slice references elements past the end of the current slice. </p> <dl>
<dt>Note</dt>
<dd> The capacity of a slice may be impacted by operations on other slices.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">//Static array slice: no capacity
int[4] sarray = [1, 2, 3, 4];
int[]  slice  = sarray[];
assert(sarray.capacity == 0);
//Appending to slice will reallocate to a new array
slice ~= 5;
assert(slice.capacity &gt;= 5);

//Dynamic array slices
int[] a = [1, 2, 3, 4];
int[] b = a[1 .. $];
int[] c = a[1 .. $ - 1];
debug(SENTINEL) {} else // non-zero capacity very much depends on the array and GC implementation
{
    assert(a.capacity != 0);
    assert(a.capacity == b.capacity + 1); //both a and b share the same tail
}
assert(c.capacity == 0);              //an append to c must relocate c.
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="reserve">pure nothrow @trusted size_t reserve(T)(ref T[] arr, size_t newcapacity)</dt> <dd>
<p>Reserves capacity for a slice. The capacity is the size that the slice can grow to before the underlying array must be reallocated or extended. </p>
<dl>
<dt>Returns:</dt>
<dd>The new capacity of the array (which may be larger than the requested capacity).</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">//Static array slice: no capacity. Reserve relocates.
int[4] sarray = [1, 2, 3, 4];
int[]  slice  = sarray[];
auto u = slice.reserve(8);
assert(u &gt;= 8);
assert(sarray.ptr !is slice.ptr);
assert(slice.capacity == u);

//Dynamic array slices
int[] a = [1, 2, 3, 4];
a.reserve(8); //prepare a for appending 4 more items
auto p = a.ptr;
u = a.capacity;
a ~= [5, 6, 7, 8];
assert(p == a.ptr);      //a should not have been reallocated
assert(u == a.capacity); //a should not have been extended
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="assumeSafeAppend">nothrow ref inout(T[]) assumeSafeAppend(T)(auto ref inout(T[]) arr)</dt> <dd>
<p>Assume that it is safe to append to this array. Appends made to this array after calling this function may append in place, even if the array was a slice of a larger array to begin with. </p>
<p>Use this only when it is certain there are no elements in use beyond the array in the memory block. If there are, those elements will be overwritten by appending to this array. </p> <dl>
<dt>Warning</dt>
<dd> Calling this function, and then using references to data located after the given array results in undefined behavior. </dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The input is returned.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">int[] a = [1, 2, 3, 4];

// Without assumeSafeAppend. Appending relocates.
int[] b = a [0 .. 3];
b ~= 5;
assert(a.ptr != b.ptr);

debug(SENTINEL) {} else
{
    // With assumeSafeAppend. Appending overwrites.
    int[] c = a [0 .. 3];
    c.assumeSafeAppend() ~= 5;
    assert(a.ptr == c.ptr);
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="_ArrayEq">bool _ArrayEq(T1, T2)(T1[] a1, T2[] a2)</dt> <dd>
<p>Helper function used to see if two containers of different types have the same contents in the same sequence.</p> </dd> <dt class="d_decl" id="hashOf">size_t hashOf(T)(auto ref T arg, size_t seed = 0)</dt> <dd>
<p>Calculates the hash value of <code>arg</code> with <code>seed</code> initial value. The result may not be equal to <code>typeid<span class="template_param_list" title="Template parameter list">(T)</span>.getHash(&amp;arg)</code>. The <code>seed</code> value may be used for hash chaining: </p>
<pre data-language="d">struct Test
{
    int a;
    string b;
    MyObject c;

    size_t toHash() const @safe pure nothrow
    {
        size_t hash = a.hashOf();
        hash = b.hashOf(hash);
        size_t h1 = c.myMegaHash();
        hash = h1.hashOf(hash); //Mix two hash values
        return hash;
    }
}
</pre>  </dd> <dt class="d_decl" id="RTInfo">enum auto RTInfo(T)</dt> <dd>
<p>Create <code>RTInfo</code> for type T</p> </dd> <dt class="d_decl" id="dup">@property auto dup(T)(T[] a)<br>@property T[] dup(T)(const(T)[] a)<br><br>  Constraints:<br>    if (!is(const(T) : T))<br>    if (is(const(T) : T))</dt> <dd>
<p>Provide the .<code>dup</code> array property.</p> </dd> <dt class="d_decl" id="idup">@property immutable(T)[] idup(T)(T[] a)<br>@property immutable(T)[] idup(T : void)(const(T)[] a)</dt> <dd>
<p>Provide the .<code>idup</code> array property.</p> </dd> </dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 1999–2017 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/phobos/object.html" class="_attribution-link" target="_blank">https://dlang.org/phobos/object.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
