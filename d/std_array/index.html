
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>std.array - D - W3cubDocs</title>
  
  <meta name="description" content=" Functions and types that manipulate built-in arrays and associative arrays. ">
  <meta name="keywords" content="std, array, -, d">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/d/std_array/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-e0f881b0fce8cbe96f33dadc355b7159d5d2912911231446d60eb8f9caffa802.css">
  <script type="text/javascript" src="/assets/application-8fc46316434047265cd383f02b8e7f434ed7dec4a59f920dd633deef8d488d1b.js"></script>
  <script src="/json/d.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/d/" class="_nav-link" title="" style="margin-left:0;">D</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _d">
				
<h1>std.array</h1>  <p>Functions and types that manipulate built-in arrays and associative arrays. </p>
<p>This module provides all kinds of functions to create, manipulate or convert arrays: <br><br>  </p>
<table>

<tr>
<th scope="col">Function Name</th> <th scope="col">Description</th> </tr> <tr>
<td><a href="#array"><code>array</code></a></td> <td>Returns a copy of the input in a newly allocated dynamic array. </td>
</tr> <tr>
<td><a href="#appender"><code>appender</code></a></td> <td>Returns a new <a href="#Appender"><code>Appender</code></a> or <a href="#RefAppender"><code>RefAppender</code></a> initialized with a given array. </td>
</tr> <tr>
<td><a href="#assocArray"><code>assocArray</code></a></td> <td>Returns a newly allocated associative array from a range of key/value tuples. </td>
</tr> <tr>
<td><a href="#byPair"><code>byPair</code></a></td> <td>Construct a range iterating over an associative array by key/value tuples. </td>
</tr> <tr>
<td><a href="#insertInPlace"><code>insertInPlace</code></a></td> <td>Inserts into an existing array at a given position. </td>
</tr> <tr>
<td><a href="#join"><code>join</code></a></td> <td>Concatenates a range of ranges into one array. </td>
</tr> <tr>
<td><a href="#minimallyInitializedArray"><code>minimallyInitializedArray</code></a></td> <td>Returns a new array of type <code>T</code>. </td>
</tr> <tr>
<td><a href="#replace"><code>replace</code></a></td> <td>Returns a new array with all occurrences of a certain subrange replaced. </td>
</tr> <tr>
<td><a href="#replaceFirst"><code>replaceFirst</code></a></td> <td>Returns a new array with the first occurrence of a certain subrange replaced. </td>
</tr> <tr>
<td><a href="#replaceInPlace"><code>replaceInPlace</code></a></td> <td>Replaces all occurrences of a certain subrange and puts the result into a given array. </td>
</tr> <tr>
<td><a href="#replaceInto"><code>replaceInto</code></a></td> <td>Replaces all occurrences of a certain subrange and puts the result into an output range. </td>
</tr> <tr>
<td><a href="#replaceLast"><code>replaceLast</code></a></td> <td>Returns a new array with the last occurrence of a certain subrange replaced. </td>
</tr> <tr>
<td><a href="#replaceSlice"><code>replaceSlice</code></a></td> <td>Returns a new array with a given slice replaced. </td>
</tr> <tr>
<td><a href="#replicate"><code>replicate</code></a></td> <td>Creates a new array out of several copies of an input array or range. </td>
</tr> <tr>
<td><a href="#sameHead"><code>sameHead</code></a></td> <td>Checks if the initial segments of two arrays refer to the same place in memory. </td>
</tr> <tr>
<td><a href="#sameTail"><code>sameTail</code></a></td> <td>Checks if the final segments of two arrays refer to the same place in memory. </td>
</tr> <tr>
<td><a href="#split"><code>split</code></a></td> <td>Eagerly split a range or string into an array. </td>
</tr> <tr>
<td><a href="#uninitializedArray"><code>uninitializedArray</code></a></td> <td>Returns a new array of type <code>T</code> without initializing its elements. </td>
</tr> </table>  <dl>
<dt>License:</dt>
<dd>
<a href="http://boost.org/LICENSE_1_0.txt" target="_blank">Boost License 1.0</a>. </dd>
</dl> <dl>
<dt>Authors:</dt>
<dd>
<a href="http://erdani.org" target="_blank">Andrei Alexandrescu</a> and Jonathan M Davis </dd>
</dl> <dl>
<dt>Source</dt>
<dd> <span class="phobos_src"><a class="https" href="https://github.com/dlang/phobos/blob/master/std/array.d" target="_blank">std/array.d</a></span>
</dd>
</dl> <dl>
<dt class="d_decl" id="array">ForeachType!Range[] array(Range)(Range r)<br><br>  Constraints:<br>    if (isIterable!Range &amp;&amp; !isNarrowString!Range &amp;&amp; !isInfinite!Range)</dt> <dd>
<p>Allocates an <code>array</code> and initializes it with copies of the elements of range <code>r</code>. </p>
<p>Narrow strings are handled as a special case in an overload. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Range <code>r</code>
</td> <td>range (or aggregate with <code>opApply</code> function) whose elements are copied into the allocated <code>array</code>
</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>allocated and initialized <code>array</code>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto a = array([1, 2, 3, 4, 5][]);
writeln(a); // [1, 2, 3, 4, 5]
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="array.2">@trusted ElementType!String[] array(String)(scope String str)<br><br>  Constraints:<br>    if (isNarrowString!String)</dt> <dd>
<p>Convert a narrow string to an <code>array</code> type that fully supports random access. This is handled as a special case and always returns an <code>array</code> of <code>dchar</code> </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>String <code>str</code>
</td> <td>
<code>isNarrowString</code> to be converted to an <code>array</code> of <code>dchar</code>
</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>a <code>dchar[]</code>, <code>const(dchar)[]</code>, or <code>immutable(dchar)[]</code> depending on the constness of the input.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.range.primitives : isRandomAccessRange;

writeln("Hello D".array); // "Hello D"d
static assert(isRandomAccessRange!string == false);

writeln("Hello D"w.array); // "Hello D"d
static assert(isRandomAccessRange!dstring == true);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="assocArray">auto assocArray(Range)(Range r)<br><br>  Constraints:<br>    if (isInputRange!Range)</dt> <dd>
<p>Returns a newly allocated associative array from a range of key/value tuples. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Range <code>r</code>
</td> <td>An <a href="../std_range_primitives/#isInputRange">input range</a> of tuples of keys and values.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A newly allocated associative array out of elements of the input range, which must be a range of tuples (Key, Value). Returns a <code>null</code> associative array reference when given an empty range. </dd>
</dl> <dl>
<dt>Duplicates</dt>
<dd> Associative arrays have unique keys. If <code>r</code> contains duplicate keys, then the result will contain the value of the last pair for that key in <code>r</code>. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="../std_typecons/#Tuple"><code>std.typecons.Tuple</code></a>, <a href="../std_range/#zip"><code>std.range.zip</code></a>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.range;
import std.typecons;
auto a = assocArray(zip([0, 1, 2], ["a", "b", "c"])); // aka zipMap
assert(is(typeof(a) == string[int]));
writeln(a); // [0:"a", 1:"b", 2:"c"]

auto b = assocArray([ tuple("foo", "bar"), tuple("baz", "quux") ]);
assert(is(typeof(b) == string[string]));
writeln(b); // ["foo":"bar", "baz":"quux"]
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="byPair">auto byPair(AA : Value[Key], Value, Key)(AA aa)</dt> <dd>
<p>Construct a range iterating over an associative array by key/value tuples. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>AA <code>aa</code>
</td> <td>The associative array to iterate over.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A <a href="../std_range_primitives/#isForwardRange">forward range</a> of Tuple's of key and value pairs from the given associative array.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.sorting : sort;
import std.typecons : tuple, Tuple;

auto aa = ["a": 1, "b": 2, "c": 3];
Tuple!(string, int)[] pairs;

// Iteration over key/value pairs.
foreach (pair; aa.byPair)
{
    pairs ~= pair;
}

// Iteration order is implementation-dependent, so we should sort it to get
// a fixed order.
sort(pairs);
assert(pairs == [
    tuple("a", 1),
    tuple("b", 2),
    tuple("c", 3)
]);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="uninitializedArray">nothrow @system auto uninitializedArray(T, I...)(I sizes)<br>nothrow @trusted auto uninitializedArray(T, I...)(I sizes)<br><br>  Constraints:<br>    if (isDynamicArray!T &amp;&amp; allSatisfy!(isIntegral, I) &amp;&amp; hasIndirections!(ElementEncodingType!T))<br>    if (isDynamicArray!T &amp;&amp; allSatisfy!(isIntegral, I) &amp;&amp; !hasIndirections!(ElementEncodingType!T))</dt> <dd>
<p>Returns a new array of type <code>T</code> allocated on the garbage collected heap without initializing its elements. This can be a useful optimization if every element will be immediately initialized. <code>T</code> may be a multidimensional array. In this case <code>sizes</code> may be specified for any number of dimensions from 0 to the number in <code>T</code>. </p>
<p><code>uninitializedArray</code> is nothrow and weakly pure. <br><br> <code>uninitializedArray</code> is @system if the uninitialized element type has pointers.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">double[] arr = uninitializedArray!(double[])(100);
writeln(arr.length); // 100

double[][] matrix = uninitializedArray!(double[][])(42, 31);
writeln(matrix.length); // 42
writeln(matrix[0].length); // 31

char*[] ptrs = uninitializedArray!(char*[])(100);
writeln(ptrs.length); // 100
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="minimallyInitializedArray">nothrow @trusted auto minimallyInitializedArray(T, I...)(I sizes)<br><br>  Constraints:<br>    if (isDynamicArray!T &amp;&amp; allSatisfy!(isIntegral, I))</dt> <dd>
<p>Returns a new array of type <code>T</code> allocated on the garbage collected heap. </p>
<p>Partial initialization is done for types with indirections, for preservation of memory safety. Note that elements will only be initialized to 0, but not necessarily the element type's <code>.init</code>. <br><br> <code>minimallyInitializedArray</code> is nothrow and weakly pure.</p> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
import std.range : repeat;

auto arr = minimallyInitializedArray!(int[])(42);
writeln(arr.length); // 42
// Elements aren't necessarily initialized to 0
assert(!arr.equal(0.repeat(42)));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="insertInPlace">void insertInPlace(T, U...)(ref T[] array, size_t pos, U stuff)<br>void insertInPlace(T, U...)(ref T[] array, size_t pos, U stuff)<br><br>  Constraints:<br>    if (!isSomeString!(T[]) &amp;&amp; allSatisfy!(isInputRangeOrConvertible!T, U) &amp;&amp; U.length &gt; 0)<br>    if (isSomeString!(T[]) &amp;&amp; allSatisfy!(isCharOrStringOrDcharRange, U))</dt> <dd>
<p>Inserts <code>stuff</code> (which must be an input range or any number of implicitly convertible items) in <code>array</code> at position <code>pos</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T[] <code>array</code>
</td> <td>The <code>array</code> that <code>stuff</code> will be inserted into.</td>
</tr> <tr>
<td>size_t <code>pos</code>
</td> <td>The position in <code>array</code> to insert the <code>stuff</code>.</td>
</tr> <tr>
<td>U <code>stuff</code>
</td> <td>An <a href="../std_range_primitives/#isInputRange">input range</a>, or any number of implicitly convertible items to insert into <code>array</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">int[] a = [ 1, 2, 3, 4 ];
a.insertInPlace(2, [ 1, 2 ]);
writeln(a); // [1, 2, 1, 2, 3, 4]
a.insertInPlace(3, 10u, 11);
writeln(a); // [1, 2, 1, 10, 11, 2, 3, 4]
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="sameHead">pure nothrow @safe bool sameHead(T)(in T[] lhs, in T[] rhs)</dt> <dd>
<p>Returns whether the <code>front</code>s of <code>lhs</code> and <code>rhs</code> both refer to the same place in memory, making one of the arrays a slice of the other which starts at index <code>0</code>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto a = [1, 2, 3, 4, 5];
auto b = a[0 .. 2];

assert(a.sameHead(b));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="sameTail">pure nothrow @trusted bool sameTail(T)(in T[] lhs, in T[] rhs)</dt> <dd>
<p>Returns whether the <code>back</code>s of <code>lhs</code> and <code>rhs</code> both refer to the same place in memory, making one of the arrays a slice of the other which end at index <code>$</code>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto a = [1, 2, 3, 4, 5];
auto b = a[3..$];

assert(a.sameTail(b));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="replicate">ElementEncodingType!S[] replicate(S)(S s, size_t n)<br>ElementType!S[] replicate(S)(S s, size_t n)<br><br>  Constraints:<br>    if (isDynamicArray!S)<br>    if (isInputRange!S &amp;&amp; !isDynamicArray!S)</dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>S <code>s</code>
</td> <td>an <a href="../std_range_primitives/#isInputRange">input range</a> or a dynamic array</td>
</tr> <tr>
<td>size_t <code>n</code>
</td> <td>number of times to repeat <code>s</code>
</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>An array that consists of <code>s</code> repeated <code>n</code> times. This function allocates, fills, and returns a new array. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>For a lazy version, refer to <a href="../std_range/#repeat"><code>std.range.repeat</code></a>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto a = "abc";
auto s = replicate(a, 3);

writeln(s); // "abcabcabc"

auto b = [1, 2, 3];
auto c = replicate(b, 3);

writeln(c); // [1, 2, 3, 1, 2, 3, 1, 2, 3]

auto d = replicate(b, 0);

writeln(d); // []
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="split">pure @safe S[] split(S)(S s)<br><br>  Constraints:<br>    if (isSomeString!S)</dt> <dd>
<p>Eagerly <code>split</code> the string <code>s</code> into an array of words, using whitespace as delimiter. Runs of whitespace are merged together (no empty words are produced). </p>
<p><code>@safe</code>, <code>pure</code> and <code>CTFE</code>-able. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>S <code>s</code>
</td> <td>the string to <code>split</code>
</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>An array of each word in <code>s</code> </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="../std_algorithm_iteration/#splitter"><code>std.algorithm.iteration.splitter</code></a> for a version that splits using any separator.  <a href="../std_regex/#splitter"><code>std.regex.splitter</code></a> for a version that splits using a regular expression defined separator.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">string str = "Hello World!";
writeln(str.split); // ["Hello", "World!"]

string str2 = "Hello\t\tWorld\t!";
writeln(str2.split); // ["Hello", "World", "!"]
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<code>split</code> allocates memory, so the same effect can be achieved lazily using <a href="../std_algorithm_iteration/#splitter"><code>std.algorithm.iteration.splitter</code></a>. <pre data-language="d">import std.ascii : isWhite;
import std.algorithm.comparison : equal;

string str = "Hello World!";
assert(str.splitter!(isWhite).equal(["Hello", "World!"]));
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(split("hello world")); // ["hello", "world"]
writeln(split("192.168.0.1", ".")); // ["192", "168", "0", "1"]

auto a = split([1, 2, 3, 4, 5, 1, 2, 3, 4, 5], [2, 3]);
writeln(a); // [[1], [4, 5, 1], [4, 5]]
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="split.2">auto split(Range, Separator)(Range range, Separator sep)<br>auto split(Range, Separator)(Range range, Separator sep)<br>auto split(alias isTerminator, Range)(Range range)<br><br>  Constraints:<br>    if (isForwardRange!Range &amp;&amp; is(typeof(ElementType!Range.init == Separator.init)))<br>    if (isForwardRange!Range &amp;&amp; isForwardRange!Separator &amp;&amp; is(typeof(ElementType!Range.init == ElementType!Separator.init)))<br>    if (isForwardRange!Range &amp;&amp; is(typeof(unaryFun!isTerminator(range.front))))</dt> <dd>
<p>Eagerly splits <code>range</code> into an array, using <code>sep</code> as the delimiter. </p>
<p>The range must be a <a href="../std_range_primitives/#isForwardRange">forward range</a>. The separator can be a value of the same type as the elements in <code>range</code> or it can be another forward range. </p> <dl>
<dt>Example</dt>
<dd> If <code>range</code> is a <code>string</code>, <code>sep</code> can be a <code>char</code> or another <code>string</code>. The return type will be an array of strings. If <code>range</code> is an <code>int</code> array, <code>sep</code> can be an <code>int</code> or another <code>int</code> array. The return type will be an array of <code>int</code> arrays. </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Range <code>range</code>
</td> <td>a forward range.</td>
</tr> <tr>
<td>Separator <code>sep</code>
</td> <td>a value of the same type as the elements of <code>range</code> or another forward <code>range</code>.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>An array containing the divided parts of <code>range</code>. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="../std_algorithm_iteration/#splitter"><code>std.algorithm.iteration.splitter</code></a> for the lazy version of this function.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.uni : isWhite;
writeln("Learning,D,is,fun".split(",")); // ["Learning", "D", "is", "fun"]
writeln("Learning D is fun".split!isWhite); // ["Learning", "D", "is", "fun"]
writeln("Learning D is fun".split(" D ")); // ["Learning", "is fun"]
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="join">ElementEncodingType!(ElementType!RoR)[] join(RoR, R)(RoR ror, scope R sep)<br>ElementEncodingType!(ElementType!RoR)[] join(RoR, E)(RoR ror, scope E sep)<br>ElementEncodingType!(ElementType!RoR)[] join(RoR)(RoR ror)<br><br>  Constraints:<br>    if (isInputRange!RoR &amp;&amp; isInputRange!(Unqual!(ElementType!RoR)) &amp;&amp; isInputRange!R &amp;&amp; is(Unqual!(ElementType!(ElementType!RoR)) == Unqual!(ElementType!R)))<br>    if (isInputRange!RoR &amp;&amp; isInputRange!(Unqual!(ElementType!RoR)) &amp;&amp; is(E : ElementType!(ElementType!RoR)))<br>    if (isInputRange!RoR &amp;&amp; isInputRange!(Unqual!(ElementType!RoR)))</dt> <dd>
<p>Eagerly concatenates all of the ranges in <code>ror</code> together (with the GC) into one array using <code>sep</code> as the separator if present. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>RoR <code>ror</code>
</td> <td>An <a href="../std_range_primitives/#isInputRange">input range</a> of input ranges</td>
</tr> <tr>
<td>R <code>sep</code>
</td> <td>An input range, or a single element, to <code>join</code> the ranges on</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>An array of elements </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>For a lazy version, see <a href="../std_algorithm_iteration/#joiner"><code>std.algorithm.iteration.joiner</code></a>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(join(["hello", "silly", "world"], " ")); // "hello silly world"
writeln(join(["hello", "silly", "world"])); // "hellosillyworld"

writeln(join([[1, 2, 3], [4, 5]], [72, 73])); // [1, 2, 3, 72, 73, 4, 5]
writeln(join([[1, 2, 3], [4, 5]])); // [1, 2, 3, 4, 5]

const string[] arr = ["apple", "banana"];
writeln(arr.join(",")); // "apple,banana"
writeln(arr.join()); // "applebanana"
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="replace">E[] replace(E, R1, R2)(E[] subject, R1 from, R2 to)<br>void replaceInto(E, Sink, R1, R2)(Sink sink, E[] subject, R1 from, R2 to)<br><br>  Constraints:<br>    if (isDynamicArray!(E[]) &amp;&amp; isForwardRange!R1 &amp;&amp; isForwardRange!R2 &amp;&amp; (hasLength!R2 || isSomeString!R2))<br>    if (isOutputRange!(Sink, E) &amp;&amp; isDynamicArray!(E[]) &amp;&amp; isForwardRange!R1 &amp;&amp; isForwardRange!R2 &amp;&amp; (hasLength!R2 || isSomeString!R2))</dt> <dd>
<p>Replace occurrences of <code>from</code> with <code>to</code> in <code>subject</code> in a new array. If <code>sink</code> is defined, then output the new array into <code>sink</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Sink <code>sink</code>
</td> <td>an <a href="../std_range_primitives/#isOutputRange">output range</a>
</td>
</tr> <tr>
<td>E[] <code>subject</code>
</td> <td>the array <code>to</code> scan</td>
</tr> <tr>
<td>R1 <code>from</code>
</td> <td>the item <code>to</code> <code>replace</code>
</td>
</tr> <tr>
<td>R2 <code>to</code>
</td> <td>the item <code>to</code> <code>replace</code> all instances of <code>from</code> with</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>If <code>sink</code> isn't defined, a new array without changing the contents of <code>subject</code>, or the original array if no match is found. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="../std_algorithm_iteration/#map"><code>std.algorithm.iteration.map</code></a> which can act as a lazy <code>replace</code>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln("Hello Wörld".replace("o Wö", "o Wo")); // "Hello World"
writeln("Hello Wörld".replace("l", "h")); // "Hehho Wörhd"
</pre> </dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto arr = [1, 2, 3, 4, 5];
auto from = [2, 3];
auto to = [4, 6];
auto sink = appender!(int[])();

replaceInto(sink, arr, from, to);

writeln(sink.data); // [1, 4, 6, 4, 5]
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="replace.2">T[] replace(T, Range)(T[] subject, size_t from, size_t to, Range stuff)<br><br>  Constraints:<br>    if (isInputRange!Range &amp;&amp; (is(ElementType!Range : T) || isSomeString!(T[]) &amp;&amp; is(ElementType!Range : dchar)))</dt> <dd>
<p>Replaces elements <code>from</code> <code>array</code> with indices ranging <code>from</code> <code>from</code> (inclusive) <code>to</code> <code>to</code> (exclusive) with the range <code>stuff</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T[] <code>subject</code>
</td> <td>the array <code>to</code> scan</td>
</tr> <tr>
<td>size_t <code>from</code>
</td> <td>the starting index</td>
</tr> <tr>
<td>size_t <code>to</code>
</td> <td>the ending index</td>
</tr> <tr>
<td>Range <code>stuff</code>
</td> <td>the items <code>to</code> <code>replace</code> in-between <code>from</code> and <code>to</code>
</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A new array without changing the contents of <code>subject</code>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto a = [ 1, 2, 3, 4 ];
auto b = a.replace(1, 3, [ 9, 9, 9 ]);
writeln(a); // [1, 2, 3, 4]
writeln(b); // [1, 9, 9, 9, 4]
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="replaceInPlace">void replaceInPlace(T, Range)(ref T[] array, size_t from, size_t to, Range stuff)<br><br>  Constraints:<br>    if (is(typeof(replace(array, from, to, stuff))))</dt> <dd>
<p>Replaces elements <code>from</code> <code>array</code> with indices ranging <code>from</code> <code>from</code> (inclusive) <code>to</code> <code>to</code> (exclusive) with the range <code>stuff</code>. Expands or shrinks the <code>array</code> as needed. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T[] <code>array</code>
</td> <td>the array <code>to</code> scan</td>
</tr> <tr>
<td>size_t <code>from</code>
</td> <td>the starting index</td>
</tr> <tr>
<td>size_t <code>to</code>
</td> <td>the ending index</td>
</tr> <tr>
<td>Range <code>stuff</code>
</td> <td>the items <code>to</code> replace in-between <code>from</code> and <code>to</code>
</td>
</tr> </table></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">int[] a = [1, 4, 5];
replaceInPlace(a, 1u, 2u, [2, 3, 4]);
writeln(a); // [1, 2, 3, 4, 5]
replaceInPlace(a, 1u, 2u, cast(int[])[]);
writeln(a); // [1, 3, 4, 5]
replaceInPlace(a, 1u, 3u, a[2 .. 4]);
writeln(a); // [1, 4, 5, 5]
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="replaceFirst">E[] replaceFirst(E, R1, R2)(E[] subject, R1 from, R2 to)<br><br>  Constraints:<br>    if (isDynamicArray!(E[]) &amp;&amp; isForwardRange!R1 &amp;&amp; is(typeof(appender!(E[])().put(from[0..1]))) &amp;&amp; isForwardRange!R2 &amp;&amp; is(typeof(appender!(E[])().put(to[0..1]))))</dt> <dd>
<p>Replaces the first occurrence of <code>from</code> with <code>to</code> in <code>subject</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>E[] <code>subject</code>
</td> <td>the array <code>to</code> scan</td>
</tr> <tr>
<td>R1 <code>from</code>
</td> <td>the item <code>to</code> replace</td>
</tr> <tr>
<td>R2 <code>to</code>
</td> <td>the item <code>to</code> replace <code>from</code> with</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A new array without changing the contents of <code>subject</code>, or the original array if no match is found.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto a = [1, 2, 2, 3, 4, 5];
auto b = a.replaceFirst([2], [1337]);
writeln(b); // [1, 1337, 2, 3, 4, 5]

auto s = "This is a foo foo list";
auto r = s.replaceFirst("foo", "silly");
writeln(r); // "This is a silly foo list"
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="replaceLast">E[] replaceLast(E, R1, R2)(E[] subject, R1 from, R2 to)<br><br>  Constraints:<br>    if (isDynamicArray!(E[]) &amp;&amp; isForwardRange!R1 &amp;&amp; is(typeof(appender!(E[])().put(from[0..1]))) &amp;&amp; isForwardRange!R2 &amp;&amp; is(typeof(appender!(E[])().put(to[0..1]))))</dt> <dd>
<p>Replaces the last occurrence of <code>from</code> with <code>to</code> in <code>subject</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>E[] <code>subject</code>
</td> <td>the array <code>to</code> scan</td>
</tr> <tr>
<td>R1 <code>from</code>
</td> <td>the item <code>to</code> replace</td>
</tr> <tr>
<td>R2 <code>to</code>
</td> <td>the item <code>to</code> replace <code>from</code> with</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A new array without changing the contents of <code>subject</code>, or the original array if no match is found.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto a = [1, 2, 2, 3, 4, 5];
auto b = a.replaceLast([2], [1337]);
writeln(b); // [1, 2, 1337, 3, 4, 5]

auto s = "This is a foo foo list";
auto r = s.replaceLast("foo", "silly");
writeln(r); // "This is a foo silly list"
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="replaceSlice">inout(T)[] replaceSlice(T)(inout(T)[] s, in T[] slice, in T[] replacement)</dt> <dd>
<p>Creates a new array such that the items in <code>slice</code> are replaced with the items in <code>replacement</code>. <code>slice</code> and <code>replacement</code> do not need to be the same length. The result will grow or shrink based on the items given. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>inout<span class="template_param_list" title="Template parameter list">(T)</span>[] <code>s</code>
</td> <td>the base of the new array</td>
</tr> <tr>
<td>T[] <code>slice</code>
</td> <td>the <code>slice</code> of <code>s</code> to be replaced</td>
</tr> <tr>
<td>T[] <code>replacement</code>
</td> <td>the items to replace <code>slice</code> with</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A new array that is <code>s</code> with <code>slice</code> replaced by <code>replacement[]</code>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto a = [1, 2, 3, 4, 5];
auto b = replaceSlice(a, a[1 .. 4], [0, 0, 0]);

writeln(b); // [1, 0, 0, 0, 5]
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="Appender">struct Appender(A) if (isDynamicArray!A)</dt> <dd>
<p>Implements an output range that appends data to an array. This is recommended over <code>array ~= data</code> when appending many elements because it is more efficient. <code>Appender</code> maintains its own array metadata locally, so it can avoid global locking for each append where <a href="#capacity"><code>capacity</code></a> is non-zero. </p>
<dl>
<dt>See Also:</dt>
<dd><a href="#appender"><code>appender</code></a></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto app = appender!string();
string b = "abcdefg";
foreach (char c; b)
    app.put(c);
writeln(app.data); // "abcdefg"

int[] a = [ 1, 2 ];
auto app2 = appender(a);
app2.put(3);
app2.put([ 4, 5, 6 ]);
writeln(app2.data); // [1, 2, 3, 4, 5, 6]
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="Appender.this">pure nothrow @trusted this(A arr)</dt> <dd>
<p>Constructs an <code>Appender</code> with a given array. Note that this does not copy the data. If the array has a larger capacity as determined by <code>arr.capacity</code>, it will be used by the appender. After initializing an appender on an array, appending to the original array will reallocate.</p> </dd> <dt class="d_decl" id="Appender.reserve">pure nothrow @safe void reserve(size_t newCapacity)</dt> <dd>
<p>Reserve at least <code>newCapacity</code> elements for appending. Note that more elements may be reserved than requested. If <code>newCapacity &lt;= capacity</code>, then nothing is done.</p> </dd> <dt class="d_decl" id="Appender.capacity">const pure nothrow @property @safe size_t capacity()</dt> <dd>
<dl>
<dt>Returns:</dt>
<dd>the <code>capacity</code> of the array (the maximum number of elements the managed array can accommodate before triggering a reallocation). If any appending will reallocate, <code>0</code> will be returned.</dd>
</dl> </dd> <dt class="d_decl" id="Appender.data">inout pure nothrow @property @trusted inout(ElementEncodingType!A)[] data()</dt> <dd>
<dl>
<dt>Returns:</dt>
<dd>The managed array.</dd>
</dl> </dd> <dt class="d_decl" id="Appender.put">void put(U)(U item)<br><br>  Constraints:<br>    if (canPutItem!U)</dt> <dd>
<p>Appends <code>item</code> to the managed array.</p> </dd> <dt class="d_decl" id="Appender.put.2">void put(Range)(Range items)<br><br>  Constraints:<br>    if (canPutRange!Range)</dt> <dd>
<p>Appends an entire range to the managed array.</p> </dd> <dt class="d_decl" id="Appender.opOpAssign">void opOpAssign(string op : "~", U)(U rhs)<br><br>  Constraints:<br>    if (__traits(compiles, put(rhs)))</dt> <dd>
<p>Appends <code>rhs</code> to the managed array. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>U <code>rhs</code>
</td> <td>Element or range.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="Appender.clear">pure nothrow @trusted void clear()</dt> <dd>
<p>Clears the managed array. This allows the elements of the array to be reused for appending. </p>
<dl>
<dt>Note</dt>
<dd> <code>clear</code> is disabled for immutable or const element types, due to the possibility that <code>Appender</code> might overwrite immutable data.</dd>
</dl> </dd> <dt class="d_decl" id="Appender.shrinkTo">pure @trusted void shrinkTo(size_t newlength)</dt> <dd>
<p>Shrinks the managed array to the given length. </p>
<dl>
<dt>Throws:</dt>
<dd>
<code>Exception</code> if <code>newlength</code> is greater than the current array length. </dd>
</dl> <dl>
<dt>Note</dt>
<dd> <code>shrinkTo</code> is disabled for immutable or const element types.</dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="RefAppender">struct RefAppender(A) if (isDynamicArray!A)</dt> <dd>
<p>A version of <a href="#Appender"><code>Appender</code></a> that can update an array in-place. It forwards all calls to an underlying appender implementation. Any calls made to the appender also update the pointer to the original array passed in. </p>
<dl>
<dt>Tip</dt>
<dd> Use the <code>arrayPtr</code> overload of <a href="#appender"><code>appender</code></a> for construction with type-inference.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">int[] a = [1, 2];
auto app2 = appender(&amp;a);
writeln(app2.data); // [1, 2]
writeln(a); // [1, 2]
app2 ~= 3;
app2 ~= [4, 5, 6];
writeln(app2.data); // [1, 2, 3, 4, 5, 6]
writeln(a); // [1, 2, 3, 4, 5, 6]

app2.reserve(5);
assert(app2.capacity &gt;= 5);
</pre> </dd>
</dl> <dl>
<dt class="d_decl" id="RefAppender.this">this(A* arr)</dt> <dd>
<p>Constructs a <code>RefAppender</code> with a given array reference. This does not copy the data. If the array has a larger capacity as determined by <code>arr.capacity</code>, it will be used by the appender. </p>
<dl>
<dt>Note</dt>
<dd> Do not use built-in appending (i.e. <code>~=</code>) on the original array until you are done with the appender, because subsequent calls to the appender will reallocate the array data without those appends. </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>A* <code>arr</code>
</td> <td>Pointer to an array. Must not be null.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="RefAppender.opDispatch">void opDispatch(string fn, Args...)(Args args)<br><br>  Constraints:<br>    if (__traits(compiles, (Appender!A a) =&gt; mixin("a." ~ fn ~ "(args)")))</dt> <dd>
<p>Wraps remaining <code>Appender</code> methods such as <a href="#put"><code>put</code></a>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>fn</td> <td>Method name to call.</td>
</tr> <tr>
<td>Args <code>args</code>
</td> <td>Arguments to pass to the method.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="RefAppender.opOpAssign">void opOpAssign(string op : "~", U)(U rhs)<br><br>  Constraints:<br>    if (__traits(compiles, (Appender!A a) { a.put(rhs); } ))</dt> <dd>
<p>Appends <code>rhs</code> to the managed array. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>U <code>rhs</code>
</td> <td>Element or range.</td>
</tr> </table></dd>
</dl> </dd> <dt class="d_decl" id="RefAppender.capacity">const @property size_t capacity()</dt> <dd>
<p>Returns the <code>capacity</code> of the array (the maximum number of elements the managed array can accommodate before triggering a reallocation). If any appending will reallocate, <code>capacity</code> returns <code>0</code>.</p> </dd> <dt class="d_decl" id="RefAppender.data">inout @property inout(ElementEncodingType!A)[] data()</dt> <dd>
<p>Returns the managed array.</p> </dd> </dl> </dd> <dt class="d_decl" id="appender">Appender!A appender(A)()<br>Appender!(E[]) appender(A : E[], E)(auto ref A array)<br><br>  Constraints:<br>    if (isDynamicArray!A)</dt> <dd>
<p>Convenience function that returns an <a href="#Appender"><code>Appender</code></a> instance, optionally initialized with <code>array</code>.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">auto w = appender!string;
// pre-allocate space for at least 10 elements (this avoids costly reallocations)
w.reserve(10);
assert(w.capacity &gt;= 10);

w.put('a'); // single elements
w.put("bc"); // multiple elements

// use the append syntax
w ~= 'd';
w ~= "ef";

writeln(w.data); // "abcdef"
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="appender.2">RefAppender!(E[]) appender(P : E[]*, E)(P arrayPtr)</dt> <dd>
<p>Convenience function that returns a <a href="#RefAppender"><code>RefAppender</code></a> instance initialized with <code>arrayPtr</code>. Don't use <code>null</code> for the array pointer, use the other version of <code>appender</code> instead.</p>
<dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">int[] a = [1, 2];
auto app2 = appender(&amp;a);
writeln(app2.data); // [1, 2]
writeln(a); // [1, 2]
app2 ~= 3;
app2 ~= [4, 5, 6];
writeln(app2.data); // [1, 2, 3, 4, 5, 6]
writeln(a); // [1, 2, 3, 4, 5, 6]

app2.reserve(5);
assert(app2.capacity &gt;= 5);
</pre> </dd>
</dl> </dd> </dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 1999–2017 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/phobos/std_array.html" class="_attribution-link" target="_blank">https://dlang.org/phobos/std_array.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
