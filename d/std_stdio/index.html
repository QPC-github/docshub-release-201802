
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>std.stdio - D - W3cubDocs</title>
  
  <meta name="description" content=" Standard I&#47;O functions that extend core.stdc.stdio. core.stdc.stdio is publically imported when importing std.stdio. ">
  <meta name="keywords" content="std, stdio, -, d">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/d/std_stdio/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-e0f881b0fce8cbe96f33dadc355b7159d5d2912911231446d60eb8f9caffa802.css">
  <script type="text/javascript" src="/assets/application-8fc46316434047265cd383f02b8e7f434ed7dec4a59f920dd633deef8d488d1b.js"></script>
  <script src="/json/d.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/d/" class="_nav-link" title="" style="margin-left:0;">D</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _d">
				
<h1>std.stdio</h1>  <p>Standard I/O functions that extend <b>core.stdc.<code>stdio</code></b>. <b>core.stdc.<code>stdio</code></b> is <span class="d_param">public</span>ally imported when importing <b>std.<code>stdio</code></b>. </p>
<dl>
<dt>Source</dt>
<dd> <span class="phobos_src"><a class="https" href="https://github.com/dlang/phobos/blob/master/std/stdio.d" target="_blank">std/stdio.d</a></span> </dd>
</dl> <dl>
<dt>License:</dt>
<dd>
<a href="http://boost.org/LICENSE_1_0.txt" target="_blank">Boost License 1.0</a>. </dd>
</dl> <dl>
<dt>Authors:</dt>
<dd>
<a href="http://digitalmars.com" target="_blank">Walter Bright</a>, <a href="http://erdani.org" target="_blank">Andrei Alexandrescu</a>, Alex RÃ¸nne Petersen</dd>
</dl> <dl>
<dt class="d_decl" id="KeepTerminator">alias KeepTerminator = std.typecons.Flag!"keepTerminator".Flag</dt> <dd>
<p>If flag <code>KeepTerminator</code> is set to <code>KeepTerminator.yes</code>, then the delimiter is included in the strings returned.</p> </dd> <dt class="d_decl" id="File">struct File</dt> <dd>
<p>Encapsulates a <code>FILE*</code>. Generally D does not attempt to provide thin wrappers over equivalent functions in the C standard library, but manipulating <code>FILE*</code> values directly is unsafe and error-prone in many ways. The <code>File</code> type ensures safe manipulation, automatic file closing, and a lot of convenience. </p>
<p>The underlying <code>FILE*</code> handle is maintained in a reference-counted manner, such that as soon as the last <code>File</code> variable bound to a given <code>FILE*</code> goes out of scope, the underlying <code>FILE*</code> is automatically closed. </p> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">// test.d
void main(string[] args)
{
    auto f = File("test.txt", "w"); // open for writing
    f.write("Hello");
    if (args.length &gt; 1)
    {
        auto g = f; // now g and f write to the same file
                    // internal reference count is 2
        g.write(", ", args[1]);
        // g exits scope, reference count decreases to 1
    }
    f.writeln("!");
    // f exits scope, reference count falls to zero,
    // underlying `FILE*` is closed.
}
</pre> <pre>% rdmd test.d Jimmy
% cat test.txt
Hello, Jimmy!
% _
</pre> <dl>
<dt class="d_decl" id="File.this">@safe this(string name, in char[] stdioOpenmode = "rb")<br>this(R1, R2)(R1 name)<br>this(R1, R2)(R1 name, R2 mode)<br><br>  Constraints:<br>    if (isInputRange!R1 &amp;&amp; isSomeChar!(ElementEncodingType!R1))<br>    if (isInputRange!R1 &amp;&amp; isSomeChar!(ElementEncodingType!R1) &amp;&amp; isInputRange!R2 &amp;&amp; isSomeChar!(ElementEncodingType!R2))</dt> <dd>
<p>Constructor taking the <code>name</code> of the file to open and the open <code>mode</code>. </p>
<p>Copying one <code>File</code> object to another results in the two <code>File</code> objects referring to the same underlying file. <br><br> The destructor automatically closes the file as soon as no <code>File</code> object refers to it anymore. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>string <code>name</code>
</td> <td>range or string representing the file name</td>
</tr> <tr>
<td>char[] <code>stdioOpenmode</code>
</td> <td>range or string represting the open <code>mode</code> (with the same semantics as in the C standard library <a href="http://cplusplus.com/reference/clibrary/cstdio/fopen.html" target="_blank">fopen</a> function)</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<code>ErrnoException</code> if the file could not be opened.</dd>
</dl> </dd> <dt class="d_decl" id="File.opAssign">@safe void opAssign(File rhs)</dt> <dd>
<p>Assigns a file to another. The target of the assignment gets detached from whatever file it was attached to, and attaches itself to the new file.</p> </dd> <dt class="d_decl" id="File.open">@safe void open(string name, in char[] stdioOpenmode = "rb")</dt> <dd>
<p>First calls <code>detach</code> (throwing on failure), and then attempts to open file <code>name</code> with mode <code>stdioOpenmode</code>. The mode has the same semantics as in the C standard library <a href="http://cplusplus.com/reference/clibrary/cstdio/fopen.html" target="_blank">fopen</a> function. </p>
<dl>
<dt>Throws:</dt>
<dd>
<code>ErrnoException</code> in case of error.</dd>
</dl> </dd> <dt class="d_decl" id="File.reopen">@trusted void reopen(string name, in char[] stdioOpenmode = "rb")</dt> <dd>
<p>Reuses the <code>File</code> object to either open a different file, or change the file mode. If <code>name</code> is <code>null</code>, the mode of the currently open file is changed; otherwise, a new file is opened, reusing the C <code>FILE*</code>. The function has the same semantics as in the C standard library <a href="http://cplusplus.com/reference/cstdio/freopen/" target="_blank">freopen</a> function. </p>
<dl>
<dt>Note</dt>
<dd> Calling <code>reopen</code> with a <code>null</code> <code>name</code> is not implemented in all C runtimes. </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<code>ErrnoException</code> in case of error.</dd>
</dl> </dd> <dt class="d_decl" id="File.popen">@safe void popen(string command, in char[] stdioOpenmode = "r")</dt> <dd>
<p>First calls <code>detach</code> (throwing on failure), and then runs a <code>command</code> by calling the C standard library function <a href="http://opengroup.org/onlinepubs/007908799/xsh/popen.html" target="_blank">popen</a>. </p>
<dl>
<dt>Throws:</dt>
<dd>
<code>ErrnoException</code> in case of error.</dd>
</dl> </dd> <dt class="d_decl" id="File.fdopen">@safe void fdopen(int fd, in char[] stdioOpenmode = "rb")</dt> <dd>
<p>First calls <code>detach</code> (throwing on failure), and then attempts to associate the given file descriptor with the <code>File</code>. The mode must be compatible with the mode of the file descriptor. </p>
<dl>
<dt>Throws:</dt>
<dd>
<code>ErrnoException</code> in case of error.</dd>
</dl> </dd> <dt class="d_decl" id="File.windowsHandleOpen">void windowsHandleOpen(HANDLE handle, in char[] stdioOpenmode)</dt> <dd>
<p>First calls <code>detach</code> (throwing on failure), and then attempts to associate the given Windows <code>HANDLE</code> with the <code>File</code>. The mode must be compatible with the access attributes of the <code>handle</code>. Windows only. </p>
<dl>
<dt>Throws:</dt>
<dd>
<code>ErrnoException</code> in case of error.</dd>
</dl> </dd> <dt class="d_decl" id="File.isOpen">const pure nothrow @property @safe bool isOpen()</dt> <dd>
<p>Returns <code>true</code> if the file is opened.</p> </dd> <dt class="d_decl" id="File.eof">const pure @property @trusted bool eof()</dt> <dd>
<p>Returns <code>true</code> if the file is at end (see <a href="http://cplusplus.com/reference/clibrary/cstdio/feof.html" target="_blank">feof</a>). </p>
<dl>
<dt>Throws:</dt>
<dd>
<code>Exception</code> if the file is not opened.</dd>
</dl> </dd> <dt class="d_decl" id="File.name">const pure nothrow @property @safe string name()</dt> <dd>
<p>Returns the <code>name</code> of the last opened file, if any. If a <code>File</code> was created with <a href="#tmpfile"><code>tmpfile</code></a> and <a href="#wrapFile"><code>wrapFile</code></a> it has no <code>name</code>.</p> </dd> <dt class="d_decl" id="File.error">const pure nothrow @property @trusted bool error()</dt> <dd>
<p>If the file is not opened, returns <code>true</code>. Otherwise, returns <a href="http://cplusplus.com/reference/clibrary/cstdio/ferror.html" target="_blank">ferror</a> for the file handle.</p> </dd> <dt class="d_decl" id="File.detach">@safe void detach()</dt> <dd>
<p>Detaches from the underlying file. If the sole owner, calls <code>close</code>. </p>
<dl>
<dt>Throws:</dt>
<dd>
<code>ErrnoException</code> on failure if closing the file.</dd>
</dl> </dd> <dt class="d_decl" id="File.close">@trusted void close()</dt> <dd>
<p>If the file was unopened, succeeds vacuously. Otherwise closes the file (by calling <a href="http://cplusplus.com/reference/clibrary/cstdio/fclose.html" target="_blank">fclose</a>), throwing on error. Even if an exception is thrown, afterwards the <code>File</code> object is empty. This is different from <code>detach</code> in that it always closes the file; consequently, all other <code>File</code> objects referring to the same handle will see a closed file henceforth. </p>
<dl>
<dt>Throws:</dt>
<dd>
<code>ErrnoException</code> on error.</dd>
</dl> </dd> <dt class="d_decl" id="File.clearerr">pure nothrow @safe void clearerr()</dt> <dd>
<p>If the file is not opened, succeeds vacuously. Otherwise, returns <a href="http://cplusplus.com/reference/clibrary/cstdio/clearerr.html" target="_blank">clearerr</a> for the file handle.</p> </dd> <dt class="d_decl" id="File.flush">@trusted void flush()</dt> <dd>
<p>Flushes the C <code>FILE</code> buffers. </p>
<p>Calls <a href="http://cplusplus.com/reference/clibrary/cstdio/fflush.html" target="_blank">fflush</a> for the file handle. </p> <dl>
<dt>Throws:</dt>
<dd>
<code>Exception</code> if the file is not opened or if the call to <code>fflush</code> fails.</dd>
</dl> </dd> <dt class="d_decl" id="File.sync">@trusted void sync()</dt> <dd>
<p>Forces any data buffered by the OS to be written to disk. Call <a href="#flush"><code>flush</code></a> before calling this function to flush the C <code>FILE</code> buffers first. </p>
<p>This function calls <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/aa364439%28v=vs.85%29.aspx" target="_blank"><code>FlushFileBuffers</code></a> on Windows and <a href="http://pubs.opengroup.org/onlinepubs/7908799/xsh/fsync.html" target="_blank"><code>fsync</code></a> on POSIX for the file handle. </p> <dl>
<dt>Throws:</dt>
<dd>
<code>Exception</code> if the file is not opened or if the OS call fails.</dd>
</dl> </dd> <dt class="d_decl" id="File.rawRead">T[] rawRead(T)(T[] buffer)</dt> <dd>
<p>Calls <a href="http://cplusplus.com/reference/clibrary/cstdio/fread.html" target="_blank">fread</a> for the file handle. The number of items to read and the size of each item is inferred from the size and type of the input array, respectively. </p>
<dl>
<dt>Returns:</dt>
<dd>The slice of <code>buffer</code> containing the data that was actually read. This will be shorter than <code>buffer</code> if EOF was reached before the <code>buffer</code> could be filled. </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<code>Exception</code> if <code>buffer</code> is empty. <code>ErrnoException</code> if the file is not opened or the call to <code>fread</code> fails.  <code>rawRead</code> always reads in binary mode on Windows.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static import std.file;

auto testFile = testFilename();
std.file.write(testFile, "\r\n\n\r\n");
scope(exit) std.file.remove(testFile);

auto f = File(testFile, "r");
auto buf = f.rawRead(new char[5]);
f.close();
writeln(buf); // "\r\n\n\r\n"
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="File.rawWrite">void rawWrite(T)(in T[] buffer)</dt> <dd>
<p>Calls <a href="http://cplusplus.com/reference/clibrary/cstdio/fwrite.html" target="_blank">fwrite</a> for the file handle. The number of items to write and the size of each item is inferred from the size and type of the input array, respectively. An error is thrown if the <code>buffer</code> could not be written in its entirety. </p>
<p><code>rawWrite</code> always writes in binary mode on Windows. </p> <dl>
<dt>Throws:</dt>
<dd>
<code>ErrnoException</code> if the file is not opened or if the call to <code>fwrite</code> fails.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static import std.file;

auto testFile = testFilename();
auto f = File(testFile, "w");
scope(exit) std.file.remove(testFile);

f.rawWrite("\r\n\n\r\n");
f.close();
writeln(std.file.read(testFile)); // "\r\n\n\r\n"
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="File.seek">@trusted void seek(long offset, int origin = SEEK_SET)</dt> <dd>
<p>Calls <a href="http://cplusplus.com/reference/clibrary/cstdio/fseek.html" target="_blank">fseek</a> for the file handle. </p>
<dl>
<dt>Throws:</dt>
<dd>
<code>Exception</code> if the file is not opened. <code>ErrnoException</code> if the call to <code>fseek</code> fails.</dd>
</dl> </dd> <dt class="d_decl" id="File.tell">const @property @trusted ulong tell()</dt> <dd>
<p>Calls <a href="http://cplusplus.com/reference/clibrary/cstdio/ftell.html" target="_blank">ftell</a> for the managed file handle. </p>
<dl>
<dt>Throws:</dt>
<dd>
<code>Exception</code> if the file is not opened. <code>ErrnoException</code> if the call to <code>ftell</code> fails.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.conv : text;
static import std.file;

auto testFile = testFilename();
std.file.write(testFile, "abcdefghijklmnopqrstuvwqxyz");
scope(exit) { std.file.remove(testFile); }

auto f = File(testFile);
auto a = new ubyte[4];
f.rawRead(a);
writeln(f.tell); // 4
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="File.rewind">@safe void rewind()</dt> <dd>
<p>Calls <a href="http://cplusplus.com/reference/clibrary/cstdio/rewind.html" target="_blank">rewind</a> for the file handle. </p>
<dl>
<dt>Throws:</dt>
<dd>
<code>Exception</code> if the file is not opened.</dd>
</dl> </dd> <dt class="d_decl" id="File.setvbuf">@trusted void setvbuf(size_t size, int mode = _IOFBF)</dt> <dd>
<p>Calls <a href="http://cplusplus.com/reference/clibrary/cstdio/setvbuf.html" target="_blank">setvbuf</a> for the file handle. </p>
<dl>
<dt>Throws:</dt>
<dd>
<code>Exception</code> if the file is not opened. <code>ErrnoException</code> if the call to <code>setvbuf</code> fails.</dd>
</dl> </dd> <dt class="d_decl" id="File.setvbuf.2">@trusted void setvbuf(void[] buf, int mode = _IOFBF)</dt> <dd>
<p>Calls <a href="http://cplusplus.com/reference/clibrary/cstdio/setvbuf.html" target="_blank">setvbuf</a> for the file handle. </p>
<dl>
<dt>Throws:</dt>
<dd>
<code>Exception</code> if the file is not opened. <code>ErrnoException</code> if the call to <code>setvbuf</code> fails.</dd>
</dl> </dd> <dt class="d_decl" id="File.lock">void lock(LockType lockType = LockType.readWrite, ulong start = 0, ulong length = 0)</dt> <dd>
<p>Locks the specified file segment. If the file segment is already locked by another process, waits until the existing <code>lock</code> is released. If both <code>start</code> and <code>length</code> are zero, the entire file is locked. </p>
<p>Locks created using <code>lock</code> and <code>tryLock</code> have the following properties: </p>
<ul> <li>All locks are automatically released when the process terminates.</li> <li>Locks are not inherited by child processes.</li> <li>Closing a file will release all locks associated with the file. On POSIX, even locks acquired via a different <code>File</code> will be released as well.</li> <li>Not all NFS implementations correctly implement file locking.</li> </ul> </dd> <dt class="d_decl" id="File.tryLock">bool tryLock(LockType lockType = LockType.readWrite, ulong start = 0, ulong length = 0)</dt> <dd>
<p>Attempts to lock the specified file segment. If both <code>start</code> and <code>length</code> are zero, the entire file is locked. </p>
<dl>
<dt>Returns:</dt>
<dd>
<code>true</code> if the lock was successful, and <code>false</code> if the specified file segment was already locked.</dd>
</dl> </dd> <dt class="d_decl" id="File.unlock">void unlock(ulong start = 0, ulong length = 0)</dt> <dd>
<p>Removes the lock over the specified file segment.</p> </dd> <dt class="d_decl" id="File.write">void write(S...)(S args)</dt> <dd>
<p>Writes its arguments in text format to the file. </p>
<dl>
<dt>Throws:</dt>
<dd>
<code>Exception</code> if the file is not opened. <code>ErrnoException</code> on an error writing to the file.</dd>
</dl> </dd> <dt class="d_decl" id="File.writeln">void writeln(S...)(S args)</dt> <dd>
<p>Writes its arguments in text format to the file, followed by a newline. </p>
<dl>
<dt>Throws:</dt>
<dd>
<code>Exception</code> if the file is not opened. <code>ErrnoException</code> on an error writing to the file.</dd>
</dl> </dd> <dt class="d_decl" id="File.writef">void writef(alias fmt, A...)(A args)<br>void writef(Char, A...)(in Char[] fmt, A args)<br><br>  Constraints:<br>    if (isSomeString!(typeof(fmt)))</dt> <dd>
<p>Writes its arguments in text format to the file, according to the format string <code>fmt</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Char[] <code>fmt</code>
</td> <td>The <a href="../std_format/#format-string">format string</a>. When passed as a compile-time argument, the string will be statically checked against the argument types passed.</td>
</tr> <tr>
<td>A <code>args</code>
</td> <td>Items to write.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<code>Exception</code> if the file is not opened. <code>ErrnoException</code> on an error writing to the file.</dd>
</dl> </dd> <dt class="d_decl" id="File.writefln">void writefln(alias fmt, A...)(A args)<br>void writefln(Char, A...)(in Char[] fmt, A args)<br><br>  Constraints:<br>    if (isSomeString!(typeof(fmt)))</dt> <dd>
<p>Equivalent to <code>file.writef(fmt, args, '\n')</code>.</p> </dd> <dt class="d_decl" id="File.readln">S readln(S = string)(dchar terminator = '\x0a')<br><br>  Constraints:<br>    if (isSomeString!S)</dt> <dd>
<p>Read line from the file handle and return it as a specified type. </p>
<p>This version manages its own read buffer, which means one memory allocation per call. If you are not retaining a reference to the read data, consider the <code>File.readln(buf)</code> version, which may offer better performance as it can reuse its read buffer. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>S</td> <td>Template parameter; the type of the allocated buffer, and the type returned. Defaults to <code>string</code>.</td>
</tr> <tr>
<td>dchar <code>terminator</code>
</td> <td>Line <code>terminator</code> (by default, <code>'\n'</code>).</td>
</tr> </table></dd>
</dl> <dl>
<dt>Note</dt>
<dd> String terminators are not supported due to ambiguity with <code>readln</code>(buf) below. </dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The line that was read, including the line <code>terminator</code> character. </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<code>StdioException</code> on I/O error, or <code>UnicodeException</code> on Unicode conversion error. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">// Reads `stdin` and writes it to `stdout`.
import std.stdio;

void main()
{
    string line;
    while ((line = stdin.readln()) !is null)
        write(line);
}
</pre>  </dd> <dt class="d_decl" id="File.readln.2">size_t readln(C)(ref C[] buf, dchar terminator = '\x0a')<br>size_t readln(C, R)(ref C[] buf, R terminator)<br><br>  Constraints:<br>    if (isSomeChar!C &amp;&amp; is(Unqual!C == C) &amp;&amp; !is(C == enum))<br>    if (isSomeChar!C &amp;&amp; is(Unqual!C == C) &amp;&amp; !is(C == enum) &amp;&amp; isBidirectionalRange!R &amp;&amp; is(typeof(terminator.front == (dchar).init)))</dt> <dd>
<p>Read line from the file handle and write it to <code>buf[]</code>, including terminating character. </p>
<p>This can be faster than <code>line = File.readln()</code> because you can reuse the buffer for each call. Note that reusing the buffer means that you must copy the previous contents if you wish to retain them. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>C[] <code>buf</code>
</td> <td>Buffer used to store the resulting line data. <code>buf</code> is resized as necessary.</td>
</tr> <tr>
<td>dchar <code>terminator</code>
</td> <td>Line <code>terminator</code> (by default, <code>'\n'</code>). Use <a href="../std_ascii/#newline"><code>std.ascii.newline</code></a> for portability (unless the file was opened in text mode).</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>0 for end of file, otherwise number of characters read </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<code>StdioException</code> on I/O error, or <code>UnicodeException</code> on Unicode conversion error. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">// Read lines from `stdin` into a string
// Ignore lines starting with '#'
// Write the string to `stdout`

void main()
{
    string output;
    char[] buf;

    while (stdin.readln(buf))
    {
        if (buf[0] == '#')
            continue;

        output ~= buf;
    }

    write(output);
}
</pre>  This method can be more efficient than the one in the previous example because <code>stdin.readln(buf)</code> reuses (if possible) memory allocated for <code>buf</code>, whereas <code>line = stdin.readln()</code> makes a new memory allocation for every line.  For even better performance you can help <code>readln</code> by passing in a large buffer to avoid memory reallocations. This can be done by reusing the largest buffer returned by <code>readln</code>:  <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">// Read lines from `stdin` and count words

void main()
{
    char[] buf;
    size_t words = 0;

    while (!stdin.eof)
    {
        char[] line = buf;
        stdin.readln(line);
        if (line.length &gt; buf.length)
            buf = line;

        words += line.split.length;
    }

    writeln(words);
}
</pre> This is actually what <a href="#byLine"><code>byLine</code></a> does internally, so its usage is recommended if you want to process a complete file. </dd> <dt class="d_decl" id="File.readf">uint readf(alias format, Data...)(auto ref Data data)<br>uint readf(Data...)(in char[] format, auto ref Data data)<br><br>  Constraints:<br>    if (isSomeString!(typeof(format)))</dt> <dd>
<p>Reads formatted data from the file using <a href="../std_format/#formattedRead"><code>std.format.formattedRead</code></a>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>char[] <code>format</code>
</td> <td>The <a href="../std_format/#format-string">format string</a>. When passed as a compile-time argument, the string will be statically checked against the argument types passed.</td>
</tr> <tr>
<td>Data <code>data</code>
</td> <td>Items to be read.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">// test.d
void main()
{
    import std.stdio;
    auto f = File("input");
    foreach (_; 0 .. 3)
    {
        int a;
        f.readf!" %d"(a);
        writeln(++a);
    }
}
</pre> <pre>% echo "1 2 3" &gt; input
% rdmd test.d
2
3
4
</pre> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static import std.file;

auto deleteme = testFilename();
std.file.write(deleteme, "hello\nworld\ntrue\nfalse\n");
scope(exit) std.file.remove(deleteme);
string s;
auto f = File(deleteme);
f.readf!"%s\n"(s);
writeln(s); // "hello"
f.readf("%s\n", s);
writeln(s); // "world"

bool b1, b2;
f.readf("%s\n%s\n", b1, b2);
assert(b1 == true &amp;&amp; b2 == false);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="File.tmpfile">static @safe File tmpfile()</dt> <dd>
<p>Returns a temporary file by calling <a href="http://cplusplus.com/reference/clibrary/cstdio/tmpfile.html" target="_blank">tmpfile</a>. Note that the created file has no <a href="#name"><code>name</code></a>.</p> </dd> <dt class="d_decl" id="File.wrapFile">static @safe File wrapFile(FILE* f)</dt> <dd>
<p>Unsafe function that wraps an existing <code>FILE*</code>. The resulting <code>File</code> never takes the initiative in closing the file. Note that the created file has no <a href="#name"><code>name</code></a></p> </dd> <dt class="d_decl" id="File.getFP">pure @safe FILE* getFP()</dt> <dd>
<p>Returns the <code>FILE*</code> corresponding to this object.</p> </dd> <dt class="d_decl" id="File.fileno">const @property @trusted int fileno()</dt> <dd>
<p>Returns the file number corresponding to this object.</p> </dd> <dt class="d_decl" id="File.windowsHandle">@property HANDLE windowsHandle()</dt> <dd>
<p>Returns the underlying operating system <code>HANDLE</code> (Windows only).</p> </dd> <dt class="d_decl" id="File.byLine">auto byLine(Terminator = char, Char = char)(KeepTerminator keepTerminator = No.keepTerminator, Terminator terminator = '\x0a')<br>auto byLine(Terminator, Char = char)(KeepTerminator keepTerminator, Terminator terminator)<br><br>  Constraints:<br>    if (isScalarType!Terminator)<br>    if (is(Unqual!(ElementEncodingType!Terminator) == Char))</dt> <dd>
<p>Returns an input range set up to read from the file handle one line at a time. </p>
<p>The element type for the range will be <code>Char[]</code>. Range primitives may throw <code>StdioException</code> on I/O error. </p> <dl>
<dt>Note</dt>
<dd> Each <code>front</code> will not persist after <code>popFront</code> is called, so the caller must copy its contents (e.g. by calling <code>to!string</code>) when retention is needed. If the caller needs to retain a copy of every line, use the <a href="#byLineCopy"><code>byLineCopy</code></a> function instead. </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Char</td> <td>Character type for each line, defaulting to <code>char</code>.</td>
</tr> <tr>
<td>KeepTerminator <code>keepTerminator</code>
</td> <td>Use <code>Yes.keepTerminator</code> to include the <code>terminator</code> at the end of each line.</td>
</tr> <tr>
<td>Terminator <code>terminator</code>
</td> <td>Line separator (<code>'\n'</code> by default). Use <a href="../std_ascii/#newline"><code>std.ascii.newline</code></a> for portability (unless the file was opened in text mode).</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">import std.algorithm, std.stdio, std.string;
// Count words in a file using ranges.
void main()
{
    auto file = File("file.txt"); // Open for reading
    const wordCount = file.byLine()            // Read lines
                          .map!split           // Split into words
                          .map!(a =&gt; a.length) // Count words per line
                          .sum();              // Total word count
    writeln(wordCount);
}
</pre>  <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">import std.range, std.stdio;
// Read lines using foreach.
void main()
{
    auto file = File("file.txt"); // Open for reading
    auto range = file.byLine();
    // Print first three lines
    foreach (line; range.take(3))
        writeln(line);
    // Print remaining lines beginning with '#'
    foreach (line; range)
    {
        if (!line.empty &amp;&amp; line[0] == '#')
            writeln(line);
    }
}
</pre> Notice that neither example accesses the line data returned by <code>front</code> after the corresponding <code>popFront</code> call is made (because the contents may well have changed). </dd> <dt class="d_decl" id="File.byLineCopy">auto byLineCopy(Terminator = char, Char = immutable(char))(KeepTerminator keepTerminator = No.keepTerminator, Terminator terminator = '\x0a')<br>auto byLineCopy(Terminator, Char = immutable(char))(KeepTerminator keepTerminator, Terminator terminator)<br><br>  Constraints:<br>    if (isScalarType!Terminator)<br>    if (is(Unqual!(ElementEncodingType!Terminator) == Unqual!Char))</dt> <dd>
<p>Returns an input range set up to read from the file handle one line at a time. Each line will be newly allocated. <code>front</code> will cache its value to allow repeated calls without unnecessary allocations. </p>
<dl>
<dt>Note</dt>
<dd> Due to caching <code>byLineCopy</code> can be more memory-efficient than <code>File.byLine.map!idup</code>. </dd>
</dl> The element type for the range will be <code>Char[]</code>. Range primitives may throw <code>StdioException</code> on I/O error.  <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Char</td> <td>Character type for each line, defaulting to <code>immutable char</code>.</td>
</tr> <tr>
<td>KeepTerminator <code>keepTerminator</code>
</td> <td>Use <code>Yes.keepTerminator</code> to include the <code>terminator</code> at the end of each line.</td>
</tr> <tr>
<td>Terminator <code>terminator</code>
</td> <td>Line separator (<code>'\n'</code> by default). Use <a href="../std_ascii/#newline"><code>std.ascii.newline</code></a> for portability (unless the file was opened in text mode).</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">import std.algorithm, std.array, std.stdio;
// Print sorted lines of a file.
void main()
{
    auto sortedLines = File("file.txt")   // Open for reading
                       .byLineCopy()      // Read persistent lines
                       .array()           // into an array
                       .sort();           // then sort them
    foreach (line; sortedLines)
        writeln(line);
}
</pre>  <dl>
<dt>See Also:</dt>
<dd><a href="../std_file/#readText"><code>std.file.readText</code></a></dd>
</dl> </dd> <dt class="d_decl" id="File.byRecord">ByRecord!Fields byRecord(Fields...)(string format)</dt> <dd>
<p>Creates an input range set up to parse one line at a time from the file into a tuple. </p>
<p>Range primitives may throw <code>StdioException</code> on I/O error. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>string <code>format</code>
</td> <td>tuple record <a href="../std_format/#formattedRead">format</a>
</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The input range set up to parse one line at a time into a record tuple. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>It is similar to <a href="#byLine"><code>byLine</code></a> and uses <a href="../std_format/#formattedRead">format</a> under the hood.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static import std.file;
import std.typecons : tuple;

// prepare test file
auto testFile = testFilename();
scope(failure) printf("Failed test at line %d\n", __LINE__);
std.file.write(testFile, "1 2\n4 1\n5 100");
scope(exit) std.file.remove(testFile);

File f = File(testFile);
scope(exit) f.close();

auto expected = [tuple(1, 2), tuple(4, 1), tuple(5, 100)];
uint i;
foreach (e; f.byRecord!(int, int)("%s %s"))
{
    writeln(e); // expected[i++]
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="File.byChunk">auto byChunk(size_t chunkSize)<br>ByChunk byChunk(ubyte[] buffer)</dt> <dd>
<p>Returns an input range set up to read from the file handle a chunk at a time. </p>
<p>The element type for the range will be <code>ubyte[]</code>. Range primitives may throw <code>StdioException</code> on I/O error. </p> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">void main()
{
    // Read standard input 4KB at a time
    foreach (ubyte[] buffer; stdin.byChunk(4096))
    {
        ... use buffer ...
    }
}
</pre>  The parameter may be a number (as shown in the example above) dictating the size of each chunk. Alternatively, <code>byChunk</code> accepts a user-provided <code>buffer</code> that it uses directly.  <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">void main()
{
    // Read standard input 4KB at a time
    foreach (ubyte[] buffer; stdin.byChunk(new ubyte[4096]))
    {
        ... use buffer ...
    }
}
</pre>  In either case, the content of the <code>buffer</code> is reused across calls. That means <code>front</code> will not persist after <code>popFront</code> is called, so if retention is needed, the caller must copy its contents (e.g. by calling <code>buffer.dup</code>).  In the example above, <code>buffer.length</code> is 4096 for all iterations, except for the last one, in which case <code>buffer.length</code> may be less than 4096 (but always greater than zero).  With the mentioned limitations, <code>byChunk</code> works with any algorithm compatible with input ranges.  <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">// Efficient file copy, 1MB at a time.
import std.algorithm, std.stdio;
void main()
{
    stdin.byChunk(1024 * 1024).copy(stdout.lockingTextWriter());
}
</pre>  <a href="../std_algorithm_iteration/#joiner"><code>std.algorithm.iteration.joiner</code></a> can be used to join chunks together into a single range lazily.  <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">import std.algorithm, std.stdio;
void main()
{
    //Range of ranges
    static assert(is(typeof(stdin.byChunk(4096).front) == ubyte[]));
    //Range of elements
    static assert(is(typeof(stdin.byChunk(4096).joiner.front) == ubyte));
}
</pre>  <dl>
<dt>Returns:</dt>
<dd>A call to <code>byChunk</code> returns a range initialized with the <code>File</code> object and the appropriate <code>buffer</code>. </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>If the user-provided size is zero or the user-provided <code>buffer</code> is empty, throws an <code>Exception</code>. In case of an I/O error throws <code>StdioException</code>.</dd>
</dl> </dd> <dt class="d_decl" id="File.lockingTextWriter">@safe auto lockingTextWriter()</dt> <dd>
<p>Returns an output range that locks the file and allows fast writing to it. </p>
<p>See <a href="#byChunk"><code>byChunk</code></a> for an example.</p> </dd> <dt class="d_decl" id="File.lockingBinaryWriter">auto lockingBinaryWriter()</dt> <dd>
<p>Returns an output range that locks the file and allows fast writing to it. </p>
<dl>
<dt>Example</dt>
<dd> Produce a grayscale image of the <a href="https://en.wikipedia.org/wiki/Mandelbrot_set" target="_blank">Mandelbrot set</a> in binary <a href="https://en.wikipedia.org/wiki/Netpbm_format" target="_blank">Netpbm format</a> to standard output. </dd>
</dl>
<pre data-language="d">import std.algorithm, std.range, std.stdio;

void main()
{
    enum size = 500;
    writef("P5\n%d %d %d\n", size, size, ubyte.max);

    iota(-1, 3, 2.0/size).map!(y =&gt;
        iota(-1.5, 0.5, 2.0/size).map!(x =&gt;
            cast(ubyte)(1+
                recurrence!((a, n) =&gt; x + y*1i + a[n-1]^^2)(0+0i)
                .take(ubyte.max)
                .countUntil!(z =&gt; z.re^^2 + z.im^^2 &gt; 4))
        )
    )
    .copy(stdout.lockingBinaryWriter);
}
</pre>  </dd> <dt class="d_decl" id="File.size">@property @safe ulong size()</dt> <dd>
<p>Get the <code>size</code> of the file, ulong.max if file is not searchable, but still throws if an actual error occurs.</p> </dd> </dl> </dd> <dt class="d_decl" id="LockType">enum LockType: int</dt> <dd>
<p>Used to specify the lock type for <code>File.lock</code> and <code>File.tryLock</code>.</p> <dl>
<dt class="d_decl" id="LockType.read">read</dt> <dd>
<p>Specifies a read (shared) lock. A read lock denies all processes write access to the specified region of the file, including the process that first locks the region. All processes can read the locked region. Multiple simultaneous read locks are allowed, as long as there are no exclusive locks.</p> </dd> <dt class="d_decl" id="LockType.readWrite">readWrite</dt> <dd>
<p>Specifies a read/write (exclusive) lock. A read/write lock denies all other processes both read and write access to the locked file region. If a segment has an exclusive lock, it may not have any shared locks or other exclusive locks.</p> </dd> </dl> </dd> <dt class="d_decl" id="isFileHandle">enum auto isFileHandle(T)</dt> <dd>
<p>Indicates whether <code>T</code> is a file handle, i.e. the type is implicitly convertable to <a href="#File"><code>File</code></a> or a pointer to a <a href="../core_stdc_stdio/#FILE"><code>core.stdc.stdio.FILE</code></a>. </p>
<dl>
<dt>Returns:</dt>
<dd>
<code>true</code> if <code>T</code> is a file handle, <code>false</code> otherwise.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">static assert(isFileHandle!(FILE*));
static assert(isFileHandle!(File));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="write">void write(T...)(T args)<br><br>  Constraints:<br>    if (!is(T[0] : File))</dt> <dd>
<p>For each argument <code>arg</code> in <code>args</code>, format the argument (using <a href="../std_conv/#to"><code>std.conv.to</code></a>) and <code>write</code> the resulting string to <code>args[0]</code>. A call without any arguments will fail to compile. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T <code>args</code>
</td> <td>the items to <code>write</code> to <code>stdout</code>
</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>In case of an I/O error, throws an <code>StdioException</code>. </dd>
</dl> <dl>
<dt>Example</dt>
<dd> Reads <code>stdin</code> and writes it to <code>stdout</code> with an argument counter. </dd>
</dl>
<pre data-language="d">import std.stdio;

void main()
{
    string line;

    for (size_t count = 0; (line = readln) !is null; count++)
    {
         write("Input ", count, ": ", line, "\n");
    }
}
</pre>  </dd> <dt class="d_decl" id="writeln">void writeln(T...)(T args)</dt> <dd>
<p>Equivalent to <code>write(args, '\n')</code>. Calling <code>writeln</code> without arguments is valid and just prints a newline to the standard output. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>T <code>args</code>
</td> <td>the items to write to <code>stdout</code>
</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>In case of an I/O error, throws an <a href="#StdioException"><code>StdioException</code></a>. </dd>
</dl> <dl>
<dt>Example</dt>
<dd> Reads <code>stdin</code> and writes it to <code>stdout</code> with a argument counter. </dd>
</dl>
<pre data-language="d">import std.stdio;

void main()
{
    string line;

    for (size_t count = 0; (line = readln) !is null; count++)
    {
         writeln("Input ", count, ": ", line);
    }
}
</pre>  </dd> <dt class="d_decl" id="writef">void writef(alias fmt, A...)(A args)<br>void writef(Char, A...)(in Char[] fmt, A args)<br><br>  Constraints:<br>    if (isSomeString!(typeof(fmt)))</dt> <dd>
<p>Writes formatted data to standard output (without a trailing newline). </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Char[] <code>fmt</code>
</td> <td>The <a href="../std_format/#format-string">format string</a>. When passed as a compile-time argument, the string will be statically checked against the argument types passed.</td>
</tr> <tr>
<td>A <code>args</code>
</td> <td>Items to write.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Note</dt>
<dd> In older versions of Phobos, it used to be possible to write: </dd>
</dl> <pre data-language="d">writef(stderr, "%s", "message");
</pre>  to print a message to <code>stderr</code>. This syntax is no longer supported, and has been superceded by:  <pre data-language="d">stderr.writef("%s", "message");
</pre>  </dd> <dt class="d_decl" id="writefln">void writefln(alias fmt, A...)(A args)<br>void writefln(Char, A...)(in Char[] fmt, A args)<br><br>  Constraints:<br>    if (isSomeString!(typeof(fmt)))</dt> <dd>
<p>Equivalent to <code>writef(fmt, args, '\n')</code>.</p> </dd> <dt class="d_decl" id="readf">uint readf(alias format, A...)(auto ref A args)<br>uint readf(A...)(in char[] format, auto ref A args)<br><br>  Constraints:<br>    if (isSomeString!(typeof(format)))</dt> <dd>
<p>Reads formatted data from <code>stdin</code> using <a href="../std_format/#formattedRead"><code>std.format.formattedRead</code></a>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>char[] <code>format</code>
</td> <td>The <a href="../std_format/#format-string">format string</a>. When passed as a compile-time argument, the string will be statically checked against the argument types passed.</td>
</tr> <tr>
<td>A <code>args</code>
</td> <td>Items to be read.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">// test.d
void main()
{
    import std.stdio;
    foreach (_; 0 .. 3)
    {
        int a;
        readf!" %d"(a);
        writeln(++a);
    }
}
</pre> <pre>% echo "1 2 3" | rdmd test.d
2
3
4
</pre> </dd> <dt class="d_decl" id="readln">S readln(S = string)(dchar terminator = '\x0a')<br><br>  Constraints:<br>    if (isSomeString!S)</dt> <dd>
<p>Read line from <code>stdin</code>. </p>
<p>This version manages its own read buffer, which means one memory allocation per call. If you are not retaining a reference to the read data, consider the <code>readln(buf)</code> version, which may offer better performance as it can reuse its read buffer. </p> <dl>
<dt>Returns:</dt>
<dd>The line that was read, including the line <code>terminator</code> character. </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>S</td> <td>Template parameter; the type of the allocated buffer, and the type returned. Defaults to <code>string</code>.</td>
</tr> <tr>
<td>dchar <code>terminator</code>
</td> <td>Line <code>terminator</code> (by default, <code>'\n'</code>).</td>
</tr> </table></dd>
</dl> <dl>
<dt>Note</dt>
<dd> String terminators are not supported due to ambiguity with <code>readln</code>(buf) below. </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<code>StdioException</code> on I/O error, or <code>UnicodeException</code> on Unicode conversion error. </dd>
</dl> <dl>
<dt>Example</dt>
<dd> Reads <code>stdin</code> and writes it to <code>stdout</code>. </dd>
</dl>
<pre data-language="d">import std.stdio;

void main()
{
    string line;
    while ((line = readln()) !is null)
        write(line);
}
</pre>  </dd> <dt class="d_decl" id="readln.2">size_t readln(C)(ref C[] buf, dchar terminator = '\x0a')<br>size_t readln(C, R)(ref C[] buf, R terminator)<br><br>  Constraints:<br>    if (isSomeChar!C &amp;&amp; is(Unqual!C == C) &amp;&amp; !is(C == enum))<br>    if (isSomeChar!C &amp;&amp; is(Unqual!C == C) &amp;&amp; !is(C == enum) &amp;&amp; isBidirectionalRange!R &amp;&amp; is(typeof(terminator.front == (dchar).init)))</dt> <dd>
<p>Read line from <code>stdin</code> and write it to <code>buf</code>[], including terminating character. </p>
<p>This can be faster than <code>line = readln()</code> because you can reuse the buffer for each call. Note that reusing the buffer means that you must copy the previous contents if you wish to retain them. </p> <dl>
<dt>Returns:</dt>
<dd>
<code>size_t</code> 0 for end of file, otherwise number of characters read </dd>
</dl> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>C[] <code>buf</code>
</td> <td>Buffer used to store the resulting line data. <code>buf</code> is resized as necessary.</td>
</tr> <tr>
<td>dchar <code>terminator</code>
</td> <td>Line <code>terminator</code> (by default, <code>'\n'</code>). Use <a href="../std_ascii/#newline"><code>std.ascii.newline</code></a> for portability (unless the file was opened in text mode).</td>
</tr> </table></dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<code>StdioException</code> on I/O error, or <code>UnicodeException</code> on Unicode conversion error. </dd>
</dl> <dl>
<dt>Example</dt>
<dd> Reads <code>stdin</code> and writes it to <code>stdout</code>. </dd>
</dl>
<pre data-language="d">import std.stdio;

void main()
{
    char[] buf;
    while (readln(buf))
        write(buf);
}
</pre>  </dd> <dt class="d_decl" id="popen">nothrow @nogc @trusted FILE* popen(R1, R2)(R1 name, R2 mode = "r")<br><br>  Constraints:<br>    if ((isInputRange!R1 &amp;&amp; isSomeChar!(ElementEncodingType!R1) || isSomeString!R1) &amp;&amp; (isInputRange!R2 &amp;&amp; isSomeChar!(ElementEncodingType!R2) || isSomeString!R2))</dt> <dd>
<p>Convenience function that forwards to <code>core.sys.posix.stdio.popen</code> with appropriately-constructed C-style strings.</p> </dd> <dt class="d_decl" id="lines">struct lines</dt> <dd>
<p>Iterates through the <code>lines</code> of a file by using <code>foreach</code>. </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">void main()
{
  foreach (string line; lines(stdin))
  {
    ... use line ...
  }
}
</pre> The line terminator (<code>'\n'</code> by default) is part of the string read (it could be missing in the last line of the file). Several types are supported for <code>line</code>, and the behavior of <code>lines</code> changes accordingly:  <ol>
<li>If <code>line</code> has type <code>string</code>, <code>wstring</code>, or <code>dstring</code>, a new string of the respective type is allocated every read.</li> <li>If <code>line</code> has type <code>char[]</code>, <code>wchar[]</code>, <code>dchar[]</code>, the line's content will be reused (overwritten) across reads.</li> <li>If <code>line</code> has type <code>immutable(ubyte)[]</code>, the behavior is similar to case (1), except that no UTF checking is attempted upon input.</li> <li>If <code>line</code> has type <code>ubyte[]</code>, the behavior is similar to case (2), except that no UTF checking is attempted upon input.</li>
</ol>  In all cases, a two-symbols versions is also accepted, in which case the first symbol (of integral type, e.g. <code>ulong</code> or <code>uint</code>) tracks the zero-based number of the current line.  <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">  foreach (ulong i, string line; lines(stdin))
  {
    ... use line ...
  }
</pre>  In case of an I/O error, an <code>StdioException</code> is thrown.  <dl>
<dt>See Also:</dt>
<dd><a href="#byLine"><code>byLine</code></a></dd>
</dl> <dl>
<dt class="d_decl" id="lines.this">this(File f, dchar terminator = '\x0a')</dt> <dd>
<p>Constructor. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>File <code>f</code>
</td> <td>File to read lines from.</td>
</tr> <tr>
<td>dchar <code>terminator</code>
</td> <td>Line separator (<code>'\n'</code> by default).</td>
</tr> </table></dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="chunks">auto chunks(File f, size_t size)</dt> <dd>
<p>Iterates through a file a chunk at a time by using <code>foreach</code>. </p>
<dl>
<dt>Example</dt>

</dl>
<pre data-language="d">void main()
{
    foreach (ubyte[] buffer; chunks(stdin, 4096))
    {
        ... use buffer ...
    }
}
</pre>  The content of <code>buffer</code> is reused across calls. In the example above, <code>buffer.length</code> is 4096 for all iterations, except for the last one, in which case <code>buffer.length</code> may be less than 4096 (but always greater than zero).  In case of an I/O error, an <code>StdioException</code> is thrown. </dd> <dt class="d_decl" id="toFile">void toFile(T)(T data, string fileName)<br><br>  Constraints:<br>    if (is(typeof(copy(data, stdout.lockingBinaryWriter))))</dt> <dd>
<p>Writes an array or range to a file. Shorthand for <code>data.copy(File(fileName, "wb").lockingBinaryWriter)</code>. Similar to <a href="../std_file/#write"><code>std.file.write</code></a>, strings are written as-is, rather than encoded according to the <code>File</code>'s <a href="http://en.cppreference.com/w/c/io#Narrow_and_wide_orientation" target="_blank">orientation</a>.</p> </dd> <dt class="d_decl" id="StdioException">class StdioException: object.Exception</dt> <dd>
<p>Thrown if I/O errors happen.</p> <dl>
<dt class="d_decl" id="StdioException.errno">uint errno</dt> <dd>
<p>Operating system error code.</p> </dd> <dt class="d_decl" id="StdioException.this">@trusted this(string message, uint e = core.stdc.errno.errno)</dt> <dd>
<p>Initialize with a <code>message</code> and an error code.</p> </dd> <dt class="d_decl" id="StdioException.opCall">static void opCall(string msg)<br>static void opCall()</dt> <dd>
<p>Convenience functions that throw an <code>StdioException</code>.</p> </dd> </dl> </dd> <dt class="d_decl" id="stdin">alias stdin = makeGlobal!(stdin).makeGlobal</dt> <dd>
<p>The standard input stream. </p>
<dl>
<dt>Bugs:</dt>
<dd>Due to <a href="https://issues.dlang.org/show_bug.cgi?id=15768" target="_blank">bug 15768</a>, it is thread un-safe to reassign <code>stdin</code> to a different <code>File</code> instance than the default.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">// Read stdin, sort lines, write to stdout
import std.algorithm.mutation : copy;
import std.algorithm.sorting : sort;
import std.array : array;
import std.typecons : Yes;

void main() {
    stdin                       // read from stdin
    .byLineCopy(Yes.keepTerminator) // copying each line
    .array()                    // convert to array of lines
    .sort()                     // sort the lines
    .copy(                      // copy output of .sort to an OutputRange
        stdout.lockingTextWriter()); // the OutputRange
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="stdout">alias stdout = makeGlobal!(stdout).makeGlobal</dt> <dd>
<p>The standard output stream. </p>
<dl>
<dt>Bugs:</dt>
<dd>Due to <a href="https://issues.dlang.org/show_bug.cgi?id=15768" target="_blank">bug 15768</a>, it is thread un-safe to reassign <code>stdout</code> to a different <code>File</code> instance than the default.</dd>
</dl> </dd> <dt class="d_decl" id="stderr">alias stderr = makeGlobal!(stderr).makeGlobal</dt> <dd>
<p>The standard error stream. </p>
<dl>
<dt>Bugs:</dt>
<dd>Due to <a href="https://issues.dlang.org/show_bug.cgi?id=15768" target="_blank">bug 15768</a>, it is thread un-safe to reassign <code>stderr</code> to a different <code>File</code> instance than the default.</dd>
</dl> </dd> <dt class="d_decl" id="openNetwork">File openNetwork(string host, ushort port)</dt> <dd>
<p>Experimental network access via the File interface </p>
<p>Opens a TCP connection to the given <code>host</code> and <code>port</code>, then returns a File struct with read and write access through the same interface as any other file (meaning writef and the byLine ranges work!). </p> <dl>
<dt>Authors:</dt>
<dd>Adam D. Ruppe </dd>
</dl> <dl>
<dt>Bugs:</dt>
<dd>Only works on Linux</dd>
</dl> </dd> </dl>
<div class="_attribution">
  <p class="_attribution-p">
    Â© 1999â2017 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/phobos/std_stdio.html" class="_attribution-link" target="_blank">https://dlang.org/phobos/std_stdio.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
