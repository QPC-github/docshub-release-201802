
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>std.path - D - W3cubDocs</title>
  
  <meta name="description" content=" This module is used to manipulate path strings. ">
  <meta name="keywords" content="std, path, -, d">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/d/std_path/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-e0f881b0fce8cbe96f33dadc355b7159d5d2912911231446d60eb8f9caffa802.css">
  <script type="text/javascript" src="/assets/application-8fc46316434047265cd383f02b8e7f434ed7dec4a59f920dd633deef8d488d1b.js"></script>
  <script src="/json/d.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/d/" class="_nav-link" title="" style="margin-left:0;">D</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _d">
				
<h1>std.path</h1>  <p>This module is used to manipulate path strings. </p>
<p>All functions, with the exception of <a href="#expandTilde"><code>expandTilde</code></a> (and in some cases <a href="#absolutePath"><code>absolutePath</code></a> and <a href="#relativePath"><code>relativePath</code></a>), are pure string manipulation functions; they don't depend on any state outside the program, nor do they perform any actual file system actions. This has the consequence that the module does not make any distinction between a path that points to a directory and a path that points to a file, and it does not know whether or not the object pointed to by the path actually exists in the file system. To differentiate between these cases, use <a href="../std_file/#isDir"><code>std.file.isDir</code></a> and <a href="../std_file/#exists"><code>std.file.exists</code></a>. <br><br> Note that on Windows, both the backslash (<code>\</code>) and the slash (<code>/</code>) are in principle valid directory separators. This module treats them both on equal footing, but in cases where a <i>new</i> separator is added, a backslash will be used. Furthermore, the <a href="#buildNormalizedPath"><code>buildNormalizedPath</code></a> function will replace all slashes with backslashes on that platform. <br><br> In general, the functions in this module assume that the input paths are well-formed. (That is, they should not contain invalid characters, they should follow the file system's path format, etc.) The result of calling a function on an ill-formed path is undefined. When there is a chance that a path or a file name is invalid (for instance, when it has been input by the user), it may sometimes be desirable to use the <a href="#isValidFilename"><code>isValidFilename</code></a> and <a href="#isValidPath"><code>isValidPath</code></a> functions to check this. <br><br> Most functions do not perform any memory allocations, and if a string is returned, it is usually a slice of an input string. If a function allocates, this is explicitly mentioned in the documentation. <br><br>  </p>
<table>

<tr>
<th scope="col">Category</th> <th scope="col">Functions</th>
</tr> <tr>
<td>Normalization</td> <td> <a href="#absolutePath"><code>absolutePath</code></a> <a href="#asAbsolutePath"><code>asAbsolutePath</code></a> <a href="#asNormalizedPath"><code>asNormalizedPath</code></a> <a href="#asRelativePath"><code>asRelativePath</code></a> <a href="#buildNormalizedPath"><code>buildNormalizedPath</code></a> <a href="#buildPath"><code>buildPath</code></a> <a href="#chainPath"><code>chainPath</code></a> <a href="#expandTilde"><code>expandTilde</code></a> </td>
</tr> <tr>
<td>Partitioning</td> <td> <a href="#baseName"><code>baseName</code></a> <a href="#dirName"><code>dirName</code></a> <a href="#dirSeparator"><code>dirSeparator</code></a> <a href="#driveName"><code>driveName</code></a> <a href="#pathSeparator"><code>pathSeparator</code></a> <a href="#pathSplitter"><code>pathSplitter</code></a> <a href="#relativePath"><code>relativePath</code></a> <a href="#rootName"><code>rootName</code></a> <a href="#stripDrive"><code>stripDrive</code></a> </td>
</tr> <tr>
<td>Validation</td> <td> <a href="#isAbsolute"><code>isAbsolute</code></a> <a href="#isDirSeparator"><code>isDirSeparator</code></a> <a href="#isRooted"><code>isRooted</code></a> <a href="#isValidFilename"><code>isValidFilename</code></a> <a href="#isValidPath"><code>isValidPath</code></a> </td>
</tr> <tr>
<td>Extension</td> <td> <a href="#defaultExtension"><code>defaultExtension</code></a> <a href="#extension"><code>extension</code></a> <a href="#setExtension"><code>setExtension</code></a> <a href="#stripExtension"><code>stripExtension</code></a> <a href="#withDefaultExtension"><code>withDefaultExtension</code></a> <a href="#withExtension"><code>withExtension</code></a> </td>
</tr> <tr>
<td>Other</td> <td> <a href="#filenameCharCmp"><code>filenameCharCmp</code></a> <a href="#filenameCmp"><code>filenameCmp</code></a> <a href="#globMatch"><code>globMatch</code></a> <a href="#CaseSensitive"><code>CaseSensitive</code></a> </td>
</tr> </table>  <dl>
<dt>Authors:</dt>
<dd>Lars Tandle Kyllingstad, <a href="http://digitalmars.com" target="_blank">Walter Bright</a>, Grzegorz Adam Hankiewicz, Thomas KÃ¼hne, <a href="http://erdani.org" target="_blank">Andrei Alexandrescu</a> </dd>
</dl> <dl>
<dt>License:</dt>
<dd>
<a href="http://boost.org/LICENSE_1_0.txt" target="_blank">Boost License 1.0</a> </dd>
</dl> <dl>
<dt>Source</dt>
<dd> <span class="phobos_src"><a class="https" href="https://github.com/dlang/phobos/blob/master/std/path.d" target="_blank">std/path.d</a></span>
</dd>
</dl> <dl>
<dt class="d_decl" id="dirSeparator">enum string dirSeparator</dt> <dd>
<p>String used to separate directory names in a path. Under POSIX this is a slash, under Windows a backslash.</p> </dd> <dt class="d_decl" id="pathSeparator">enum string pathSeparator</dt> <dd>
<p>Path separator string. A colon under POSIX, a semicolon under Windows.</p> </dd> <dt class="d_decl" id="isDirSeparator">pure nothrow @nogc @safe bool isDirSeparator(dchar c)</dt> <dd>
<p>Determines whether the given character is a directory separator. </p>
<p>On Windows, this includes both <code>\</code> and <code>/</code>. On POSIX, it's just <code>/</code>.</p> </dd> <dt class="d_decl" id="CaseSensitive">enum CaseSensitive: bool</dt> <dd>
<p>This <code>enum</code> is used as a template argument to functions which compare file names, and determines whether the comparison is case sensitive or not.</p> <dl>
<dt class="d_decl" id="CaseSensitive.no">no</dt> <dd>
<p>File names are case insensitive</p> </dd> <dt class="d_decl" id="CaseSensitive.yes">yes</dt> <dd>
<p>File names are case sensitive</p> </dd> <dt class="d_decl" id="CaseSensitive.osDefault">osDefault</dt> <dd>
<p>The default (or most common) setting for the current platform. That is, <code>no</code> on Windows and Mac OS X, and <code>yes</code> on all POSIX systems except OS X (Linux, *BSD, etc.).</p> </dd> </dl> </dd> <dt class="d_decl" id="baseName">auto baseName(R)(R path)<br>auto baseName(C)(C[] path)<br>pure @safe inout(C)[] baseName(CaseSensitive cs = CaseSensitive.osDefault, C, C1)(inout(C)[] path, in C1[] suffix)<br><br>  Constraints:<br>    if (isRandomAccessRange!R &amp;&amp; hasSlicing!R &amp;&amp; isSomeChar!(ElementType!R) &amp;&amp; !isSomeString!R)<br>    if (isSomeChar!C)<br>    if (isSomeChar!C &amp;&amp; isSomeChar!C1)</dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>cs</td> <td>Whether or not <code>suffix</code> matching is case-sensitive.</td>
</tr> <tr>
<td>R <code>path</code>
</td> <td>A <code>path</code> name. It can be a string, or any random-access range of characters.</td>
</tr> <tr>
<td>C1[] <code>suffix</code>
</td> <td>An optional <code>suffix</code> to be removed from the file name.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The name of the file in the <code>path</code> name, without any leading directory and with an optional <code>suffix</code> chopped off.  If <code>suffix</code> is specified, it will be compared to <code>path</code> using <code>filenameCmp!cs</code>, where <code>cs</code> is an optional template parameter determining whether the comparison is case sensitive or not. See the <a href="#filenameCmp"><code>filenameCmp</code></a> documentation for details. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">assert(baseName("dir/file.ext")         == "file.ext");
assert(baseName("dir/file.ext", ".ext") == "file");
assert(baseName("dir/file.ext", ".xyz") == "file.ext");
assert(baseName("dir/filename", "name") == "file");
assert(baseName("dir/subdir/")          == "subdir");

version (Windows)
{
    assert(baseName(`d:file.ext`)      == "file.ext");
    assert(baseName(`d:\dir\file.ext`) == "file.ext");
}
</pre>  <dl>
<dt>Note</dt>
<dd> This function <i>only</i> strips away the specified <code>suffix</code>, which doesn't necessarily have to represent an extension. To remove the extension from a <code>path</code>, regardless of what the extension is, use <a href="#stripExtension"><code>stripExtension</code></a>. To obtain the filename without leading directories and without an extension, combine the functions like this: </dd>
</dl>
<pre data-language="d">assert(baseName(stripExtension("dir/file.ext")) == "file");
</pre>  <dl>
<dt>Standards:</dt>
<dd>This function complies with <a href="http://pubs.opengroup.org/onlinepubs/9699919799/utilities/basename.html" target="_blank"> the POSIX requirements for the 'basename' shell utility</a> (with suitable adaptations for Windows paths).</dd>
</dl> </dd> <dt class="d_decl" id="dirName">auto dirName(R)(R path)<br>auto dirName(C)(C[] path)<br><br>  Constraints:<br>    if (isRandomAccessRange!R &amp;&amp; hasSlicing!R &amp;&amp; hasLength!R &amp;&amp; isSomeChar!(ElementType!R) &amp;&amp; !isSomeString!R)<br>    if (isSomeChar!C)</dt> <dd>
<p>Returns the directory part of a <code>path</code>. On Windows, this includes the drive letter if present. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>path</code>
</td> <td>A <code>path</code> name.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A slice of <code>path</code> or ".". </dd>
</dl> <dl>
<dt>Standards:</dt>
<dd>This function complies with <a href="http://pubs.opengroup.org/onlinepubs/9699919799/utilities/dirname.html" target="_blank"> the POSIX requirements for the 'dirname' shell utility</a> (with suitable adaptations for Windows paths).</dd>
</dl> </dd> <dt class="d_decl" id="rootName">auto rootName(R)(R path)<br><br>  Constraints:<br>    if ((isRandomAccessRange!R &amp;&amp; hasSlicing!R &amp;&amp; hasLength!R &amp;&amp; isSomeChar!(ElementType!R) || isNarrowString!R) &amp;&amp; !isConvertibleToString!R)</dt> <dd>
<p>Returns the root directory of the specified <code>path</code>, or <code>null</code> if the <code>path</code> is not rooted. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>path</code>
</td> <td>A <code>path</code> name.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A slice of <code>path</code>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(rootName("") is null);
assert(rootName("foo") is null);
writeln(rootName("/")); // "/"
writeln(rootName("/foo/bar")); // "/"

version (Windows)
{
    assert(rootName("d:foo") is null);
    writeln(rootName(`d:\foo`)); // `d:\`
    writeln(rootName(`\\server\share\foo`)); // `\\server\share`
    writeln(rootName(`\\server\share`)); // `\\server\share`
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="driveName">auto driveName(R)(R path)<br><br>  Constraints:<br>    if ((isRandomAccessRange!R &amp;&amp; hasSlicing!R &amp;&amp; hasLength!R &amp;&amp; isSomeChar!(ElementType!R) || isNarrowString!R) &amp;&amp; !isConvertibleToString!R)</dt> <dd>
<p>Get the drive portion of a <code>path</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>path</code>
</td> <td>string or range of characters</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A slice of <code>path</code> that is the drive, or an empty range if the drive is not specified. In the case of UNC paths, the network share is returned.  Always returns an empty range on POSIX.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.range : empty;
version (Posix)  assert(driveName("c:/foo").empty);
version (Windows)
{
    assert(driveName(`dir\file`).empty);
    writeln(driveName(`d:file`)); // "d:"
    writeln(driveName(`d:\file`)); // "d:"
    writeln(driveName("d:")); // "d:"
    writeln(driveName(`\\server\share\file`)); // `\\server\share`
    writeln(driveName(`\\server\share\`)); // `\\server\share`
    writeln(driveName(`\\server\share`)); // `\\server\share`

    static assert(driveName(`d:\file`) == "d:");
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="stripDrive">auto stripDrive(R)(R path)<br><br>  Constraints:<br>    if ((isRandomAccessRange!R &amp;&amp; hasSlicing!R &amp;&amp; isSomeChar!(ElementType!R) || isNarrowString!R) &amp;&amp; !isConvertibleToString!R)</dt> <dd>
<p>Strips the drive from a Windows <code>path</code>. On POSIX, the <code>path</code> is returned unaltered. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>path</code>
</td> <td>A pathname</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A slice of <code>path</code> without the drive component.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">version (Windows)
{
    writeln(stripDrive(`d:\dir\file`)); // `\dir\file`
    writeln(stripDrive(`\\server\share\dir\file`)); // `\dir\file`
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="extension">auto extension(R)(R path)<br><br>  Constraints:<br>    if (isRandomAccessRange!R &amp;&amp; hasSlicing!R &amp;&amp; isSomeChar!(ElementType!R) || is(StringTypeOf!R))</dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>path</code>
</td> <td>A <code>path</code> name.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The extension part of a file name, including the dot.  If there is no extension, <code>null</code> is returned.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.range : empty;
assert(extension("file").empty);
writeln(extension("file.")); // "."
writeln(extension("file.ext"w)); // ".ext"
writeln(extension("file.ext1.ext2"d)); // ".ext2"
assert(extension(".foo".dup).empty);
writeln(extension(".foo.ext"w.dup)); // ".ext"

static assert(extension("file").empty);
static assert(extension("file.ext") == ".ext");
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="stripExtension">auto stripExtension(R)(R path)<br><br>  Constraints:<br>    if ((isRandomAccessRange!R &amp;&amp; hasSlicing!R &amp;&amp; hasLength!R &amp;&amp; isSomeChar!(ElementType!R) || isNarrowString!R) &amp;&amp; !isConvertibleToString!R)</dt> <dd>
<p>Remove extension from <code>path</code>. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>path</code>
</td> <td>string or range to be sliced</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>slice of <code>path</code> with the extension (if any) stripped off</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(stripExtension("file")); // "file"
writeln(stripExtension("file.ext")); // "file"
writeln(stripExtension("file.ext1.ext2")); // "file.ext1"
writeln(stripExtension("file.")); // "file"
writeln(stripExtension(".file")); // ".file"
writeln(stripExtension(".file.ext")); // ".file"
writeln(stripExtension("dir/file.ext")); // "dir/file"
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="setExtension">immutable(Unqual!C1)[] setExtension(C1, C2)(in C1[] path, in C2[] ext)<br>immutable(C1)[] setExtension(C1, C2)(immutable(C1)[] path, const(C2)[] ext)<br><br>  Constraints:<br>    if (isSomeChar!C1 &amp;&amp; !is(C1 == immutable) &amp;&amp; is(Unqual!C1 == Unqual!C2))<br>    if (isSomeChar!C1 &amp;&amp; is(Unqual!C1 == Unqual!C2))</dt> <dd>
<p>Sets or replaces an extension. </p>
<p>If the filename already has an extension, it is replaced. If not, the extension is simply appended to the filename. Including a leading dot in <code>ext</code> is optional. <br><br> If the extension is empty, this function is equivalent to <a href="#stripExtension"><code>stripExtension</code></a>. <br><br> This function normally allocates a new string (the possible exception being the case when <code>path</code> is immutable and doesn't already have an extension). </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>C1[] <code>path</code>
</td> <td>A <code>path</code> name</td>
</tr> <tr>
<td>C2[] <code>ext</code>
</td> <td>The new extension</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>A string containing the path given by <code>path</code>, but where the extension has been set to <code>ext</code>. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="#withExtension"><code>withExtension</code></a> which does not allocate and returns a lazy range.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(setExtension("file", "ext")); // "file.ext"
writeln(setExtension("file"w, ".ext"w)); // "file.ext"
writeln(setExtension("file."d, "ext"d)); // "file.ext"
writeln(setExtension("file.", ".ext")); // "file.ext"
writeln(setExtension("file.old"w, "new"w)); // "file.new"
writeln(setExtension("file.old"d, ".new"d)); // "file.new"
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="withExtension">auto withExtension(R, C)(R path, C[] ext)<br><br>  Constraints:<br>    if ((isRandomAccessRange!R &amp;&amp; hasSlicing!R &amp;&amp; hasLength!R &amp;&amp; isSomeChar!(ElementType!R) || isNarrowString!R) &amp;&amp; !isConvertibleToString!R &amp;&amp; isSomeChar!C)</dt> <dd>
<p>Replace existing extension on filespec with new one. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>path</code>
</td> <td>string or random access range representing a filespec</td>
</tr> <tr>
<td>C[] <code>ext</code>
</td> <td>the new extension</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>Range with <code>path</code>'s extension (if any) replaced with <code>ext</code>. The element encoding type of the returned range will be the same as <code>path</code>'s. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd><a href="#setExtension"><code>setExtension</code></a></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.array;
writeln(withExtension("file", "ext").array); // "file.ext"
writeln(withExtension("file"w, ".ext"w).array); // "file.ext"
writeln(withExtension("file.ext"w, ".").array); // "file."

import std.utf : byChar, byWchar;
writeln(withExtension("file".byChar, "ext").array); // "file.ext"
writeln(withExtension("file"w.byWchar, ".ext"w).array); // "file.ext"w
writeln(withExtension("file.ext"w.byWchar, ".").array); // "file."w
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="defaultExtension">immutable(Unqual!C1)[] defaultExtension(C1, C2)(in C1[] path, in C2[] ext)<br><br>  Constraints:<br>    if (isSomeChar!C1 &amp;&amp; is(Unqual!C1 == Unqual!C2))</dt> <dd>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>C1[] <code>path</code>
</td> <td>A <code>path</code> name.</td>
</tr> <tr>
<td>C2[] <code>ext</code>
</td> <td>The default extension to use.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The path given by <code>path</code>, with the extension given by <code>ext</code> appended if the <code>path</code> doesn't already have one.  Including the dot in the extension is optional.  This function always allocates a new string, except in the case when <code>path</code> is immutable and already has an extension.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(defaultExtension("file", "ext")); // "file.ext"
writeln(defaultExtension("file", ".ext")); // "file.ext"
writeln(defaultExtension("file.", "ext")); // "file."
writeln(defaultExtension("file.old", "new")); // "file.old"
writeln(defaultExtension("file.old", ".new")); // "file.old"
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="withDefaultExtension">auto withDefaultExtension(R, C)(R path, C[] ext)<br><br>  Constraints:<br>    if ((isRandomAccessRange!R &amp;&amp; hasSlicing!R &amp;&amp; hasLength!R &amp;&amp; isSomeChar!(ElementType!R) || isNarrowString!R) &amp;&amp; !isConvertibleToString!R &amp;&amp; isSomeChar!C)</dt> <dd>
<p>Set the extension of <code>path</code> to <code>ext</code> if <code>path</code> doesn't have one. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>path</code>
</td> <td>filespec as string or range</td>
</tr> <tr>
<td>C[] <code>ext</code>
</td> <td>extension, may have leading '.'</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>range with the result</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.array;
writeln(withDefaultExtension("file", "ext").array); // "file.ext"
writeln(withDefaultExtension("file"w, ".ext").array); // "file.ext"w
writeln(withDefaultExtension("file.", "ext").array); // "file."
writeln(withDefaultExtension("file", "").array); // "file."

import std.utf : byChar, byWchar;
writeln(withDefaultExtension("file".byChar, "ext").array); // "file.ext"
writeln(withDefaultExtension("file"w.byWchar, ".ext").array); // "file.ext"w
writeln(withDefaultExtension("file.".byChar, "ext"d).array); // "file."
writeln(withDefaultExtension("file".byChar, "").array); // "file."
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="buildPath">immutable(ElementEncodingType!(ElementType!Range))[] buildPath(Range)(Range segments)<br>pure nothrow @safe immutable(C)[] buildPath(C)(const(C)[][] paths...)<br><br>  Constraints:<br>    if (isInputRange!Range &amp;&amp; !isInfinite!Range &amp;&amp; isSomeString!(ElementType!Range))<br>    if (isSomeChar!C)</dt> <dd>
<p>Combines one or more path <code>segments</code>. </p>
<p>This function takes a set of path <code>segments</code>, given as an input range of string elements or as a set of string arguments, and concatenates them with each other. Directory separators are inserted between <code>segments</code> if necessary. If any of the path <code>segments</code> are absolute (as defined by <a href="#isAbsolute"><code>isAbsolute</code></a>), the preceding <code>segments</code> will be dropped. <br><br> On Windows, if one of the path <code>segments</code> are rooted, but not absolute (e.g. <code>\foo</code>), all preceding path <code>segments</code> down to the previous root will be dropped. (See below for an example.) <br><br> This function always allocates memory to hold the resulting path. The variadic overload is guaranteed to only perform a single allocation, as is the range version if <code>paths</code> is a forward range. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Range <code>segments</code>
</td> <td>An input range of <code>segments</code> to assemble the path from.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The assembled path.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">version (Posix)
{
    writeln(buildPath("foo", "bar", "baz")); // "foo/bar/baz"
    writeln(buildPath("/foo/", "bar/baz")); // "/foo/bar/baz"
    writeln(buildPath("/foo", "/bar")); // "/bar"
}

version (Windows)
{
    writeln(buildPath("foo", "bar", "baz")); // `foo\bar\baz`
    writeln(buildPath(`c:\foo`, `bar\baz`)); // `c:\foo\bar\baz`
    writeln(buildPath("foo", `d:\bar`)); // `d:\bar`
    writeln(buildPath("foo", `\bar`)); // `\bar`
    writeln(buildPath(`c:\foo`, `\bar`)); // `c:\bar`
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="chainPath">auto chainPath(R1, R2, Ranges...)(R1 r1, R2 r2, Ranges ranges)<br><br>  Constraints:<br>    if ((isRandomAccessRange!R1 &amp;&amp; hasSlicing!R1 &amp;&amp; hasLength!R1 &amp;&amp; isSomeChar!(ElementType!R1) || isNarrowString!R1 &amp;&amp; !isConvertibleToString!R1) &amp;&amp; (isRandomAccessRange!R2 &amp;&amp; hasSlicing!R2 &amp;&amp; hasLength!R2 &amp;&amp; isSomeChar!(ElementType!R2) || isNarrowString!R2 &amp;&amp; !isConvertibleToString!R2) &amp;&amp; (Ranges.length == 0 || is(typeof(chainPath(r2, ranges)))))</dt> <dd>
<p>Concatenate path segments together to form one path. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R1 <code>r1</code>
</td> <td>first segment</td>
</tr> <tr>
<td>R2 <code>r2</code>
</td> <td>second segment</td>
</tr> <tr>
<td>Ranges <code>ranges</code>
</td> <td>0 or more segments</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>Lazy range which is the concatenation of <code>r1</code>, <code>r2</code> and <code>ranges</code> with path separators. The resulting element type is that of <code>r1</code>. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd><a href="#buildPath"><code>buildPath</code></a></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.array;
version (Posix)
{
    writeln(chainPath("foo", "bar", "baz").array); // "foo/bar/baz"
    writeln(chainPath("/foo/", "bar/baz").array); // "/foo/bar/baz"
    writeln(chainPath("/foo", "/bar").array); // "/bar"
}

version (Windows)
{
    writeln(chainPath("foo", "bar", "baz").array); // `foo\bar\baz`
    writeln(chainPath(`c:\foo`, `bar\baz`).array); // `c:\foo\bar\baz`
    writeln(chainPath("foo", `d:\bar`).array); // `d:\bar`
    writeln(chainPath("foo", `\bar`).array); // `\bar`
    writeln(chainPath(`c:\foo`, `\bar`).array); // `c:\bar`
}

import std.utf : byChar;
version (Posix)
{
    writeln(chainPath("foo", "bar", "baz").array); // "foo/bar/baz"
    writeln(chainPath("/foo/".byChar, "bar/baz").array); // "/foo/bar/baz"
    writeln(chainPath("/foo", "/bar".byChar).array); // "/bar"
}

version (Windows)
{
    writeln(chainPath("foo", "bar", "baz").array); // `foo\bar\baz`
    writeln(chainPath(`c:\foo`.byChar, `bar\baz`).array); // `c:\foo\bar\baz`
    writeln(chainPath("foo", `d:\bar`).array); // `d:\bar`
    writeln(chainPath("foo", `\bar`.byChar).array); // `\bar`
    writeln(chainPath(`c:\foo`, `\bar`w).array); // `c:\bar`
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="buildNormalizedPath">pure nothrow @trusted immutable(C)[] buildNormalizedPath(C)(const(C[])[] paths...)<br><br>  Constraints:<br>    if (isSomeChar!C)</dt> <dd>
<p>Performs the same task as <a href="#buildPath"><code>buildPath</code></a>, while at the same time resolving current/parent directory symbols (<code>"."</code> and <code>".."</code>) and removing superfluous directory separators. It will return "." if the path leads to the starting directory. On Windows, slashes are replaced with backslashes. </p>
<p>Using <code>buildNormalizedPath</code> on <code>null</code> <code>paths</code> will always return <code>null</code>. <br><br> Note that this function does not resolve symbolic links. <br><br> This function always allocates memory to hold the resulting path. Use <a href="#asNormalizedPath"><code>asNormalizedPath</code></a> to not allocate memory. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>const(C[])[] <code>paths</code>
</td> <td>An array of <code>paths</code> to assemble.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The assembled path.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(buildNormalizedPath("foo", "..")); // "."

version (Posix)
{
    writeln(buildNormalizedPath("/foo/./bar/..//baz/")); // "/foo/baz"
    writeln(buildNormalizedPath("../foo/.")); // "../foo"
    writeln(buildNormalizedPath("/foo", "bar/baz/")); // "/foo/bar/baz"
    writeln(buildNormalizedPath("/foo", "/bar/..", "baz")); // "/baz"
    writeln(buildNormalizedPath("foo/./bar", "../../", "../baz")); // "../baz"
    writeln(buildNormalizedPath("/foo/./bar", "../../baz")); // "/baz"
}

version (Windows)
{
    writeln(buildNormalizedPath(`c:\foo\.\bar/..\\baz\`)); // `c:\foo\baz`
    writeln(buildNormalizedPath(`..\foo\.`)); // `..\foo`
    writeln(buildNormalizedPath(`c:\foo`, `bar\baz\`)); // `c:\foo\bar\baz`
    writeln(buildNormalizedPath(`c:\foo`, `bar/..`)); // `c:\foo`
    assert(buildNormalizedPath(`\\server\share\foo`, `..\bar`) ==
            `\\server\share\bar`);
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="asNormalizedPath">auto asNormalizedPath(R)(R path)<br><br>  Constraints:<br>    if (isSomeChar!(ElementEncodingType!R) &amp;&amp; (isRandomAccessRange!R &amp;&amp; hasSlicing!R &amp;&amp; hasLength!R || isNarrowString!R) &amp;&amp; !isConvertibleToString!R)</dt> <dd>
<p>Normalize a <code>path</code> by resolving current/parent directory symbols (<code>"."</code> and <code>".."</code>) and removing superfluous directory separators. It will return "." if the <code>path</code> leads to the starting directory. On Windows, slashes are replaced with backslashes. </p>
<p>Using <code>asNormalizedPath</code> on empty paths will always return an empty <code>path</code>. <br><br> Does not resolve symbolic links. <br><br> This function always allocates memory to hold the resulting <code>path</code>. Use <a href="#buildNormalizedPath"><code>buildNormalizedPath</code></a> to allocate memory and return a string. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>path</code>
</td> <td>string or random access range representing the path to normalize</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>normalized <code>path</code> as a forward range</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.array;
writeln(asNormalizedPath("foo/..").array); // "."

version (Posix)
{
    writeln(asNormalizedPath("/foo/./bar/..//baz/").array); // "/foo/baz"
    writeln(asNormalizedPath("../foo/.").array); // "../foo"
    writeln(asNormalizedPath("/foo/bar/baz/").array); // "/foo/bar/baz"
    writeln(asNormalizedPath("/foo/./bar/../../baz").array); // "/baz"
}

version (Windows)
{
    writeln(asNormalizedPath(`c:\foo\.\bar/..\\baz\`).array); // `c:\foo\baz`
    writeln(asNormalizedPath(`..\foo\.`).array); // `..\foo`
    writeln(asNormalizedPath(`c:\foo\bar\baz\`).array); // `c:\foo\bar\baz`
    writeln(asNormalizedPath(`c:\foo\bar/..`).array); // `c:\foo`
    assert(asNormalizedPath(`\\server\share\foo\..\bar`).array ==
            `\\server\share\bar`);
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="pathSplitter">auto pathSplitter(R)(R path)<br><br>  Constraints:<br>    if ((isRandomAccessRange!R &amp;&amp; hasSlicing!R || isNarrowString!R) &amp;&amp; !isConvertibleToString!R)</dt> <dd>
<p>Slice up a <code>path</code> into its elements. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>path</code>
</td> <td>string or slicable random access range</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>bidirectional range of slices of <code>path</code>
</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.algorithm.comparison : equal;
import std.conv : to;

assert(equal(pathSplitter("/"), ["/"]));
assert(equal(pathSplitter("/foo/bar"), ["/", "foo", "bar"]));
assert(equal(pathSplitter("foo/../bar//./"), ["foo", "..", "bar", "."]));

version (Posix)
{
    assert(equal(pathSplitter("//foo/bar"), ["/", "foo", "bar"]));
}

version (Windows)
{
    assert(equal(pathSplitter(`foo\..\bar\/.\`), ["foo", "..", "bar", "."]));
    assert(equal(pathSplitter("c:"), ["c:"]));
    assert(equal(pathSplitter(`c:\foo\bar`), [`c:\`, "foo", "bar"]));
    assert(equal(pathSplitter(`c:foo\bar`), ["c:foo", "bar"]));
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isRooted">bool isRooted(R)(R path)<br><br>  Constraints:<br>    if (isRandomAccessRange!R &amp;&amp; isSomeChar!(ElementType!R) || is(StringTypeOf!R))</dt> <dd>
<p>Determines whether a <code>path</code> starts at a root directory. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>path</code>
</td> <td>A <code>path</code> name.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd> Whether a <code>path</code> starts at a root directory.  On POSIX, this function returns <code>true</code> if and only if the <code>path</code> starts with a slash (/). <pre data-language="d">version (Posix)
{
    assert(isRooted("/"));
    assert(isRooted("/foo"));
    assert(!isRooted("foo"));
    assert(!isRooted("../foo"));
}
</pre>  On Windows, this function returns <code>true</code> if the <code>path</code> starts at the root directory of the current drive, of some other drive, or of a network drive. <pre data-language="d">version (Windows)
{
    assert(isRooted(`\`));
    assert(isRooted(`\foo`));
    assert(isRooted(`d:\foo`));
    assert(isRooted(`\\foo\bar`));
    assert(!isRooted("foo"));
    assert(!isRooted("d:foo"));
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isAbsolute">pure nothrow @safe bool isAbsolute(R)(R path)<br><br>  Constraints:<br>    if (isRandomAccessRange!R &amp;&amp; isSomeChar!(ElementType!R) || is(StringTypeOf!R))</dt> <dd>
<p>Determines whether a <code>path</code> is absolute or not. </p>
<dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>path</code>
</td> <td>A <code>path</code> name.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>Whether a <code>path</code> is absolute or not. </dd>
</dl> <dl>
<dt>Example</dt>
<dd> On POSIX, an absolute <code>path</code> starts at the root directory. (In fact, <code>isAbsolute</code> is just an alias for <a href="#isRooted"><code>isRooted</code></a>.) </dd>
</dl>
<pre data-language="d">version (Posix)
{
    assert(isAbsolute("/"));
    assert(isAbsolute("/foo"));
    assert(!isAbsolute("foo"));
    assert(!isAbsolute("../foo"));
}
</pre>  On Windows, an absolute <code>path</code> starts at the root directory of a specific drive. Hence, it must start with <code>d:\</code> or <code>d:/</code>, where <code>d</code> is the drive letter. Alternatively, it may be a network <code>path</code>, i.e. a <code>path</code> starting with a double (back)slash. <pre data-language="d">version (Windows)
{
    assert(isAbsolute(`d:\`));
    assert(isAbsolute(`d:\foo`));
    assert(isAbsolute(`\\foo\bar`));
    assert(!isAbsolute(`\`));
    assert(!isAbsolute(`\foo`));
    assert(!isAbsolute("d:foo"));
}
</pre>  </dd> <dt class="d_decl" id="absolutePath">pure @safe string absolutePath(string path, lazy string base = getcwd())</dt> <dd>
<p>Transforms <code>path</code> into an absolute path. </p>
<p>The following algorithm is used: </p>
<ol> <li>If <code>path</code> is empty, return <code>null</code>.</li> <li>If <code>path</code> is already absolute, return it.</li> <li>Otherwise, append <code>path</code> to <code>base</code> and return the result. If <code>base</code> is not specified, the current working directory is used.</li> </ol> The function allocates memory if and only if it gets to the third stage of this algorithm.  <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>string <code>path</code>
</td> <td>the relative <code>path</code> to transform</td>
</tr> <tr>
<td>string <code>base</code>
</td> <td>the <code>base</code> directory of the relative <code>path</code>
</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>string of transformed <code>path</code> </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<code>Exception</code> if the specified base directory is not absolute. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="#asAbsolutePath"><code>asAbsolutePath</code></a> which does not allocate</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">version (Posix)
{
    writeln(absolutePath("some/file", "/foo/bar")); // "/foo/bar/some/file"
    writeln(absolutePath("../file", "/foo/bar")); // "/foo/bar/../file"
    writeln(absolutePath("/some/file", "/foo/bar")); // "/some/file"
}

version (Windows)
{
    writeln(absolutePath(`some\file`, `c:\foo\bar`)); // `c:\foo\bar\some\file`
    writeln(absolutePath(`..\file`, `c:\foo\bar`)); // `c:\foo\bar\..\file`
    writeln(absolutePath(`c:\some\file`, `c:\foo\bar`)); // `c:\some\file`
    writeln(absolutePath(`\`, `c:\`)); // `c:\`
    writeln(absolutePath(`\some\file`, `c:\foo\bar`)); // `c:\some\file`
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="asAbsolutePath">auto asAbsolutePath(R)(R path)<br><br>  Constraints:<br>    if ((isRandomAccessRange!R &amp;&amp; isSomeChar!(ElementType!R) || isNarrowString!R) &amp;&amp; !isConvertibleToString!R)</dt> <dd>
<p>Transforms <code>path</code> into an absolute path. </p>
<p>The following algorithm is used: </p>
<ol> <li>If <code>path</code> is empty, return <code>null</code>.</li> <li>If <code>path</code> is already absolute, return it.</li> <li>Otherwise, append <code>path</code> to the current working directory, which allocates memory.</li> </ol>  <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R <code>path</code>
</td> <td>the relative <code>path</code> to transform</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>the transformed <code>path</code> as a lazy range </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="#absolutePath"><code>absolutePath</code></a> which returns an allocated string</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.array;
writeln(asAbsolutePath(cast(string)null).array); // ""
version (Posix)
{
    writeln(asAbsolutePath("/foo").array); // "/foo"
}
version (Windows)
{
    writeln(asAbsolutePath("c:/foo").array); // "c:/foo"
}
asAbsolutePath("foo");
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="relativePath">string relativePath(CaseSensitive cs = CaseSensitive.osDefault)(string path, lazy string base = getcwd())</dt> <dd>
<p>Translates <code>path</code> into a relative path. </p>
<p>The returned path is relative to <code>base</code>, which is by default taken to be the current working directory. If specified, <code>base</code> must be an absolute path, and it is always assumed to refer to a directory. If <code>path</code> and <code>base</code> refer to the same directory, the function returns <code>.</code>. <br><br> The following algorithm is used: </p>
<ol> <li>If <code>path</code> is a relative directory, return it unaltered.</li> <li>Find a common root between <code>path</code> and <code>base</code>. If there is no common root, return <code>path</code> unaltered.</li> <li>Prepare a string with as many <code>../</code> or <code>..\</code> as necessary to reach the common root from <code>base</code> <code>path</code>.</li> <li>Append the remaining segments of <code>path</code> to the string and return.</li> </ol> <br><br> In the second step, <code>path</code> components are compared using <code>filenameCmp!cs</code>, where <code>cs</code> is an optional template parameter determining whether the comparison is case sensitive or not. See the <a href="#filenameCmp"><code>filenameCmp</code></a> documentation for details. <br><br> This function allocates memory.  <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>cs</td> <td>Whether matching <code>path</code> name components against the <code>base</code> <code>path</code> should be case-sensitive or not.</td>
</tr> <tr>
<td>string <code>path</code>
</td> <td>A <code>path</code> name.</td>
</tr> <tr>
<td>string <code>base</code>
</td> <td>The <code>base</code> <code>path</code> to construct the relative <code>path</code> from.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>The relative <code>path</code>. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd>
<a href="#asRelativePath"><code>asRelativePath</code></a> which does not allocate memory </dd>
</dl> <dl>
<dt>Throws:</dt>
<dd>
<code>Exception</code> if the specified base directory is not absolute.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(relativePath("foo")); // "foo"

version (Posix)
{
    writeln(relativePath("foo", "/bar")); // "foo"
    writeln(relativePath("/foo/bar", "/foo/bar")); // "."
    writeln(relativePath("/foo/bar", "/foo/baz")); // "../bar"
    writeln(relativePath("/foo/bar/baz", "/foo/woo/wee")); // "../../bar/baz"
    writeln(relativePath("/foo/bar/baz", "/foo/bar")); // "baz"
}
version (Windows)
{
    writeln(relativePath("foo", `c:\bar`)); // "foo"
    writeln(relativePath(`c:\foo\bar`, `c:\foo\bar`)); // "."
    writeln(relativePath(`c:\foo\bar`, `c:\foo\baz`)); // `..\bar`
    writeln(relativePath(`c:\foo\bar\baz`, `c:\foo\woo\wee`)); // `..\..\bar\baz`
    writeln(relativePath(`c:\foo\bar\baz`, `c:\foo\bar`)); // "baz"
    writeln(relativePath(`c:\foo\bar`, `d:\foo`)); // `c:\foo\bar`
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="asRelativePath">auto asRelativePath(CaseSensitive cs = CaseSensitive.osDefault, R1, R2)(R1 path, R2 base)<br><br>  Constraints:<br>    if ((isNarrowString!R1 || isRandomAccessRange!R1 &amp;&amp; hasSlicing!R1 &amp;&amp; isSomeChar!(ElementType!R1) &amp;&amp; !isConvertibleToString!R1) &amp;&amp; (isNarrowString!R2 || isRandomAccessRange!R2 &amp;&amp; hasSlicing!R2 &amp;&amp; isSomeChar!(ElementType!R2) &amp;&amp; !isConvertibleToString!R2))</dt> <dd>
<p>Transforms <code>path</code> into a path relative to <code>base</code>. </p>
<p>The returned path is relative to <code>base</code>, which is usually the current working directory. <code>base</code> must be an absolute path, and it is always assumed to refer to a directory. If <code>path</code> and <code>base</code> refer to the same directory, the function returns <code>'.'</code>. <br><br> The following algorithm is used: </p>
<ol> <li>If <code>path</code> is a relative directory, return it unaltered.</li> <li>Find a common root between <code>path</code> and <code>base</code>. If there is no common root, return <code>path</code> unaltered.</li> <li>Prepare a string with as many <code>../</code> or <code>..\</code> as necessary to reach the common root from <code>base</code> <code>path</code>.</li> <li>Append the remaining segments of <code>path</code> to the string and return.</li> </ol> <br><br> In the second step, <code>path</code> components are compared using <code>filenameCmp!cs</code>, where <code>cs</code> is an optional template parameter determining whether the comparison is case sensitive or not. See the <a href="#filenameCmp"><code>filenameCmp</code></a> documentation for details.  <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>R1 <code>path</code>
</td> <td>path to transform</td>
</tr> <tr>
<td>R2 <code>base</code>
</td> <td>absolute <code>path</code>
</td>
</tr> <tr>
<td>cs</td> <td>whether filespec comparisons are sensitive or not; defaults to <code>CaseSensitive.osDefault</code>
</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>a random access range of the transformed path </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd><a href="#relativePath"><code>relativePath</code></a></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.array;
version (Posix)
{
    writeln(asRelativePath("foo", "/bar").array); // "foo"
    writeln(asRelativePath("/foo/bar", "/foo/bar").array); // "."
    writeln(asRelativePath("/foo/bar", "/foo/baz").array); // "../bar"
    writeln(asRelativePath("/foo/bar/baz", "/foo/woo/wee").array); // "../../bar/baz"
    writeln(asRelativePath("/foo/bar/baz", "/foo/bar").array); // "baz"
}
else version (Windows)
{
    writeln(asRelativePath("foo", `c:\bar`).array); // "foo"
    writeln(asRelativePath(`c:\foo\bar`, `c:\foo\bar`).array); // "."
    writeln(asRelativePath(`c:\foo\bar`, `c:\foo\baz`).array); // `..\bar`
    writeln(asRelativePath(`c:\foo\bar\baz`, `c:\foo\woo\wee`).array); // `..\..\bar\baz`
    writeln(asRelativePath(`c:/foo/bar/baz`, `c:\foo\woo\wee`).array); // `..\..\bar\baz`
    writeln(asRelativePath(`c:\foo\bar\baz`, `c:\foo\bar`).array); // "baz"
    writeln(asRelativePath(`c:\foo\bar`, `d:\foo`).array); // `c:\foo\bar`
    writeln(asRelativePath(`\\foo\bar`, `c:\foo`).array); // `\\foo\bar`
}
else
    static assert(0);
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="filenameCharCmp">pure nothrow @safe int filenameCharCmp(CaseSensitive cs = CaseSensitive.osDefault)(dchar a, dchar b)</dt> <dd>
<p>Compares filename characters. </p>
<p>This function can perform <code>a</code> case-sensitive or <code>a</code> case-insensitive comparison. This is controlled through the <code>cs</code> template parameter which, if not specified, is given by <a href="#CaseSensitive"><code>CaseSensitive</code></a><code>.osDefault</code>. <br><br> On Windows, the backslash and slash characters (<code>\</code> and <code>/</code>) are considered equal. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>cs</td> <td>Case-sensitivity of the comparison.</td>
</tr> <tr>
<td>dchar <code>a</code>
</td> <td>A filename character.</td>
</tr> <tr>
<td>dchar <code>b</code>
</td> <td>A filename character.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>&lt; 0</code> if <code>a &lt; b</code>, <code>0</code> if <code>a == b</code>, and <code>&gt; 0</code> if <code>a &gt; b</code>.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(filenameCharCmp('a', 'a')); // 0
assert(filenameCharCmp('a', 'b') &lt; 0);
assert(filenameCharCmp('b', 'a') &gt; 0);

version (linux)
{
    // Same as calling filenameCharCmp!(CaseSensitive.yes)(a, b)
    assert(filenameCharCmp('A', 'a') &lt; 0);
    assert(filenameCharCmp('a', 'A') &gt; 0);
}
version (Windows)
{
    // Same as calling filenameCharCmp!(CaseSensitive.no)(a, b)
    writeln(filenameCharCmp('a', 'A')); // 0
    assert(filenameCharCmp('a', 'B') &lt; 0);
    assert(filenameCharCmp('A', 'b') &lt; 0);
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="filenameCmp">int filenameCmp(CaseSensitive cs = CaseSensitive.osDefault, Range1, Range2)(Range1 filename1, Range2 filename2)<br><br>  Constraints:<br>    if (isInputRange!Range1 &amp;&amp; !isInfinite!Range1 &amp;&amp; isSomeChar!(ElementEncodingType!Range1) &amp;&amp; !isConvertibleToString!Range1 &amp;&amp; isInputRange!Range2 &amp;&amp; !isInfinite!Range2 &amp;&amp; isSomeChar!(ElementEncodingType!Range2) &amp;&amp; !isConvertibleToString!Range2)</dt> <dd>
<p>Compares file names and returns </p>
<p>Individual characters are compared using <code>filenameCharCmp!cs</code>, where <code>cs</code> is an optional template parameter determining whether the comparison is case sensitive or not. <br><br> Treatment of invalid UTF encodings is implementation defined. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>cs</td> <td>case sensitivity</td>
</tr> <tr>
<td>Range1 <code>filename1</code>
</td> <td>range for first file name</td>
</tr> <tr>
<td>Range2 <code>filename2</code>
</td> <td>range for second file name</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>&lt; 0</code> if <code>filename1 &lt; filename2</code>, <code>0</code> if <code>filename1 == filename2</code> and <code>&gt; 0</code> if <code>filename1 &gt; filename2</code>. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd><a href="#filenameCharCmp"><code>filenameCharCmp</code></a></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">writeln(filenameCmp("abc", "abc")); // 0
assert(filenameCmp("abc", "abd") &lt; 0);
assert(filenameCmp("abc", "abb") &gt; 0);
assert(filenameCmp("abc", "abcd") &lt; 0);
assert(filenameCmp("abcd", "abc") &gt; 0);

version (linux)
{
    // Same as calling filenameCmp!(CaseSensitive.yes)(filename1, filename2)
    assert(filenameCmp("Abc", "abc") &lt; 0);
    assert(filenameCmp("abc", "Abc") &gt; 0);
}
version (Windows)
{
    // Same as calling filenameCmp!(CaseSensitive.no)(filename1, filename2)
    writeln(filenameCmp("Abc", "abc")); // 0
    writeln(filenameCmp("abc", "Abc")); // 0
    assert(filenameCmp("Abc", "abD") &lt; 0);
    assert(filenameCmp("abc", "AbB") &gt; 0);
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="globMatch">pure nothrow @safe bool globMatch(CaseSensitive cs = CaseSensitive.osDefault, C, Range)(Range path, const(C)[] pattern)<br><br>  Constraints:<br>    if (isForwardRange!Range &amp;&amp; !isInfinite!Range &amp;&amp; isSomeChar!(ElementEncodingType!Range) &amp;&amp; !isConvertibleToString!Range &amp;&amp; isSomeChar!C &amp;&amp; is(Unqual!C == Unqual!(ElementEncodingType!Range)))</dt> <dd>
<p>Matches a <code>pattern</code> against a <code>path</code>. </p>
<p>Some characters of <code>pattern</code> have a special meaning (they are <i>meta-characters</i>) and can't be escaped. These are: <br><br> </p>
<table>
 <tr>
<td><code>*</code></td> <td>Matches 0 or more instances of any character.</td>
</tr> <tr>
<td><code>?</code></td> <td>Matches exactly one instance of any character.</td>
</tr> <tr>
<td>
<code>[</code><i>chars</i><code>]</code>
</td> <td>Matches one instance of any character that appears between the brackets.</td>
</tr> <tr>
<td>
<code>[!</code><i>chars</i><code>]</code>
</td> <td>Matches one instance of any character that does not appear between the brackets after the exclamation mark.</td>
</tr> <tr>
<td>
<code>{</code><i>string1</i><code>,</code><i>string2</i><code>,</code>â¦<code>}</code>
</td> <td>Matches either of the specified strings.</td>
</tr> </table> <br><br> Individual characters are compared using <code>filenameCharCmp!cs</code>, where <code>cs</code> is an optional template parameter determining whether the comparison is case sensitive or not. See the <a href="#filenameCharCmp"><code>filenameCharCmp</code></a> documentation for details. <br><br> Note that directory separators and dots don't stop a meta-character from matching further portions of the <code>path</code>.  <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>cs</td> <td>Whether the matching should be case-sensitive</td>
</tr> <tr>
<td>Range <code>path</code>
</td> <td>The <code>path</code> to be matched against</td>
</tr> <tr>
<td>const(C)[] <code>pattern</code>
</td> <td>The glob <code>pattern</code>
</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>true</code> if <code>pattern</code> matches <code>path</code>, <code>false</code> otherwise. </dd>
</dl> <dl>
<dt>See Also:</dt>
<dd><a href="http://en.wikipedia.org/wiki/Glob_%28programming%29" target="_blank">Wikipedia: glob (programming)</a></dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(globMatch("foo.bar", "*"));
assert(globMatch("foo.bar", "*.*"));
assert(globMatch(`foo/foo\bar`, "f*b*r"));
assert(globMatch("foo.bar", "f???bar"));
assert(globMatch("foo.bar", "[fg]???bar"));
assert(globMatch("foo.bar", "[!gh]*bar"));
assert(globMatch("bar.fooz", "bar.{foo,bif}z"));
assert(globMatch("bar.bifz", "bar.{foo,bif}z"));

version (Windows)
{
    // Same as calling globMatch!(CaseSensitive.no)(path, pattern)
    assert(globMatch("foo", "Foo"));
    assert(globMatch("Goo.bar", "[fg]???bar"));
}
version (linux)
{
    // Same as calling globMatch!(CaseSensitive.yes)(path, pattern)
    assert(!globMatch("foo", "Foo"));
    assert(!globMatch("Goo.bar", "[fg]???bar"));
}
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isValidFilename">bool isValidFilename(Range)(Range filename)<br><br>  Constraints:<br>    if ((isRandomAccessRange!Range &amp;&amp; hasLength!Range &amp;&amp; hasSlicing!Range &amp;&amp; isSomeChar!(ElementEncodingType!Range) || isNarrowString!Range) &amp;&amp; !isConvertibleToString!Range)</dt> <dd>
<p>Checks that the given file or directory name is valid. </p>
<p>The maximum length of <code>filename</code> is given by the constant <code>core.stdc.stdio.FILENAME_MAX</code>. (On Windows, this number is defined as the maximum number of UTF-16 code points, and the test will therefore only yield strictly correct results when <code>filename</code> is a string of <code>wchar</code>s.) <br><br> On Windows, the following criteria must be satisfied (<a href="http://msdn.microsoft.com/en-us/library/aa365247(v=vs.85).aspx" target="_blank">source</a>): </p>
<ul> <li>
<code>filename</code> must not contain any characters whose integer representation is in the range 0-31.</li> <li>
<code>filename</code> must not contain any of the following <i>reserved characters</i>: &lt;&gt;:"/\|?*</li> <li>
<code>filename</code> may not end with a space (<code>' '</code>) or a period (<code>'.'</code>).</li> </ul> <br><br> On POSIX, <code>filename</code> may not contain a forward slash (<code>'/'</code>) or the <code>null</code> character (<code>'\0'</code>).  <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Range <code>filename</code>
</td> <td>string to check</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>true</code> if and only if <code>filename</code> is not empty, not too long, and does not contain invalid characters.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">import std.utf : byCodeUnit;

assert(isValidFilename("hello.exe".byCodeUnit));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="isValidPath">bool isValidPath(Range)(Range path)<br><br>  Constraints:<br>    if ((isRandomAccessRange!Range &amp;&amp; hasLength!Range &amp;&amp; hasSlicing!Range &amp;&amp; isSomeChar!(ElementEncodingType!Range) || isNarrowString!Range) &amp;&amp; !isConvertibleToString!Range)</dt> <dd>
<p>Checks whether <code>path</code> is a valid path. </p>
<p>Generally, this function checks that <code>path</code> is not empty, and that each component of the <code>path</code> either satisfies <a href="#isValidFilename"><code>isValidFilename</code></a> or is equal to <code>"."</code> or <code>".."</code>. <br><br> <b>It does <i>not</i> check whether the path points to an existing file or directory; use <a href="../std_file/#exists"><code>std.file.exists</code></a> for this purpose.</b> <br><br> On Windows, some special rules apply: </p>
<ul> <li>If the second character of <code>path</code> is a colon (<code>':'</code>), the first character is interpreted as a drive letter, and must be in the range A-Z (case insensitive).</li> <li>If <code>path</code> is on the form <code>\\<i>server</i>\<i>share</i>\...</code> (UNC <code>path</code>), <a href="#isValidFilename"><code>isValidFilename</code></a> is applied to <i>server</i> and <i>share</i> as well.</li> <li>If <code>path</code> starts with <code>\\?\</code> (long UNC <code>path</code>), the only requirement for the rest of the string is that it does not contain the <code>null</code> character.</li> <li>If <code>path</code> starts with <code>\\.\</code> (Win32 device namespace) this function returns <code>false</code>; such paths are beyond the scope of this module.</li> </ul>  <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Range <code>path</code>
</td> <td>string or Range of characters to check</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>true</code> if <code>path</code> is a valid path.</dd>
</dl> <dl>
<dt>Examples:</dt>
<dd>
<pre data-language="d">assert(isValidPath("/foo/bar"));
assert(!isValidPath("/foo\0/bar"));
assert(isValidPath("/"));
assert(isValidPath("a"));

version (Windows)
{
    assert(isValidPath(`c:\`));
    assert(isValidPath(`c:\foo`));
    assert(isValidPath(`c:\foo\.\bar\\\..\`));
    assert(!isValidPath(`!:\foo`));
    assert(!isValidPath(`c::\foo`));
    assert(!isValidPath(`c:\foo?`));
    assert(!isValidPath(`c:\foo.`));

    assert(isValidPath(`\\server\share`));
    assert(isValidPath(`\\server\share\foo`));
    assert(isValidPath(`\\server\share\\foo`));
    assert(!isValidPath(`\\\server\share\foo`));
    assert(!isValidPath(`\\server\\share\foo`));
    assert(!isValidPath(`\\ser*er\share\foo`));
    assert(!isValidPath(`\\server\sha?e\foo`));
    assert(!isValidPath(`\\server\share\|oo`));

    assert(isValidPath(`\\?\&lt;&gt;:"?*|/\..\.`));
    assert(!isValidPath("\\\\?\\foo\0bar"));

    assert(!isValidPath(`\\.\PhysicalDisk1`));
    assert(!isValidPath(`\\`));
}

import std.utf : byCodeUnit;
assert(isValidPath("/foo/bar".byCodeUnit));
</pre> </dd>
</dl> </dd> <dt class="d_decl" id="expandTilde">nothrow string expandTilde(string inputPath)</dt> <dd>
<p>Performs tilde expansion in paths on POSIX systems. On Windows, this function does nothing. </p>
<p>There are two ways of using tilde expansion in a path. One involves using the tilde alone or followed by a path separator. In this case, the tilde will be expanded with the value of the environment variable <code>HOME</code>. The second way is putting a username after the tilde (i.e. <code>~john/Mail</code>). Here, the username will be searched for in the user database (i.e. <code>/etc/passwd</code> on Unix systems) and will expand to whatever path is stored there. The username is considered the string after the tilde ending at the first instance of a path separator. <br><br> Note that using the <code>~user</code> syntax may give different values from just <code>~</code> if the environment variable doesn't match the value stored in the user database. <br><br> When the environment variable version is used, the path won't be modified if the environment variable doesn't exist or it is empty. When the database version is used, the path won't be modified if the user doesn't exist in the database or there is not enough memory to perform the query. <br><br> This function performs several memory allocations. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>string <code>inputPath</code>
</td> <td>The path name to expand.</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>inputPath</code> with the tilde expanded, or just <code>inputPath</code> if it could not be expanded. For Windows, <code>expandTilde</code> merely returns its argument <code>inputPath</code>. </dd>
</dl> <dl>
<dt>Example</dt>

</dl>
<pre data-language="d">void processFile(string path)
{
    // Allow calling this function with paths such as ~/foo
    auto fullPath = expandTilde(path);
    ...
}
</pre>  </dd> </dl>
<div class="_attribution">
  <p class="_attribution-p">
    Â© 1999â2017 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/phobos/std_path.html" class="_attribution-link" target="_blank">https://dlang.org/phobos/std_path.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
