
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>ddmd.mtype - D - W3cubDocs</title>
  
  <meta name="description" content=" Compiler implementation of the D programming language. ">
  <meta name="keywords" content="ddmd, mtype, -, d">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/d/ddmd_mtype/">
  <link href="/favicon.png" rel="icon">
  <link type="text/css" rel="stylesheet" href="/assets/application-e0f881b0fce8cbe96f33dadc355b7159d5d2912911231446d60eb8f9caffa802.css">
  <script type="text/javascript" src="/assets/application-8fc46316434047265cd383f02b8e7f434ed7dec4a59f920dd633deef8d488d1b.js"></script>
  <script src="/json/d.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/d/" class="_nav-link" title="" style="margin-left:0;">D</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _d">
				
<h1>ddmd.mtype</h1>  <p>Compiler implementation of the <a href="http://www.dlang.org" target="_blank">D programming language</a>. </p> <dl>
<dt>Authors:</dt>
<dd>
<a href="http://www.digitalmars.com" target="_blank">Walter Bright</a> </dd>
</dl> <dl>
<dt>License:</dt>
<dd>
<a href="http://www.boost.org/LICENSE_1_0.txt" target="_blank">Boost License 1.0</a> </dd>
</dl> <dl>
<dt>Source:</dt>
<dd> <a href="https://github.com/dlang/dmd/blob/master/src/ddmd/mtype.d" target="_blank">mtype.d</a>
</dd>
</dl> <dl>
<dt class="d_decl" id="MODimplicitConv">pure nothrow @nogc @safe bool MODimplicitConv(MOD modfrom, MOD modto)</dt> <dd>
<p>Return !=0 if <code>modfrom</code> can be implicitly converted to <code>modto</code></p> </dd> <dt class="d_decl" id="MODmethodConv">pure nothrow @nogc @safe MATCH MODmethodConv(MOD modfrom, MOD modto)</dt> <dd>
<p>Return MATCHexact or MATCHconst if a method of type '() <code>modfrom</code>' can call a method of type '() <code>modto</code>'.</p> </dd> <dt class="d_decl" id="MODmerge">pure nothrow @nogc @safe MOD MODmerge(MOD mod1, MOD mod2)</dt> <dd>
<p>Merge mod bits to form common mod.</p> </dd> <dt class="d_decl" id="MODtoBuffer">void MODtoBuffer(OutBuffer* buf, MOD mod)</dt> <dd>
<p>Store modifier name into <code>buf</code>.</p> </dd> <dt class="d_decl" id="MODtoChars">char* MODtoChars(MOD mod)</dt> <dd>
<p>Return modifier name.</p> </dd> <dt class="d_decl" id="ModToStc">pure nothrow @nogc @safe StorageClass ModToStc(uint mod)</dt> <dd>
<p>Convert MODxxxx to STCxxx</p> </dd> <dt class="d_decl" id="Type">abstract class Type: ddmd.root.rootobject.RootObject</dt> <dd> <dl>
<dt class="d_decl" id="Type.covariant">final int covariant(Type t, StorageClass* pstc = null, bool fix17349 = true)</dt> <dd>
<p>Covariant means that 'this' can substitute for '<code>t</code>', i.e. a pure function is a match for an impure type. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Type <code>t</code>
</td> <td>type 'this' is <code>covariant</code> with</td>
</tr> <tr>
<td>StorageClass* <code>pstc</code>
</td> <td>if not <code>null</code>, store STCxxxx which would make it <code>covariant</code>
</td>
</tr> <tr>
<td>bool <code>fix17349</code>
</td> <td>enable fix https://issues.dlang.org/show_bug.cgi?id=17349</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>0 types are distinct 1 this is <code>covariant</code> with <code>t</code> 2 arguments match as far as overloading goes, but types are not <code>covariant</code> 3 cannot determine covariance because of forward references *<code>pstc</code> STCxxxx which would make it <code>covariant</code>
</dd>
</dl> </dd> <dt class="d_decl" id="Type.toChars">final const(char)* toChars()</dt> <dd>
<p>For pretty-printing a type.</p> </dd> <dt class="d_decl" id="Type.merge">final Type merge()</dt>  <dt class="d_decl" id="Type.merge2">final Type merge2()</dt> <dd>
<p>This version does a merge even if the deco is already computed. Necessary for types that have a deco, but are not merged.</p> </dd> <dt class="d_decl" id="Type.modToBuffer">final void modToBuffer(OutBuffer* buf)</dt> <dd>
<p>Store this type's modifier name into <code>buf</code>.</p> </dd> <dt class="d_decl" id="Type.modToChars">final char* modToChars()</dt> <dd>
<p>Return this type's modifier name.</p> </dd> <dt class="d_decl" id="Type.modifiersApply">final int modifiersApply(void* param, int function(void*, const(char)*) fp)</dt> <dd>
<p>For each active modifier (MODconst, MODimmutable, etc) call <code>fp</code> with a void* for the work <code>param</code> and a string representation of the attribute.</p> </dd> <dt class="d_decl" id="Type.isAssignable">bool isAssignable()</dt> <dd>
<p>When T is mutable, </p> <dl>
<dt>Given:</dt>
<dd> T a, b; Can we bitwise assign: a = b; ?</dd>
</dl> </dd> <dt class="d_decl" id="Type.isBoolean">bool isBoolean()</dt> <dd>
<p>Returns <code>true</code> if T can be converted to boolean value.</p> </dd> <dt class="d_decl" id="Type.checkDeprecated">void checkDeprecated(Loc loc, Scope* sc)</dt> <dd>
<p>Check type to see if it is based on a deprecated symbol.</p> </dd> <dt class="d_decl" id="Type.nullAttributes">final Type nullAttributes()</dt> <dd>
<p>Return a copy of this type with all attributes <code>null</code>-initialized. Useful for creating a type with different modifiers.</p> </dd> <dt class="d_decl" id="Type.constOf">final Type constOf()</dt> <dd>
<p>Convert to 'const'.</p> </dd> <dt class="d_decl" id="Type.immutableOf">final Type immutableOf()</dt> <dd>
<p>Convert to 'immutable'.</p> </dd> <dt class="d_decl" id="Type.mutableOf">final Type mutableOf()</dt> <dd>
<p>Make type mutable.</p> </dd> <dt class="d_decl" id="Type.unSharedOf">final Type unSharedOf()</dt> <dd>
<p>Make type unshared. 0 =&gt; 0 const =&gt; const immutable =&gt; immutable shared =&gt; 0 shared const =&gt; const wild =&gt; wild wild const =&gt; wild const shared wild =&gt; wild shared wild const =&gt; wild const</p> </dd> <dt class="d_decl" id="Type.wildOf">final Type wildOf()</dt> <dd>
<p>Convert to 'wild'.</p> </dd> <dt class="d_decl" id="Type.fixTo">final void fixTo(Type t)</dt> <dd>
<p>For our new type 'this', which is type-constructed from <code>t</code>, fill in the cto, ito, sto, scto, wto shortcuts.</p> </dd> <dt class="d_decl" id="Type.check">final void check()</dt> <dd>
<p>Look for bugs in constructing types.</p> </dd> <dt class="d_decl" id="Type.addSTC">final Type addSTC(StorageClass stc)</dt> <dd>
<p>Apply STCxxxx bits to existing type. Use *before* semantic analysis is run.</p> </dd> <dt class="d_decl" id="Type.castMod">final Type castMod(MOD mod)</dt> <dd>
<p>Apply MODxxxx bits to existing type.</p> </dd> <dt class="d_decl" id="Type.addMod">final Type addMod(MOD mod)</dt> <dd>
<p>Add MODxxxx bits to existing type. We're adding, not replacing, so adding const to a shared type =&gt; "shared const"</p> </dd> <dt class="d_decl" id="Type.addStorageClass">Type addStorageClass(StorageClass stc)</dt> <dd>
<p>Add storage class modifiers to type.</p> </dd> <dt class="d_decl" id="Type.toBasetype">Type toBasetype()</dt> <dd>
<p>If this is a shell around another type, get that other type.</p> </dd> <dt class="d_decl" id="Type.implicitConvTo">MATCH implicitConvTo(Type to)</dt> <dd>
<p>Determine if 'this' can be implicitly converted <code>to</code> type '<code>to</code>'. </p> <dl>
<dt>Returns:</dt>
<dd>MATCHnomatch, MATCHconvert, MATCHconst, MATCHexact</dd>
</dl> </dd> <dt class="d_decl" id="Type.constConv">MATCH constConv(Type to)</dt> <dd>
<p>Determine if converting 'this' <code>to</code> '<code>to</code>' is an identity operation, a conversion <code>to</code> const operation, or the types aren't the same. </p> <dl>
<dt>Returns:</dt>
<dd>MATCHexact 'this' == '<code>to</code>' MATCHconst '<code>to</code>' is const MATCHnomatch conversion <code>to</code> mutable or invariant</dd>
</dl> </dd> <dt class="d_decl" id="Type.deduceWild">ubyte deduceWild(Type t, bool isRef)</dt> <dd>
<p>Return MOD bits matching this type to wild parameter type (tprm).</p> </dd> <dt class="d_decl" id="Type.toHeadMutable">Type toHeadMutable()</dt> <dd>
<p>Return type with the top level of it being mutable.</p> </dd> <dt class="d_decl" id="Type.getProperty">Expression getProperty(Loc loc, Identifier ident, int flag)</dt> <dd>
<p>Calculate built-in properties which just the type is necessary. </p> <p>If <code>flag</code> &amp; 1, don't report "not a property" error and just return NULL.</p> </dd> <dt class="d_decl" id="Type.DotExpFlag">enum DotExpFlag: int</dt> <dd>
<p>dotExp() bit flags</p> </dd> <dt class="d_decl" id="Type.dotExp">Expression dotExp(Scope* sc, Expression e, Identifier ident, int flag)</dt> <dd>
<p>Access the members of the object <code>e</code>. This type is same as <code>e</code>.type. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>int <code>flag</code>
</td> <td>DotExpFlag bit flags</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>resulting expression with <code>e</code>.<code>ident</code> resolved</dd>
</dl> </dd> <dt class="d_decl" id="Type.alignment">structalign_t alignment()</dt> <dd>
<p>Return <code>alignment</code> to use for this type.</p> </dd> <dt class="d_decl" id="Type.noMember">final Expression noMember(Scope* sc, Expression e, Identifier ident, int flag)</dt> <dd>
<p>Figures out what to do with an undefined member reference for classes and structs. </p> <p>If <code>flag</code> &amp; 1, don't report "not a property" error and just return NULL.</p> </dd> <dt class="d_decl" id="Type.defaultInitLiteral">Expression defaultInitLiteral(Loc loc)</dt> <dd>
<p>Use when we prefer the default initializer to be a literal, rather than a global immutable variable.</p> </dd> <dt class="d_decl" id="Type.resolve">void resolve(Loc loc, Scope* sc, Expression* pe, Type* pt, Dsymbol* ps, bool intypeid = false)</dt> <dd>
<p>Resolve 'this' type to either type, symbol, or expression. If errors happened, resolved to Type.terror.</p> </dd> <dt class="d_decl" id="Type.resolveExp">final void resolveExp(Expression e, Type* pt, Expression* pe, Dsymbol* ps)</dt> <dd>
<p>Normalize <code>e</code> as the result of Type.resolve() process.</p> </dd> <dt class="d_decl" id="Type.hasWild">const int hasWild()</dt> <dd>
<p>Return !=0 if the type or any of its subtypes is wild.</p> </dd> <dt class="d_decl" id="Type.hasPointers">bool hasPointers()</dt> <dd>
<p>Return !=0 if type has pointers that need to be scanned by the GC during a collection cycle.</p> </dd> <dt class="d_decl" id="Type.hasVoidInitPointers">bool hasVoidInitPointers()</dt> <dd>
<p>Detect if type has pointer fields that are initialized to void. Local stack variables with such void fields can remain uninitialized, leading to pointer bugs. </p> <dl>
<dt>Returns:</dt>
<dd>
<code>true</code> if so</dd>
</dl> </dd> <dt class="d_decl" id="Type.nextOf">Type nextOf()</dt> <dd>
<p>If this is a type of something, return that something.</p> </dd> <dt class="d_decl" id="Type.baseElemOf">final Type baseElemOf()</dt> <dd>
<p>If this is a type of static array, return its base element type.</p> </dd> <dt class="d_decl" id="Type.sizemask">final uinteger_t sizemask()</dt> <dd>
<p>Return the mask that an integral type will fit into.</p> </dd> <dt class="d_decl" id="Type.needsDestruction">bool needsDestruction()</dt> <dd>
<p><code>true</code> if when type goes out of scope, it needs a destructor applied. Only applies to value types, not ref types.</p> </dd> <dt class="d_decl" id="Type.needsNested">bool needsNested()</dt>  <dt class="d_decl" id="Type.checkComplexTransition">final void checkComplexTransition(Loc loc)</dt> <dd>
<dl>
<dt>https:</dt>
<dd> //issues.dlang.org/show_bug.cgi?id=14488 Check if the inner most base type is complex or imaginary. Should only give alerts when set to emit transitional messages.</dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="TypeError">class TypeError: ddmd.mtype.Type</dt>  <dt class="d_decl" id="TypeNext">abstract class TypeNext: ddmd.mtype.Type</dt> <dd> <dl>
<dt class="d_decl" id="TypeNext.nextOf">final Type nextOf()</dt> <dd>
<p>For TypeFunction, <code>nextOf</code>() can return NULL if the function return type is meant to be inferred, and semantic() hasn't yet ben run on the function. After semantic(), it must no longer be NULL.</p> </dd> </dl> </dd> <dt class="d_decl" id="TypeBasic">class TypeBasic: ddmd.mtype.Type</dt>  <dt class="d_decl" id="TypeVector">class TypeVector: ddmd.mtype.Type</dt> <dd>
<p>The basetype must be one of: byte[16],ubyte[16],short[8],ushort[8],int[4],uint[4],long[2],ulong[2],float[4],double[2] For AVX: byte[32],ubyte[32],short[16],ushort[16],int[8],uint[8],long[4],ulong[4],float[8],double[4]</p> </dd> <dt class="d_decl" id="TypeArray">class TypeArray: ddmd.mtype.TypeNext</dt>  <dt class="d_decl" id="TypeSArray">class TypeSArray: ddmd.mtype.TypeArray</dt> <dd>
<p>Static array, one with a fixed dimension</p> <dl>
<dt class="d_decl" id="TypeSArray.needsNested">bool needsNested()</dt>  </dl> </dd> <dt class="d_decl" id="TypeDArray">class TypeDArray: ddmd.mtype.TypeArray</dt> <dd>
<p>Dynamic array, no dimension</p> </dd> <dt class="d_decl" id="TypeAArray">class TypeAArray: ddmd.mtype.TypeArray</dt>  <dt class="d_decl" id="TypePointer">class TypePointer: ddmd.mtype.TypeNext</dt>  <dt class="d_decl" id="TypeReference">class TypeReference: ddmd.mtype.TypeNext</dt>  <dt class="d_decl" id="TypeFunction">class TypeFunction: ddmd.mtype.TypeNext</dt> <dd> <dl>
<dt class="d_decl" id="TypeFunction.purityLevel">void purityLevel()</dt> <dd>
<p>Set 'purity' field of 'this'. Do this lazily, as the parameter types might be forward referenced.</p> </dd> <dt class="d_decl" id="TypeFunction.hasLazyParameters">bool hasLazyParameters()</dt> <dd>
<p>Return <code>true</code> if there are lazy parameters.</p> </dd> <dt class="d_decl" id="TypeFunction.parameterEscapes">bool parameterEscapes(Parameter p)</dt> <dd>
<p>Examine function signature for parameter <code>p</code> and see if the value of <code>p</code> can 'escape' the scope of the function. This is useful to minimize the needed annotations for the parameters. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Parameter <code>p</code>
</td> <td>parameter to this function</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>true</code> if escapes via assignment to global or through a parameter</dd>
</dl> </dd> <dt class="d_decl" id="TypeFunction.parameterStorageClass">final StorageClass parameterStorageClass(Parameter p)</dt> <dd>
<p>Take the specified storage class for <code>p</code>, and use the function signature to infer whether STCscope and STCreturn should be OR'd in. (This will not affect the name mangling.) </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Parameter <code>p</code>
</td> <td>one of the parameters to 'this'</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>storage class with STCscope or STCreturn OR'd in</dd>
</dl> </dd> <dt class="d_decl" id="TypeFunction.attributesApply">int attributesApply(void* param, int function(void*, const(char)*) fp, TRUSTformat trustFormat = TRUSTformatDefault)</dt> <dd>
<p>For each active attribute (ref/const/nogc/etc) call <code>fp</code> with a void* for the work <code>param</code> and a string representation of the attribute.</p> </dd> <dt class="d_decl" id="TypeFunction.callMatch">MATCH callMatch(Type tthis, Expressions* args, int flag = 0)</dt> <dd>
<p>'<code>args</code>' are being matched to function 'this' Determine match level. </p> <dl>
<dt>Input:</dt>
<dd> <code>flag</code> 1 performing a partial ordering match </dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>MATCHxxxx</dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="TypeDelegate">class TypeDelegate: ddmd.mtype.TypeNext</dt>  <dt class="d_decl" id="TypeQualified">abstract class TypeQualified: ddmd.mtype.Type</dt> <dd> <dl>
<dt class="d_decl" id="TypeQualified.resolveTupleIndex">final void resolveTupleIndex(Loc loc, Scope* sc, Dsymbol s, Expression* pe, Type* pt, Dsymbol* ps, RootObject oindex)</dt> <dd>
<p>Resolve a tuple index.</p> </dd> <dt class="d_decl" id="TypeQualified.resolveHelper">final void resolveHelper(Loc loc, Scope* sc, Dsymbol s, Dsymbol scopesym, Expression* pe, Type* pt, Dsymbol* ps, bool intypeid = false)</dt> <dd>
<p>Takes an array of Identifiers and figures out if it represents a Type or an Expression. </p> <dl>
<dt>Output:</dt>
<dd> if expression, *<code>pe</code> is set if type, *<code>pt</code> is set</dd>
</dl> </dd> </dl> </dd> <dt class="d_decl" id="TypeIdentifier">class TypeIdentifier: ddmd.mtype.TypeQualified</dt> <dd> <dl>
<dt class="d_decl" id="TypeIdentifier.resolve">void resolve(Loc loc, Scope* sc, Expression* pe, Type* pt, Dsymbol* ps, bool intypeid = false)</dt> <dd>
<p>Takes an array of Identifiers and figures out if it represents a Type or an Expression. </p> <dl>
<dt>Output:</dt>
<dd> if expression, *<code>pe</code> is set if type, *<code>pt</code> is set</dd>
</dl> </dd> <dt class="d_decl" id="TypeIdentifier.toDsymbol">Dsymbol toDsymbol(Scope* sc)</dt> <dd>
<p>See if type resolves to a symbol, if so, return that symbol.</p> </dd> </dl> </dd> <dt class="d_decl" id="TypeInstance">class TypeInstance: ddmd.mtype.TypeQualified</dt> <dd>
<p>Similar to TypeIdentifier, but with a TemplateInstance as the root</p> </dd> <dt class="d_decl" id="TypeTypeof">class TypeTypeof: ddmd.mtype.TypeQualified</dt>  <dt class="d_decl" id="TypeReturn">class TypeReturn: ddmd.mtype.TypeQualified</dt>  <dt class="d_decl" id="TypeStruct">class TypeStruct: ddmd.mtype.Type</dt> <dd> <dl>
<dt class="d_decl" id="TypeStruct.defaultInitLiteral">Expression defaultInitLiteral(Loc loc)</dt> <dd>
<p>Use when we prefer the default initializer to be a literal, rather than a global immutable variable.</p> </dd> </dl> </dd> <dt class="d_decl" id="TypeEnum">class TypeEnum: ddmd.mtype.Type</dt>  <dt class="d_decl" id="TypeClass">class TypeClass: ddmd.mtype.Type</dt>  <dt class="d_decl" id="TypeTuple">class TypeTuple: ddmd.mtype.Type</dt> <dd> <dl>
<dt class="d_decl" id="TypeTuple.this">this(Expressions* exps)</dt> <dd>
<p>Form TypeTuple from the types of the expressions. Assume <code>exps</code>[] is already tuple expanded.</p> </dd> <dt class="d_decl" id="TypeTuple.this.2">this()</dt> <dd>
<p>Type tuple with 0, 1 or 2 types in it.</p> </dd> </dl> </dd> <dt class="d_decl" id="TypeSlice">class TypeSlice: ddmd.mtype.TypeNext</dt> <dd>
<p>This is so we can slice a TypeTuple</p> </dd> <dt class="d_decl" id="TypeNull">class TypeNull: ddmd.mtype.Type</dt>  <dt class="d_decl" id="Parameter">class Parameter: ddmd.root.rootobject.RootObject</dt> <dd> <dl>
<dt class="d_decl" id="Parameter.isLazyArray">Type isLazyArray()</dt> <dd>
<p>Determine if parameter is a lazy array of delegates. If so, return the return type of those delegates. If not, return NULL. </p> <p>Returns T if the type is one of the following forms: T delegate()[] T delegate()[dim]</p> </dd> <dt class="d_decl" id="Parameter.isTPL">static int isTPL(Parameters* parameters)</dt> <dd>
<p>Determine if parameter list is really a template parameter list (i.e. it has auto or alias <code>parameters</code>)</p> </dd> <dt class="d_decl" id="Parameter.dim">static size_t dim(Parameters* parameters)</dt> <dd>
<p>Determine number of arguments, folding in tuples.</p> </dd> <dt class="d_decl" id="Parameter.getNth">static Parameter getNth(Parameters* parameters, size_t nth, size_t* pn = null)</dt> <dd>
<p>Get <code>nth</code> Parameter, folding in tuples. </p> <dl>
<dt>Returns:</dt>
<dd>Parameter* <code>nth</code> Parameter NULL not found, *<code>pn</code> gets incremented by the number of Parameters</dd>
</dl> </dd> <dt class="d_decl" id="Parameter._foreach">static int _foreach(Parameters* parameters, scope ForeachDg dg, size_t* pn = null)</dt> <dd>
<p>Expands tuples in args in depth first order. Calls <code>dg</code>(void *ctx, size_t argidx, Parameter *arg) for each Parameter. If <code>dg</code> returns !=0, stops and returns that value else returns 0. Use this function to avoid the O(N + N^2/2) complexity of calculating dim and calling N times getNth.</p> </dd> <dt class="d_decl" id="Parameter.isCovariant">final const pure nothrow @nogc @safe bool isCovariant(bool returnByRef, const Parameter p)</dt> <dd>
<p>Compute covariance of parameters <code>this</code> and <code>p</code> as determined by the storage classes of both. </p> <dl>
<dt>Parameters:</dt>
<dd><table>
<tr>
<td>Parameter <code>p</code>
</td> <td>Parameter to compare with</td>
</tr> </table></dd>
</dl> <dl>
<dt>Returns:</dt>
<dd>
<code>true</code> = <code>this</code> can be used in place of <code>p</code> <code>false</code> = nope</dd>
</dl> </dd> </dl> </dd> </dl>
<div class="_attribution">
  <p class="_attribution-p">
    © 1999–2017 The D Language Foundation<br>Licensed under the Boost License 1.0.<br>
    <a href="https://dlang.org/phobos/ddmd_mtype.html" class="_attribution-link" target="_blank">https://dlang.org/phobos/ddmd_mtype.html</a>
  </p>
</div>

			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
